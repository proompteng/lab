apiVersion: v1
kind: ConfigMap
metadata:
  name: torghut-llm-guardrails-exporter
  namespace: torghut
  labels:
    app.kubernetes.io/name: torghut-llm-guardrails-exporter
    app.kubernetes.io/part-of: torghut
data:
  exporter.py: |
    import json
    import os
    import threading
    import time
    import urllib.request
    from http.server import BaseHTTPRequestHandler, HTTPServer

    TORGHUT_BASE_URL = os.environ.get("TORGHUT_BASE_URL", "http://torghut.torghut.svc.cluster.local")
    METRICS_PATH = os.environ.get("TORGHUT_METRICS_PATH", "/trading/metrics")
    STATUS_PATH = os.environ.get("TORGHUT_STATUS_PATH", "/trading/status")
    EXPORTER_PORT = int(os.environ.get("EXPORTER_PORT", "9110"))
    SCRAPE_INTERVAL_SECONDS = int(os.environ.get("SCRAPE_INTERVAL_SECONDS", "30"))
    LLM_VETO_RATE_BASELINE = float(os.environ.get("LLM_VETO_RATE_BASELINE", "0.4"))
    LLM_TOKENS_PER_REQUEST_BUDGET = float(os.environ.get("LLM_TOKENS_PER_REQUEST_BUDGET", "800"))


    def fetch_json(path: str) -> dict:
        url = f"{TORGHUT_BASE_URL.rstrip('/')}{path}"
        req = urllib.request.Request(url, headers={"Accept": "application/json"}, method="GET")
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode("utf-8").strip()
        if not body:
            return {}
        return json.loads(body)


    class State:
        def __init__(self):
            self.lock = threading.Lock()
            self.metrics: dict[str, object] = {}
            self.llm: dict[str, object] = {}
            self.last_scrape_success = 0.0
            self.last_scrape_ts_seconds = 0.0
            self.last_error = ""

        def snapshot(self) -> dict:
            with self.lock:
                return {
                    "metrics": dict(self.metrics),
                    "llm": dict(self.llm),
                    "last_scrape_success": self.last_scrape_success,
                    "last_scrape_ts_seconds": self.last_scrape_ts_seconds,
                    "last_error": self.last_error,
                }


    state = State()


    def float_or_nan(value: object) -> float:
        try:
            return float(value)
        except Exception:
            return float("nan")


    def scrape_once():
        now = time.time()
        try:
            payload = fetch_json(METRICS_PATH)
            metrics = payload.get("metrics", {})
            if not isinstance(metrics, dict):
                raise RuntimeError("metrics payload missing or invalid")
            status_payload = fetch_json(STATUS_PATH)
            llm = status_payload.get("llm", {})
            if not isinstance(llm, dict):
                llm = {}

            with state.lock:
                state.metrics = metrics
                state.llm = llm
                state.last_scrape_success = 1.0
                state.last_scrape_ts_seconds = now
                state.last_error = ""
        except Exception as exc:
            with state.lock:
                state.last_scrape_success = 0.0
                state.last_scrape_ts_seconds = now
                state.last_error = str(exc)


    def scrape_loop():
        while True:
            scrape_once()
            time.sleep(SCRAPE_INTERVAL_SECONDS)


    def render_metrics(snapshot: dict) -> str:
        metrics = snapshot.get("metrics", {})
        llm = snapshot.get("llm", {})
        lines = []

        lines.append("# HELP torghut_llm_guardrails_last_scrape_success 1 if the last scrape succeeded.")
        lines.append("# TYPE torghut_llm_guardrails_last_scrape_success gauge")
        lines.append(f"torghut_llm_guardrails_last_scrape_success {snapshot.get('last_scrape_success', 0.0)}")

        lines.append("# HELP torghut_llm_guardrails_last_scrape_ts_seconds Unix timestamp of the last scrape attempt.")
        lines.append("# TYPE torghut_llm_guardrails_last_scrape_ts_seconds gauge")
        lines.append(f"torghut_llm_guardrails_last_scrape_ts_seconds {snapshot.get('last_scrape_ts_seconds', 0.0)}")

        lines.append("# HELP torghut_llm_enabled 1 if LLM reviews are enabled.")
        lines.append("# TYPE torghut_llm_enabled gauge")
        lines.append(f"torghut_llm_enabled {1.0 if llm.get('enabled') else 0.0}")

        lines.append("# HELP torghut_llm_shadow_mode 1 if LLM is running in shadow mode.")
        lines.append("# TYPE torghut_llm_shadow_mode gauge")
        lines.append(f"torghut_llm_shadow_mode {1.0 if llm.get('shadow_mode') else 0.0}")

        lines.append("# HELP torghut_llm_veto_rate_baseline Baseline veto rate configured for guardrails alerts.")
        lines.append("# TYPE torghut_llm_veto_rate_baseline gauge")
        lines.append(f"torghut_llm_veto_rate_baseline {LLM_VETO_RATE_BASELINE}")

        lines.append("# HELP torghut_llm_tokens_per_request_budget Budgeted total tokens per request for guardrails alerts.")
        lines.append("# TYPE torghut_llm_tokens_per_request_budget gauge")
        lines.append(f"torghut_llm_tokens_per_request_budget {LLM_TOKENS_PER_REQUEST_BUDGET}")

        counters = [
            "llm_requests_total",
            "llm_approve_total",
            "llm_veto_total",
            "llm_adjust_total",
            "llm_error_total",
            "llm_parse_error_total",
            "llm_validation_error_total",
            "llm_circuit_open_total",
            "llm_shadow_total",
            "llm_guardrail_block_total",
            "llm_guardrail_shadow_total",
            "llm_tokens_prompt_total",
            "llm_tokens_completion_total",
        ]

        for key in counters:
            metric_name = f"torghut_{key}"
            lines.append(f"# HELP {metric_name} Torghut trading LLM metric {key}.")
            lines.append(f"# TYPE {metric_name} counter")
            value = float_or_nan(metrics.get(key, 0))
            lines.append(f"{metric_name} {value}")

        return "\n".join(lines) + "\n"


    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path not in ("/metrics", "/"):
                self.send_response(404)
                self.end_headers()
                return
            snapshot = state.snapshot()
            body = render_metrics(snapshot).encode("utf-8")
            self.send_response(200)
            self.send_header("Content-Type", "text/plain; version=0.0.4")
            self.send_header("Content-Length", str(len(body)))
            self.end_headers()
            self.wfile.write(body)

        def log_message(self, format, *args):
            return


    def main():
        thread = threading.Thread(target=scrape_loop, daemon=True)
        thread.start()
        server = HTTPServer(("0.0.0.0", EXPORTER_PORT), Handler)
        server.serve_forever()


    if __name__ == "__main__":
        main()
