// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/errordetails/v1/message.proto (package temporal.api.errordetails.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// These error details are supplied in google.rpc.Status#details as described in "Google APIs, Error Model" (https://cloud.google.com/apis/design/errors#error_model)
// and extend standard Error Details defined in https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf'
import { Any, Message, proto3 } from '@bufbuild/protobuf'
import { NamespaceState } from '../../enums/v1/namespace_pbts'
import { Failure } from '../../failure/v1/message_pbts'
import { ResourceExhaustedCause, ResourceExhaustedScope } from '../../enums/v1/failed_cause_pbts'
import { WorkflowExecution } from '../../common/v1/message_pbts'

/**
 * @generated from message temporal.api.errordetails.v1.NotFoundFailure
 */
export class NotFoundFailure extends Message<NotFoundFailure> {
  /**
   * @generated from field: string current_cluster = 1;
   */
  currentCluster = ''

  /**
   * @generated from field: string active_cluster = 2;
   */
  activeCluster = ''

  constructor(data?: PartialMessage<NotFoundFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NotFoundFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'current_cluster', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'active_cluster', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotFoundFailure {
    return new NotFoundFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotFoundFailure {
    return new NotFoundFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotFoundFailure {
    return new NotFoundFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NotFoundFailure | PlainMessage<NotFoundFailure> | undefined,
    b: NotFoundFailure | PlainMessage<NotFoundFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NotFoundFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure
 */
export class WorkflowExecutionAlreadyStartedFailure extends Message<WorkflowExecutionAlreadyStartedFailure> {
  /**
   * @generated from field: string start_request_id = 1;
   */
  startRequestId = ''

  /**
   * @generated from field: string run_id = 2;
   */
  runId = ''

  constructor(data?: PartialMessage<WorkflowExecutionAlreadyStartedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.WorkflowExecutionAlreadyStartedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'start_request_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'run_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionAlreadyStartedFailure {
    return new WorkflowExecutionAlreadyStartedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionAlreadyStartedFailure {
    return new WorkflowExecutionAlreadyStartedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): WorkflowExecutionAlreadyStartedFailure {
    return new WorkflowExecutionAlreadyStartedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: WorkflowExecutionAlreadyStartedFailure | PlainMessage<WorkflowExecutionAlreadyStartedFailure> | undefined,
    b: WorkflowExecutionAlreadyStartedFailure | PlainMessage<WorkflowExecutionAlreadyStartedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(WorkflowExecutionAlreadyStartedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.NamespaceNotActiveFailure
 */
export class NamespaceNotActiveFailure extends Message<NamespaceNotActiveFailure> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  /**
   * @generated from field: string current_cluster = 2;
   */
  currentCluster = ''

  /**
   * @generated from field: string active_cluster = 3;
   */
  activeCluster = ''

  constructor(data?: PartialMessage<NamespaceNotActiveFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NamespaceNotActiveFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'current_cluster', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'active_cluster', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceNotActiveFailure {
    return new NamespaceNotActiveFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceNotActiveFailure {
    return new NamespaceNotActiveFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceNotActiveFailure {
    return new NamespaceNotActiveFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NamespaceNotActiveFailure | PlainMessage<NamespaceNotActiveFailure> | undefined,
    b: NamespaceNotActiveFailure | PlainMessage<NamespaceNotActiveFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NamespaceNotActiveFailure, a, b)
  }
}

/**
 * NamespaceUnavailableFailure is returned by the service when a request addresses a namespace that is unavailable. For
 * example, when a namespace is in the process of failing over between clusters.
 * This is a transient error that should be automatically retried by clients.
 *
 * @generated from message temporal.api.errordetails.v1.NamespaceUnavailableFailure
 */
export class NamespaceUnavailableFailure extends Message<NamespaceUnavailableFailure> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  constructor(data?: PartialMessage<NamespaceUnavailableFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NamespaceUnavailableFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceUnavailableFailure {
    return new NamespaceUnavailableFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceUnavailableFailure {
    return new NamespaceUnavailableFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceUnavailableFailure {
    return new NamespaceUnavailableFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NamespaceUnavailableFailure | PlainMessage<NamespaceUnavailableFailure> | undefined,
    b: NamespaceUnavailableFailure | PlainMessage<NamespaceUnavailableFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NamespaceUnavailableFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.NamespaceInvalidStateFailure
 */
export class NamespaceInvalidStateFailure extends Message<NamespaceInvalidStateFailure> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  /**
   * Current state of the requested namespace.
   *
   * @generated from field: temporal.api.enums.v1.NamespaceState state = 2;
   */
  state = NamespaceState.UNSPECIFIED

  /**
   * Allowed namespace states for requested operation.
   * For example NAMESPACE_STATE_DELETED is forbidden for most operations but allowed for DescribeNamespace.
   *
   * @generated from field: repeated temporal.api.enums.v1.NamespaceState allowed_states = 3;
   */
  allowedStates: NamespaceState[] = []

  constructor(data?: PartialMessage<NamespaceInvalidStateFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NamespaceInvalidStateFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'state', kind: 'enum', T: proto3.getEnumType(NamespaceState) },
    { no: 3, name: 'allowed_states', kind: 'enum', T: proto3.getEnumType(NamespaceState), repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceInvalidStateFailure {
    return new NamespaceInvalidStateFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceInvalidStateFailure {
    return new NamespaceInvalidStateFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceInvalidStateFailure {
    return new NamespaceInvalidStateFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NamespaceInvalidStateFailure | PlainMessage<NamespaceInvalidStateFailure> | undefined,
    b: NamespaceInvalidStateFailure | PlainMessage<NamespaceInvalidStateFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NamespaceInvalidStateFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.NamespaceNotFoundFailure
 */
export class NamespaceNotFoundFailure extends Message<NamespaceNotFoundFailure> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  constructor(data?: PartialMessage<NamespaceNotFoundFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NamespaceNotFoundFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceNotFoundFailure {
    return new NamespaceNotFoundFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceNotFoundFailure {
    return new NamespaceNotFoundFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceNotFoundFailure {
    return new NamespaceNotFoundFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NamespaceNotFoundFailure | PlainMessage<NamespaceNotFoundFailure> | undefined,
    b: NamespaceNotFoundFailure | PlainMessage<NamespaceNotFoundFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NamespaceNotFoundFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.NamespaceAlreadyExistsFailure
 */
export class NamespaceAlreadyExistsFailure extends Message<NamespaceAlreadyExistsFailure> {
  constructor(data?: PartialMessage<NamespaceAlreadyExistsFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NamespaceAlreadyExistsFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceAlreadyExistsFailure {
    return new NamespaceAlreadyExistsFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceAlreadyExistsFailure {
    return new NamespaceAlreadyExistsFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceAlreadyExistsFailure {
    return new NamespaceAlreadyExistsFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NamespaceAlreadyExistsFailure | PlainMessage<NamespaceAlreadyExistsFailure> | undefined,
    b: NamespaceAlreadyExistsFailure | PlainMessage<NamespaceAlreadyExistsFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NamespaceAlreadyExistsFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.ClientVersionNotSupportedFailure
 */
export class ClientVersionNotSupportedFailure extends Message<ClientVersionNotSupportedFailure> {
  /**
   * @generated from field: string client_version = 1;
   */
  clientVersion = ''

  /**
   * @generated from field: string client_name = 2;
   */
  clientName = ''

  /**
   * @generated from field: string supported_versions = 3;
   */
  supportedVersions = ''

  constructor(data?: PartialMessage<ClientVersionNotSupportedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.ClientVersionNotSupportedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'client_version', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'client_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'supported_versions', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientVersionNotSupportedFailure {
    return new ClientVersionNotSupportedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientVersionNotSupportedFailure {
    return new ClientVersionNotSupportedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientVersionNotSupportedFailure {
    return new ClientVersionNotSupportedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: ClientVersionNotSupportedFailure | PlainMessage<ClientVersionNotSupportedFailure> | undefined,
    b: ClientVersionNotSupportedFailure | PlainMessage<ClientVersionNotSupportedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(ClientVersionNotSupportedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.ServerVersionNotSupportedFailure
 */
export class ServerVersionNotSupportedFailure extends Message<ServerVersionNotSupportedFailure> {
  /**
   * @generated from field: string server_version = 1;
   */
  serverVersion = ''

  /**
   * @generated from field: string client_supported_server_versions = 2;
   */
  clientSupportedServerVersions = ''

  constructor(data?: PartialMessage<ServerVersionNotSupportedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.ServerVersionNotSupportedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'server_version', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'client_supported_server_versions', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerVersionNotSupportedFailure {
    return new ServerVersionNotSupportedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerVersionNotSupportedFailure {
    return new ServerVersionNotSupportedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerVersionNotSupportedFailure {
    return new ServerVersionNotSupportedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: ServerVersionNotSupportedFailure | PlainMessage<ServerVersionNotSupportedFailure> | undefined,
    b: ServerVersionNotSupportedFailure | PlainMessage<ServerVersionNotSupportedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(ServerVersionNotSupportedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.CancellationAlreadyRequestedFailure
 */
export class CancellationAlreadyRequestedFailure extends Message<CancellationAlreadyRequestedFailure> {
  constructor(data?: PartialMessage<CancellationAlreadyRequestedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.CancellationAlreadyRequestedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancellationAlreadyRequestedFailure {
    return new CancellationAlreadyRequestedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancellationAlreadyRequestedFailure {
    return new CancellationAlreadyRequestedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancellationAlreadyRequestedFailure {
    return new CancellationAlreadyRequestedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: CancellationAlreadyRequestedFailure | PlainMessage<CancellationAlreadyRequestedFailure> | undefined,
    b: CancellationAlreadyRequestedFailure | PlainMessage<CancellationAlreadyRequestedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(CancellationAlreadyRequestedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.QueryFailedFailure
 */
export class QueryFailedFailure extends Message<QueryFailedFailure> {
  /**
   * The full reason for this query failure. May not be available if the response is generated by an old
   * SDK. This field can be encoded by the SDK's failure converter to support E2E encryption of messages and stack
   * traces.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure

  constructor(data?: PartialMessage<QueryFailedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.QueryFailedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'failure', kind: 'message', T: Failure },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFailedFailure {
    return new QueryFailedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFailedFailure {
    return new QueryFailedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFailedFailure {
    return new QueryFailedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: QueryFailedFailure | PlainMessage<QueryFailedFailure> | undefined,
    b: QueryFailedFailure | PlainMessage<QueryFailedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(QueryFailedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.PermissionDeniedFailure
 */
export class PermissionDeniedFailure extends Message<PermissionDeniedFailure> {
  /**
   * @generated from field: string reason = 1;
   */
  reason = ''

  constructor(data?: PartialMessage<PermissionDeniedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.PermissionDeniedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'reason', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionDeniedFailure {
    return new PermissionDeniedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionDeniedFailure {
    return new PermissionDeniedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionDeniedFailure {
    return new PermissionDeniedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: PermissionDeniedFailure | PlainMessage<PermissionDeniedFailure> | undefined,
    b: PermissionDeniedFailure | PlainMessage<PermissionDeniedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(PermissionDeniedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.ResourceExhaustedFailure
 */
export class ResourceExhaustedFailure extends Message<ResourceExhaustedFailure> {
  /**
   * @generated from field: temporal.api.enums.v1.ResourceExhaustedCause cause = 1;
   */
  cause = ResourceExhaustedCause.UNSPECIFIED

  /**
   * @generated from field: temporal.api.enums.v1.ResourceExhaustedScope scope = 2;
   */
  scope = ResourceExhaustedScope.UNSPECIFIED

  constructor(data?: PartialMessage<ResourceExhaustedFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.ResourceExhaustedFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'cause', kind: 'enum', T: proto3.getEnumType(ResourceExhaustedCause) },
    { no: 2, name: 'scope', kind: 'enum', T: proto3.getEnumType(ResourceExhaustedScope) },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceExhaustedFailure {
    return new ResourceExhaustedFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceExhaustedFailure {
    return new ResourceExhaustedFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceExhaustedFailure {
    return new ResourceExhaustedFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: ResourceExhaustedFailure | PlainMessage<ResourceExhaustedFailure> | undefined,
    b: ResourceExhaustedFailure | PlainMessage<ResourceExhaustedFailure> | undefined,
  ): boolean {
    return proto3.util.equals(ResourceExhaustedFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.SystemWorkflowFailure
 */
export class SystemWorkflowFailure extends Message<SystemWorkflowFailure> {
  /**
   * WorkflowId and RunId of the Temporal system workflow performing the underlying operation.
   * Looking up the info of the system workflow run may help identify the issue causing the failure.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 1;
   */
  workflowExecution?: WorkflowExecution

  /**
   * Serialized error returned by the system workflow performing the underlying operation.
   *
   * @generated from field: string workflow_error = 2;
   */
  workflowError = ''

  constructor(data?: PartialMessage<SystemWorkflowFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.SystemWorkflowFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'workflow_execution', kind: 'message', T: WorkflowExecution },
    { no: 2, name: 'workflow_error', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SystemWorkflowFailure {
    return new SystemWorkflowFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SystemWorkflowFailure {
    return new SystemWorkflowFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SystemWorkflowFailure {
    return new SystemWorkflowFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: SystemWorkflowFailure | PlainMessage<SystemWorkflowFailure> | undefined,
    b: SystemWorkflowFailure | PlainMessage<SystemWorkflowFailure> | undefined,
  ): boolean {
    return proto3.util.equals(SystemWorkflowFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.WorkflowNotReadyFailure
 */
export class WorkflowNotReadyFailure extends Message<WorkflowNotReadyFailure> {
  constructor(data?: PartialMessage<WorkflowNotReadyFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.WorkflowNotReadyFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowNotReadyFailure {
    return new WorkflowNotReadyFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowNotReadyFailure {
    return new WorkflowNotReadyFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowNotReadyFailure {
    return new WorkflowNotReadyFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: WorkflowNotReadyFailure | PlainMessage<WorkflowNotReadyFailure> | undefined,
    b: WorkflowNotReadyFailure | PlainMessage<WorkflowNotReadyFailure> | undefined,
  ): boolean {
    return proto3.util.equals(WorkflowNotReadyFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.NewerBuildExistsFailure
 */
export class NewerBuildExistsFailure extends Message<NewerBuildExistsFailure> {
  /**
   * The current default compatible build ID which will receive tasks
   *
   * @generated from field: string default_build_id = 1;
   */
  defaultBuildId = ''

  constructor(data?: PartialMessage<NewerBuildExistsFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.NewerBuildExistsFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'default_build_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewerBuildExistsFailure {
    return new NewerBuildExistsFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewerBuildExistsFailure {
    return new NewerBuildExistsFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewerBuildExistsFailure {
    return new NewerBuildExistsFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: NewerBuildExistsFailure | PlainMessage<NewerBuildExistsFailure> | undefined,
    b: NewerBuildExistsFailure | PlainMessage<NewerBuildExistsFailure> | undefined,
  ): boolean {
    return proto3.util.equals(NewerBuildExistsFailure, a, b)
  }
}

/**
 * @generated from message temporal.api.errordetails.v1.MultiOperationExecutionFailure
 */
export class MultiOperationExecutionFailure extends Message<MultiOperationExecutionFailure> {
  /**
   * One status for each requested operation from the failed MultiOperation. The failed
   * operation(s) have the same error details as if it was executed separately. All other operations have the
   * status code `Aborted` and `MultiOperationExecutionAborted` is added to the details field.
   *
   * @generated from field: repeated temporal.api.errordetails.v1.MultiOperationExecutionFailure.OperationStatus statuses = 1;
   */
  statuses: MultiOperationExecutionFailure_OperationStatus[] = []

  constructor(data?: PartialMessage<MultiOperationExecutionFailure>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.MultiOperationExecutionFailure'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'statuses', kind: 'message', T: MultiOperationExecutionFailure_OperationStatus, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiOperationExecutionFailure {
    return new MultiOperationExecutionFailure().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiOperationExecutionFailure {
    return new MultiOperationExecutionFailure().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiOperationExecutionFailure {
    return new MultiOperationExecutionFailure().fromJsonString(jsonString, options)
  }

  static equals(
    a: MultiOperationExecutionFailure | PlainMessage<MultiOperationExecutionFailure> | undefined,
    b: MultiOperationExecutionFailure | PlainMessage<MultiOperationExecutionFailure> | undefined,
  ): boolean {
    return proto3.util.equals(MultiOperationExecutionFailure, a, b)
  }
}

/**
 * NOTE: `OperationStatus` is modelled after
 * [`google.rpc.Status`](https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto).
 *
 * (-- api-linter: core::0146::any=disabled
 *     aip.dev/not-precedent: details are meant to hold arbitrary payloads. --)
 *
 * @generated from message temporal.api.errordetails.v1.MultiOperationExecutionFailure.OperationStatus
 */
export class MultiOperationExecutionFailure_OperationStatus extends Message<MultiOperationExecutionFailure_OperationStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0

  /**
   * @generated from field: string message = 2;
   */
  message = ''

  /**
   * @generated from field: repeated google.protobuf.Any details = 3;
   */
  details: Any[] = []

  constructor(data?: PartialMessage<MultiOperationExecutionFailure_OperationStatus>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.errordetails.v1.MultiOperationExecutionFailure.OperationStatus'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'code', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: 'message', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'details', kind: 'message', T: Any, repeated: true },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): MultiOperationExecutionFailure_OperationStatus {
    return new MultiOperationExecutionFailure_OperationStatus().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): MultiOperationExecutionFailure_OperationStatus {
    return new MultiOperationExecutionFailure_OperationStatus().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): MultiOperationExecutionFailure_OperationStatus {
    return new MultiOperationExecutionFailure_OperationStatus().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | MultiOperationExecutionFailure_OperationStatus
      | PlainMessage<MultiOperationExecutionFailure_OperationStatus>
      | undefined,
    b:
      | MultiOperationExecutionFailure_OperationStatus
      | PlainMessage<MultiOperationExecutionFailure_OperationStatus>
      | undefined,
  ): boolean {
    return proto3.util.equals(MultiOperationExecutionFailure_OperationStatus, a, b)
  }
}
