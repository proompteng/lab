// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/batch/v1/message.proto (package temporal.api.batch.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ActivityOptions } from "../../activity/v1/message_pb.js";
import { file_temporal_api_activity_v1_message } from "../../activity/v1/message_pb.js";
import type { Header, Payloads, ResetOptions } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { BatchOperationState } from "../../enums/v1/batch_operation_pb.js";
import { file_temporal_api_enums_v1_batch_operation } from "../../enums/v1/batch_operation_pb.js";
import type { ResetReapplyType, ResetType } from "../../enums/v1/reset_pb.js";
import { file_temporal_api_enums_v1_reset } from "../../enums/v1/reset_pb.js";
import type { WorkflowRuleSpec } from "../../rules/v1/message_pb.js";
import { file_temporal_api_rules_v1_message } from "../../rules/v1/message_pb.js";
import type { PostResetOperation, WorkflowExecutionOptions } from "../../workflow/v1/message_pb.js";
import { file_temporal_api_workflow_v1_message } from "../../workflow/v1/message_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/batch/v1/message.proto.
 */
export const file_temporal_api_batch_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiN0ZW1wb3JhbC9hcGkvYmF0Y2gvdjEvbWVzc2FnZS5wcm90bxIVdGVtcG9yYWwuYXBpLmJhdGNoLnYxIr8BChJCYXRjaE9wZXJhdGlvbkluZm8SDgoGam9iX2lkGAEgASgJEjkKBXN0YXRlGAIgASgOMioudGVtcG9yYWwuYXBpLmVudW1zLnYxLkJhdGNoT3BlcmF0aW9uU3RhdGUSLgoKc3RhcnRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKY2xvc2VfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiYAoZQmF0Y2hPcGVyYXRpb25UZXJtaW5hdGlvbhIxCgdkZXRhaWxzGAEgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIQCghpZGVudGl0eRgCIAEoCSKZAQoUQmF0Y2hPcGVyYXRpb25TaWduYWwSDgoGc2lnbmFsGAEgASgJEi8KBWlucHV0GAIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIuCgZoZWFkZXIYAyABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIQCghpZGVudGl0eRgEIAEoCSIuChpCYXRjaE9wZXJhdGlvbkNhbmNlbGxhdGlvbhIQCghpZGVudGl0eRgBIAEoCSIqChZCYXRjaE9wZXJhdGlvbkRlbGV0aW9uEhAKCGlkZW50aXR5GAEgASgJIq4CChNCYXRjaE9wZXJhdGlvblJlc2V0EhAKCGlkZW50aXR5GAMgASgJEjUKB29wdGlvbnMYBCABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlJlc2V0T3B0aW9ucxI4CgpyZXNldF90eXBlGAEgASgOMiAudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJlc2V0VHlwZUICGAESRwoScmVzZXRfcmVhcHBseV90eXBlGAIgASgOMicudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJlc2V0UmVhcHBseVR5cGVCAhgBEksKFXBvc3RfcmVzZXRfb3BlcmF0aW9ucxgFIAMoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5Qb3N0UmVzZXRPcGVyYXRpb24iyQEKLEJhdGNoT3BlcmF0aW9uVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25PcHRpb25zEhAKCGlkZW50aXR5GAEgASgJElYKGndvcmtmbG93X2V4ZWN1dGlvbl9vcHRpb25zGAIgASgLMjIudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uT3B0aW9ucxIvCgt1cGRhdGVfbWFzaxgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siwAEKH0JhdGNoT3BlcmF0aW9uVW5wYXVzZUFjdGl2aXRpZXMSEAoIaWRlbnRpdHkYASABKAkSDgoEdHlwZRgCIAEoCUgAEhMKCW1hdGNoX2FsbBgDIAEoCEgAEhYKDnJlc2V0X2F0dGVtcHRzGAQgASgIEhcKD3Jlc2V0X2hlYXJ0YmVhdBgFIAEoCBIpCgZqaXR0ZXIYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCgoIYWN0aXZpdHkihAEKIUJhdGNoT3BlcmF0aW9uVHJpZ2dlcldvcmtmbG93UnVsZRIQCghpZGVudGl0eRgBIAEoCRIMCgJpZBgCIAEoCUgAEjcKBHNwZWMYAyABKAsyJy50ZW1wb3JhbC5hcGkucnVsZXMudjEuV29ya2Zsb3dSdWxlU3BlY0gAQgYKBHJ1bGUi9QEKHUJhdGNoT3BlcmF0aW9uUmVzZXRBY3Rpdml0aWVzEhAKCGlkZW50aXR5GAEgASgJEg4KBHR5cGUYAiABKAlIABITCgltYXRjaF9hbGwYAyABKAhIABIWCg5yZXNldF9hdHRlbXB0cxgEIAEoCBIXCg9yZXNldF9oZWFydGJlYXQYBSABKAgSEwoLa2VlcF9wYXVzZWQYBiABKAgSKQoGaml0dGVyGAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEiAKGHJlc3RvcmVfb3JpZ2luYWxfb3B0aW9ucxgIIAEoCEIKCghhY3Rpdml0eSL4AQojQmF0Y2hPcGVyYXRpb25VcGRhdGVBY3Rpdml0eU9wdGlvbnMSEAoIaWRlbnRpdHkYASABKAkSDgoEdHlwZRgCIAEoCUgAEhMKCW1hdGNoX2FsbBgDIAEoCEgAEkMKEGFjdGl2aXR5X29wdGlvbnMYBCABKAsyKS50ZW1wb3JhbC5hcGkuYWN0aXZpdHkudjEuQWN0aXZpdHlPcHRpb25zEi8KC3VwZGF0ZV9tYXNrGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzaxIYChByZXN0b3JlX29yaWdpbmFsGAYgASgIQgoKCGFjdGl2aXR5QoQBChhpby50ZW1wb3JhbC5hcGkuYmF0Y2gudjFCDE1lc3NhZ2VQcm90b1ABWiFnby50ZW1wb3JhbC5pby9hcGkvYmF0Y2gvdjE7YmF0Y2iqAhdUZW1wb3JhbGlvLkFwaS5CYXRjaC5WMeoCGlRlbXBvcmFsaW86OkFwaTo6QmF0Y2g6OlYxYgZwcm90bzM", [file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp, file_temporal_api_activity_v1_message, file_temporal_api_common_v1_message, file_temporal_api_enums_v1_batch_operation, file_temporal_api_enums_v1_reset, file_temporal_api_rules_v1_message, file_temporal_api_workflow_v1_message]);

/**
 * @generated from message temporal.api.batch.v1.BatchOperationInfo
 */
export type BatchOperationInfo = Message<"temporal.api.batch.v1.BatchOperationInfo"> & {
  /**
   * Batch job ID
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * Batch operation state
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationState state = 2;
   */
  state: BatchOperationState;

  /**
   * Batch operation start time
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * Batch operation close time
   *
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationInfo.
 * Use `create(BatchOperationInfoSchema)` to create a new message.
 */
export const BatchOperationInfoSchema: GenMessage<BatchOperationInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 0);

/**
 * BatchOperationTermination sends terminate requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
 * Ignore first_execution_run_id because this is used for single workflow operation.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationTermination
 */
export type BatchOperationTermination = Message<"temporal.api.batch.v1.BatchOperationTermination"> & {
  /**
   * Serialized value(s) to provide to the termination event
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 2;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationTermination.
 * Use `create(BatchOperationTerminationSchema)` to create a new message.
 */
export const BatchOperationTerminationSchema: GenMessage<BatchOperationTermination> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 1);

/**
 * BatchOperationSignal sends signals to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationSignal
 */
export type BatchOperationSignal = Message<"temporal.api.batch.v1.BatchOperationSignal"> & {
  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal = 1;
   */
  signal: string;

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads;

  /**
   * Headers that are passed with the signal to the processing workflow.
   * These can include things like auth or tracing tokens.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 4;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationSignal.
 * Use `create(BatchOperationSignalSchema)` to create a new message.
 */
export const BatchOperationSignalSchema: GenMessage<BatchOperationSignal> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 2);

/**
 * BatchOperationCancellation sends cancel requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
 * Ignore first_execution_run_id because this is used for single workflow operation.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationCancellation
 */
export type BatchOperationCancellation = Message<"temporal.api.batch.v1.BatchOperationCancellation"> & {
  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 1;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationCancellation.
 * Use `create(BatchOperationCancellationSchema)` to create a new message.
 */
export const BatchOperationCancellationSchema: GenMessage<BatchOperationCancellation> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 3);

/**
 * BatchOperationDeletion sends deletion requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationDeletion
 */
export type BatchOperationDeletion = Message<"temporal.api.batch.v1.BatchOperationDeletion"> & {
  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 1;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationDeletion.
 * Use `create(BatchOperationDeletionSchema)` to create a new message.
 */
export const BatchOperationDeletionSchema: GenMessage<BatchOperationDeletion> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 4);

/**
 * BatchOperationReset sends reset requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationReset
 */
export type BatchOperationReset = Message<"temporal.api.batch.v1.BatchOperationReset"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored.
   *
   * @generated from field: temporal.api.common.v1.ResetOptions options = 4;
   */
  options?: ResetOptions;

  /**
   * Deprecated. Use `options`.
   *
   * @generated from field: temporal.api.enums.v1.ResetType reset_type = 1 [deprecated = true];
   * @deprecated
   */
  resetType: ResetType;

  /**
   * Deprecated. Use `options`.
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 2 [deprecated = true];
   * @deprecated
   */
  resetReapplyType: ResetReapplyType;

  /**
   * Operations to perform after the workflow has been reset. These operations will be applied
   * to the *new* run of the workflow execution in the order they are provided.
   * All operations are applied to the workflow before the first new workflow task is generated
   *
   * @generated from field: repeated temporal.api.workflow.v1.PostResetOperation post_reset_operations = 5;
   */
  postResetOperations: PostResetOperation[];
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationReset.
 * Use `create(BatchOperationResetSchema)` to create a new message.
 */
export const BatchOperationResetSchema: GenMessage<BatchOperationReset> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 5);

/**
 * BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
 * Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions
 */
export type BatchOperationUpdateWorkflowExecutionOptions = Message<"temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 2;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
 * Use `create(BatchOperationUpdateWorkflowExecutionOptionsSchema)` to create a new message.
 */
export const BatchOperationUpdateWorkflowExecutionOptionsSchema: GenMessage<BatchOperationUpdateWorkflowExecutionOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 6);

/**
 * BatchOperationUnpauseActivities sends unpause requests to batch workflows.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUnpauseActivities
 */
export type BatchOperationUnpauseActivities = Message<"temporal.api.batch.v1.BatchOperationUnpauseActivities"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * The activity to unpause. If match_all is set to true, all activities will be unpaused.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationUnpauseActivities.activity
   */
  activity: {
    /**
     * @generated from field: string type = 2;
     */
    value: string;
    case: "type";
  } | {
    /**
     * @generated from field: bool match_all = 3;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined };

  /**
   * Setting this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 4;
   */
  resetAttempts: boolean;

  /**
   * Setting this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 5;
   */
  resetHeartbeat: boolean;

  /**
   * If set, the activity will start at a random time within the specified jitter
   * duration, introducing variability to the start time.
   *
   * @generated from field: google.protobuf.Duration jitter = 6;
   */
  jitter?: Duration;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationUnpauseActivities.
 * Use `create(BatchOperationUnpauseActivitiesSchema)` to create a new message.
 */
export const BatchOperationUnpauseActivitiesSchema: GenMessage<BatchOperationUnpauseActivities> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 7);

/**
 * BatchOperationTriggerWorkflowRule sends TriggerWorkflowRule requests to batch workflows.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationTriggerWorkflowRule
 */
export type BatchOperationTriggerWorkflowRule = Message<"temporal.api.batch.v1.BatchOperationTriggerWorkflowRule"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * @generated from oneof temporal.api.batch.v1.BatchOperationTriggerWorkflowRule.rule
   */
  rule: {
    /**
     * ID of existing rule.
     *
     * @generated from field: string id = 2;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Rule specification to be applied to the workflow without creating a new rule.
     *
     * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 3;
     */
    value: WorkflowRuleSpec;
    case: "spec";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationTriggerWorkflowRule.
 * Use `create(BatchOperationTriggerWorkflowRuleSchema)` to create a new message.
 */
export const BatchOperationTriggerWorkflowRuleSchema: GenMessage<BatchOperationTriggerWorkflowRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 8);

/**
 * BatchOperationResetActivities sends activity reset requests in a batch.
 * NOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest
 *
 * @generated from message temporal.api.batch.v1.BatchOperationResetActivities
 */
export type BatchOperationResetActivities = Message<"temporal.api.batch.v1.BatchOperationResetActivities"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * The activities to reset. If match_all is set to true, all activities will be reset.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationResetActivities.activity
   */
  activity: {
    /**
     * @generated from field: string type = 2;
     */
    value: string;
    case: "type";
  } | {
    /**
     * @generated from field: bool match_all = 3;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined };

  /**
   * Setting this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 4;
   */
  resetAttempts: boolean;

  /**
   * Setting this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 5;
   */
  resetHeartbeat: boolean;

  /**
   * If activity is paused, it will remain paused after reset
   *
   * @generated from field: bool keep_paused = 6;
   */
  keepPaused: boolean;

  /**
   * If set, the activity will start at a random time within the specified jitter
   * duration, introducing variability to the start time.
   *
   * @generated from field: google.protobuf.Duration jitter = 7;
   */
  jitter?: Duration;

  /**
   * If set, the activity options will be restored to the defaults.
   * Default options are then options activity was created with.
   * They are part of the first ActivityTaskScheduled event.
   *
   * @generated from field: bool restore_original_options = 8;
   */
  restoreOriginalOptions: boolean;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationResetActivities.
 * Use `create(BatchOperationResetActivitiesSchema)` to create a new message.
 */
export const BatchOperationResetActivitiesSchema: GenMessage<BatchOperationResetActivities> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 9);

/**
 * BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.
 * NOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUpdateActivityOptions
 */
export type BatchOperationUpdateActivityOptions = Message<"temporal.api.batch.v1.BatchOperationUpdateActivityOptions"> & {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * The activity to update. If match_all is set to true, all activities will be updated.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationUpdateActivityOptions.activity
   */
  activity: {
    /**
     * @generated from field: string type = 2;
     */
    value: string;
    case: "type";
  } | {
    /**
     * @generated from field: bool match_all = 3;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined };

  /**
   * Update Activity options. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 4;
   */
  activityOptions?: ActivityOptions;

  /**
   * Controls which fields from `activity_options` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;

  /**
   * If set, the activity options will be restored to the default.
   * Default options are then options activity was created with.
   * They are part of the first ActivityTaskScheduled event.
   * This flag cannot be combined with any other option; if you supply
   * restore_original together with other options, the request will be rejected.
   *
   * @generated from field: bool restore_original = 6;
   */
  restoreOriginal: boolean;
};

/**
 * Describes the message temporal.api.batch.v1.BatchOperationUpdateActivityOptions.
 * Use `create(BatchOperationUpdateActivityOptionsSchema)` to create a new message.
 */
export const BatchOperationUpdateActivityOptionsSchema: GenMessage<BatchOperationUpdateActivityOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_batch_v1_message, 10);

