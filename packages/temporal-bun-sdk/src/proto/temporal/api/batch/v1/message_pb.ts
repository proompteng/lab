// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/batch/v1/message.proto (package temporal.api.batch.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf'
import { Duration, FieldMask, Message, proto3, Timestamp } from '@bufbuild/protobuf'
import { BatchOperationState } from '../../enums/v1/batch_operation_pbts'
import { Header, Payloads, ResetOptions } from '../../common/v1/message_pbts'
import { ResetReapplyType, ResetType } from '../../enums/v1/reset_pbts'
import { PostResetOperation, WorkflowExecutionOptions } from '../../workflow/v1/message_pbts'
import { WorkflowRuleSpec } from '../../rules/v1/message_pbts'
import { ActivityOptions } from '../../activity/v1/message_pbts'

/**
 * @generated from message temporal.api.batch.v1.BatchOperationInfo
 */
export class BatchOperationInfo extends Message<BatchOperationInfo> {
  /**
   * Batch job ID
   *
   * @generated from field: string job_id = 1;
   */
  jobId = ''

  /**
   * Batch operation state
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationState state = 2;
   */
  state = BatchOperationState.UNSPECIFIED

  /**
   * Batch operation start time
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp

  /**
   * Batch operation close time
   *
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp

  constructor(data?: PartialMessage<BatchOperationInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'job_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'state', kind: 'enum', T: proto3.getEnumType(BatchOperationState) },
    { no: 3, name: 'start_time', kind: 'message', T: Timestamp },
    { no: 4, name: 'close_time', kind: 'message', T: Timestamp },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationInfo {
    return new BatchOperationInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationInfo {
    return new BatchOperationInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationInfo {
    return new BatchOperationInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationInfo | PlainMessage<BatchOperationInfo> | undefined,
    b: BatchOperationInfo | PlainMessage<BatchOperationInfo> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationInfo, a, b)
  }
}

/**
 * BatchOperationTermination sends terminate requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
 * Ignore first_execution_run_id because this is used for single workflow operation.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationTermination
 */
export class BatchOperationTermination extends Message<BatchOperationTermination> {
  /**
   * Serialized value(s) to provide to the termination event
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 2;
   */
  identity = ''

  constructor(data?: PartialMessage<BatchOperationTermination>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationTermination'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'details', kind: 'message', T: Payloads },
    { no: 2, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationTermination {
    return new BatchOperationTermination().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationTermination {
    return new BatchOperationTermination().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationTermination {
    return new BatchOperationTermination().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationTermination | PlainMessage<BatchOperationTermination> | undefined,
    b: BatchOperationTermination | PlainMessage<BatchOperationTermination> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationTermination, a, b)
  }
}

/**
 * BatchOperationSignal sends signals to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationSignal
 */
export class BatchOperationSignal extends Message<BatchOperationSignal> {
  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal = 1;
   */
  signal = ''

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads

  /**
   * Headers that are passed with the signal to the processing workflow.
   * These can include things like auth or tracing tokens.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 4;
   */
  identity = ''

  constructor(data?: PartialMessage<BatchOperationSignal>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationSignal'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'signal', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'input', kind: 'message', T: Payloads },
    { no: 3, name: 'header', kind: 'message', T: Header },
    { no: 4, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationSignal {
    return new BatchOperationSignal().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationSignal {
    return new BatchOperationSignal().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationSignal {
    return new BatchOperationSignal().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationSignal | PlainMessage<BatchOperationSignal> | undefined,
    b: BatchOperationSignal | PlainMessage<BatchOperationSignal> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationSignal, a, b)
  }
}

/**
 * BatchOperationCancellation sends cancel requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
 * Ignore first_execution_run_id because this is used for single workflow operation.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationCancellation
 */
export class BatchOperationCancellation extends Message<BatchOperationCancellation> {
  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  constructor(data?: PartialMessage<BatchOperationCancellation>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationCancellation'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationCancellation {
    return new BatchOperationCancellation().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationCancellation {
    return new BatchOperationCancellation().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationCancellation {
    return new BatchOperationCancellation().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationCancellation | PlainMessage<BatchOperationCancellation> | undefined,
    b: BatchOperationCancellation | PlainMessage<BatchOperationCancellation> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationCancellation, a, b)
  }
}

/**
 * BatchOperationDeletion sends deletion requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationDeletion
 */
export class BatchOperationDeletion extends Message<BatchOperationDeletion> {
  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  constructor(data?: PartialMessage<BatchOperationDeletion>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationDeletion'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationDeletion {
    return new BatchOperationDeletion().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationDeletion {
    return new BatchOperationDeletion().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationDeletion {
    return new BatchOperationDeletion().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationDeletion | PlainMessage<BatchOperationDeletion> | undefined,
    b: BatchOperationDeletion | PlainMessage<BatchOperationDeletion> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationDeletion, a, b)
  }
}

/**
 * BatchOperationReset sends reset requests to batch workflows.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationReset
 */
export class BatchOperationReset extends Message<BatchOperationReset> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 3;
   */
  identity = ''

  /**
   * Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored.
   *
   * @generated from field: temporal.api.common.v1.ResetOptions options = 4;
   */
  options?: ResetOptions

  /**
   * Deprecated. Use `options`.
   *
   * @generated from field: temporal.api.enums.v1.ResetType reset_type = 1 [deprecated = true];
   * @deprecated
   */
  resetType = ResetType.UNSPECIFIED

  /**
   * Deprecated. Use `options`.
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 2 [deprecated = true];
   * @deprecated
   */
  resetReapplyType = ResetReapplyType.UNSPECIFIED

  /**
   * Operations to perform after the workflow has been reset. These operations will be applied
   * to the *new* run of the workflow execution in the order they are provided.
   * All operations are applied to the workflow before the first new workflow task is generated
   *
   * @generated from field: repeated temporal.api.workflow.v1.PostResetOperation post_reset_operations = 5;
   */
  postResetOperations: PostResetOperation[] = []

  constructor(data?: PartialMessage<BatchOperationReset>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationReset'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'options', kind: 'message', T: ResetOptions },
    { no: 1, name: 'reset_type', kind: 'enum', T: proto3.getEnumType(ResetType) },
    { no: 2, name: 'reset_reapply_type', kind: 'enum', T: proto3.getEnumType(ResetReapplyType) },
    { no: 5, name: 'post_reset_operations', kind: 'message', T: PostResetOperation, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationReset {
    return new BatchOperationReset().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationReset {
    return new BatchOperationReset().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationReset {
    return new BatchOperationReset().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationReset | PlainMessage<BatchOperationReset> | undefined,
    b: BatchOperationReset | PlainMessage<BatchOperationReset> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationReset, a, b)
  }
}

/**
 * BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
 * Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions
 */
export class BatchOperationUpdateWorkflowExecutionOptions extends Message<BatchOperationUpdateWorkflowExecutionOptions> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  /**
   * Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 2;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask

  constructor(data?: PartialMessage<BatchOperationUpdateWorkflowExecutionOptions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'workflow_execution_options', kind: 'message', T: WorkflowExecutionOptions },
    { no: 3, name: 'update_mask', kind: 'message', T: FieldMask },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): BatchOperationUpdateWorkflowExecutionOptions {
    return new BatchOperationUpdateWorkflowExecutionOptions().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): BatchOperationUpdateWorkflowExecutionOptions {
    return new BatchOperationUpdateWorkflowExecutionOptions().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): BatchOperationUpdateWorkflowExecutionOptions {
    return new BatchOperationUpdateWorkflowExecutionOptions().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | BatchOperationUpdateWorkflowExecutionOptions
      | PlainMessage<BatchOperationUpdateWorkflowExecutionOptions>
      | undefined,
    b:
      | BatchOperationUpdateWorkflowExecutionOptions
      | PlainMessage<BatchOperationUpdateWorkflowExecutionOptions>
      | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationUpdateWorkflowExecutionOptions, a, b)
  }
}

/**
 * BatchOperationUnpauseActivities sends unpause requests to batch workflows.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUnpauseActivities
 */
export class BatchOperationUnpauseActivities extends Message<BatchOperationUnpauseActivities> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  /**
   * The activity to unpause. If match_all is set to true, all activities will be unpaused.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationUnpauseActivities.activity
   */
  activity:
    | {
        /**
         * @generated from field: string type = 2;
         */
        value: string
        case: 'type'
      }
    | {
        /**
         * @generated from field: bool match_all = 3;
         */
        value: boolean
        case: 'matchAll'
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  /**
   * Setting this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 4;
   */
  resetAttempts = false

  /**
   * Setting this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 5;
   */
  resetHeartbeat = false

  /**
   * If set, the activity will start at a random time within the specified jitter
   * duration, introducing variability to the start time.
   *
   * @generated from field: google.protobuf.Duration jitter = 6;
   */
  jitter?: Duration

  constructor(data?: PartialMessage<BatchOperationUnpauseActivities>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationUnpauseActivities'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'type', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'activity' },
    { no: 3, name: 'match_all', kind: 'scalar', T: 8 /* ScalarType.BOOL */, oneof: 'activity' },
    { no: 4, name: 'reset_attempts', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: 'reset_heartbeat', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: 'jitter', kind: 'message', T: Duration },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationUnpauseActivities {
    return new BatchOperationUnpauseActivities().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationUnpauseActivities {
    return new BatchOperationUnpauseActivities().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationUnpauseActivities {
    return new BatchOperationUnpauseActivities().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationUnpauseActivities | PlainMessage<BatchOperationUnpauseActivities> | undefined,
    b: BatchOperationUnpauseActivities | PlainMessage<BatchOperationUnpauseActivities> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationUnpauseActivities, a, b)
  }
}

/**
 * BatchOperationTriggerWorkflowRule sends TriggerWorkflowRule requests to batch workflows.
 *
 * @generated from message temporal.api.batch.v1.BatchOperationTriggerWorkflowRule
 */
export class BatchOperationTriggerWorkflowRule extends Message<BatchOperationTriggerWorkflowRule> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  /**
   * @generated from oneof temporal.api.batch.v1.BatchOperationTriggerWorkflowRule.rule
   */
  rule:
    | {
        /**
         * ID of existing rule.
         *
         * @generated from field: string id = 2;
         */
        value: string
        case: 'id'
      }
    | {
        /**
         * Rule specification to be applied to the workflow without creating a new rule.
         *
         * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 3;
         */
        value: WorkflowRuleSpec
        case: 'spec'
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  constructor(data?: PartialMessage<BatchOperationTriggerWorkflowRule>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationTriggerWorkflowRule'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'rule' },
    { no: 3, name: 'spec', kind: 'message', T: WorkflowRuleSpec, oneof: 'rule' },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationTriggerWorkflowRule {
    return new BatchOperationTriggerWorkflowRule().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationTriggerWorkflowRule {
    return new BatchOperationTriggerWorkflowRule().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationTriggerWorkflowRule {
    return new BatchOperationTriggerWorkflowRule().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationTriggerWorkflowRule | PlainMessage<BatchOperationTriggerWorkflowRule> | undefined,
    b: BatchOperationTriggerWorkflowRule | PlainMessage<BatchOperationTriggerWorkflowRule> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationTriggerWorkflowRule, a, b)
  }
}

/**
 * BatchOperationResetActivities sends activity reset requests in a batch.
 * NOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest
 *
 * @generated from message temporal.api.batch.v1.BatchOperationResetActivities
 */
export class BatchOperationResetActivities extends Message<BatchOperationResetActivities> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  /**
   * The activities to reset. If match_all is set to true, all activities will be reset.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationResetActivities.activity
   */
  activity:
    | {
        /**
         * @generated from field: string type = 2;
         */
        value: string
        case: 'type'
      }
    | {
        /**
         * @generated from field: bool match_all = 3;
         */
        value: boolean
        case: 'matchAll'
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  /**
   * Setting this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 4;
   */
  resetAttempts = false

  /**
   * Setting this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 5;
   */
  resetHeartbeat = false

  /**
   * If activity is paused, it will remain paused after reset
   *
   * @generated from field: bool keep_paused = 6;
   */
  keepPaused = false

  /**
   * If set, the activity will start at a random time within the specified jitter
   * duration, introducing variability to the start time.
   *
   * @generated from field: google.protobuf.Duration jitter = 7;
   */
  jitter?: Duration

  /**
   * If set, the activity options will be restored to the defaults.
   * Default options are then options activity was created with.
   * They are part of the first ActivityTaskScheduled event.
   *
   * @generated from field: bool restore_original_options = 8;
   */
  restoreOriginalOptions = false

  constructor(data?: PartialMessage<BatchOperationResetActivities>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationResetActivities'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'type', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'activity' },
    { no: 3, name: 'match_all', kind: 'scalar', T: 8 /* ScalarType.BOOL */, oneof: 'activity' },
    { no: 4, name: 'reset_attempts', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: 'reset_heartbeat', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: 'keep_paused', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: 'jitter', kind: 'message', T: Duration },
    { no: 8, name: 'restore_original_options', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationResetActivities {
    return new BatchOperationResetActivities().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationResetActivities {
    return new BatchOperationResetActivities().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationResetActivities {
    return new BatchOperationResetActivities().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationResetActivities | PlainMessage<BatchOperationResetActivities> | undefined,
    b: BatchOperationResetActivities | PlainMessage<BatchOperationResetActivities> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationResetActivities, a, b)
  }
}

/**
 * BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.
 * NOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest
 *
 * @generated from message temporal.api.batch.v1.BatchOperationUpdateActivityOptions
 */
export class BatchOperationUpdateActivityOptions extends Message<BatchOperationUpdateActivityOptions> {
  /**
   * The identity of the worker/client.
   *
   * @generated from field: string identity = 1;
   */
  identity = ''

  /**
   * The activity to update. If match_all is set to true, all activities will be updated.
   *
   * @generated from oneof temporal.api.batch.v1.BatchOperationUpdateActivityOptions.activity
   */
  activity:
    | {
        /**
         * @generated from field: string type = 2;
         */
        value: string
        case: 'type'
      }
    | {
        /**
         * @generated from field: bool match_all = 3;
         */
        value: boolean
        case: 'matchAll'
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  /**
   * Update Activity options. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 4;
   */
  activityOptions?: ActivityOptions

  /**
   * Controls which fields from `activity_options` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask

  /**
   * If set, the activity options will be restored to the default.
   * Default options are then options activity was created with.
   * They are part of the first ActivityTaskScheduled event.
   * This flag cannot be combined with any other option; if you supply
   * restore_original together with other options, the request will be rejected.
   *
   * @generated from field: bool restore_original = 6;
   */
  restoreOriginal = false

  constructor(data?: PartialMessage<BatchOperationUpdateActivityOptions>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.batch.v1.BatchOperationUpdateActivityOptions'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'identity', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'type', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'activity' },
    { no: 3, name: 'match_all', kind: 'scalar', T: 8 /* ScalarType.BOOL */, oneof: 'activity' },
    { no: 4, name: 'activity_options', kind: 'message', T: ActivityOptions },
    { no: 5, name: 'update_mask', kind: 'message', T: FieldMask },
    { no: 6, name: 'restore_original', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchOperationUpdateActivityOptions {
    return new BatchOperationUpdateActivityOptions().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchOperationUpdateActivityOptions {
    return new BatchOperationUpdateActivityOptions().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchOperationUpdateActivityOptions {
    return new BatchOperationUpdateActivityOptions().fromJsonString(jsonString, options)
  }

  static equals(
    a: BatchOperationUpdateActivityOptions | PlainMessage<BatchOperationUpdateActivityOptions> | undefined,
    b: BatchOperationUpdateActivityOptions | PlainMessage<BatchOperationUpdateActivityOptions> | undefined,
  ): boolean {
    return proto3.util.equals(BatchOperationUpdateActivityOptions, a, b)
  }
}
