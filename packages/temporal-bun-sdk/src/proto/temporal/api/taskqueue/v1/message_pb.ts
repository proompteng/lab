// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/taskqueue/v1/message.proto (package temporal.api.taskqueue.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { BuildIdTaskReachability, TaskQueueKind, TaskReachability } from "../../enums/v1/task_queue_pb.js";
import { file_temporal_api_enums_v1_task_queue } from "../../enums/v1/task_queue_pb.js";
import type { WorkerVersionCapabilities } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { WorkerDeploymentOptions, WorkerDeploymentVersion } from "../../deployment/v1/message_pb.js";
import { file_temporal_api_deployment_v1_message } from "../../deployment/v1/message_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/taskqueue/v1/message.proto.
 */
export const file_temporal_api_taskqueue_v1_message: GenFile = /*@__PURE__*/
  fileDesc("Cid0ZW1wb3JhbC9hcGkvdGFza3F1ZXVlL3YxL21lc3NhZ2UucHJvdG8SGXRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEiYgoJVGFza1F1ZXVlEgwKBG5hbWUYASABKAkSMgoEa2luZBgCIAEoDjIkLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5UYXNrUXVldWVLaW5kEhMKC25vcm1hbF9uYW1lGAMgASgJIk8KEVRhc2tRdWV1ZU1ldGFkYXRhEjoKFG1heF90YXNrc19wZXJfc2Vjb25kGAEgASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlItoCChdUYXNrUXVldWVWZXJzaW9uaW5nSW5mbxJXChpjdXJyZW50X2RlcGxveW1lbnRfdmVyc2lvbhgHIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uEhsKD2N1cnJlbnRfdmVyc2lvbhgBIAEoCUICGAESVwoacmFtcGluZ19kZXBsb3ltZW50X3ZlcnNpb24YCSABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhIbCg9yYW1waW5nX3ZlcnNpb24YAiABKAlCAhgBEiIKGnJhbXBpbmdfdmVyc2lvbl9wZXJjZW50YWdlGAMgASgCEi8KC3VwZGF0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJXChlUYXNrUXVldWVWZXJzaW9uU2VsZWN0aW9uEhEKCWJ1aWxkX2lkcxgBIAMoCRITCgt1bnZlcnNpb25lZBgCIAEoCBISCgphbGxfYWN0aXZlGAMgASgIIpUCChRUYXNrUXVldWVWZXJzaW9uSW5mbxJSCgp0eXBlc19pbmZvGAEgAygLMj4udGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVWZXJzaW9uSW5mby5UeXBlc0luZm9FbnRyeRJJChF0YXNrX3JlYWNoYWJpbGl0eRgCIAEoDjIuLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5CdWlsZElkVGFza1JlYWNoYWJpbGl0eRpeCg5UeXBlc0luZm9FbnRyeRILCgNrZXkYASABKAUSOwoFdmFsdWUYAiABKAsyLC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVR5cGVJbmZvOgI4ASKFAQoRVGFza1F1ZXVlVHlwZUluZm8SNgoHcG9sbGVycxgBIAMoCzIlLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuUG9sbGVySW5mbxI4CgVzdGF0cxgCIAEoCzIpLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlU3RhdHMipAEKDlRhc2tRdWV1ZVN0YXRzEiEKGWFwcHJveGltYXRlX2JhY2tsb2dfY291bnQYASABKAMSOgoXYXBwcm94aW1hdGVfYmFja2xvZ19hZ2UYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SFgoOdGFza3NfYWRkX3JhdGUYAyABKAISGwoTdGFza3NfZGlzcGF0Y2hfcmF0ZRgEIAEoAiKsAQoPVGFza1F1ZXVlU3RhdHVzEhoKEmJhY2tsb2dfY291bnRfaGludBgBIAEoAxISCgpyZWFkX2xldmVsGAIgASgDEhEKCWFja19sZXZlbBgDIAEoAxIXCg9yYXRlX3Blcl9zZWNvbmQYBCABKAESPQoNdGFza19pZF9ibG9jaxgFIAEoCzImLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza0lkQmxvY2siLwoLVGFza0lkQmxvY2sSEAoIc3RhcnRfaWQYASABKAMSDgoGZW5kX2lkGAIgASgDIkIKGlRhc2tRdWV1ZVBhcnRpdGlvbk1ldGFkYXRhEgsKA2tleRgBIAEoCRIXCg9vd25lcl9ob3N0X25hbWUYAiABKAkimgIKClBvbGxlckluZm8SNAoQbGFzdF9hY2Nlc3NfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEAoIaWRlbnRpdHkYAiABKAkSFwoPcmF0ZV9wZXJfc2Vjb25kGAMgASgBEloKG3dvcmtlcl92ZXJzaW9uX2NhcGFiaWxpdGllcxgEIAEoCzIxLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvbkNhcGFiaWxpdGllc0ICGAESTwoSZGVwbG95bWVudF9vcHRpb25zGAUgASgLMjMudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudE9wdGlvbnMimgEKGVN0aWNreUV4ZWN1dGlvbkF0dHJpYnV0ZXMSPwoRd29ya2VyX3Rhc2tfcXVldWUYASABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRI8ChlzY2hlZHVsZV90b19zdGFydF90aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIikKFENvbXBhdGlibGVWZXJzaW9uU2V0EhEKCWJ1aWxkX2lkcxgBIAMoCSJqChVUYXNrUXVldWVSZWFjaGFiaWxpdHkSEgoKdGFza19xdWV1ZRgBIAEoCRI9CgxyZWFjaGFiaWxpdHkYAiADKA4yJy50ZW1wb3JhbC5hcGkuZW51bXMudjEuVGFza1JlYWNoYWJpbGl0eSJ6ChNCdWlsZElkUmVhY2hhYmlsaXR5EhAKCGJ1aWxkX2lkGAEgASgJElEKF3Rhc2tfcXVldWVfcmVhY2hhYmlsaXR5GAIgAygLMjAudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVSZWFjaGFiaWxpdHkiKwoQUmFtcEJ5UGVyY2VudGFnZRIXCg9yYW1wX3BlcmNlbnRhZ2UYASABKAIigAEKFUJ1aWxkSWRBc3NpZ25tZW50UnVsZRIXCg90YXJnZXRfYnVpbGRfaWQYASABKAkSRgoPcGVyY2VudGFnZV9yYW1wGAMgASgLMisudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5SYW1wQnlQZXJjZW50YWdlSABCBgoEcmFtcCJRCh1Db21wYXRpYmxlQnVpbGRJZFJlZGlyZWN0UnVsZRIXCg9zb3VyY2VfYnVpbGRfaWQYASABKAkSFwoPdGFyZ2V0X2J1aWxkX2lkGAIgASgJIpMBCiBUaW1lc3RhbXBlZEJ1aWxkSWRBc3NpZ25tZW50UnVsZRI+CgRydWxlGAEgASgLMjAudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5CdWlsZElkQXNzaWdubWVudFJ1bGUSLwoLY3JlYXRlX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIqMBCihUaW1lc3RhbXBlZENvbXBhdGlibGVCdWlsZElkUmVkaXJlY3RSdWxlEkYKBHJ1bGUYASABKAsyOC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkNvbXBhdGlibGVCdWlsZElkUmVkaXJlY3RSdWxlEi8KC2NyZWF0ZV90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCI+ChVQb2xsZXJTY2FsaW5nRGVjaXNpb24SJQodcG9sbF9yZXF1ZXN0X2RlbHRhX3N1Z2dlc3Rpb24YASABKAUiKAoJUmF0ZUxpbWl0EhsKE3JlcXVlc3RzX3Blcl9zZWNvbmQYASABKAIiagoOQ29uZmlnTWV0YWRhdGESDgoGcmVhc29uGAEgASgJEhcKD3VwZGF0ZV9pZGVudGl0eRgCIAEoCRIvCgt1cGRhdGVfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiiAEKD1JhdGVMaW1pdENvbmZpZxI4CgpyYXRlX2xpbWl0GAEgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5SYXRlTGltaXQSOwoIbWV0YWRhdGEYAiABKAsyKS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkNvbmZpZ01ldGFkYXRhItkCCg9UYXNrUXVldWVDb25maWcSRAoQcXVldWVfcmF0ZV9saW1pdBgBIAEoCzIqLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuUmF0ZUxpbWl0Q29uZmlnElQKIGZhaXJuZXNzX2tleXNfcmF0ZV9saW1pdF9kZWZhdWx0GAIgASgLMioudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5SYXRlTGltaXRDb25maWcSagoZZmFpcm5lc3Nfd2VpZ2h0X292ZXJyaWRlcxgDIAMoCzJHLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlQ29uZmlnLkZhaXJuZXNzV2VpZ2h0T3ZlcnJpZGVzRW50cnkaPgocRmFpcm5lc3NXZWlnaHRPdmVycmlkZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAI6AjgBQpgBChxpby50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxQgxNZXNzYWdlUHJvdG9QAVopZ28udGVtcG9yYWwuaW8vYXBpL3Rhc2txdWV1ZS92MTt0YXNrcXVldWWqAhtUZW1wb3JhbGlvLkFwaS5UYXNrUXVldWUuVjHqAh5UZW1wb3JhbGlvOjpBcGk6OlRhc2tRdWV1ZTo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers, file_temporal_api_enums_v1_task_queue, file_temporal_api_common_v1_message, file_temporal_api_deployment_v1_message]);

/**
 * See https://docs.temporal.io/docs/concepts/task-queues/
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueue
 */
export type TaskQueue = Message<"temporal.api.taskqueue.v1.TaskQueue"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Default: TASK_QUEUE_KIND_NORMAL.
   *
   * @generated from field: temporal.api.enums.v1.TaskQueueKind kind = 2;
   */
  kind: TaskQueueKind;

  /**
   * Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
   * the normal task queue that the sticky worker is running on.
   *
   * @generated from field: string normal_name = 3;
   */
  normalName: string;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueue.
 * Use `create(TaskQueueSchema)` to create a new message.
 */
export const TaskQueueSchema: GenMessage<TaskQueue> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 0);

/**
 * Only applies to activity task queues
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueMetadata
 */
export type TaskQueueMetadata = Message<"temporal.api.taskqueue.v1.TaskQueueMetadata"> & {
  /**
   * Allows throttling dispatch of tasks from this queue
   *
   * @generated from field: google.protobuf.DoubleValue max_tasks_per_second = 1;
   */
  maxTasksPerSecond?: number;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueMetadata.
 * Use `create(TaskQueueMetadataSchema)` to create a new message.
 */
export const TaskQueueMetadataSchema: GenMessage<TaskQueueMetadata> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 1);

/**
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersioningInfo
 */
export type TaskQueueVersioningInfo = Message<"temporal.api.taskqueue.v1.TaskQueueVersioningInfo"> & {
  /**
   * Specifies which Deployment Version should receive new workflow executions and tasks of
   * existing unversioned or AutoUpgrade workflows.
   * Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   * Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
   * is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion current_deployment_version = 7;
   */
  currentDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `current_deployment_version`.
   *
   * @generated from field: string current_version = 1 [deprecated = true];
   * @deprecated
   */
  currentVersion: string;

  /**
   * When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
   * Must always be different from `current_deployment_version` unless both are nil.
   * Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   * Note that it is possible to ramp from one Version to another Version, or from unversioned
   * workers to a particular Version, or from a particular Version to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion ramping_deployment_version = 9;
   */
  rampingDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `ramping_deployment_version`.
   *
   * @generated from field: string ramping_version = 2 [deprecated = true];
   * @deprecated
   */
  rampingVersion: string;

  /**
   * Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
   * Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
   * not yet "promoted" to be the Current Version, likely due to pending validations.
   * A 0% value means the Ramping Version is receiving no traffic.
   *
   * @generated from field: float ramping_version_percentage = 3;
   */
  rampingVersionPercentage: number;

  /**
   * Last time versioning information of this Task Queue changed.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 4;
   */
  updateTime?: Timestamp;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueVersioningInfo.
 * Use `create(TaskQueueVersioningInfoSchema)` to create a new message.
 */
export const TaskQueueVersioningInfoSchema: GenMessage<TaskQueueVersioningInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 2);

/**
 * Used for specifying versions the caller is interested in.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersionSelection
 */
export type TaskQueueVersionSelection = Message<"temporal.api.taskqueue.v1.TaskQueueVersionSelection"> & {
  /**
   * Include specific Build IDs.
   *
   * @generated from field: repeated string build_ids = 1;
   */
  buildIds: string[];

  /**
   * Include the unversioned queue.
   *
   * @generated from field: bool unversioned = 2;
   */
  unversioned: boolean;

  /**
   * Include all active versions. A version is considered active if, in the last few minutes,
   * it has had new tasks or polls, or it has been the subject of certain task queue API calls.
   *
   * @generated from field: bool all_active = 3;
   */
  allActive: boolean;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueVersionSelection.
 * Use `create(TaskQueueVersionSelectionSchema)` to create a new message.
 */
export const TaskQueueVersionSelectionSchema: GenMessage<TaskQueueVersionSelection> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 3);

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersionInfo
 */
export type TaskQueueVersionInfo = Message<"temporal.api.taskqueue.v1.TaskQueueVersionInfo"> & {
  /**
   * Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueTypeInfo> types_info = 1;
   */
  typesInfo: { [key: number]: TaskQueueTypeInfo };

  /**
   * Task Reachability is eventually consistent; there may be a delay until it converges to the most
   * accurate value but it is designed in a way to take the more conservative side until it converges.
   * For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
   *
   * Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
   * accounted for reachability as server cannot know if they'll happen as they do not use
   * assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
   * who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
   * sure to query reachability for the parent/previous workflow's Task Queue as well.
   *
   * @generated from field: temporal.api.enums.v1.BuildIdTaskReachability task_reachability = 2;
   */
  taskReachability: BuildIdTaskReachability;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueVersionInfo.
 * Use `create(TaskQueueVersionInfoSchema)` to create a new message.
 */
export const TaskQueueVersionInfoSchema: GenMessage<TaskQueueVersionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 4);

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueTypeInfo
 */
export type TaskQueueTypeInfo = Message<"temporal.api.taskqueue.v1.TaskQueueTypeInfo"> & {
  /**
   * Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.PollerInfo pollers = 1;
   */
  pollers: PollerInfo[];

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 2;
   */
  stats?: TaskQueueStats;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueTypeInfo.
 * Use `create(TaskQueueTypeInfoSchema)` to create a new message.
 */
export const TaskQueueTypeInfoSchema: GenMessage<TaskQueueTypeInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 5);

/**
 * TaskQueueStats contains statistics about task queue backlog and activity.
 *
 * For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
 * comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueStats
 */
export type TaskQueueStats = Message<"temporal.api.taskqueue.v1.TaskQueueStats"> & {
  /**
   * The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
   * converges to the right value. Can be relied upon for scaling decisions.
   *
   * Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
   * those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
   * grows.
   *
   * @generated from field: int64 approximate_backlog_count = 1;
   */
  approximateBacklogCount: bigint;

  /**
   * Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
   * the queue. Can be relied upon for scaling decisions.
   *
   * Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
   * those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
   * few seconds.
   *
   * @generated from field: google.protobuf.Duration approximate_backlog_age = 2;
   */
  approximateBacklogAge?: Duration;

  /**
   * The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
   * whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
   * to the backlog (sync-matched).
   *
   * The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
   * backlog grows/shrinks.
   *
   * Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
   * tasks_add_rate, because:
   * - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
   *   enable for activities by default in the latest SDKs.
   * - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
   *   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
   *   worker instance.
   *
   * @generated from field: float tasks_add_rate = 3;
   */
  tasksAddRate: number;

  /**
   * The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
   * tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
   * going to the backlog (sync-matched).
   *
   * The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
   * backlog grows/shrinks.
   *
   * Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
   * tasks_dispatch_rate, because:
   * - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
   *   enable for activities by default in the latest SDKs.
   * - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
   *   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
   *   worker instance.
   *
   * @generated from field: float tasks_dispatch_rate = 4;
   */
  tasksDispatchRate: number;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueStats.
 * Use `create(TaskQueueStatsSchema)` to create a new message.
 */
export const TaskQueueStatsSchema: GenMessage<TaskQueueStats> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 6);

/**
 * Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueStatus
 */
export type TaskQueueStatus = Message<"temporal.api.taskqueue.v1.TaskQueueStatus"> & {
  /**
   * @generated from field: int64 backlog_count_hint = 1;
   */
  backlogCountHint: bigint;

  /**
   * @generated from field: int64 read_level = 2;
   */
  readLevel: bigint;

  /**
   * @generated from field: int64 ack_level = 3;
   */
  ackLevel: bigint;

  /**
   * @generated from field: double rate_per_second = 4;
   */
  ratePerSecond: number;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskIdBlock task_id_block = 5;
   */
  taskIdBlock?: TaskIdBlock;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueStatus.
 * Use `create(TaskQueueStatusSchema)` to create a new message.
 */
export const TaskQueueStatusSchema: GenMessage<TaskQueueStatus> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 7);

/**
 * @generated from message temporal.api.taskqueue.v1.TaskIdBlock
 */
export type TaskIdBlock = Message<"temporal.api.taskqueue.v1.TaskIdBlock"> & {
  /**
   * @generated from field: int64 start_id = 1;
   */
  startId: bigint;

  /**
   * @generated from field: int64 end_id = 2;
   */
  endId: bigint;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskIdBlock.
 * Use `create(TaskIdBlockSchema)` to create a new message.
 */
export const TaskIdBlockSchema: GenMessage<TaskIdBlock> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 8);

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueuePartitionMetadata
 */
export type TaskQueuePartitionMetadata = Message<"temporal.api.taskqueue.v1.TaskQueuePartitionMetadata"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string owner_host_name = 2;
   */
  ownerHostName: string;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueuePartitionMetadata.
 * Use `create(TaskQueuePartitionMetadataSchema)` to create a new message.
 */
export const TaskQueuePartitionMetadataSchema: GenMessage<TaskQueuePartitionMetadata> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 9);

/**
 * @generated from message temporal.api.taskqueue.v1.PollerInfo
 */
export type PollerInfo = Message<"temporal.api.taskqueue.v1.PollerInfo"> & {
  /**
   * @generated from field: google.protobuf.Timestamp last_access_time = 1;
   */
  lastAccessTime?: Timestamp;

  /**
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * @generated from field: double rate_per_second = 3;
   */
  ratePerSecond: number;

  /**
   * If a worker has opted into the worker versioning feature while polling, its capabilities will
   * appear here.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that SDK sent to server.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 5;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.taskqueue.v1.PollerInfo.
 * Use `create(PollerInfoSchema)` to create a new message.
 */
export const PollerInfoSchema: GenMessage<PollerInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 10);

/**
 * @generated from message temporal.api.taskqueue.v1.StickyExecutionAttributes
 */
export type StickyExecutionAttributes = Message<"temporal.api.taskqueue.v1.StickyExecutionAttributes"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue worker_task_queue = 1;
   */
  workerTaskQueue?: TaskQueue;

  /**
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 2;
   */
  scheduleToStartTimeout?: Duration;
};

/**
 * Describes the message temporal.api.taskqueue.v1.StickyExecutionAttributes.
 * Use `create(StickyExecutionAttributesSchema)` to create a new message.
 */
export const StickyExecutionAttributesSchema: GenMessage<StickyExecutionAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 11);

/**
 * Used by the worker versioning APIs, represents an unordered set of one or more versions which are
 * considered to be compatible with each other. Currently the versions are always worker build IDs.
 *
 * @generated from message temporal.api.taskqueue.v1.CompatibleVersionSet
 */
export type CompatibleVersionSet = Message<"temporal.api.taskqueue.v1.CompatibleVersionSet"> & {
  /**
   * All the compatible versions, unordered, except for the last element, which is considered the set "default".
   *
   * @generated from field: repeated string build_ids = 1;
   */
  buildIds: string[];
};

/**
 * Describes the message temporal.api.taskqueue.v1.CompatibleVersionSet.
 * Use `create(CompatibleVersionSetSchema)` to create a new message.
 */
export const CompatibleVersionSetSchema: GenMessage<CompatibleVersionSet> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 12);

/**
 * Reachability of tasks for a worker on a single task queue.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueReachability
 */
export type TaskQueueReachability = Message<"temporal.api.taskqueue.v1.TaskQueueReachability"> & {
  /**
   * @generated from field: string task_queue = 1;
   */
  taskQueue: string;

  /**
   * Task reachability for a worker in a single task queue.
   * See the TaskReachability docstring for information about each enum variant.
   * If reachability is empty, this worker is considered unreachable in this task queue.
   *
   * @generated from field: repeated temporal.api.enums.v1.TaskReachability reachability = 2;
   */
  reachability: TaskReachability[];
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueReachability.
 * Use `create(TaskQueueReachabilitySchema)` to create a new message.
 */
export const TaskQueueReachabilitySchema: GenMessage<TaskQueueReachability> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 13);

/**
 * Reachability of tasks for a worker by build id, in one or more task queues.
 *
 * @generated from message temporal.api.taskqueue.v1.BuildIdReachability
 */
export type BuildIdReachability = Message<"temporal.api.taskqueue.v1.BuildIdReachability"> & {
  /**
   * A build id or empty if unversioned.
   *
   * @generated from field: string build_id = 1;
   */
  buildId: string;

  /**
   * Reachability per task queue.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueueReachability task_queue_reachability = 2;
   */
  taskQueueReachability: TaskQueueReachability[];
};

/**
 * Describes the message temporal.api.taskqueue.v1.BuildIdReachability.
 * Use `create(BuildIdReachabilitySchema)` to create a new message.
 */
export const BuildIdReachabilitySchema: GenMessage<BuildIdReachability> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 14);

/**
 * @generated from message temporal.api.taskqueue.v1.RampByPercentage
 */
export type RampByPercentage = Message<"temporal.api.taskqueue.v1.RampByPercentage"> & {
  /**
   * Acceptable range is [0,100).
   *
   * @generated from field: float ramp_percentage = 1;
   */
  rampPercentage: number;
};

/**
 * Describes the message temporal.api.taskqueue.v1.RampByPercentage.
 * Use `create(RampByPercentageSchema)` to create a new message.
 */
export const RampByPercentageSchema: GenMessage<RampByPercentage> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 15);

/**
 * Assignment rules are applied to *new* Workflow and Activity executions at
 * schedule time to assign them to a Build ID.
 *
 * Assignment rules will not be used in the following cases:
 *    - Child Workflows or Continue-As-New Executions who inherit their
 *      parent/previous Workflow's assigned Build ID (by setting the
 *      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
 *      is used.)
 *    - An Activity that inherits the assigned Build ID of its Workflow (by
 *      setting the `use_workflow_build_id` flag - default behavior in SDKs
 *      when the same Task Queue is used.)
 *
 * In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
 * the task will be dispatched to Workers of the Build ID determined by the
 * assignment rules (or inherited). Otherwise, the final Build ID will be
 * determined by the redirect rules.
 *
 * Once a Workflow completes its first Workflow Task in a particular Build ID it
 * stays in that Build ID regardless of changes to assignment rules. Redirect
 * rules can be used to move the workflow to another compatible Build ID.
 *
 * When using Worker Versioning on a Task Queue, in the steady state,
 * there should typically be a single assignment rule to send all new executions
 * to the latest Build ID. Existence of at least one such "unconditional"
 * rule at all times is enforces by the system, unless the `force` flag is used
 * by the user when replacing/deleting these rules (for exceptional cases).
 *
 * During a deployment, one or more additional rules can be added to assign a
 * subset of the tasks to a new Build ID based on a "ramp percentage".
 *
 * When there are multiple assignment rules for a Task Queue, the rules are
 * evaluated in order, starting from index 0. The first applicable rule will be
 * applied and the rest will be ignored.
 *
 * In the event that no assignment rule is applicable on a task (or the Task
 * Queue is simply not versioned), the tasks will be dispatched to an
 * unversioned Worker.
 *
 * @generated from message temporal.api.taskqueue.v1.BuildIdAssignmentRule
 */
export type BuildIdAssignmentRule = Message<"temporal.api.taskqueue.v1.BuildIdAssignmentRule"> & {
  /**
   * @generated from field: string target_build_id = 1;
   */
  targetBuildId: string;

  /**
   * If a ramp is provided, this rule will be applied only to a sample of
   * tasks according to the provided percentage.
   * This option can be used only on "terminal" Build IDs (the ones not used
   * as source in any redirect rules).
   *
   * @generated from oneof temporal.api.taskqueue.v1.BuildIdAssignmentRule.ramp
   */
  ramp: {
    /**
     * This ramp is useful for gradual Blue/Green deployments (and similar)
     * where you want to send a certain portion of the traffic to the target
     * Build ID.
     *
     * @generated from field: temporal.api.taskqueue.v1.RampByPercentage percentage_ramp = 3;
     */
    value: RampByPercentage;
    case: "percentageRamp";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.taskqueue.v1.BuildIdAssignmentRule.
 * Use `create(BuildIdAssignmentRuleSchema)` to create a new message.
 */
export const BuildIdAssignmentRuleSchema: GenMessage<BuildIdAssignmentRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 16);

/**
 * These rules apply to tasks assigned to a particular Build ID
 * (`source_build_id`) to redirect them to another *compatible* Build ID
 * (`target_build_id`).
 *
 * It is user's responsibility to ensure that the target Build ID is compatible
 * with the source Build ID (e.g. by using the Patching API).
 *
 * Most deployments are not expected to need these rules, however following
 * situations can greatly benefit from redirects:
 *  - Need to move long-running Workflow Executions from an old Build ID to a
 *    newer one.
 *  - Need to hotfix some broken or stuck Workflow Executions.
 *
 * In steady state, redirect rules are beneficial when dealing with old
 * Executions ran on now-decommissioned Build IDs:
 *  - To redirecting the Workflow Queries to the current (compatible) Build ID.
 *  - To be able to Reset an old Execution so it can run on the current
 *    (compatible) Build ID.
 *
 * Redirect rules can be chained.
 *
 * @generated from message temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule
 */
export type CompatibleBuildIdRedirectRule = Message<"temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule"> & {
  /**
   * @generated from field: string source_build_id = 1;
   */
  sourceBuildId: string;

  /**
   * Target Build ID must be compatible with the Source Build ID; that is it
   * must be able to process event histories made by the Source Build ID by
   * using [Patching](https://docs.temporal.io/workflows#patching) or other
   * means.
   *
   * @generated from field: string target_build_id = 2;
   */
  targetBuildId: string;
};

/**
 * Describes the message temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule.
 * Use `create(CompatibleBuildIdRedirectRuleSchema)` to create a new message.
 */
export const CompatibleBuildIdRedirectRuleSchema: GenMessage<CompatibleBuildIdRedirectRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 17);

/**
 * @generated from message temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule
 */
export type TimestampedBuildIdAssignmentRule = Message<"temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 1;
   */
  rule?: BuildIdAssignmentRule;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule.
 * Use `create(TimestampedBuildIdAssignmentRuleSchema)` to create a new message.
 */
export const TimestampedBuildIdAssignmentRuleSchema: GenMessage<TimestampedBuildIdAssignmentRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 18);

/**
 * @generated from message temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule
 */
export type TimestampedCompatibleBuildIdRedirectRule = Message<"temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;
};

/**
 * Describes the message temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule.
 * Use `create(TimestampedCompatibleBuildIdRedirectRuleSchema)` to create a new message.
 */
export const TimestampedCompatibleBuildIdRedirectRuleSchema: GenMessage<TimestampedCompatibleBuildIdRedirectRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 19);

/**
 * Attached to task responses to give hints to the SDK about how it may adjust its number of
 * pollers.
 *
 * @generated from message temporal.api.taskqueue.v1.PollerScalingDecision
 */
export type PollerScalingDecision = Message<"temporal.api.taskqueue.v1.PollerScalingDecision"> & {
  /**
   * How many poll requests to suggest should be added or removed, if any. As of now, server only
   * scales up or down by 1. However, SDKs should allow for other values (while staying within
   * defined min/max).
   *
   * The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
   * all slots are already occupied.
   *
   * @generated from field: int32 poll_request_delta_suggestion = 1;
   */
  pollRequestDeltaSuggestion: number;
};

/**
 * Describes the message temporal.api.taskqueue.v1.PollerScalingDecision.
 * Use `create(PollerScalingDecisionSchema)` to create a new message.
 */
export const PollerScalingDecisionSchema: GenMessage<PollerScalingDecision> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 20);

/**
 * @generated from message temporal.api.taskqueue.v1.RateLimit
 */
export type RateLimit = Message<"temporal.api.taskqueue.v1.RateLimit"> & {
  /**
   * Zero is a valid rate limit.
   *
   * @generated from field: float requests_per_second = 1;
   */
  requestsPerSecond: number;
};

/**
 * Describes the message temporal.api.taskqueue.v1.RateLimit.
 * Use `create(RateLimitSchema)` to create a new message.
 */
export const RateLimitSchema: GenMessage<RateLimit> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 21);

/**
 * @generated from message temporal.api.taskqueue.v1.ConfigMetadata
 */
export type ConfigMetadata = Message<"temporal.api.taskqueue.v1.ConfigMetadata"> & {
  /**
   * Reason for why the config was set.
   *
   * @generated from field: string reason = 1;
   */
  reason: string;

  /**
   * Identity of the last updater.
   * Set by the request's identity field.
   *
   * @generated from field: string update_identity = 2;
   */
  updateIdentity: string;

  /**
   * Time of the last update.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;
};

/**
 * Describes the message temporal.api.taskqueue.v1.ConfigMetadata.
 * Use `create(ConfigMetadataSchema)` to create a new message.
 */
export const ConfigMetadataSchema: GenMessage<ConfigMetadata> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 22);

/**
 * @generated from message temporal.api.taskqueue.v1.RateLimitConfig
 */
export type RateLimitConfig = Message<"temporal.api.taskqueue.v1.RateLimitConfig"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.RateLimit rate_limit = 1;
   */
  rateLimit?: RateLimit;

  /**
   * @generated from field: temporal.api.taskqueue.v1.ConfigMetadata metadata = 2;
   */
  metadata?: ConfigMetadata;
};

/**
 * Describes the message temporal.api.taskqueue.v1.RateLimitConfig.
 * Use `create(RateLimitConfigSchema)` to create a new message.
 */
export const RateLimitConfigSchema: GenMessage<RateLimitConfig> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 23);

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueConfig
 */
export type TaskQueueConfig = Message<"temporal.api.taskqueue.v1.TaskQueueConfig"> & {
  /**
   * Unless modified, this is the system-defined rate limit.
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimitConfig queue_rate_limit = 1;
   */
  queueRateLimit?: RateLimitConfig;

  /**
   * If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key.
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimitConfig fairness_keys_rate_limit_default = 2;
   */
  fairnessKeysRateLimitDefault?: RateLimitConfig;

  /**
   * If set, overrides the fairness weights for the corresponding fairness keys.
   *
   * @generated from field: map<string, float> fairness_weight_overrides = 3;
   */
  fairnessWeightOverrides: { [key: string]: number };
};

/**
 * Describes the message temporal.api.taskqueue.v1.TaskQueueConfig.
 * Use `create(TaskQueueConfigSchema)` to create a new message.
 */
export const TaskQueueConfigSchema: GenMessage<TaskQueueConfig> = /*@__PURE__*/
  messageDesc(file_temporal_api_taskqueue_v1_message, 24);

