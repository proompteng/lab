// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/schedule/v1/message.proto (package temporal.api.schedule.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Memo, SearchAttributes, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { ScheduleOverlapPolicy } from "../../enums/v1/schedule_pb.js";
import { file_temporal_api_enums_v1_schedule } from "../../enums/v1/schedule_pb.js";
import type { WorkflowExecutionStatus } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { NewWorkflowExecutionInfo } from "../../workflow/v1/message_pb.js";
import { file_temporal_api_workflow_v1_message } from "../../workflow/v1/message_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/schedule/v1/message.proto.
 */
export const file_temporal_api_schedule_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiZ0ZW1wb3JhbC9hcGkvc2NoZWR1bGUvdjEvbWVzc2FnZS5wcm90bxIYdGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxIpUBCgxDYWxlbmRhclNwZWMSDgoGc2Vjb25kGAEgASgJEg4KBm1pbnV0ZRgCIAEoCRIMCgRob3VyGAMgASgJEhQKDGRheV9vZl9tb250aBgEIAEoCRINCgVtb250aBgFIAEoCRIMCgR5ZWFyGAYgASgJEhMKC2RheV9vZl93ZWVrGAcgASgJEg8KB2NvbW1lbnQYCCABKAkiMQoFUmFuZ2USDQoFc3RhcnQYASABKAUSCwoDZW5kGAIgASgFEgwKBHN0ZXAYAyABKAUihgMKFlN0cnVjdHVyZWRDYWxlbmRhclNwZWMSLwoGc2Vjb25kGAEgAygLMh8udGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlJhbmdlEi8KBm1pbnV0ZRgCIAMoCzIfLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5SYW5nZRItCgRob3VyGAMgAygLMh8udGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlJhbmdlEjUKDGRheV9vZl9tb250aBgEIAMoCzIfLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5SYW5nZRIuCgVtb250aBgFIAMoCzIfLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5SYW5nZRItCgR5ZWFyGAYgAygLMh8udGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlJhbmdlEjQKC2RheV9vZl93ZWVrGAcgAygLMh8udGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlJhbmdlEg8KB2NvbW1lbnQYCCABKAkiZQoMSW50ZXJ2YWxTcGVjEisKCGludGVydmFsGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEigKBXBoYXNlGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIroECgxTY2hlZHVsZVNwZWMSTQoTc3RydWN0dXJlZF9jYWxlbmRhchgHIAMoCzIwLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TdHJ1Y3R1cmVkQ2FsZW5kYXJTcGVjEhMKC2Nyb25fc3RyaW5nGAggAygJEjgKCGNhbGVuZGFyGAEgAygLMiYudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLkNhbGVuZGFyU3BlYxI4CghpbnRlcnZhbBgCIAMoCzImLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5JbnRlcnZhbFNwZWMSRAoQZXhjbHVkZV9jYWxlbmRhchgDIAMoCzImLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5DYWxlbmRhclNwZWNCAhgBElUKG2V4Y2x1ZGVfc3RydWN0dXJlZF9jYWxlbmRhchgJIAMoCzIwLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TdHJ1Y3R1cmVkQ2FsZW5kYXJTcGVjEi4KCnN0YXJ0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiwKCGVuZF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIpCgZqaXR0ZXIYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SFQoNdGltZXpvbmVfbmFtZRgKIAEoCRIVCg10aW1lem9uZV9kYXRhGAsgASgMIsgBChBTY2hlZHVsZVBvbGljaWVzEkQKDm92ZXJsYXBfcG9saWN5GAEgASgOMiwudGVtcG9yYWwuYXBpLmVudW1zLnYxLlNjaGVkdWxlT3ZlcmxhcFBvbGljeRIxCg5jYXRjaHVwX3dpbmRvdxgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIYChBwYXVzZV9vbl9mYWlsdXJlGAMgASgIEiEKGWtlZXBfb3JpZ2luYWxfd29ya2Zsb3dfaWQYBCABKAgiaAoOU2NoZWR1bGVBY3Rpb24STAoOc3RhcnRfd29ya2Zsb3cYASABKAsyMi50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuTmV3V29ya2Zsb3dFeGVjdXRpb25JbmZvSABCCAoGYWN0aW9uIpMCChRTY2hlZHVsZUFjdGlvblJlc3VsdBIxCg1zY2hlZHVsZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIvCgthY3R1YWxfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASSAoVc3RhcnRfd29ya2Zsb3dfcmVzdWx0GAsgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhJNChVzdGFydF93b3JrZmxvd19zdGF0dXMYDCABKA4yLi50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dFeGVjdXRpb25TdGF0dXMiYgoNU2NoZWR1bGVTdGF0ZRINCgVub3RlcxgBIAEoCRIOCgZwYXVzZWQYAiABKAgSFwoPbGltaXRlZF9hY3Rpb25zGAMgASgIEhkKEXJlbWFpbmluZ19hY3Rpb25zGAQgASgDIpUBChlUcmlnZ2VySW1tZWRpYXRlbHlSZXF1ZXN0EkQKDm92ZXJsYXBfcG9saWN5GAEgASgOMiwudGVtcG9yYWwuYXBpLmVudW1zLnYxLlNjaGVkdWxlT3ZlcmxhcFBvbGljeRIyCg5zY2hlZHVsZWRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAitQEKD0JhY2tmaWxsUmVxdWVzdBIuCgpzdGFydF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASRAoOb3ZlcmxhcF9wb2xpY3kYAyABKA4yLC50ZW1wb3JhbC5hcGkuZW51bXMudjEuU2NoZWR1bGVPdmVybGFwUG9saWN5IsYBCg1TY2hlZHVsZVBhdGNoElAKE3RyaWdnZXJfaW1tZWRpYXRlbHkYASABKAsyMy50ZW1wb3JhbC5hcGkuc2NoZWR1bGUudjEuVHJpZ2dlckltbWVkaWF0ZWx5UmVxdWVzdBJDChBiYWNrZmlsbF9yZXF1ZXN0GAIgAygLMikudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLkJhY2tmaWxsUmVxdWVzdBINCgVwYXVzZRgDIAEoCRIPCgd1bnBhdXNlGAQgASgJItYDCgxTY2hlZHVsZUluZm8SFAoMYWN0aW9uX2NvdW50GAEgASgDEh0KFW1pc3NlZF9jYXRjaHVwX3dpbmRvdxgCIAEoAxIXCg9vdmVybGFwX3NraXBwZWQYAyABKAMSFgoOYnVmZmVyX2Ryb3BwZWQYCiABKAMSEwoLYnVmZmVyX3NpemUYCyABKAMSRAoRcnVubmluZ193b3JrZmxvd3MYCSADKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEkYKDnJlY2VudF9hY3Rpb25zGAQgAygLMi4udGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlQWN0aW9uUmVzdWx0EjcKE2Z1dHVyZV9hY3Rpb25fdGltZXMYBSADKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi8KC2NyZWF0ZV90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIvCgt1cGRhdGVfdGltZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASIgoWaW52YWxpZF9zY2hlZHVsZV9lcnJvchgIIAEoCUICGAEi8AEKCFNjaGVkdWxlEjQKBHNwZWMYASABKAsyJi50ZW1wb3JhbC5hcGkuc2NoZWR1bGUudjEuU2NoZWR1bGVTcGVjEjgKBmFjdGlvbhgCIAEoCzIoLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TY2hlZHVsZUFjdGlvbhI8Cghwb2xpY2llcxgDIAEoCzIqLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TY2hlZHVsZVBvbGljaWVzEjYKBXN0YXRlGAQgASgLMicudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlU3RhdGUipQIKEFNjaGVkdWxlTGlzdEluZm8SNAoEc3BlYxgBIAEoCzImLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TY2hlZHVsZVNwZWMSOwoNd29ya2Zsb3dfdHlwZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEg0KBW5vdGVzGAMgASgJEg4KBnBhdXNlZBgEIAEoCBJGCg5yZWNlbnRfYWN0aW9ucxgFIAMoCzIuLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TY2hlZHVsZUFjdGlvblJlc3VsdBI3ChNmdXR1cmVfYWN0aW9uX3RpbWVzGAYgAygLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCLTAQoRU2NoZWR1bGVMaXN0RW50cnkSEwoLc2NoZWR1bGVfaWQYASABKAkSKgoEbWVtbxgCIAEoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTWVtbxJDChFzZWFyY2hfYXR0cmlidXRlcxgDIAEoCzIoLnRlbXBvcmFsLmFwaS5jb21tb24udjEuU2VhcmNoQXR0cmlidXRlcxI4CgRpbmZvGAQgASgLMioudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlTGlzdEluZm9CkwEKG2lvLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MUIMTWVzc2FnZVByb3RvUAFaJ2dvLnRlbXBvcmFsLmlvL2FwaS9zY2hlZHVsZS92MTtzY2hlZHVsZaoCGlRlbXBvcmFsaW8uQXBpLlNjaGVkdWxlLlYx6gIdVGVtcG9yYWxpbzo6QXBpOjpTY2hlZHVsZTo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_google_protobuf_timestamp, file_temporal_api_common_v1_message, file_temporal_api_enums_v1_schedule, file_temporal_api_enums_v1_workflow, file_temporal_api_workflow_v1_message]);

/**
 * CalendarSpec describes an event specification relative to the calendar,
 * similar to a traditional cron specification, but with labeled fields. Each
 * field can be one of:
 *   *: matches always
 *   x: matches when the field equals x
 *   x/y : matches when the field equals x+n*y where n is an integer
 *   x-z: matches when the field is between x and z inclusive
 *   w,x,y,...: matches when the field is one of the listed values
 * Each x, y, z, ... is either a decimal integer, or a month or day of week name
 * or abbreviation (in the appropriate fields).
 * A timestamp matches if all fields match.
 * Note that fields have different default values, for convenience.
 * Note that the special case that some cron implementations have for treating
 * day_of_month and day_of_week as "or" instead of "and" when both are set is
 * not implemented.
 * day_of_week can accept 0 or 7 as Sunday
 * CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
 * returned if you describe the schedule.
 *
 * @generated from message temporal.api.schedule.v1.CalendarSpec
 */
export type CalendarSpec = Message<"temporal.api.schedule.v1.CalendarSpec"> & {
  /**
   * Expression to match seconds. Default: 0
   *
   * @generated from field: string second = 1;
   */
  second: string;

  /**
   * Expression to match minutes. Default: 0
   *
   * @generated from field: string minute = 2;
   */
  minute: string;

  /**
   * Expression to match hours. Default: 0
   *
   * @generated from field: string hour = 3;
   */
  hour: string;

  /**
   * Expression to match days of the month. Default: *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: standard name of field --)
   *
   * @generated from field: string day_of_month = 4;
   */
  dayOfMonth: string;

  /**
   * Expression to match months. Default: *
   *
   * @generated from field: string month = 5;
   */
  month: string;

  /**
   * Expression to match years. Default: *
   *
   * @generated from field: string year = 6;
   */
  year: string;

  /**
   * Expression to match days of the week. Default: *
   *
   * @generated from field: string day_of_week = 7;
   */
  dayOfWeek: string;

  /**
   * Free-form comment describing the intention of this spec.
   *
   * @generated from field: string comment = 8;
   */
  comment: string;
};

/**
 * Describes the message temporal.api.schedule.v1.CalendarSpec.
 * Use `create(CalendarSpecSchema)` to create a new message.
 */
export const CalendarSpecSchema: GenMessage<CalendarSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 0);

/**
 * Range represents a set of integer values, used to match fields of a calendar
 * time in StructuredCalendarSpec. If end < start, then end is interpreted as
 * equal to start. This means you can use a Range with start set to a value, and
 * end and step unset (defaulting to 0) to represent a single value.
 *
 * @generated from message temporal.api.schedule.v1.Range
 */
export type Range = Message<"temporal.api.schedule.v1.Range"> & {
  /**
   * Start of range (inclusive).
   *
   * @generated from field: int32 start = 1;
   */
  start: number;

  /**
   * End of range (inclusive).
   *
   * @generated from field: int32 end = 2;
   */
  end: number;

  /**
   * Step (optional, default 1).
   *
   * @generated from field: int32 step = 3;
   */
  step: number;
};

/**
 * Describes the message temporal.api.schedule.v1.Range.
 * Use `create(RangeSchema)` to create a new message.
 */
export const RangeSchema: GenMessage<Range> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 1);

/**
 * StructuredCalendarSpec describes an event specification relative to the
 * calendar, in a form that's easy to work with programmatically. Each field can
 * be one or more ranges.
 * A timestamp matches if at least one range of each field matches the
 * corresponding fields of the timestamp, except for year: if year is missing,
 * that means all years match. For all fields besides year, at least one Range
 * must be present to match anything.
 * Relative expressions such as "last day of the month" or "third Monday" are not currently
 * representable; callers must enumerate the concrete days they require.
 *
 * @generated from message temporal.api.schedule.v1.StructuredCalendarSpec
 */
export type StructuredCalendarSpec = Message<"temporal.api.schedule.v1.StructuredCalendarSpec"> & {
  /**
   * Match seconds (0-59)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range second = 1;
   */
  second: Range[];

  /**
   * Match minutes (0-59)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range minute = 2;
   */
  minute: Range[];

  /**
   * Match hours (0-23)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range hour = 3;
   */
  hour: Range[];

  /**
   * Match days of the month (1-31)
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: standard name of field --)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range day_of_month = 4;
   */
  dayOfMonth: Range[];

  /**
   * Match months (1-12)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range month = 5;
   */
  month: Range[];

  /**
   * Match years.
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range year = 6;
   */
  year: Range[];

  /**
   * Match days of the week (0-6; 0 is Sunday).
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range day_of_week = 7;
   */
  dayOfWeek: Range[];

  /**
   * Free-form comment describing the intention of this spec.
   *
   * @generated from field: string comment = 8;
   */
  comment: string;
};

/**
 * Describes the message temporal.api.schedule.v1.StructuredCalendarSpec.
 * Use `create(StructuredCalendarSpecSchema)` to create a new message.
 */
export const StructuredCalendarSpecSchema: GenMessage<StructuredCalendarSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 2);

/**
 * IntervalSpec matches times that can be expressed as:
 * epoch + n * interval + phase
 * where n is an integer.
 * phase defaults to zero if missing. interval is required.
 * Both interval and phase must be non-negative and are truncated to the nearest
 * second before any calculations.
 * For example, an interval of 1 hour with phase of zero would match every hour,
 * on the hour. The same interval but a phase of 19 minutes would match every
 * xx:19:00. An interval of 28 days with phase zero would match
 * 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
 * days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
 *
 * @generated from message temporal.api.schedule.v1.IntervalSpec
 */
export type IntervalSpec = Message<"temporal.api.schedule.v1.IntervalSpec"> & {
  /**
   * @generated from field: google.protobuf.Duration interval = 1;
   */
  interval?: Duration;

  /**
   * @generated from field: google.protobuf.Duration phase = 2;
   */
  phase?: Duration;
};

/**
 * Describes the message temporal.api.schedule.v1.IntervalSpec.
 * Use `create(IntervalSpecSchema)` to create a new message.
 */
export const IntervalSpecSchema: GenMessage<IntervalSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 3);

/**
 * ScheduleSpec is a complete description of a set of absolute timestamps
 * (possibly infinite) that an action should occur at. The meaning of a
 * ScheduleSpec depends only on its contents and never changes, except that the
 * definition of a time zone can change over time (most commonly, when daylight
 * saving time policy changes for an area). To create a totally self-contained
 * ScheduleSpec, use UTC or include timezone_data.
 *
 * For input, you can provide zero or more of: structured_calendar, calendar,
 * cron_string, interval, and exclude_structured_calendar, and all of them will
 * be used (the schedule will take action at the union of all of their times,
 * minus the ones that match exclude_structured_calendar).
 *
 * On input, calendar and cron_string fields will be compiled into
 * structured_calendar (and maybe interval and timezone_name), so if you
 * Describe a schedule, you'll see only structured_calendar, interval, etc.
 *
 * If a spec has no matching times after the current time, then the schedule
 * will be subject to automatic deletion (after several days).
 *
 * @generated from message temporal.api.schedule.v1.ScheduleSpec
 */
export type ScheduleSpec = Message<"temporal.api.schedule.v1.ScheduleSpec"> & {
  /**
   * Calendar-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.StructuredCalendarSpec structured_calendar = 7;
   */
  structuredCalendar: StructuredCalendarSpec[];

  /**
   * cron_string holds a traditional cron specification as a string. It
   * accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
   * same way as CalendarSpec.
   * 5 fields:         minute, hour, day_of_month, month, day_of_week
   * 6 fields:         minute, hour, day_of_month, month, day_of_week, year
   * 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
   * If year is not given, it defaults to *. If second is not given, it
   * defaults to 0.
   * Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
   * accepted instead of the 5-7 time fields.
   * Optionally, the string can be preceded by CRON_TZ=<timezone name> or
   * TZ=<timezone name>, which will get copied to timezone_name. (There must
   * not also be a timezone_name present.)
   * Optionally "#" followed by a comment can appear at the end of the string.
   * Note that the special case that some cron implementations have for
   * treating day_of_month and day_of_week as "or" instead of "and" when both
   * are set is not implemented.
   * @every <interval>[/<phase>] is accepted and gets compiled into an
   * IntervalSpec instead. <interval> and <phase> should be a decimal integer
   * with a unit suffix s, m, h, or d.
   *
   * @generated from field: repeated string cron_string = 8;
   */
  cronString: string[];

  /**
   * Calendar-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.CalendarSpec calendar = 1;
   */
  calendar: CalendarSpec[];

  /**
   * Interval-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.IntervalSpec interval = 2;
   */
  interval: IntervalSpec[];

  /**
   * Any timestamps matching any of exclude_* will be skipped.
   * Deprecated. Use exclude_structured_calendar.
   *
   * @generated from field: repeated temporal.api.schedule.v1.CalendarSpec exclude_calendar = 3 [deprecated = true];
   * @deprecated
   */
  excludeCalendar: CalendarSpec[];

  /**
   * @generated from field: repeated temporal.api.schedule.v1.StructuredCalendarSpec exclude_structured_calendar = 9;
   */
  excludeStructuredCalendar: StructuredCalendarSpec[];

  /**
   * If start_time is set, any timestamps before start_time will be skipped.
   * (Together, start_time and end_time make an inclusive interval.)
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * If end_time is set, any timestamps after end_time will be skipped.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 5;
   */
  endTime?: Timestamp;

  /**
   * All timestamps will be incremented by a random value from 0 to this
   * amount of jitter. Default: 0
   *
   * @generated from field: google.protobuf.Duration jitter = 6;
   */
  jitter?: Duration;

  /**
   * Time zone to interpret all calendar-based specs in.
   *
   * If unset, defaults to UTC. We recommend using UTC for your application if
   * at all possible, to avoid various surprising properties of time zones.
   *
   * Time zones may be provided by name, corresponding to names in the IANA
   * time zone database (see https://www.iana.org/time-zones). The definition
   * will be loaded by the Temporal server from the environment it runs in.
   *
   * If your application requires more control over the time zone definition
   * used, it may pass in a complete definition in the form of a TZif file
   * from the time zone database. If present, this will be used instead of
   * loading anything from the environment. You are then responsible for
   * updating timezone_data when the definition changes.
   *
   * Calendar spec matching is based on literal matching of the clock time
   * with no special handling of DST: if you write a calendar spec that fires
   * at 2:30am and specify a time zone that follows DST, that action will not
   * be triggered on the day that has no 2:30am. Similarly, an action that
   * fires at 1:30am will be triggered twice on the day that has two 1:30s.
   *
   * Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
   *
   * @generated from field: string timezone_name = 10;
   */
  timezoneName: string;

  /**
   * @generated from field: bytes timezone_data = 11;
   */
  timezoneData: Uint8Array;
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleSpec.
 * Use `create(ScheduleSpecSchema)` to create a new message.
 */
export const ScheduleSpecSchema: GenMessage<ScheduleSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 4);

/**
 * @generated from message temporal.api.schedule.v1.SchedulePolicies
 */
export type SchedulePolicies = Message<"temporal.api.schedule.v1.SchedulePolicies"> & {
  /**
   * Policy for overlaps.
   * Note that this can be changed after a schedule has taken some actions,
   * and some changes might produce unintuitive results. In general, the later
   * policy overrides the earlier policy.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 1;
   */
  overlapPolicy: ScheduleOverlapPolicy;

  /**
   * Policy for catchups:
   * If the Temporal server misses an action due to one or more components
   * being down, and comes back up, the action will be run if the scheduled
   * time is within this window from the current time.
   * This value defaults to one year, and can't be less than 10 seconds.
   *
   * @generated from field: google.protobuf.Duration catchup_window = 2;
   */
  catchupWindow?: Duration;

  /**
   * If true, and a workflow run fails or times out, turn on "paused".
   * This applies after retry policies: the full chain of retries must fail to
   * trigger a pause here.
   *
   * @generated from field: bool pause_on_failure = 3;
   */
  pauseOnFailure: boolean;

  /**
   * If true, and the action would start a workflow, a timestamp will not be
   * appended to the scheduled workflow id.
   *
   * @generated from field: bool keep_original_workflow_id = 4;
   */
  keepOriginalWorkflowId: boolean;
};

/**
 * Describes the message temporal.api.schedule.v1.SchedulePolicies.
 * Use `create(SchedulePoliciesSchema)` to create a new message.
 */
export const SchedulePoliciesSchema: GenMessage<SchedulePolicies> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 5);

/**
 * @generated from message temporal.api.schedule.v1.ScheduleAction
 */
export type ScheduleAction = Message<"temporal.api.schedule.v1.ScheduleAction"> & {
  /**
   * @generated from oneof temporal.api.schedule.v1.ScheduleAction.action
   */
  action: {
    /**
     * All fields of NewWorkflowExecutionInfo are valid except for:
     * - workflow_id_reuse_policy
     * - cron_schedule
     * The workflow id of the started workflow may not match this exactly,
     * it may have a timestamp appended for uniqueness.
     *
     * @generated from field: temporal.api.workflow.v1.NewWorkflowExecutionInfo start_workflow = 1;
     */
    value: NewWorkflowExecutionInfo;
    case: "startWorkflow";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleAction.
 * Use `create(ScheduleActionSchema)` to create a new message.
 */
export const ScheduleActionSchema: GenMessage<ScheduleAction> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 6);

/**
 * @generated from message temporal.api.schedule.v1.ScheduleActionResult
 */
export type ScheduleActionResult = Message<"temporal.api.schedule.v1.ScheduleActionResult"> & {
  /**
   * Time that the action was taken (according to the schedule, including jitter).
   *
   * @generated from field: google.protobuf.Timestamp schedule_time = 1;
   */
  scheduleTime?: Timestamp;

  /**
   * Time that the action was taken (real time).
   *
   * @generated from field: google.protobuf.Timestamp actual_time = 2;
   */
  actualTime?: Timestamp;

  /**
   * If action was start_workflow:
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution start_workflow_result = 11;
   */
  startWorkflowResult?: WorkflowExecution;

  /**
   * If the action was start_workflow, this field will reflect an
   * eventually-consistent view of the started workflow's status.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus start_workflow_status = 12;
   */
  startWorkflowStatus: WorkflowExecutionStatus;
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleActionResult.
 * Use `create(ScheduleActionResultSchema)` to create a new message.
 */
export const ScheduleActionResultSchema: GenMessage<ScheduleActionResult> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 7);

/**
 * @generated from message temporal.api.schedule.v1.ScheduleState
 */
export type ScheduleState = Message<"temporal.api.schedule.v1.ScheduleState"> & {
  /**
   * Informative human-readable message with contextual notes, e.g. the reason
   * a schedule is paused. The system may overwrite this message on certain
   * conditions, e.g. when pause-on-failure happens.
   *
   * @generated from field: string notes = 1;
   */
  notes: string;

  /**
   * If true, do not take any actions based on the schedule spec.
   *
   * @generated from field: bool paused = 2;
   */
  paused: boolean;

  /**
   * If limited_actions is true, decrement remaining_actions after each
   * action, and do not take any more scheduled actions if remaining_actions
   * is zero. Actions may still be taken by explicit request (i.e. trigger
   * immediately or backfill). Skipped actions (due to overlap policy) do not
   * count against remaining actions.
   * If a schedule has no more remaining actions, then the schedule will be
   * subject to automatic deletion (after several days).
   *
   * @generated from field: bool limited_actions = 3;
   */
  limitedActions: boolean;

  /**
   * @generated from field: int64 remaining_actions = 4;
   */
  remainingActions: bigint;
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleState.
 * Use `create(ScheduleStateSchema)` to create a new message.
 */
export const ScheduleStateSchema: GenMessage<ScheduleState> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 8);

/**
 * @generated from message temporal.api.schedule.v1.TriggerImmediatelyRequest
 */
export type TriggerImmediatelyRequest = Message<"temporal.api.schedule.v1.TriggerImmediatelyRequest"> & {
  /**
   * If set, override overlap policy for this one request.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 1;
   */
  overlapPolicy: ScheduleOverlapPolicy;

  /**
   * Timestamp used for the identity of the target workflow.
   * If not set the default value is the current time.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 2;
   */
  scheduledTime?: Timestamp;
};

/**
 * Describes the message temporal.api.schedule.v1.TriggerImmediatelyRequest.
 * Use `create(TriggerImmediatelyRequestSchema)` to create a new message.
 */
export const TriggerImmediatelyRequestSchema: GenMessage<TriggerImmediatelyRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 9);

/**
 * @generated from message temporal.api.schedule.v1.BackfillRequest
 */
export type BackfillRequest = Message<"temporal.api.schedule.v1.BackfillRequest"> & {
  /**
   * Time range to evaluate schedule in. Currently, this time range is
   * exclusive on start_time and inclusive on end_time. (This is admittedly
   * counterintuitive and it may change in the future, so to be safe, use a
   * start time strictly before a scheduled time.) Also note that an action
   * nominally scheduled in the interval but with jitter that pushes it after
   * end_time will not be included.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * If set, override overlap policy for this request.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 3;
   */
  overlapPolicy: ScheduleOverlapPolicy;
};

/**
 * Describes the message temporal.api.schedule.v1.BackfillRequest.
 * Use `create(BackfillRequestSchema)` to create a new message.
 */
export const BackfillRequestSchema: GenMessage<BackfillRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 10);

/**
 * @generated from message temporal.api.schedule.v1.SchedulePatch
 */
export type SchedulePatch = Message<"temporal.api.schedule.v1.SchedulePatch"> & {
  /**
   * If set, trigger one action immediately.
   *
   * @generated from field: temporal.api.schedule.v1.TriggerImmediatelyRequest trigger_immediately = 1;
   */
  triggerImmediately?: TriggerImmediatelyRequest;

  /**
   * If set, runs though the specified time period(s) and takes actions as if that time
   * passed by right now, all at once. The overlap policy can be overridden for the
   * scope of the backfill.
   *
   * @generated from field: repeated temporal.api.schedule.v1.BackfillRequest backfill_request = 2;
   */
  backfillRequest: BackfillRequest[];

  /**
   * If set, change the state to paused or unpaused (respectively) and set the
   * notes field to the value of the string.
   *
   * @generated from field: string pause = 3;
   */
  pause: string;

  /**
   * @generated from field: string unpause = 4;
   */
  unpause: string;
};

/**
 * Describes the message temporal.api.schedule.v1.SchedulePatch.
 * Use `create(SchedulePatchSchema)` to create a new message.
 */
export const SchedulePatchSchema: GenMessage<SchedulePatch> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 11);

/**
 * @generated from message temporal.api.schedule.v1.ScheduleInfo
 */
export type ScheduleInfo = Message<"temporal.api.schedule.v1.ScheduleInfo"> & {
  /**
   * Number of actions taken so far.
   *
   * @generated from field: int64 action_count = 1;
   */
  actionCount: bigint;

  /**
   * Number of times a scheduled action was skipped due to missing the catchup window.
   *
   * @generated from field: int64 missed_catchup_window = 2;
   */
  missedCatchupWindow: bigint;

  /**
   * Number of skipped actions due to overlap.
   *
   * @generated from field: int64 overlap_skipped = 3;
   */
  overlapSkipped: bigint;

  /**
   * Number of dropped actions due to buffer limit.
   *
   * @generated from field: int64 buffer_dropped = 10;
   */
  bufferDropped: bigint;

  /**
   * Number of actions in the buffer. The buffer holds the actions that cannot
   * be immediately triggered (due to the overlap policy). These actions can be a result of
   * the normal schedule or a backfill.
   *
   * @generated from field: int64 buffer_size = 11;
   */
  bufferSize: bigint;

  /**
   * Currently-running workflows started by this schedule. (There might be
   * more than one if the overlap policy allows overlaps.)
   * Note that the run_ids in here are the original execution run ids as
   * started by the schedule. If the workflows retried, did continue-as-new,
   * or were reset, they might still be running but with a different run_id.
   *
   * @generated from field: repeated temporal.api.common.v1.WorkflowExecution running_workflows = 9;
   */
  runningWorkflows: WorkflowExecution[];

  /**
   * Most recent ten actual action times (including manual triggers).
   *
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleActionResult recent_actions = 4;
   */
  recentActions: ScheduleActionResult[];

  /**
   * Next ten scheduled action times.
   *
   * @generated from field: repeated google.protobuf.Timestamp future_action_times = 5;
   */
  futureActionTimes: Timestamp[];

  /**
   * Timestamps of schedule creation and last update.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 7;
   */
  updateTime?: Timestamp;

  /**
   * Deprecated.
   *
   * @generated from field: string invalid_schedule_error = 8 [deprecated = true];
   * @deprecated
   */
  invalidScheduleError: string;
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleInfo.
 * Use `create(ScheduleInfoSchema)` to create a new message.
 */
export const ScheduleInfoSchema: GenMessage<ScheduleInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 12);

/**
 * @generated from message temporal.api.schedule.v1.Schedule
 */
export type Schedule = Message<"temporal.api.schedule.v1.Schedule"> & {
  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleSpec spec = 1;
   */
  spec?: ScheduleSpec;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleAction action = 2;
   */
  action?: ScheduleAction;

  /**
   * @generated from field: temporal.api.schedule.v1.SchedulePolicies policies = 3;
   */
  policies?: SchedulePolicies;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleState state = 4;
   */
  state?: ScheduleState;
};

/**
 * Describes the message temporal.api.schedule.v1.Schedule.
 * Use `create(ScheduleSchema)` to create a new message.
 */
export const ScheduleSchema: GenMessage<Schedule> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 13);

/**
 * ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
 * that's returned in ListSchedules.
 *
 * @generated from message temporal.api.schedule.v1.ScheduleListInfo
 */
export type ScheduleListInfo = Message<"temporal.api.schedule.v1.ScheduleListInfo"> & {
  /**
   * From spec:
   * Some fields are dropped from this copy of spec: timezone_data
   *
   * @generated from field: temporal.api.schedule.v1.ScheduleSpec spec = 1;
   */
  spec?: ScheduleSpec;

  /**
   * From action:
   * Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
   * well with JSON. If action is start_workflow, this is set:
   *
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * From state:
   *
   * @generated from field: string notes = 3;
   */
  notes: string;

  /**
   * @generated from field: bool paused = 4;
   */
  paused: boolean;

  /**
   * From info (maybe fewer entries):
   *
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleActionResult recent_actions = 5;
   */
  recentActions: ScheduleActionResult[];

  /**
   * @generated from field: repeated google.protobuf.Timestamp future_action_times = 6;
   */
  futureActionTimes: Timestamp[];
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleListInfo.
 * Use `create(ScheduleListInfoSchema)` to create a new message.
 */
export const ScheduleListInfoSchema: GenMessage<ScheduleListInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 14);

/**
 * ScheduleListEntry is returned by ListSchedules.
 *
 * @generated from message temporal.api.schedule.v1.ScheduleListEntry
 */
export type ScheduleListEntry = Message<"temporal.api.schedule.v1.ScheduleListEntry"> & {
  /**
   * @generated from field: string schedule_id = 1;
   */
  scheduleId: string;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 2;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 3;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleListInfo info = 4;
   */
  info?: ScheduleListInfo;
};

/**
 * Describes the message temporal.api.schedule.v1.ScheduleListEntry.
 * Use `create(ScheduleListEntrySchema)` to create a new message.
 */
export const ScheduleListEntrySchema: GenMessage<ScheduleListEntry> = /*@__PURE__*/
  messageDesc(file_temporal_api_schedule_v1_message, 15);

