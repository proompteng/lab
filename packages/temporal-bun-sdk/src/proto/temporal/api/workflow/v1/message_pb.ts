// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/workflow/v1/message.proto (package temporal.api.workflow.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Empty, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ActivityOptions } from "../../activity/v1/message_pb.js";
import { file_temporal_api_activity_v1_message } from "../../activity/v1/message_pb.js";
import type { CallbackState, NexusOperationCancellationState, PendingNexusOperationState } from "../../enums/v1/common_pb.js";
import { file_temporal_api_enums_v1_common } from "../../enums/v1/common_pb.js";
import type { EventType } from "../../enums/v1/event_type_pb.js";
import { file_temporal_api_enums_v1_event_type } from "../../enums/v1/event_type_pb.js";
import type { ParentClosePolicy, PendingActivityState, PendingWorkflowTaskState, VersioningBehavior, WorkflowExecutionStatus, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { ActivityType, Callback, Header, Link, Memo, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { Deployment, WorkerDeploymentVersion } from "../../deployment/v1/message_pb.js";
import { file_temporal_api_deployment_v1_message } from "../../deployment/v1/message_pb.js";
import type { Failure } from "../../failure/v1/message_pb.js";
import { file_temporal_api_failure_v1_message } from "../../failure/v1/message_pb.js";
import type { TaskQueue } from "../../taskqueue/v1/message_pb.js";
import { file_temporal_api_taskqueue_v1_message } from "../../taskqueue/v1/message_pb.js";
import type { UserMetadata } from "../../sdk/v1/user_metadata_pb.js";
import { file_temporal_api_sdk_v1_user_metadata } from "../../sdk/v1/user_metadata_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/workflow/v1/message.proto.
 */
export const file_temporal_api_workflow_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiZ0ZW1wb3JhbC9hcGkvd29ya2Zsb3cvdjEvbWVzc2FnZS5wcm90bxIYdGVtcG9yYWwuYXBpLndvcmtmbG93LnYxIvAJChVXb3JrZmxvd0V4ZWN1dGlvbkluZm8SPAoJZXhlY3V0aW9uGAEgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIyCgR0eXBlGAIgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSLgoKc3RhcnRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKY2xvc2VfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoGc3RhdHVzGAUgASgOMi4udGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93RXhlY3V0aW9uU3RhdHVzEhYKDmhpc3RvcnlfbGVuZ3RoGAYgASgDEhsKE3BhcmVudF9uYW1lc3BhY2VfaWQYByABKAkSQwoQcGFyZW50X2V4ZWN1dGlvbhgIIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SMgoOZXhlY3V0aW9uX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEioKBG1lbW8YCiABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYCyABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMSQAoRYXV0b19yZXNldF9wb2ludHMYDCABKAsyJS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUmVzZXRQb2ludHMSEgoKdGFza19xdWV1ZRgNIAEoCRIeChZzdGF0ZV90cmFuc2l0aW9uX2NvdW50GA4gASgDEhoKEmhpc3Rvcnlfc2l6ZV9ieXRlcxgPIAEoAxJYCiBtb3N0X3JlY2VudF93b3JrZXJfdmVyc2lvbl9zdGFtcBgQIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYARI1ChJleGVjdXRpb25fZHVyYXRpb24YESABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SQQoOcm9vdF9leGVjdXRpb24YEiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEh0KEWFzc2lnbmVkX2J1aWxkX2lkGBMgASgJQgIYARIeChJpbmhlcml0ZWRfYnVpbGRfaWQYFCABKAlCAhgBEhQKDGZpcnN0X3J1bl9pZBgVIAEoCRJSCg92ZXJzaW9uaW5nX2luZm8YFiABKAsyOS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25WZXJzaW9uaW5nSW5mbxIeChZ3b3JrZXJfZGVwbG95bWVudF9uYW1lGBcgASgJEjIKCHByaW9yaXR5GBggASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eRIjChtleHRlcm5hbF9wYXlsb2FkX3NpemVfYnl0ZXMYGSABKAMSHgoWZXh0ZXJuYWxfcGF5bG9hZF9jb3VudBgaIAEoAyLGBAodV29ya2Zsb3dFeGVjdXRpb25FeHRlbmRlZEluZm8SPQoZZXhlY3V0aW9uX2V4cGlyYXRpb25fdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNwoTcnVuX2V4cGlyYXRpb25fdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASGAoQY2FuY2VsX3JlcXVlc3RlZBgDIAEoCBIzCg9sYXN0X3Jlc2V0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjcKE29yaWdpbmFsX3N0YXJ0X3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhQKDHJlc2V0X3J1bl9pZBgGIAEoCRJlChByZXF1ZXN0X2lkX2luZm9zGAcgAygLMksudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uRXh0ZW5kZWRJbmZvLlJlcXVlc3RJZEluZm9zRW50cnkSSAoKcGF1c2VfaW5mbxgIIAEoCzI0LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5Xb3JrZmxvd0V4ZWN1dGlvblBhdXNlSW5mbxpeChNSZXF1ZXN0SWRJbmZvc0VudHJ5EgsKA2tleRgBIAEoCRI2CgV2YWx1ZRgCIAEoCzInLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5SZXF1ZXN0SWRJbmZvOgI4ASKOBAofV29ya2Zsb3dFeGVjdXRpb25WZXJzaW9uaW5nSW5mbxI7CghiZWhhdmlvchgBIAEoDjIpLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5WZXJzaW9uaW5nQmVoYXZpb3ISPgoKZGVwbG95bWVudBgCIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRCAhgBEhMKB3ZlcnNpb24YBSABKAlCAhgBEk8KEmRlcGxveW1lbnRfdmVyc2lvbhgHIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uEkkKE3ZlcnNpb25pbmdfb3ZlcnJpZGUYAyABKAsyLC50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuVmVyc2lvbmluZ092ZXJyaWRlElEKFWRlcGxveW1lbnRfdHJhbnNpdGlvbhgEIAEoCzIuLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5EZXBsb3ltZW50VHJhbnNpdGlvbkICGAESUQoSdmVyc2lvbl90cmFuc2l0aW9uGAYgASgLMjUudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLkRlcGxveW1lbnRWZXJzaW9uVHJhbnNpdGlvbhIXCg9yZXZpc2lvbl9udW1iZXIYCCABKAMiUgoURGVwbG95bWVudFRyYW5zaXRpb24SOgoKZGVwbG95bWVudBgBIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnQigwEKG0RlcGxveW1lbnRWZXJzaW9uVHJhbnNpdGlvbhITCgd2ZXJzaW9uGAEgASgJQgIYARJPChJkZXBsb3ltZW50X3ZlcnNpb24YAiABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbiLHAgoXV29ya2Zsb3dFeGVjdXRpb25Db25maWcSOAoKdGFza19xdWV1ZRgBIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEj0KGndvcmtmbG93X2V4ZWN1dGlvbl90aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjcKFHdvcmtmbG93X3J1bl90aW1lb3V0GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkAKHWRlZmF1bHRfd29ya2Zsb3dfdGFza190aW1lb3V0GAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjgKDXVzZXJfbWV0YWRhdGEYBSABKAsyIS50ZW1wb3JhbC5hcGkuc2RrLnYxLlVzZXJNZXRhZGF0YSK9DQoTUGVuZGluZ0FjdGl2aXR5SW5mbxITCgthY3Rpdml0eV9pZBgBIAEoCRI7Cg1hY3Rpdml0eV90eXBlGAIgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5BY3Rpdml0eVR5cGUSOgoFc3RhdGUYAyABKA4yKy50ZW1wb3JhbC5hcGkuZW51bXMudjEuUGVuZGluZ0FjdGl2aXR5U3RhdGUSOwoRaGVhcnRiZWF0X2RldGFpbHMYBCABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEjcKE2xhc3RfaGVhcnRiZWF0X3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjUKEWxhc3Rfc3RhcnRlZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIPCgdhdHRlbXB0GAcgASgFEhgKEG1heGltdW1fYXR0ZW1wdHMYCCABKAUSMgoOc2NoZWR1bGVkX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjMKD2V4cGlyYXRpb25fdGltZRgKIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNgoMbGFzdF9mYWlsdXJlGAsgASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZRIcChRsYXN0X3dvcmtlcl9pZGVudGl0eRgMIAEoCRI7ChV1c2Vfd29ya2Zsb3dfYnVpbGRfaWQYDSABKAsyFi5nb29nbGUucHJvdG9idWYuRW1wdHlCAhgBSAASMgokbGFzdF9pbmRlcGVuZGVudGx5X2Fzc2lnbmVkX2J1aWxkX2lkGA4gASgJQgIYAUgAElEKGWxhc3Rfd29ya2VyX3ZlcnNpb25fc3RhbXAYDyABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESOQoWY3VycmVudF9yZXRyeV9pbnRlcnZhbBgQIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI+ChpsYXN0X2F0dGVtcHRfY29tcGxldGVfdGltZRgRIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoabmV4dF9hdHRlbXB0X3NjaGVkdWxlX3RpbWUYEiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg4KBnBhdXNlZBgTIAEoCBJDCg9sYXN0X2RlcGxveW1lbnQYFCABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50QgIYARIqCh5sYXN0X3dvcmtlcl9kZXBsb3ltZW50X3ZlcnNpb24YFSABKAlCAhgBElQKF2xhc3RfZGVwbG95bWVudF92ZXJzaW9uGBkgASgLMjMudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudFZlcnNpb24SMgoIcHJpb3JpdHkYFiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlByaW9yaXR5EksKCnBhdXNlX2luZm8YFyABKAsyNy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ0FjdGl2aXR5SW5mby5QYXVzZUluZm8SQwoQYWN0aXZpdHlfb3B0aW9ucxgYIAEoCzIpLnRlbXBvcmFsLmFwaS5hY3Rpdml0eS52MS5BY3Rpdml0eU9wdGlvbnMazwIKCVBhdXNlSW5mbxIuCgpwYXVzZV90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJQCgZtYW51YWwYAiABKAsyPi50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ0FjdGl2aXR5SW5mby5QYXVzZUluZm8uTWFudWFsSAASTAoEcnVsZRgEIAEoCzI8LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5QZW5kaW5nQWN0aXZpdHlJbmZvLlBhdXNlSW5mby5SdWxlSAAaKgoGTWFudWFsEhAKCGlkZW50aXR5GAEgASgJEg4KBnJlYXNvbhgCIAEoCRo5CgRSdWxlEg8KB3J1bGVfaWQYASABKAkSEAoIaWRlbnRpdHkYAiABKAkSDgoGcmVhc29uGAMgASgJQgsKCXBhdXNlZF9ieUITChFhc3NpZ25lZF9idWlsZF9pZCK5AQoZUGVuZGluZ0NoaWxkRXhlY3V0aW9uSW5mbxITCgt3b3JrZmxvd19pZBgBIAEoCRIOCgZydW5faWQYAiABKAkSGgoSd29ya2Zsb3dfdHlwZV9uYW1lGAMgASgJEhQKDGluaXRpYXRlZF9pZBgEIAEoAxJFChNwYXJlbnRfY2xvc2VfcG9saWN5GAUgASgOMigudGVtcG9yYWwuYXBpLmVudW1zLnYxLlBhcmVudENsb3NlUG9saWN5Io0CChdQZW5kaW5nV29ya2Zsb3dUYXNrSW5mbxI+CgVzdGF0ZRgBIAEoDjIvLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5QZW5kaW5nV29ya2Zsb3dUYXNrU3RhdGUSMgoOc2NoZWR1bGVkX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjsKF29yaWdpbmFsX3NjaGVkdWxlZF90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIwCgxzdGFydGVkX3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg8KB2F0dGVtcHQYBSABKAUiRwoLUmVzZXRQb2ludHMSOAoGcG9pbnRzGAEgAygLMigudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlJlc2V0UG9pbnRJbmZvIu8BCg5SZXNldFBvaW50SW5mbxIQCghidWlsZF9pZBgHIAEoCRIbCg9iaW5hcnlfY2hlY2tzdW0YASABKAlCAhgBEg4KBnJ1bl9pZBgCIAEoCRIoCiBmaXJzdF93b3JrZmxvd190YXNrX2NvbXBsZXRlZF9pZBgDIAEoAxIvCgtjcmVhdGVfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLwoLZXhwaXJlX3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhIKCnJlc2V0dGFibGUYBiABKAgihQcKGE5ld1dvcmtmbG93RXhlY3V0aW9uSW5mbxITCgt3b3JrZmxvd19pZBgBIAEoCRI7Cg13b3JrZmxvd190eXBlGAIgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSOAoKdGFza19xdWV1ZRgDIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEi8KBWlucHV0GAQgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI9Chp3b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI3ChR3b3JrZmxvd19ydW5fdGltZW91dBgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4ChV3b3JrZmxvd190YXNrX3RpbWVvdXQYByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24STgoYd29ya2Zsb3dfaWRfcmV1c2VfcG9saWN5GAggASgOMiwudGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeRI5CgxyZXRyeV9wb2xpY3kYCSABKAsyIy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlJldHJ5UG9saWN5EhUKDWNyb25fc2NoZWR1bGUYCiABKAkSKgoEbWVtbxgLIAEoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTWVtbxJDChFzZWFyY2hfYXR0cmlidXRlcxgMIAEoCzIoLnRlbXBvcmFsLmFwaS5jb21tb24udjEuU2VhcmNoQXR0cmlidXRlcxIuCgZoZWFkZXIYDSABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchI4Cg11c2VyX21ldGFkYXRhGA4gASgLMiEudGVtcG9yYWwuYXBpLnNkay52MS5Vc2VyTWV0YWRhdGESSQoTdmVyc2lvbmluZ19vdmVycmlkZRgPIAEoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUSMgoIcHJpb3JpdHkYECABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlByaW9yaXR5ItIECgxDYWxsYmFja0luZm8SMgoIY2FsbGJhY2sYASABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkNhbGxiYWNrEj8KB3RyaWdnZXIYAiABKAsyLi50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuQ2FsbGJhY2tJbmZvLlRyaWdnZXISNQoRcmVnaXN0cmF0aW9uX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjMKBXN0YXRlGAQgASgOMiQudGVtcG9yYWwuYXBpLmVudW1zLnYxLkNhbGxiYWNrU3RhdGUSDwoHYXR0ZW1wdBgFIAEoBRI+ChpsYXN0X2F0dGVtcHRfY29tcGxldGVfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoUbGFzdF9hdHRlbXB0X2ZhaWx1cmUYByABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEj4KGm5leHRfYXR0ZW1wdF9zY2hlZHVsZV90aW1lGAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIWCg5ibG9ja2VkX3JlYXNvbhgJIAEoCRoQCg5Xb3JrZmxvd0Nsb3NlZBpmCgdUcmlnZ2VyElAKD3dvcmtmbG93X2Nsb3NlZBgBIAEoCzI1LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5DYWxsYmFja0luZm8uV29ya2Zsb3dDbG9zZWRIAEIJCgd2YXJpYW50IosGChlQZW5kaW5nTmV4dXNPcGVyYXRpb25JbmZvEhAKCGVuZHBvaW50GAEgASgJEg8KB3NlcnZpY2UYAiABKAkSEQoJb3BlcmF0aW9uGAMgASgJEhgKDG9wZXJhdGlvbl9pZBgEIAEoCUICGAESPAoZc2NoZWR1bGVfdG9fY2xvc2VfdGltZW91dBgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIyCg5zY2hlZHVsZWRfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASQAoFc3RhdGUYByABKA4yMS50ZW1wb3JhbC5hcGkuZW51bXMudjEuUGVuZGluZ05leHVzT3BlcmF0aW9uU3RhdGUSDwoHYXR0ZW1wdBgIIAEoBRI+ChpsYXN0X2F0dGVtcHRfY29tcGxldGVfdGltZRgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoUbGFzdF9hdHRlbXB0X2ZhaWx1cmUYCiABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEj4KGm5leHRfYXR0ZW1wdF9zY2hlZHVsZV90aW1lGAsgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJTChFjYW5jZWxsYXRpb25faW5mbxgMIAEoCzI4LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5OZXh1c09wZXJhdGlvbkNhbmNlbGxhdGlvbkluZm8SGgoSc2NoZWR1bGVkX2V2ZW50X2lkGA0gASgDEhYKDmJsb2NrZWRfcmVhc29uGA4gASgJEhcKD29wZXJhdGlvbl90b2tlbhgPIAEoCRI8ChlzY2hlZHVsZV90b19zdGFydF90aW1lb3V0GBAgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjkKFnN0YXJ0X3RvX2Nsb3NlX3RpbWVvdXQYESABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24ihAMKHk5leHVzT3BlcmF0aW9uQ2FuY2VsbGF0aW9uSW5mbxIyCg5yZXF1ZXN0ZWRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASRQoFc3RhdGUYAiABKA4yNi50ZW1wb3JhbC5hcGkuZW51bXMudjEuTmV4dXNPcGVyYXRpb25DYW5jZWxsYXRpb25TdGF0ZRIPCgdhdHRlbXB0GAMgASgFEj4KGmxhc3RfYXR0ZW1wdF9jb21wbGV0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI+ChRsYXN0X2F0dGVtcHRfZmFpbHVyZRgFIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSPgoabmV4dF9hdHRlbXB0X3NjaGVkdWxlX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhYKDmJsb2NrZWRfcmVhc29uGAcgASgJIpkBChhXb3JrZmxvd0V4ZWN1dGlvbk9wdGlvbnMSSQoTdmVyc2lvbmluZ19vdmVycmlkZRgBIAEoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUSMgoIcHJpb3JpdHkYAiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlByaW9yaXR5Ir0EChJWZXJzaW9uaW5nT3ZlcnJpZGUSTQoGcGlubmVkGAMgASgLMjsudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlZlcnNpb25pbmdPdmVycmlkZS5QaW5uZWRPdmVycmlkZUgAEhYKDGF1dG9fdXBncmFkZRgEIAEoCEgAEj8KCGJlaGF2aW9yGAEgASgOMikudGVtcG9yYWwuYXBpLmVudW1zLnYxLlZlcnNpb25pbmdCZWhhdmlvckICGAESPgoKZGVwbG95bWVudBgCIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRCAhgBEhoKDnBpbm5lZF92ZXJzaW9uGAkgASgJQgIYARqtAQoOUGlubmVkT3ZlcnJpZGUSVQoIYmVoYXZpb3IYASABKA4yQy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuVmVyc2lvbmluZ092ZXJyaWRlLlBpbm5lZE92ZXJyaWRlQmVoYXZpb3ISRAoHdmVyc2lvbhgCIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uImcKFlBpbm5lZE92ZXJyaWRlQmVoYXZpb3ISKAokUElOTkVEX09WRVJSSURFX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAASIwofUElOTkVEX09WRVJSSURFX0JFSEFWSU9SX1BJTk5FRBABQgoKCG92ZXJyaWRlImkKEU9uQ29uZmxpY3RPcHRpb25zEhkKEWF0dGFjaF9yZXF1ZXN0X2lkGAEgASgIEiMKG2F0dGFjaF9jb21wbGV0aW9uX2NhbGxiYWNrcxgCIAEoCBIUCgxhdHRhY2hfbGlua3MYAyABKAgiaQoNUmVxdWVzdElkSW5mbxI0CgpldmVudF90eXBlGAEgASgOMiAudGVtcG9yYWwuYXBpLmVudW1zLnYxLkV2ZW50VHlwZRIQCghldmVudF9pZBgCIAEoAxIQCghidWZmZXJlZBgDIAEoCCK3BAoSUG9zdFJlc2V0T3BlcmF0aW9uElYKD3NpZ25hbF93b3JrZmxvdxgBIAEoCzI7LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5Qb3N0UmVzZXRPcGVyYXRpb24uU2lnbmFsV29ya2Zsb3dIABJlChd1cGRhdGVfd29ya2Zsb3dfb3B0aW9ucxgCIAEoCzJCLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5Qb3N0UmVzZXRPcGVyYXRpb24uVXBkYXRlV29ya2Zsb3dPcHRpb25zSAAaswEKDlNpZ25hbFdvcmtmbG93EhMKC3NpZ25hbF9uYW1lGAEgASgJEi8KBWlucHV0GAIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIuCgZoZWFkZXIYAyABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIrCgVsaW5rcxgEIAMoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTGluaxqgAQoVVXBkYXRlV29ya2Zsb3dPcHRpb25zElYKGndvcmtmbG93X2V4ZWN1dGlvbl9vcHRpb25zGAEgASgLMjIudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uT3B0aW9ucxIvCgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tCCQoHdmFyaWFudCJvChpXb3JrZmxvd0V4ZWN1dGlvblBhdXNlSW5mbxIQCghpZGVudGl0eRgBIAEoCRIvCgtwYXVzZWRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDgoGcmVhc29uGAMgASgJQpMBChtpby50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjFCDE1lc3NhZ2VQcm90b1ABWidnby50ZW1wb3JhbC5pby9hcGkvd29ya2Zsb3cvdjE7d29ya2Zsb3eqAhpUZW1wb3JhbGlvLkFwaS5Xb3JrZmxvdy5WMeoCHVRlbXBvcmFsaW86OkFwaTo6V29ya2Zsb3c6OlYxYgZwcm90bzM", [file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_protobuf_field_mask, file_temporal_api_activity_v1_message, file_temporal_api_enums_v1_common, file_temporal_api_enums_v1_event_type, file_temporal_api_enums_v1_workflow, file_temporal_api_common_v1_message, file_temporal_api_deployment_v1_message, file_temporal_api_failure_v1_message, file_temporal_api_taskqueue_v1_message, file_temporal_api_sdk_v1_user_metadata]);

/**
 * Hold basic information about a workflow execution.
 * This structure is a part of visibility, and thus contain a limited subset of information.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionInfo
 */
export type WorkflowExecutionInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionInfo"> & {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 1;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType type = 2;
   */
  type?: WorkflowType;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
   */
  status: WorkflowExecutionStatus;

  /**
   * @generated from field: int64 history_length = 6;
   */
  historyLength: bigint;

  /**
   * @generated from field: string parent_namespace_id = 7;
   */
  parentNamespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution parent_execution = 8;
   */
  parentExecution?: WorkflowExecution;

  /**
   * @generated from field: google.protobuf.Timestamp execution_time = 9;
   */
  executionTime?: Timestamp;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 10;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 11;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.workflow.v1.ResetPoints auto_reset_points = 12;
   */
  autoResetPoints?: ResetPoints;

  /**
   * @generated from field: string task_queue = 13;
   */
  taskQueue: string;

  /**
   * @generated from field: int64 state_transition_count = 14;
   */
  stateTransitionCount: bigint;

  /**
   * @generated from field: int64 history_size_bytes = 15;
   */
  historySizeBytes: bigint;

  /**
   * If set, the most recent worker version stamp that appeared in a workflow task completion
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp most_recent_worker_version_stamp = 16 [deprecated = true];
   * @deprecated
   */
  mostRecentWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * Workflow execution duration is defined as difference between close time and execution time.
   * This field is only populated if the workflow is closed.
   *
   * @generated from field: google.protobuf.Duration execution_duration = 17;
   */
  executionDuration?: Duration;

  /**
   * Contains information about the root workflow execution.
   * The root workflow execution is defined as follows:
   * 1. A workflow without parent workflow is its own root workflow.
   * 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
   * Note: workflows continued as new or reseted may or may not have parents, check examples below.
   *
   * Examples:
   *   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 3: Workflow W1 continued as new W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
   *     - The root workflow of all three workflows is W1.
   *   Scenario 5: Workflow W1 is reseted, creating W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution root_execution = 18;
   */
  rootExecution?: WorkflowExecution;

  /**
   * The currently assigned build ID for this execution. Presence of this value means worker versioning is used
   * for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
   * when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
   * again, the assigned build ID may change according to the latest versioning rules.
   * Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
   * this execution.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string assigned_build_id = 19 [deprecated = true];
   * @deprecated
   */
  assignedBuildId: string;

  /**
   * Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
   * of using the assignment rules.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string inherited_build_id = 20 [deprecated = true];
   * @deprecated
   */
  inheritedBuildId: string;

  /**
   * The first run ID in the execution chain.
   * Executions created via the following operations are considered to be in the same chain
   * - ContinueAsNew
   * - Workflow Retry
   * - Workflow Reset
   * - Cron Schedule
   *
   * @generated from field: string first_run_id = 21;
   */
  firstRunId: string;

  /**
   * Absent value means the workflow execution is not versioned. When present, the execution might
   * be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
   * Experimental. Versioning info is experimental and might change in the future.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo versioning_info = 22;
   */
  versioningInfo?: WorkflowExecutionVersioningInfo;

  /**
   * The name of Worker Deployment that completed the most recent workflow task.
   * Experimental. Worker Deployments are experimental and might change in the future.
   *
   * @generated from field: string worker_deployment_name = 23;
   */
  workerDeploymentName: string;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 24;
   */
  priority?: Priority;

  /**
   * Total size in bytes of all external payloads referenced in workflow history.
   *
   * @generated from field: int64 external_payload_size_bytes = 25;
   */
  externalPayloadSizeBytes: bigint;

  /**
   * Count of external payloads referenced in workflow history.
   *
   * @generated from field: int64 external_payload_count = 26;
   */
  externalPayloadCount: bigint;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionInfo.
 * Use `create(WorkflowExecutionInfoSchema)` to create a new message.
 */
export const WorkflowExecutionInfoSchema: GenMessage<WorkflowExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 0);

/**
 * Holds all the extra information about workflow execution that is not part of Visibility.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionExtendedInfo
 */
export type WorkflowExecutionExtendedInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionExtendedInfo"> & {
  /**
   * Workflow execution expiration time is defined as workflow start time plus expiration timeout.
   * Workflow start time may change after workflow reset.
   *
   * @generated from field: google.protobuf.Timestamp execution_expiration_time = 1;
   */
  executionExpirationTime?: Timestamp;

  /**
   * Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
   *
   * @generated from field: google.protobuf.Timestamp run_expiration_time = 2;
   */
  runExpirationTime?: Timestamp;

  /**
   * indicates if the workflow received a cancel request
   *
   * @generated from field: bool cancel_requested = 3;
   */
  cancelRequested: boolean;

  /**
   * Last workflow reset time. Nil if the workflow was never reset.
   *
   * @generated from field: google.protobuf.Timestamp last_reset_time = 4;
   */
  lastResetTime?: Timestamp;

  /**
   * Original workflow start time.
   *
   * @generated from field: google.protobuf.Timestamp original_start_time = 5;
   */
  originalStartTime?: Timestamp;

  /**
   * Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
   *
   * @generated from field: string reset_run_id = 6;
   */
  resetRunId: string;

  /**
   * Request ID information (eg: history event information associated with the request ID).
   * Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
   * calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
   * used in the StartWorkflowExecution request).
   *
   * @generated from field: map<string, temporal.api.workflow.v1.RequestIdInfo> request_id_infos = 7;
   */
  requestIdInfos: { [key: string]: RequestIdInfo };

  /**
   * Information about the workflow execution pause operation.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionPauseInfo pause_info = 8;
   */
  pauseInfo?: WorkflowExecutionPauseInfo;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.
 * Use `create(WorkflowExecutionExtendedInfoSchema)` to create a new message.
 */
export const WorkflowExecutionExtendedInfoSchema: GenMessage<WorkflowExecutionExtendedInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 1);

/**
 * Holds all the information about worker versioning for a particular workflow execution.
 * Experimental. Versioning info is experimental and might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
 */
export type WorkflowExecutionVersioningInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionVersioningInfo"> & {
  /**
   * Versioning behavior determines how the server should treat this execution when workers are
   * upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
   * unversioned. See the comments in `VersioningBehavior` enum for more info about different
   * behaviors.
   *
   * Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning 
   * Behavior and Version (except when the new execution runs on a task queue not belonging to the 
   * same deployment version as the parent/previous run's task queue). The first workflow task will
   * be dispatched according to the inherited behavior (or to the current version of the task-queue's 
   * deployment in the case of AutoUpgrade.) After completion of their first workflow task the 
   * Deployment Version and Behavior of the execution will update according to configuration on the worker.
   *
   * Note that `behavior` is overridden by `versioning_override` if the latter is present.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1;
   */
  behavior: VersioningBehavior;

  /**
   * The worker deployment that completed the last workflow task of this workflow execution. Must
   * be present if `behavior` is set. Absent value means no workflow task is completed, or the
   * last workflow task was completed by an unversioned worker. Unversioned workers may still send
   * a deployment value which will be stored here, so the right way to check if an execution is
   * versioned if an execution is versioned or not is via the `behavior` field.
   * Note that `deployment` is overridden by `versioning_override` if the latter is present.
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 5 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The Worker Deployment Version that completed the last workflow task of this workflow execution.
   * An absent value means no workflow task is completed, or the workflow is unversioned.
   * If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
   * by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
   *
   * Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning 
   * Behavior and Version (except when the new execution runs on a task queue not belonging to the 
   * same deployment version as the parent/previous run's task queue). The first workflow task will
   * be dispatched according to the inherited behavior (or to the current version of the task-queue's 
   * deployment in the case of AutoUpgrade.) After completion of their first workflow task the 
   * Deployment Version and Behavior of the execution will update according to configuration on the worker.
   *
   * Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
   * will override this value. 
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 7;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Present if user has set an execution-specific versioning override. This override takes
   * precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
   * override can be set when starting a new execution, as well as afterwards by calling the
   * `UpdateWorkflowExecutionOptions` API.
   * Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
   * workflow retries, and cron workflows.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 3;
   */
  versioningOverride?: VersioningOverride;

  /**
   * When present, indicates the workflow is transitioning to a different deployment. Can
   * indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current deployment if the task queue's current
   * deployment is different from the workflow's deployment.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current deployment. As soon as a poller from
   * that deployment is available to receive the task, the workflow will automatically start a
   * transition to that deployment and continue execution there.
   * A deployment transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target deployment, the
   * transition completes and the workflow's `deployment` and `behavior` fields are updated per
   * the worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new deployment.
   * Deprecated. Use version_transition.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentTransition deployment_transition = 4 [deprecated = true];
   * @deprecated
   */
  deploymentTransition?: DeploymentTransition;

  /**
   * When present, indicates the workflow is transitioning to a different deployment version
   * (which may belong to the same deployment name or another). Can indicate one of the following
   * transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment version, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current version if the task queue's current version is
   * different from the workflow's current deployment version.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current version. As soon as a poller from
   * that deployment version is available to receive the task, the workflow will automatically
   * start a transition to that version and continue execution there.
   * A version transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target version, the
   * transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
   * worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new version.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentVersionTransition version_transition = 6;
   */
  versionTransition?: DeploymentVersionTransition;

  /**
   * Monotonic counter reflecting the latest routing decision for this workflow execution.
   * Used for staleness detection between history and matching when dispatching tasks to workers.
   * Incremented when a workflow execution routes to a new deployment version, which happens
   * when a worker of the new deployment version completes a workflow task.
   * Note: Pinned tasks and sticky tasks send a value of 0 for this field since these tasks do not
   * face the problem of inconsistent dispatching that arises from eventual consistency between
   * task queues and their partitions.
   *
   * @generated from field: int64 revision_number = 8;
   */
  revisionNumber: bigint;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.
 * Use `create(WorkflowExecutionVersioningInfoSchema)` to create a new message.
 */
export const WorkflowExecutionVersioningInfoSchema: GenMessage<WorkflowExecutionVersioningInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 2);

/**
 * Holds information about ongoing transition of a workflow execution from one deployment to another.
 * Deprecated. Use DeploymentVersionTransition.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentTransition
 */
export type DeploymentTransition = Message<"temporal.api.workflow.v1.DeploymentTransition"> & {
  /**
   * The target deployment of the transition. Null means a so-far-versioned workflow is
   * transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 1;
   */
  deployment?: Deployment;
};

/**
 * Describes the message temporal.api.workflow.v1.DeploymentTransition.
 * Use `create(DeploymentTransitionSchema)` to create a new message.
 */
export const DeploymentTransitionSchema: GenMessage<DeploymentTransition> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 3);

/**
 * Holds information about ongoing transition of a workflow execution from one worker
 * deployment version to another.
 * Experimental. Might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentVersionTransition
 */
export type DeploymentVersionTransition = Message<"temporal.api.workflow.v1.DeploymentVersionTransition"> & {
  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 1 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The target Version of the transition.
   * If nil, a so-far-versioned workflow is transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 2;
   */
  deploymentVersion?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.workflow.v1.DeploymentVersionTransition.
 * Use `create(DeploymentVersionTransitionSchema)` to create a new message.
 */
export const DeploymentVersionTransitionSchema: GenMessage<DeploymentVersionTransition> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 4);

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionConfig
 */
export type WorkflowExecutionConfig = Message<"temporal.api.workflow.v1.WorkflowExecutionConfig"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 2;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 3;
   */
  workflowRunTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration default_workflow_task_timeout = 4;
   */
  defaultWorkflowTaskTimeout?: Duration;

  /**
   * User metadata provided on start workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 5;
   */
  userMetadata?: UserMetadata;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionConfig.
 * Use `create(WorkflowExecutionConfigSchema)` to create a new message.
 */
export const WorkflowExecutionConfigSchema: GenMessage<WorkflowExecutionConfig> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 5);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo
 */
export type PendingActivityInfo = Message<"temporal.api.workflow.v1.PendingActivityInfo"> & {
  /**
   * @generated from field: string activity_id = 1;
   */
  activityId: string;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: temporal.api.enums.v1.PendingActivityState state = 3;
   */
  state: PendingActivityState;

  /**
   * @generated from field: temporal.api.common.v1.Payloads heartbeat_details = 4;
   */
  heartbeatDetails?: Payloads;

  /**
   * @generated from field: google.protobuf.Timestamp last_heartbeat_time = 5;
   */
  lastHeartbeatTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_started_time = 6;
   */
  lastStartedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 7;
   */
  attempt: number;

  /**
   * @generated from field: int32 maximum_attempts = 8;
   */
  maximumAttempts: number;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 9;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp expiration_time = 10;
   */
  expirationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.failure.v1.Failure last_failure = 11;
   */
  lastFailure?: Failure;

  /**
   * @generated from field: string last_worker_identity = 12;
   */
  lastWorkerIdentity: string;

  /**
   * Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
   * In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
   * independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.assigned_build_id
   */
  assignedBuildId: {
    /**
     * Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
     *
     * @generated from field: google.protobuf.Empty use_workflow_build_id = 13 [deprecated = true];
     * @deprecated
     */
    value: Empty;
    case: "useWorkflowBuildId";
  } | {
    /**
     * Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
     * The activity will use the build id in this field instead.
     * If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
     * rules.
     *
     * @generated from field: string last_independently_assigned_build_id = 14 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "lastIndependentlyAssignedBuildId";
  } | { case: undefined; value?: undefined };

  /**
   * Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
   * This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp last_worker_version_stamp = 15 [deprecated = true];
   * @deprecated
   */
  lastWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * The time activity will wait until the next retry.
   * If activity is currently running it will be next retry interval if activity failed.
   * If activity is currently waiting it will be current retry interval.
   * If there will be no retry it will be null.
   *
   * @generated from field: google.protobuf.Duration current_retry_interval = 16;
   */
  currentRetryInterval?: Duration;

  /**
   * The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 17;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * Next time when activity will be scheduled.
   * If activity is currently scheduled or started it will be null.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 18;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * Indicates if activity is paused.
   *
   * @generated from field: bool paused = 19;
   */
  paused: boolean;

  /**
   * The deployment this activity was dispatched to most recently. Present only if the activity
   * was dispatched to a versioned worker.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment last_deployment = 20 [deprecated = true];
   * @deprecated
   */
  lastDeployment?: Deployment;

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: string last_worker_deployment_version = 21 [deprecated = true];
   * @deprecated
   */
  lastWorkerDeploymentVersion: string;

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion last_deployment_version = 25;
   */
  lastDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 22;
   */
  priority?: Priority;

  /**
   * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo pause_info = 23;
   */
  pauseInfo?: PendingActivityInfo_PauseInfo;

  /**
   * Current activity options. May be different from the one used to start the activity.
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 24;
   */
  activityOptions?: ActivityOptions;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.
 * Use `create(PendingActivityInfoSchema)` to create a new message.
 */
export const PendingActivityInfoSchema: GenMessage<PendingActivityInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo
 */
export type PendingActivityInfo_PauseInfo = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo"> & {
  /**
   * The time when the activity was paused.
   *
   * @generated from field: google.protobuf.Timestamp pause_time = 1;
   */
  pauseTime?: Timestamp;

  /**
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.paused_by
   */
  pausedBy: {
    /**
     * activity was paused by the manual intervention
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual manual = 2;
     */
    value: PendingActivityInfo_PauseInfo_Manual;
    case: "manual";
  } | {
    /**
     * activity was paused by the rule
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule rule = 4;
     */
    value: PendingActivityInfo_PauseInfo_Rule;
    case: "rule";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.
 * Use `create(PendingActivityInfo_PauseInfoSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfoSchema: GenMessage<PendingActivityInfo_PauseInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual
 */
export type PendingActivityInfo_PauseInfo_Manual = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual"> & {
  /**
   * The identity of the actor that paused the activity.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * Reason for pausing the activity.
   *
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual.
 * Use `create(PendingActivityInfo_PauseInfo_ManualSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfo_ManualSchema: GenMessage<PendingActivityInfo_PauseInfo_Manual> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0, 0);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule
 */
export type PendingActivityInfo_PauseInfo_Rule = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule"> & {
  /**
   * The rule that paused the activity.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId: string;

  /**
   * The identity of the actor that created the rule.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * Reason why rule was created. Populated from rule description.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule.
 * Use `create(PendingActivityInfo_PauseInfo_RuleSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfo_RuleSchema: GenMessage<PendingActivityInfo_PauseInfo_Rule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0, 1);

/**
 * @generated from message temporal.api.workflow.v1.PendingChildExecutionInfo
 */
export type PendingChildExecutionInfo = Message<"temporal.api.workflow.v1.PendingChildExecutionInfo"> & {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * @generated from field: string run_id = 2;
   */
  runId: string;

  /**
   * @generated from field: string workflow_type_name = 3;
   */
  workflowTypeName: string;

  /**
   * @generated from field: int64 initiated_id = 4;
   */
  initiatedId: bigint;

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 5;
   */
  parentClosePolicy: ParentClosePolicy;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingChildExecutionInfo.
 * Use `create(PendingChildExecutionInfoSchema)` to create a new message.
 */
export const PendingChildExecutionInfoSchema: GenMessage<PendingChildExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 7);

/**
 * @generated from message temporal.api.workflow.v1.PendingWorkflowTaskInfo
 */
export type PendingWorkflowTaskInfo = Message<"temporal.api.workflow.v1.PendingWorkflowTaskInfo"> & {
  /**
   * @generated from field: temporal.api.enums.v1.PendingWorkflowTaskState state = 1;
   */
  state: PendingWorkflowTaskState;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 2;
   */
  scheduledTime?: Timestamp;

  /**
   * original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
   * Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
   * In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
   * some threshold, the workflow task will be forced timeout.
   *
   * @generated from field: google.protobuf.Timestamp original_scheduled_time = 3;
   */
  originalScheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp started_time = 4;
   */
  startedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 5;
   */
  attempt: number;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingWorkflowTaskInfo.
 * Use `create(PendingWorkflowTaskInfoSchema)` to create a new message.
 */
export const PendingWorkflowTaskInfoSchema: GenMessage<PendingWorkflowTaskInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 8);

/**
 * @generated from message temporal.api.workflow.v1.ResetPoints
 */
export type ResetPoints = Message<"temporal.api.workflow.v1.ResetPoints"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.ResetPointInfo points = 1;
   */
  points: ResetPointInfo[];
};

/**
 * Describes the message temporal.api.workflow.v1.ResetPoints.
 * Use `create(ResetPointsSchema)` to create a new message.
 */
export const ResetPointsSchema: GenMessage<ResetPoints> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 9);

/**
 * ResetPointInfo records the workflow event id that is the first one processed by a given
 * build id or binary checksum. A new reset point will be created if either build id or binary
 * checksum changes (although in general only one or the other will be used at a time).
 *
 * @generated from message temporal.api.workflow.v1.ResetPointInfo
 */
export type ResetPointInfo = Message<"temporal.api.workflow.v1.ResetPointInfo"> & {
  /**
   * Worker build id.
   *
   * @generated from field: string build_id = 7;
   */
  buildId: string;

  /**
   * Deprecated. A worker binary version identifier.
   *
   * @generated from field: string binary_checksum = 1 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * The first run ID in the execution chain that was touched by this worker build.
   *
   * @generated from field: string run_id = 2;
   */
  runId: string;

  /**
   * Event ID of the first WorkflowTaskCompleted event processed by this worker build.
   *
   * @generated from field: int64 first_workflow_task_completed_id = 3;
   */
  firstWorkflowTaskCompletedId: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * (-- api-linter: core::0214::resource-expiry=disabled
   *     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
   * The time that the run is deleted due to retention.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 5;
   */
  expireTime?: Timestamp;

  /**
   * false if the reset point has pending childWFs/reqCancels/signalExternals.
   *
   * @generated from field: bool resettable = 6;
   */
  resettable: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.ResetPointInfo.
 * Use `create(ResetPointInfoSchema)` to create a new message.
 */
export const ResetPointInfoSchema: GenMessage<ResetPointInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 10);

/**
 * NewWorkflowExecutionInfo is a shared message that encapsulates all the
 * required arguments to starting a workflow in different contexts.
 *
 * @generated from message temporal.api.workflow.v1.NewWorkflowExecutionInfo
 */
export type NewWorkflowExecutionInfo = Message<"temporal.api.workflow.v1.NewWorkflowExecutionInfo"> & {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 5;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 6;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 7;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 8;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 9;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 10;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 11;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 12;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 13;
   */
  header?: Header;

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 14;
   */
  userMetadata?: UserMetadata;

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 15;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 16;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflow.v1.NewWorkflowExecutionInfo.
 * Use `create(NewWorkflowExecutionInfoSchema)` to create a new message.
 */
export const NewWorkflowExecutionInfoSchema: GenMessage<NewWorkflowExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 11);

/**
 * CallbackInfo contains the state of an attached workflow callback.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo
 */
export type CallbackInfo = Message<"temporal.api.workflow.v1.CallbackInfo"> & {
  /**
   * Information on how this callback should be invoked (e.g. its URL and type).
   *
   * @generated from field: temporal.api.common.v1.Callback callback = 1;
   */
  callback?: Callback;

  /**
   * Trigger for this callback.
   *
   * @generated from field: temporal.api.workflow.v1.CallbackInfo.Trigger trigger = 2;
   */
  trigger?: CallbackInfo_Trigger;

  /**
   * The time when the callback was registered.
   *
   * @generated from field: google.protobuf.Timestamp registration_time = 3;
   */
  registrationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.CallbackState state = 4;
   */
  state: CallbackState;

  /**
   * The number of attempts made to deliver the callback.
   * This number represents a minimum bound since the attempt is incremented after the callback request completes.
   *
   * @generated from field: int32 attempt = 5;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 6;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 7;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 8;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 9;
   */
  blockedReason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.
 * Use `create(CallbackInfoSchema)` to create a new message.
 */
export const CallbackInfoSchema: GenMessage<CallbackInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12);

/**
 * Trigger for when the workflow is closed.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo.WorkflowClosed
 */
export type CallbackInfo_WorkflowClosed = Message<"temporal.api.workflow.v1.CallbackInfo.WorkflowClosed"> & {
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.WorkflowClosed.
 * Use `create(CallbackInfo_WorkflowClosedSchema)` to create a new message.
 */
export const CallbackInfo_WorkflowClosedSchema: GenMessage<CallbackInfo_WorkflowClosed> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12, 0);

/**
 * @generated from message temporal.api.workflow.v1.CallbackInfo.Trigger
 */
export type CallbackInfo_Trigger = Message<"temporal.api.workflow.v1.CallbackInfo.Trigger"> & {
  /**
   * @generated from oneof temporal.api.workflow.v1.CallbackInfo.Trigger.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.CallbackInfo.WorkflowClosed workflow_closed = 1;
     */
    value: CallbackInfo_WorkflowClosed;
    case: "workflowClosed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.Trigger.
 * Use `create(CallbackInfo_TriggerSchema)` to create a new message.
 */
export const CallbackInfo_TriggerSchema: GenMessage<CallbackInfo_Trigger> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12, 1);

/**
 * PendingNexusOperationInfo contains the state of a pending Nexus operation.
 *
 * @generated from message temporal.api.workflow.v1.PendingNexusOperationInfo
 */
export type PendingNexusOperationInfo = Message<"temporal.api.workflow.v1.PendingNexusOperationInfo"> & {
  /**
   * Endpoint name.
   * Resolved to a URL via the cluster's endpoint registry.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service: string;

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation: string;

  /**
   * Operation ID. Only set for asynchronous operations after a successful StartOperation call.
   *
   * Deprecated. Renamed to operation_token.
   *
   * @generated from field: string operation_id = 4 [deprecated = true];
   * @deprecated
   */
  operationId: string;

  /**
   * Schedule-to-close timeout for this operation.
   * This is the only timeout settable by a workflow.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * The time when the operation was scheduled.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 6;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.PendingNexusOperationState state = 7;
   */
  state: PendingNexusOperationState;

  /**
   * The number of attempts made to deliver the start operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 8;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 9;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 10;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 11;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * @generated from field: temporal.api.workflow.v1.NexusOperationCancellationInfo cancellation_info = 12;
   */
  cancellationInfo?: NexusOperationCancellationInfo;

  /**
   * The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
   * DescribeWorkflowExecution response with workflow history.
   *
   * @generated from field: int64 scheduled_event_id = 13;
   */
  scheduledEventId: bigint;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 14;
   */
  blockedReason: string;

  /**
   * Operation token. Only set for asynchronous operations after a successful StartOperation call.
   *
   * @generated from field: string operation_token = 15;
   */
  operationToken: string;

  /**
   * Schedule-to-start timeout for this operation.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 16;
   */
  scheduleToStartTimeout?: Duration;

  /**
   * Start-to-close timeout for this operation.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 17;
   */
  startToCloseTimeout?: Duration;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingNexusOperationInfo.
 * Use `create(PendingNexusOperationInfoSchema)` to create a new message.
 */
export const PendingNexusOperationInfoSchema: GenMessage<PendingNexusOperationInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 13);

/**
 * NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
 *
 * @generated from message temporal.api.workflow.v1.NexusOperationCancellationInfo
 */
export type NexusOperationCancellationInfo = Message<"temporal.api.workflow.v1.NexusOperationCancellationInfo"> & {
  /**
   * The time when cancellation was requested.
   *
   * @generated from field: google.protobuf.Timestamp requested_time = 1;
   */
  requestedTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.NexusOperationCancellationState state = 2;
   */
  state: NexusOperationCancellationState;

  /**
   * The number of attempts made to deliver the cancel operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 3;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 4;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 5;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 6;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 7;
   */
  blockedReason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.NexusOperationCancellationInfo.
 * Use `create(NexusOperationCancellationInfoSchema)` to create a new message.
 */
export const NexusOperationCancellationInfoSchema: GenMessage<NexusOperationCancellationInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 14);

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionOptions
 */
export type WorkflowExecutionOptions = Message<"temporal.api.workflow.v1.WorkflowExecutionOptions"> & {
  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 1;
   */
  versioningOverride?: VersioningOverride;

  /**
   * If set, overrides the workflow's priority sent by the SDK.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 2;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionOptions.
 * Use `create(WorkflowExecutionOptionsSchema)` to create a new message.
 */
export const WorkflowExecutionOptionsSchema: GenMessage<WorkflowExecutionOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 15);

/**
 * Used to override the versioning behavior (and pinned deployment version, if applicable) of a
 * specific workflow execution. If set, this override takes precedence over worker-sent values.
 * See `WorkflowExecutionInfo.VersioningInfo` for more information.
 *
 * To remove the override, call `UpdateWorkflowExecutionOptions` with a null
 * `VersioningOverride`, and use the `update_mask` to indicate that it should be mutated.
 *
 * Pinned behavior overrides are automatically inherited by child workflows, workflow retries, continue-as-new
 * workflows, and cron workflows.
 *
 * @generated from message temporal.api.workflow.v1.VersioningOverride
 */
export type VersioningOverride = Message<"temporal.api.workflow.v1.VersioningOverride"> & {
  /**
   * Indicates whether to override the workflow to be AutoUpgrade or Pinned.
   *
   * @generated from oneof temporal.api.workflow.v1.VersioningOverride.override
   */
  override: {
    /**
     * Override the workflow to have Pinned behavior.
     *
     * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverride pinned = 3;
     */
    value: VersioningOverride_PinnedOverride;
    case: "pinned";
  } | {
    /**
     * Override the workflow to have AutoUpgrade behavior.
     *
     * @generated from field: bool auto_upgrade = 4;
     */
    value: boolean;
    case: "autoUpgrade";
  } | { case: undefined; value?: undefined };

  /**
   * Required.
   * Deprecated. Use `override`.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1 [deprecated = true];
   * @deprecated
   */
  behavior: VersioningBehavior;

  /**
   * Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
   * Identifies the worker deployment to pin the workflow to.
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
   * Identifies the worker deployment version to pin the workflow to, in the format
   * "<deployment_name>.<build_id>".
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: string pinned_version = 9 [deprecated = true];
   * @deprecated
   */
  pinnedVersion: string;
};

/**
 * Describes the message temporal.api.workflow.v1.VersioningOverride.
 * Use `create(VersioningOverrideSchema)` to create a new message.
 */
export const VersioningOverrideSchema: GenMessage<VersioningOverride> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 16);

/**
 * @generated from message temporal.api.workflow.v1.VersioningOverride.PinnedOverride
 */
export type VersioningOverride_PinnedOverride = Message<"temporal.api.workflow.v1.VersioningOverride.PinnedOverride"> & {
  /**
   * Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
   * See `PinnedOverrideBehavior` for details.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior behavior = 1;
   */
  behavior: VersioningOverride_PinnedOverrideBehavior;

  /**
   * Specifies the Worker Deployment Version to pin this workflow to.
   * Required if the target workflow is not already pinned to a version.
   *
   * If omitted and the target workflow is already pinned, the effective
   * pinned version will be the existing pinned version.
   *
   * If omitted and the target workflow is not pinned, the override request
   * will be rejected with a PreconditionFailed error.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion version = 2;
   */
  version?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.workflow.v1.VersioningOverride.PinnedOverride.
 * Use `create(VersioningOverride_PinnedOverrideSchema)` to create a new message.
 */
export const VersioningOverride_PinnedOverrideSchema: GenMessage<VersioningOverride_PinnedOverride> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 16, 0);

/**
 * @generated from enum temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior
 */
export enum VersioningOverride_PinnedOverrideBehavior {
  /**
   * Unspecified.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Override workflow behavior to be Pinned.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,
}

/**
 * Describes the enum temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior.
 */
export const VersioningOverride_PinnedOverrideBehaviorSchema: GenEnum<VersioningOverride_PinnedOverrideBehavior> = /*@__PURE__*/
  enumDesc(file_temporal_api_workflow_v1_message, 16, 0);

/**
 * When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
 * there is already an existing running workflow, OnConflictOptions defines actions to be taken on
 * the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
 * history event in the running workflow with the changes requested in this object.
 *
 * @generated from message temporal.api.workflow.v1.OnConflictOptions
 */
export type OnConflictOptions = Message<"temporal.api.workflow.v1.OnConflictOptions"> & {
  /**
   * Attaches the request ID to the running workflow.
   *
   * @generated from field: bool attach_request_id = 1;
   */
  attachRequestId: boolean;

  /**
   * Attaches the completion callbacks to the running workflow.
   *
   * @generated from field: bool attach_completion_callbacks = 2;
   */
  attachCompletionCallbacks: boolean;

  /**
   * Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
   *
   * @generated from field: bool attach_links = 3;
   */
  attachLinks: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.OnConflictOptions.
 * Use `create(OnConflictOptionsSchema)` to create a new message.
 */
export const OnConflictOptionsSchema: GenMessage<OnConflictOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 17);

/**
 * RequestIdInfo contains details of a request ID.
 *
 * @generated from message temporal.api.workflow.v1.RequestIdInfo
 */
export type RequestIdInfo = Message<"temporal.api.workflow.v1.RequestIdInfo"> & {
  /**
   * The event type of the history event generated by the request.
   *
   * @generated from field: temporal.api.enums.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * The event id of the history event generated by the request. It's possible the event ID is not
   * known (unflushed buffered event). In this case, the value will be zero or a negative value,
   * representing an invalid ID.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId: bigint;

  /**
   * Indicate if the request is still buffered. If so, the event ID is not known and its value
   * will be an invalid event ID.
   *
   * @generated from field: bool buffered = 3;
   */
  buffered: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.RequestIdInfo.
 * Use `create(RequestIdInfoSchema)` to create a new message.
 */
export const RequestIdInfoSchema: GenMessage<RequestIdInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 18);

/**
 * PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation
 */
export type PostResetOperation = Message<"temporal.api.workflow.v1.PostResetOperation"> & {
  /**
   * @generated from oneof temporal.api.workflow.v1.PostResetOperation.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow signal_workflow = 1;
     */
    value: PostResetOperation_SignalWorkflow;
    case: "signalWorkflow";
  } | {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions update_workflow_options = 2;
     */
    value: PostResetOperation_UpdateWorkflowOptions;
    case: "updateWorkflowOptions";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.
 * Use `create(PostResetOperationSchema)` to create a new message.
 */
export const PostResetOperationSchema: GenMessage<PostResetOperation> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19);

/**
 * SignalWorkflow represents sending a signal after a workflow reset.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.SignalWorkflow
 */
export type PostResetOperation_SignalWorkflow = Message<"temporal.api.workflow.v1.PostResetOperation.SignalWorkflow"> & {
  /**
   * The workflow author-defined name of the signal to send to the workflow.
   *
   * @generated from field: string signal_name = 1;
   */
  signalName: string;

  /**
   * Serialized value(s) to provide with the signal.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads;

  /**
   * Headers that are passed with the signal to the processing workflow.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  /**
   * Links to be associated with the WorkflowExecutionSignaled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 4;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
 * Use `create(PostResetOperation_SignalWorkflowSchema)` to create a new message.
 */
export const PostResetOperation_SignalWorkflowSchema: GenMessage<PostResetOperation_SignalWorkflow> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19, 0);

/**
 * UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
 * Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions
 */
export type PostResetOperation_UpdateWorkflowOptions = Message<"temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions"> & {
  /**
   * Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 1;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
 * Use `create(PostResetOperation_UpdateWorkflowOptionsSchema)` to create a new message.
 */
export const PostResetOperation_UpdateWorkflowOptionsSchema: GenMessage<PostResetOperation_UpdateWorkflowOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19, 1);

/**
 * WorkflowExecutionPauseInfo contains the information about a workflow execution pause.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionPauseInfo
 */
export type WorkflowExecutionPauseInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionPauseInfo"> & {
  /**
   * The identity of the client who paused the workflow execution.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * The time when the workflow execution was paused.
   *
   * @generated from field: google.protobuf.Timestamp paused_time = 2;
   */
  pausedTime?: Timestamp;

  /**
   * The reason for pausing the workflow execution.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionPauseInfo.
 * Use `create(WorkflowExecutionPauseInfoSchema)` to create a new message.
 */
export const WorkflowExecutionPauseInfoSchema: GenMessage<WorkflowExecutionPauseInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 20);

