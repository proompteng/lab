// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/workflow/v1/message.proto (package temporal.api.workflow.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Empty, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ActivityOptions } from "../../activity/v1/message_pb.js";
import { file_temporal_api_activity_v1_message } from "../../activity/v1/message_pb.js";
import type { CallbackState, NexusOperationCancellationState, PendingNexusOperationState } from "../../enums/v1/common_pb.js";
import { file_temporal_api_enums_v1_common } from "../../enums/v1/common_pb.js";
import type { EventType } from "../../enums/v1/event_type_pb.js";
import { file_temporal_api_enums_v1_event_type } from "../../enums/v1/event_type_pb.js";
import type { ParentClosePolicy, PendingActivityState, PendingWorkflowTaskState, VersioningBehavior, WorkflowExecutionStatus, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { ActivityType, Callback, Header, Link, Memo, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { Deployment, WorkerDeploymentVersion } from "../../deployment/v1/message_pb.js";
import { file_temporal_api_deployment_v1_message } from "../../deployment/v1/message_pb.js";
import type { Failure } from "../../failure/v1/message_pb.js";
import { file_temporal_api_failure_v1_message } from "../../failure/v1/message_pb.js";
import type { TaskQueue } from "../../taskqueue/v1/message_pb.js";
import { file_temporal_api_taskqueue_v1_message } from "../../taskqueue/v1/message_pb.js";
import type { UserMetadata } from "../../sdk/v1/user_metadata_pb.js";
import { file_temporal_api_sdk_v1_user_metadata } from "../../sdk/v1/user_metadata_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/workflow/v1/message.proto.
 */
export const file_temporal_api_workflow_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiZ0ZW1wb3JhbC9hcGkvd29ya2Zsb3cvdjEvbWVzc2FnZS5wcm90bxIYdGVtcG9yYWwuYXBpLndvcmtmbG93LnYxIqsJChVXb3JrZmxvd0V4ZWN1dGlvbkluZm8SPAoJZXhlY3V0aW9uGAEgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIyCgR0eXBlGAIgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSLgoKc3RhcnRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKY2xvc2VfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoGc3RhdHVzGAUgASgOMi4udGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93RXhlY3V0aW9uU3RhdHVzEhYKDmhpc3RvcnlfbGVuZ3RoGAYgASgDEhsKE3BhcmVudF9uYW1lc3BhY2VfaWQYByABKAkSQwoQcGFyZW50X2V4ZWN1dGlvbhgIIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SMgoOZXhlY3V0aW9uX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEioKBG1lbW8YCiABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYCyABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMSQAoRYXV0b19yZXNldF9wb2ludHMYDCABKAsyJS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUmVzZXRQb2ludHMSEgoKdGFza19xdWV1ZRgNIAEoCRIeChZzdGF0ZV90cmFuc2l0aW9uX2NvdW50GA4gASgDEhoKEmhpc3Rvcnlfc2l6ZV9ieXRlcxgPIAEoAxJYCiBtb3N0X3JlY2VudF93b3JrZXJfdmVyc2lvbl9zdGFtcBgQIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYARI1ChJleGVjdXRpb25fZHVyYXRpb24YESABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SQQoOcm9vdF9leGVjdXRpb24YEiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEh0KEWFzc2lnbmVkX2J1aWxkX2lkGBMgASgJQgIYARIeChJpbmhlcml0ZWRfYnVpbGRfaWQYFCABKAlCAhgBEhQKDGZpcnN0X3J1bl9pZBgVIAEoCRJSCg92ZXJzaW9uaW5nX2luZm8YFiABKAsyOS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25WZXJzaW9uaW5nSW5mbxIeChZ3b3JrZXJfZGVwbG95bWVudF9uYW1lGBcgASgJEjIKCHByaW9yaXR5GBggASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eSL8AwodV29ya2Zsb3dFeGVjdXRpb25FeHRlbmRlZEluZm8SPQoZZXhlY3V0aW9uX2V4cGlyYXRpb25fdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNwoTcnVuX2V4cGlyYXRpb25fdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASGAoQY2FuY2VsX3JlcXVlc3RlZBgDIAEoCBIzCg9sYXN0X3Jlc2V0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjcKE29yaWdpbmFsX3N0YXJ0X3RpbWUYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhQKDHJlc2V0X3J1bl9pZBgGIAEoCRJlChByZXF1ZXN0X2lkX2luZm9zGAcgAygLMksudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uRXh0ZW5kZWRJbmZvLlJlcXVlc3RJZEluZm9zRW50cnkaXgoTUmVxdWVzdElkSW5mb3NFbnRyeRILCgNrZXkYASABKAkSNgoFdmFsdWUYAiABKAsyJy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUmVxdWVzdElkSW5mbzoCOAEijgQKH1dvcmtmbG93RXhlY3V0aW9uVmVyc2lvbmluZ0luZm8SOwoIYmVoYXZpb3IYASABKA4yKS50ZW1wb3JhbC5hcGkuZW51bXMudjEuVmVyc2lvbmluZ0JlaGF2aW9yEj4KCmRlcGxveW1lbnQYAiABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50QgIYARITCgd2ZXJzaW9uGAUgASgJQgIYARJPChJkZXBsb3ltZW50X3ZlcnNpb24YByABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhJJChN2ZXJzaW9uaW5nX292ZXJyaWRlGAMgASgLMiwudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlZlcnNpb25pbmdPdmVycmlkZRJRChVkZXBsb3ltZW50X3RyYW5zaXRpb24YBCABKAsyLi50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuRGVwbG95bWVudFRyYW5zaXRpb25CAhgBElEKEnZlcnNpb25fdHJhbnNpdGlvbhgGIAEoCzI1LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5EZXBsb3ltZW50VmVyc2lvblRyYW5zaXRpb24SFwoPcmV2aXNpb25fbnVtYmVyGAggASgDIlIKFERlcGxveW1lbnRUcmFuc2l0aW9uEjoKCmRlcGxveW1lbnQYASABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50IoMBChtEZXBsb3ltZW50VmVyc2lvblRyYW5zaXRpb24SEwoHdmVyc2lvbhgBIAEoCUICGAESTwoSZGVwbG95bWVudF92ZXJzaW9uGAIgASgLMjMudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudFZlcnNpb24ixwIKF1dvcmtmbG93RXhlY3V0aW9uQ29uZmlnEjgKCnRhc2tfcXVldWUYASABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRI9Chp3b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI3ChR3b3JrZmxvd19ydW5fdGltZW91dBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJACh1kZWZhdWx0X3dvcmtmbG93X3Rhc2tfdGltZW91dBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4Cg11c2VyX21ldGFkYXRhGAUgASgLMiEudGVtcG9yYWwuYXBpLnNkay52MS5Vc2VyTWV0YWRhdGEivQ0KE1BlbmRpbmdBY3Rpdml0eUluZm8SEwoLYWN0aXZpdHlfaWQYASABKAkSOwoNYWN0aXZpdHlfdHlwZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuQWN0aXZpdHlUeXBlEjoKBXN0YXRlGAMgASgOMisudGVtcG9yYWwuYXBpLmVudW1zLnYxLlBlbmRpbmdBY3Rpdml0eVN0YXRlEjsKEWhlYXJ0YmVhdF9kZXRhaWxzGAQgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI3ChNsYXN0X2hlYXJ0YmVhdF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI1ChFsYXN0X3N0YXJ0ZWRfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDwoHYXR0ZW1wdBgHIAEoBRIYChBtYXhpbXVtX2F0dGVtcHRzGAggASgFEjIKDnNjaGVkdWxlZF90aW1lGAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIzCg9leHBpcmF0aW9uX3RpbWUYCiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjYKDGxhc3RfZmFpbHVyZRgLIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSHAoUbGFzdF93b3JrZXJfaWRlbnRpdHkYDCABKAkSOwoVdXNlX3dvcmtmbG93X2J1aWxkX2lkGA0gASgLMhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5QgIYAUgAEjIKJGxhc3RfaW5kZXBlbmRlbnRseV9hc3NpZ25lZF9idWlsZF9pZBgOIAEoCUICGAFIABJRChlsYXN0X3dvcmtlcl92ZXJzaW9uX3N0YW1wGA8gASgLMioudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJWZXJzaW9uU3RhbXBCAhgBEjkKFmN1cnJlbnRfcmV0cnlfaW50ZXJ2YWwYECABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SPgoabGFzdF9hdHRlbXB0X2NvbXBsZXRlX3RpbWUYESABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEj4KGm5leHRfYXR0ZW1wdF9zY2hlZHVsZV90aW1lGBIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIOCgZwYXVzZWQYEyABKAgSQwoPbGFzdF9kZXBsb3ltZW50GBQgASgLMiYudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudEICGAESKgoebGFzdF93b3JrZXJfZGVwbG95bWVudF92ZXJzaW9uGBUgASgJQgIYARJUChdsYXN0X2RlcGxveW1lbnRfdmVyc2lvbhgZIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uEjIKCHByaW9yaXR5GBYgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eRJLCgpwYXVzZV9pbmZvGBcgASgLMjcudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlBlbmRpbmdBY3Rpdml0eUluZm8uUGF1c2VJbmZvEkMKEGFjdGl2aXR5X29wdGlvbnMYGCABKAsyKS50ZW1wb3JhbC5hcGkuYWN0aXZpdHkudjEuQWN0aXZpdHlPcHRpb25zGs8CCglQYXVzZUluZm8SLgoKcGF1c2VfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASUAoGbWFudWFsGAIgASgLMj4udGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlBlbmRpbmdBY3Rpdml0eUluZm8uUGF1c2VJbmZvLk1hbnVhbEgAEkwKBHJ1bGUYBCABKAsyPC50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ0FjdGl2aXR5SW5mby5QYXVzZUluZm8uUnVsZUgAGioKBk1hbnVhbBIQCghpZGVudGl0eRgBIAEoCRIOCgZyZWFzb24YAiABKAkaOQoEUnVsZRIPCgdydWxlX2lkGAEgASgJEhAKCGlkZW50aXR5GAIgASgJEg4KBnJlYXNvbhgDIAEoCUILCglwYXVzZWRfYnlCEwoRYXNzaWduZWRfYnVpbGRfaWQiuQEKGVBlbmRpbmdDaGlsZEV4ZWN1dGlvbkluZm8SEwoLd29ya2Zsb3dfaWQYASABKAkSDgoGcnVuX2lkGAIgASgJEhoKEndvcmtmbG93X3R5cGVfbmFtZRgDIAEoCRIUCgxpbml0aWF0ZWRfaWQYBCABKAMSRQoTcGFyZW50X2Nsb3NlX3BvbGljeRgFIAEoDjIoLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5QYXJlbnRDbG9zZVBvbGljeSKNAgoXUGVuZGluZ1dvcmtmbG93VGFza0luZm8SPgoFc3RhdGUYASABKA4yLy50ZW1wb3JhbC5hcGkuZW51bXMudjEuUGVuZGluZ1dvcmtmbG93VGFza1N0YXRlEjIKDnNjaGVkdWxlZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI7ChdvcmlnaW5hbF9zY2hlZHVsZWRfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMAoMc3RhcnRlZF90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIPCgdhdHRlbXB0GAUgASgFIkcKC1Jlc2V0UG9pbnRzEjgKBnBvaW50cxgBIAMoCzIoLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5SZXNldFBvaW50SW5mbyLvAQoOUmVzZXRQb2ludEluZm8SEAoIYnVpbGRfaWQYByABKAkSGwoPYmluYXJ5X2NoZWNrc3VtGAEgASgJQgIYARIOCgZydW5faWQYAiABKAkSKAogZmlyc3Rfd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfaWQYAyABKAMSLwoLY3JlYXRlX3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi8KC2V4cGlyZV90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBISCgpyZXNldHRhYmxlGAYgASgIIoUHChhOZXdXb3JrZmxvd0V4ZWN1dGlvbkluZm8SEwoLd29ya2Zsb3dfaWQYASABKAkSOwoNd29ya2Zsb3dfdHlwZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEjgKCnRhc2tfcXVldWUYAyABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRIvCgVpbnB1dBgEIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSPQoad29ya2Zsb3dfZXhlY3V0aW9uX3RpbWVvdXQYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SNwoUd29ya2Zsb3dfcnVuX3RpbWVvdXQYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOAoVd29ya2Zsb3dfdGFza190aW1lb3V0GAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEk4KGHdvcmtmbG93X2lkX3JldXNlX3BvbGljeRgIIAEoDjIsLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkUmV1c2VQb2xpY3kSOQoMcmV0cnlfcG9saWN5GAkgASgLMiMudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5SZXRyeVBvbGljeRIVCg1jcm9uX3NjaGVkdWxlGAogASgJEioKBG1lbW8YCyABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYDCABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMSLgoGaGVhZGVyGA0gASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISOAoNdXNlcl9tZXRhZGF0YRgOIAEoCzIhLnRlbXBvcmFsLmFwaS5zZGsudjEuVXNlck1ldGFkYXRhEkkKE3ZlcnNpb25pbmdfb3ZlcnJpZGUYDyABKAsyLC50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuVmVyc2lvbmluZ092ZXJyaWRlEjIKCHByaW9yaXR5GBAgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eSLSBAoMQ2FsbGJhY2tJbmZvEjIKCGNhbGxiYWNrGAEgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5DYWxsYmFjaxI/Cgd0cmlnZ2VyGAIgASgLMi4udGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLkNhbGxiYWNrSW5mby5UcmlnZ2VyEjUKEXJlZ2lzdHJhdGlvbl90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIzCgVzdGF0ZRgEIAEoDjIkLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5DYWxsYmFja1N0YXRlEg8KB2F0dGVtcHQYBSABKAUSPgoabGFzdF9hdHRlbXB0X2NvbXBsZXRlX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEj4KFGxhc3RfYXR0ZW1wdF9mYWlsdXJlGAcgASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZRI+ChpuZXh0X2F0dGVtcHRfc2NoZWR1bGVfdGltZRgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFgoOYmxvY2tlZF9yZWFzb24YCSABKAkaEAoOV29ya2Zsb3dDbG9zZWQaZgoHVHJpZ2dlchJQCg93b3JrZmxvd19jbG9zZWQYASABKAsyNS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuQ2FsbGJhY2tJbmZvLldvcmtmbG93Q2xvc2VkSABCCQoHdmFyaWFudCKSBQoZUGVuZGluZ05leHVzT3BlcmF0aW9uSW5mbxIQCghlbmRwb2ludBgBIAEoCRIPCgdzZXJ2aWNlGAIgASgJEhEKCW9wZXJhdGlvbhgDIAEoCRIYCgxvcGVyYXRpb25faWQYBCABKAlCAhgBEjwKGXNjaGVkdWxlX3RvX2Nsb3NlX3RpbWVvdXQYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SMgoOc2NoZWR1bGVkX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEkAKBXN0YXRlGAcgASgOMjEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlBlbmRpbmdOZXh1c09wZXJhdGlvblN0YXRlEg8KB2F0dGVtcHQYCCABKAUSPgoabGFzdF9hdHRlbXB0X2NvbXBsZXRlX3RpbWUYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEj4KFGxhc3RfYXR0ZW1wdF9mYWlsdXJlGAogASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZRI+ChpuZXh0X2F0dGVtcHRfc2NoZWR1bGVfdGltZRgLIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASUwoRY2FuY2VsbGF0aW9uX2luZm8YDCABKAsyOC50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuTmV4dXNPcGVyYXRpb25DYW5jZWxsYXRpb25JbmZvEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgNIAEoAxIWCg5ibG9ja2VkX3JlYXNvbhgOIAEoCRIXCg9vcGVyYXRpb25fdG9rZW4YDyABKAkihAMKHk5leHVzT3BlcmF0aW9uQ2FuY2VsbGF0aW9uSW5mbxIyCg5yZXF1ZXN0ZWRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASRQoFc3RhdGUYAiABKA4yNi50ZW1wb3JhbC5hcGkuZW51bXMudjEuTmV4dXNPcGVyYXRpb25DYW5jZWxsYXRpb25TdGF0ZRIPCgdhdHRlbXB0GAMgASgFEj4KGmxhc3RfYXR0ZW1wdF9jb21wbGV0ZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI+ChRsYXN0X2F0dGVtcHRfZmFpbHVyZRgFIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSPgoabmV4dF9hdHRlbXB0X3NjaGVkdWxlX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhYKDmJsb2NrZWRfcmVhc29uGAcgASgJImUKGFdvcmtmbG93RXhlY3V0aW9uT3B0aW9ucxJJChN2ZXJzaW9uaW5nX292ZXJyaWRlGAEgASgLMiwudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlZlcnNpb25pbmdPdmVycmlkZSK9BAoSVmVyc2lvbmluZ092ZXJyaWRlEk0KBnBpbm5lZBgDIAEoCzI7LnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUuUGlubmVkT3ZlcnJpZGVIABIWCgxhdXRvX3VwZ3JhZGUYBCABKAhIABI/CghiZWhhdmlvchgBIAEoDjIpLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5WZXJzaW9uaW5nQmVoYXZpb3JCAhgBEj4KCmRlcGxveW1lbnQYAiABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50QgIYARIaCg5waW5uZWRfdmVyc2lvbhgJIAEoCUICGAEarQEKDlBpbm5lZE92ZXJyaWRlElUKCGJlaGF2aW9yGAEgASgOMkMudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlZlcnNpb25pbmdPdmVycmlkZS5QaW5uZWRPdmVycmlkZUJlaGF2aW9yEkQKB3ZlcnNpb24YAiABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbiJnChZQaW5uZWRPdmVycmlkZUJlaGF2aW9yEigKJFBJTk5FRF9PVkVSUklERV9CRUhBVklPUl9VTlNQRUNJRklFRBAAEiMKH1BJTk5FRF9PVkVSUklERV9CRUhBVklPUl9QSU5ORUQQAUIKCghvdmVycmlkZSJpChFPbkNvbmZsaWN0T3B0aW9ucxIZChFhdHRhY2hfcmVxdWVzdF9pZBgBIAEoCBIjChthdHRhY2hfY29tcGxldGlvbl9jYWxsYmFja3MYAiABKAgSFAoMYXR0YWNoX2xpbmtzGAMgASgIImkKDVJlcXVlc3RJZEluZm8SNAoKZXZlbnRfdHlwZRgBIAEoDjIgLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5FdmVudFR5cGUSEAoIZXZlbnRfaWQYAiABKAMSEAoIYnVmZmVyZWQYAyABKAgitwQKElBvc3RSZXNldE9wZXJhdGlvbhJWCg9zaWduYWxfd29ya2Zsb3cYASABKAsyOy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUG9zdFJlc2V0T3BlcmF0aW9uLlNpZ25hbFdvcmtmbG93SAASZQoXdXBkYXRlX3dvcmtmbG93X29wdGlvbnMYAiABKAsyQi50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUG9zdFJlc2V0T3BlcmF0aW9uLlVwZGF0ZVdvcmtmbG93T3B0aW9uc0gAGrMBCg5TaWduYWxXb3JrZmxvdxITCgtzaWduYWxfbmFtZRgBIAEoCRIvCgVpbnB1dBgCIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSLgoGaGVhZGVyGAMgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISKwoFbGlua3MYBCADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsaoAEKFVVwZGF0ZVdvcmtmbG93T3B0aW9ucxJWChp3b3JrZmxvd19leGVjdXRpb25fb3B0aW9ucxgBIAEoCzIyLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5Xb3JrZmxvd0V4ZWN1dGlvbk9wdGlvbnMSLwoLdXBkYXRlX21hc2sYAiABKAsyGi5nb29nbGUucHJvdG9idWYuRmllbGRNYXNrQgkKB3ZhcmlhbnRCkwEKG2lvLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MUIMTWVzc2FnZVByb3RvUAFaJ2dvLnRlbXBvcmFsLmlvL2FwaS93b3JrZmxvdy92MTt3b3JrZmxvd6oCGlRlbXBvcmFsaW8uQXBpLldvcmtmbG93LlYx6gIdVGVtcG9yYWxpbzo6QXBpOjpXb3JrZmxvdzo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_google_protobuf_empty, file_google_protobuf_timestamp, file_google_protobuf_field_mask, file_temporal_api_activity_v1_message, file_temporal_api_enums_v1_common, file_temporal_api_enums_v1_event_type, file_temporal_api_enums_v1_workflow, file_temporal_api_common_v1_message, file_temporal_api_deployment_v1_message, file_temporal_api_failure_v1_message, file_temporal_api_taskqueue_v1_message, file_temporal_api_sdk_v1_user_metadata]);

/**
 * Hold basic information about a workflow execution.
 * This structure is a part of visibility, and thus contain a limited subset of information.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionInfo
 */
export type WorkflowExecutionInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionInfo"> & {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 1;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType type = 2;
   */
  type?: WorkflowType;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
   */
  status: WorkflowExecutionStatus;

  /**
   * @generated from field: int64 history_length = 6;
   */
  historyLength: bigint;

  /**
   * @generated from field: string parent_namespace_id = 7;
   */
  parentNamespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution parent_execution = 8;
   */
  parentExecution?: WorkflowExecution;

  /**
   * @generated from field: google.protobuf.Timestamp execution_time = 9;
   */
  executionTime?: Timestamp;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 10;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 11;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.workflow.v1.ResetPoints auto_reset_points = 12;
   */
  autoResetPoints?: ResetPoints;

  /**
   * @generated from field: string task_queue = 13;
   */
  taskQueue: string;

  /**
   * @generated from field: int64 state_transition_count = 14;
   */
  stateTransitionCount: bigint;

  /**
   * @generated from field: int64 history_size_bytes = 15;
   */
  historySizeBytes: bigint;

  /**
   * If set, the most recent worker version stamp that appeared in a workflow task completion
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp most_recent_worker_version_stamp = 16 [deprecated = true];
   * @deprecated
   */
  mostRecentWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * Workflow execution duration is defined as difference between close time and execution time.
   * This field is only populated if the workflow is closed.
   *
   * @generated from field: google.protobuf.Duration execution_duration = 17;
   */
  executionDuration?: Duration;

  /**
   * Contains information about the root workflow execution.
   * The root workflow execution is defined as follows:
   * 1. A workflow without parent workflow is its own root workflow.
   * 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
   * Note: workflows continued as new or reseted may or may not have parents, check examples below.
   *
   * Examples:
   *   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 3: Workflow W1 continued as new W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
   *     - The root workflow of all three workflows is W1.
   *   Scenario 5: Workflow W1 is reseted, creating W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution root_execution = 18;
   */
  rootExecution?: WorkflowExecution;

  /**
   * The currently assigned build ID for this execution. Presence of this value means worker versioning is used
   * for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
   * when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
   * again, the assigned build ID may change according to the latest versioning rules.
   * Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
   * this execution.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string assigned_build_id = 19 [deprecated = true];
   * @deprecated
   */
  assignedBuildId: string;

  /**
   * Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
   * of using the assignment rules.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string inherited_build_id = 20 [deprecated = true];
   * @deprecated
   */
  inheritedBuildId: string;

  /**
   * The first run ID in the execution chain.
   * Executions created via the following operations are considered to be in the same chain
   * - ContinueAsNew
   * - Workflow Retry
   * - Workflow Reset
   * - Cron Schedule
   *
   * @generated from field: string first_run_id = 21;
   */
  firstRunId: string;

  /**
   * Absent value means the workflow execution is not versioned. When present, the execution might
   * be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
   * Experimental. Versioning info is experimental and might change in the future.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo versioning_info = 22;
   */
  versioningInfo?: WorkflowExecutionVersioningInfo;

  /**
   * The name of Worker Deployment that completed the most recent workflow task.
   * Experimental. Worker Deployments are experimental and might change in the future.
   *
   * @generated from field: string worker_deployment_name = 23;
   */
  workerDeploymentName: string;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 24;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionInfo.
 * Use `create(WorkflowExecutionInfoSchema)` to create a new message.
 */
export const WorkflowExecutionInfoSchema: GenMessage<WorkflowExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 0);

/**
 * Holds all the extra information about workflow execution that is not part of Visibility.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionExtendedInfo
 */
export type WorkflowExecutionExtendedInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionExtendedInfo"> & {
  /**
   * Workflow execution expiration time is defined as workflow start time plus expiration timeout.
   * Workflow start time may change after workflow reset.
   *
   * @generated from field: google.protobuf.Timestamp execution_expiration_time = 1;
   */
  executionExpirationTime?: Timestamp;

  /**
   * Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
   *
   * @generated from field: google.protobuf.Timestamp run_expiration_time = 2;
   */
  runExpirationTime?: Timestamp;

  /**
   * indicates if the workflow received a cancel request
   *
   * @generated from field: bool cancel_requested = 3;
   */
  cancelRequested: boolean;

  /**
   * Last workflow reset time. Nil if the workflow was never reset.
   *
   * @generated from field: google.protobuf.Timestamp last_reset_time = 4;
   */
  lastResetTime?: Timestamp;

  /**
   * Original workflow start time.
   *
   * @generated from field: google.protobuf.Timestamp original_start_time = 5;
   */
  originalStartTime?: Timestamp;

  /**
   * Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
   *
   * @generated from field: string reset_run_id = 6;
   */
  resetRunId: string;

  /**
   * Request ID information (eg: history event information associated with the request ID).
   * Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
   * calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
   * used in the StartWorkflowExecution request).
   *
   * @generated from field: map<string, temporal.api.workflow.v1.RequestIdInfo> request_id_infos = 7;
   */
  requestIdInfos: { [key: string]: RequestIdInfo };
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionExtendedInfo.
 * Use `create(WorkflowExecutionExtendedInfoSchema)` to create a new message.
 */
export const WorkflowExecutionExtendedInfoSchema: GenMessage<WorkflowExecutionExtendedInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 1);

/**
 * Holds all the information about worker versioning for a particular workflow execution.
 * Experimental. Versioning info is experimental and might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
 */
export type WorkflowExecutionVersioningInfo = Message<"temporal.api.workflow.v1.WorkflowExecutionVersioningInfo"> & {
  /**
   * Versioning behavior determines how the server should treat this execution when workers are
   * upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
   * unversioned. See the comments in `VersioningBehavior` enum for more info about different
   * behaviors.
   * This field is first set after an execution completes its first workflow task on a versioned
   * worker, and set again on completion of every subsequent workflow task.
   * For child workflows of Pinned parents, this will be set to Pinned (along with `deployment_version`) when
   * the the child starts so that child's first workflow task goes to the same Version as the
   * parent. After the first workflow task, it depends on the child workflow itself if it wants
   * to stay pinned or become unpinned (according to Versioning Behavior set in the worker).
   * Note that `behavior` is overridden by `versioning_override` if the latter is present.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1;
   */
  behavior: VersioningBehavior;

  /**
   * The worker deployment that completed the last workflow task of this workflow execution. Must
   * be present if `behavior` is set. Absent value means no workflow task is completed, or the
   * last workflow task was completed by an unversioned worker. Unversioned workers may still send
   * a deployment value which will be stored here, so the right way to check if an execution is
   * versioned if an execution is versioned or not is via the `behavior` field.
   * Note that `deployment` is overridden by `versioning_override` if the latter is present.
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 5 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The Worker Deployment Version that completed the last workflow task of this workflow execution.
   * An absent value means no workflow task is completed, or the workflow is unversioned.
   * If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
   * by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
   *
   * For child workflows of Pinned parents, this will be set to the parent's Pinned Version when
   * the child starts, so that the child's first workflow task goes to the same Version as the parent.
   * Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
   * will override this value.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 7;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Present if user has set an execution-specific versioning override. This override takes
   * precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
   * override can be set when starting a new execution, as well as afterwards by calling the
   * `UpdateWorkflowExecutionOptions` API.
   * Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
   * workflow retries, and cron workflows.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 3;
   */
  versioningOverride?: VersioningOverride;

  /**
   * When present, indicates the workflow is transitioning to a different deployment. Can
   * indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current deployment if the task queue's current
   * deployment is different from the workflow's deployment.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current deployment. As soon as a poller from
   * that deployment is available to receive the task, the workflow will automatically start a
   * transition to that deployment and continue execution there.
   * A deployment transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target deployment, the
   * transition completes and the workflow's `deployment` and `behavior` fields are updated per
   * the worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new deployment.
   * Deprecated. Use version_transition.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentTransition deployment_transition = 4 [deprecated = true];
   * @deprecated
   */
  deploymentTransition?: DeploymentTransition;

  /**
   * When present, indicates the workflow is transitioning to a different deployment version
   * (which may belong to the same deployment name or another). Can indicate one of the following
   * transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment version, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current version if the task queue's current version is
   * different from the workflow's current deployment version.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current version. As soon as a poller from
   * that deployment version is available to receive the task, the workflow will automatically
   * start a transition to that version and continue execution there.
   * A version transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target version, the
   * transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
   * worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new version.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentVersionTransition version_transition = 6;
   */
  versionTransition?: DeploymentVersionTransition;

  /**
   * Monotonic counter reflecting the latest routing decision for this workflow execution.
   * Used for staleness detection between history and matching when dispatching tasks to workers.
   * Incremented when a workflow execution routes to a new deployment version, which happens 
   * when a worker of the new deployment version completes a workflow task.
   * Note: Pinned tasks and sticky tasks send a value of 0 for this field since these tasks do not
   * face the problem of inconsistent dispatching that arises from eventual consistency between 
   * task queues and their partitions.
   *
   * @generated from field: int64 revision_number = 8;
   */
  revisionNumber: bigint;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionVersioningInfo.
 * Use `create(WorkflowExecutionVersioningInfoSchema)` to create a new message.
 */
export const WorkflowExecutionVersioningInfoSchema: GenMessage<WorkflowExecutionVersioningInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 2);

/**
 * Holds information about ongoing transition of a workflow execution from one deployment to another.
 * Deprecated. Use DeploymentVersionTransition.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentTransition
 */
export type DeploymentTransition = Message<"temporal.api.workflow.v1.DeploymentTransition"> & {
  /**
   * The target deployment of the transition. Null means a so-far-versioned workflow is
   * transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 1;
   */
  deployment?: Deployment;
};

/**
 * Describes the message temporal.api.workflow.v1.DeploymentTransition.
 * Use `create(DeploymentTransitionSchema)` to create a new message.
 */
export const DeploymentTransitionSchema: GenMessage<DeploymentTransition> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 3);

/**
 * Holds information about ongoing transition of a workflow execution from one worker
 * deployment version to another.
 * Experimental. Might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentVersionTransition
 */
export type DeploymentVersionTransition = Message<"temporal.api.workflow.v1.DeploymentVersionTransition"> & {
  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 1 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The target Version of the transition.
   * If nil, a so-far-versioned workflow is transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 2;
   */
  deploymentVersion?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.workflow.v1.DeploymentVersionTransition.
 * Use `create(DeploymentVersionTransitionSchema)` to create a new message.
 */
export const DeploymentVersionTransitionSchema: GenMessage<DeploymentVersionTransition> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 4);

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionConfig
 */
export type WorkflowExecutionConfig = Message<"temporal.api.workflow.v1.WorkflowExecutionConfig"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 2;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 3;
   */
  workflowRunTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration default_workflow_task_timeout = 4;
   */
  defaultWorkflowTaskTimeout?: Duration;

  /**
   * User metadata provided on start workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 5;
   */
  userMetadata?: UserMetadata;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionConfig.
 * Use `create(WorkflowExecutionConfigSchema)` to create a new message.
 */
export const WorkflowExecutionConfigSchema: GenMessage<WorkflowExecutionConfig> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 5);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo
 */
export type PendingActivityInfo = Message<"temporal.api.workflow.v1.PendingActivityInfo"> & {
  /**
   * @generated from field: string activity_id = 1;
   */
  activityId: string;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: temporal.api.enums.v1.PendingActivityState state = 3;
   */
  state: PendingActivityState;

  /**
   * @generated from field: temporal.api.common.v1.Payloads heartbeat_details = 4;
   */
  heartbeatDetails?: Payloads;

  /**
   * @generated from field: google.protobuf.Timestamp last_heartbeat_time = 5;
   */
  lastHeartbeatTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_started_time = 6;
   */
  lastStartedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 7;
   */
  attempt: number;

  /**
   * @generated from field: int32 maximum_attempts = 8;
   */
  maximumAttempts: number;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 9;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp expiration_time = 10;
   */
  expirationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.failure.v1.Failure last_failure = 11;
   */
  lastFailure?: Failure;

  /**
   * @generated from field: string last_worker_identity = 12;
   */
  lastWorkerIdentity: string;

  /**
   * Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
   * In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
   * independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.assigned_build_id
   */
  assignedBuildId: {
    /**
     * Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
     *
     * @generated from field: google.protobuf.Empty use_workflow_build_id = 13 [deprecated = true];
     * @deprecated
     */
    value: Empty;
    case: "useWorkflowBuildId";
  } | {
    /**
     * Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
     * The activity will use the build id in this field instead.
     * If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
     * rules.
     *
     * @generated from field: string last_independently_assigned_build_id = 14 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "lastIndependentlyAssignedBuildId";
  } | { case: undefined; value?: undefined };

  /**
   * Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
   * This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp last_worker_version_stamp = 15 [deprecated = true];
   * @deprecated
   */
  lastWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * The time activity will wait until the next retry.
   * If activity is currently running it will be next retry interval if activity failed.
   * If activity is currently waiting it will be current retry interval.
   * If there will be no retry it will be null.
   *
   * @generated from field: google.protobuf.Duration current_retry_interval = 16;
   */
  currentRetryInterval?: Duration;

  /**
   * The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 17;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * Next time when activity will be scheduled.
   * If activity is currently scheduled or started it will be null.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 18;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * Indicates if activity is paused.
   *
   * @generated from field: bool paused = 19;
   */
  paused: boolean;

  /**
   * The deployment this activity was dispatched to most recently. Present only if the activity
   * was dispatched to a versioned worker.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment last_deployment = 20 [deprecated = true];
   * @deprecated
   */
  lastDeployment?: Deployment;

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: string last_worker_deployment_version = 21 [deprecated = true];
   * @deprecated
   */
  lastWorkerDeploymentVersion: string;

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion last_deployment_version = 25;
   */
  lastDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 22;
   */
  priority?: Priority;

  /**
   * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo pause_info = 23;
   */
  pauseInfo?: PendingActivityInfo_PauseInfo;

  /**
   * Current activity options. May be different from the one used to start the activity.
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 24;
   */
  activityOptions?: ActivityOptions;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.
 * Use `create(PendingActivityInfoSchema)` to create a new message.
 */
export const PendingActivityInfoSchema: GenMessage<PendingActivityInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo
 */
export type PendingActivityInfo_PauseInfo = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo"> & {
  /**
   * The time when the activity was paused.
   *
   * @generated from field: google.protobuf.Timestamp pause_time = 1;
   */
  pauseTime?: Timestamp;

  /**
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.paused_by
   */
  pausedBy: {
    /**
     * activity was paused by the manual intervention
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual manual = 2;
     */
    value: PendingActivityInfo_PauseInfo_Manual;
    case: "manual";
  } | {
    /**
     * activity was paused by the rule
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule rule = 4;
     */
    value: PendingActivityInfo_PauseInfo_Rule;
    case: "rule";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.
 * Use `create(PendingActivityInfo_PauseInfoSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfoSchema: GenMessage<PendingActivityInfo_PauseInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual
 */
export type PendingActivityInfo_PauseInfo_Manual = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual"> & {
  /**
   * The identity of the actor that paused the activity.
   *
   * @generated from field: string identity = 1;
   */
  identity: string;

  /**
   * Reason for pausing the activity.
   *
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual.
 * Use `create(PendingActivityInfo_PauseInfo_ManualSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfo_ManualSchema: GenMessage<PendingActivityInfo_PauseInfo_Manual> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0, 0);

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule
 */
export type PendingActivityInfo_PauseInfo_Rule = Message<"temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule"> & {
  /**
   * The rule that paused the activity.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId: string;

  /**
   * The identity of the actor that created the rule.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * Reason why rule was created. Populated from rule description.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule.
 * Use `create(PendingActivityInfo_PauseInfo_RuleSchema)` to create a new message.
 */
export const PendingActivityInfo_PauseInfo_RuleSchema: GenMessage<PendingActivityInfo_PauseInfo_Rule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 6, 0, 1);

/**
 * @generated from message temporal.api.workflow.v1.PendingChildExecutionInfo
 */
export type PendingChildExecutionInfo = Message<"temporal.api.workflow.v1.PendingChildExecutionInfo"> & {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * @generated from field: string run_id = 2;
   */
  runId: string;

  /**
   * @generated from field: string workflow_type_name = 3;
   */
  workflowTypeName: string;

  /**
   * @generated from field: int64 initiated_id = 4;
   */
  initiatedId: bigint;

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 5;
   */
  parentClosePolicy: ParentClosePolicy;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingChildExecutionInfo.
 * Use `create(PendingChildExecutionInfoSchema)` to create a new message.
 */
export const PendingChildExecutionInfoSchema: GenMessage<PendingChildExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 7);

/**
 * @generated from message temporal.api.workflow.v1.PendingWorkflowTaskInfo
 */
export type PendingWorkflowTaskInfo = Message<"temporal.api.workflow.v1.PendingWorkflowTaskInfo"> & {
  /**
   * @generated from field: temporal.api.enums.v1.PendingWorkflowTaskState state = 1;
   */
  state: PendingWorkflowTaskState;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 2;
   */
  scheduledTime?: Timestamp;

  /**
   * original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
   * Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
   * In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
   * some threshold, the workflow task will be forced timeout.
   *
   * @generated from field: google.protobuf.Timestamp original_scheduled_time = 3;
   */
  originalScheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp started_time = 4;
   */
  startedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 5;
   */
  attempt: number;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingWorkflowTaskInfo.
 * Use `create(PendingWorkflowTaskInfoSchema)` to create a new message.
 */
export const PendingWorkflowTaskInfoSchema: GenMessage<PendingWorkflowTaskInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 8);

/**
 * @generated from message temporal.api.workflow.v1.ResetPoints
 */
export type ResetPoints = Message<"temporal.api.workflow.v1.ResetPoints"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.ResetPointInfo points = 1;
   */
  points: ResetPointInfo[];
};

/**
 * Describes the message temporal.api.workflow.v1.ResetPoints.
 * Use `create(ResetPointsSchema)` to create a new message.
 */
export const ResetPointsSchema: GenMessage<ResetPoints> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 9);

/**
 * ResetPointInfo records the workflow event id that is the first one processed by a given
 * build id or binary checksum. A new reset point will be created if either build id or binary
 * checksum changes (although in general only one or the other will be used at a time).
 *
 * @generated from message temporal.api.workflow.v1.ResetPointInfo
 */
export type ResetPointInfo = Message<"temporal.api.workflow.v1.ResetPointInfo"> & {
  /**
   * Worker build id.
   *
   * @generated from field: string build_id = 7;
   */
  buildId: string;

  /**
   * Deprecated. A worker binary version identifier.
   *
   * @generated from field: string binary_checksum = 1 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * The first run ID in the execution chain that was touched by this worker build.
   *
   * @generated from field: string run_id = 2;
   */
  runId: string;

  /**
   * Event ID of the first WorkflowTaskCompleted event processed by this worker build.
   *
   * @generated from field: int64 first_workflow_task_completed_id = 3;
   */
  firstWorkflowTaskCompletedId: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * (-- api-linter: core::0214::resource-expiry=disabled
   *     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
   * The time that the run is deleted due to retention.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 5;
   */
  expireTime?: Timestamp;

  /**
   * false if the reset point has pending childWFs/reqCancels/signalExternals.
   *
   * @generated from field: bool resettable = 6;
   */
  resettable: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.ResetPointInfo.
 * Use `create(ResetPointInfoSchema)` to create a new message.
 */
export const ResetPointInfoSchema: GenMessage<ResetPointInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 10);

/**
 * NewWorkflowExecutionInfo is a shared message that encapsulates all the
 * required arguments to starting a workflow in different contexts.
 *
 * @generated from message temporal.api.workflow.v1.NewWorkflowExecutionInfo
 */
export type NewWorkflowExecutionInfo = Message<"temporal.api.workflow.v1.NewWorkflowExecutionInfo"> & {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 5;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 6;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 7;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 8;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 9;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 10;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 11;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 12;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 13;
   */
  header?: Header;

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 14;
   */
  userMetadata?: UserMetadata;

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 15;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 16;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflow.v1.NewWorkflowExecutionInfo.
 * Use `create(NewWorkflowExecutionInfoSchema)` to create a new message.
 */
export const NewWorkflowExecutionInfoSchema: GenMessage<NewWorkflowExecutionInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 11);

/**
 * CallbackInfo contains the state of an attached workflow callback.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo
 */
export type CallbackInfo = Message<"temporal.api.workflow.v1.CallbackInfo"> & {
  /**
   * Information on how this callback should be invoked (e.g. its URL and type).
   *
   * @generated from field: temporal.api.common.v1.Callback callback = 1;
   */
  callback?: Callback;

  /**
   * Trigger for this callback.
   *
   * @generated from field: temporal.api.workflow.v1.CallbackInfo.Trigger trigger = 2;
   */
  trigger?: CallbackInfo_Trigger;

  /**
   * The time when the callback was registered.
   *
   * @generated from field: google.protobuf.Timestamp registration_time = 3;
   */
  registrationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.CallbackState state = 4;
   */
  state: CallbackState;

  /**
   * The number of attempts made to deliver the callback.
   * This number represents a minimum bound since the attempt is incremented after the callback request completes.
   *
   * @generated from field: int32 attempt = 5;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 6;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 7;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 8;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 9;
   */
  blockedReason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.
 * Use `create(CallbackInfoSchema)` to create a new message.
 */
export const CallbackInfoSchema: GenMessage<CallbackInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12);

/**
 * Trigger for when the workflow is closed.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo.WorkflowClosed
 */
export type CallbackInfo_WorkflowClosed = Message<"temporal.api.workflow.v1.CallbackInfo.WorkflowClosed"> & {
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.WorkflowClosed.
 * Use `create(CallbackInfo_WorkflowClosedSchema)` to create a new message.
 */
export const CallbackInfo_WorkflowClosedSchema: GenMessage<CallbackInfo_WorkflowClosed> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12, 0);

/**
 * @generated from message temporal.api.workflow.v1.CallbackInfo.Trigger
 */
export type CallbackInfo_Trigger = Message<"temporal.api.workflow.v1.CallbackInfo.Trigger"> & {
  /**
   * @generated from oneof temporal.api.workflow.v1.CallbackInfo.Trigger.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.CallbackInfo.WorkflowClosed workflow_closed = 1;
     */
    value: CallbackInfo_WorkflowClosed;
    case: "workflowClosed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.CallbackInfo.Trigger.
 * Use `create(CallbackInfo_TriggerSchema)` to create a new message.
 */
export const CallbackInfo_TriggerSchema: GenMessage<CallbackInfo_Trigger> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 12, 1);

/**
 * PendingNexusOperationInfo contains the state of a pending Nexus operation.
 *
 * @generated from message temporal.api.workflow.v1.PendingNexusOperationInfo
 */
export type PendingNexusOperationInfo = Message<"temporal.api.workflow.v1.PendingNexusOperationInfo"> & {
  /**
   * Endpoint name.
   * Resolved to a URL via the cluster's endpoint registry.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service: string;

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation: string;

  /**
   * Operation ID. Only set for asynchronous operations after a successful StartOperation call.
   *
   * Deprecated. Renamed to operation_token.
   *
   * @generated from field: string operation_id = 4 [deprecated = true];
   * @deprecated
   */
  operationId: string;

  /**
   * Schedule-to-close timeout for this operation.
   * This is the only timeout settable by a workflow.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * The time when the operation was scheduled.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 6;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.PendingNexusOperationState state = 7;
   */
  state: PendingNexusOperationState;

  /**
   * The number of attempts made to deliver the start operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 8;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 9;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 10;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 11;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * @generated from field: temporal.api.workflow.v1.NexusOperationCancellationInfo cancellation_info = 12;
   */
  cancellationInfo?: NexusOperationCancellationInfo;

  /**
   * The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
   * DescribeWorkflowExecution response with workflow history.
   *
   * @generated from field: int64 scheduled_event_id = 13;
   */
  scheduledEventId: bigint;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 14;
   */
  blockedReason: string;

  /**
   * Operation token. Only set for asynchronous operations after a successful StartOperation call.
   *
   * @generated from field: string operation_token = 15;
   */
  operationToken: string;
};

/**
 * Describes the message temporal.api.workflow.v1.PendingNexusOperationInfo.
 * Use `create(PendingNexusOperationInfoSchema)` to create a new message.
 */
export const PendingNexusOperationInfoSchema: GenMessage<PendingNexusOperationInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 13);

/**
 * NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
 *
 * @generated from message temporal.api.workflow.v1.NexusOperationCancellationInfo
 */
export type NexusOperationCancellationInfo = Message<"temporal.api.workflow.v1.NexusOperationCancellationInfo"> & {
  /**
   * The time when cancellation was requested.
   *
   * @generated from field: google.protobuf.Timestamp requested_time = 1;
   */
  requestedTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.NexusOperationCancellationState state = 2;
   */
  state: NexusOperationCancellationState;

  /**
   * The number of attempts made to deliver the cancel operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 3;
   */
  attempt: number;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 4;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 5;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 6;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 7;
   */
  blockedReason: string;
};

/**
 * Describes the message temporal.api.workflow.v1.NexusOperationCancellationInfo.
 * Use `create(NexusOperationCancellationInfoSchema)` to create a new message.
 */
export const NexusOperationCancellationInfoSchema: GenMessage<NexusOperationCancellationInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 14);

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionOptions
 */
export type WorkflowExecutionOptions = Message<"temporal.api.workflow.v1.WorkflowExecutionOptions"> & {
  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 1;
   */
  versioningOverride?: VersioningOverride;
};

/**
 * Describes the message temporal.api.workflow.v1.WorkflowExecutionOptions.
 * Use `create(WorkflowExecutionOptionsSchema)` to create a new message.
 */
export const WorkflowExecutionOptionsSchema: GenMessage<WorkflowExecutionOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 15);

/**
 * Used to override the versioning behavior (and pinned deployment version, if applicable) of a
 * specific workflow execution. If set, takes precedence over the worker-sent values. See
 * `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call
 * `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`
 * to indicate that it should be mutated.
 * Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
 * workflow retries, and cron workflows.
 *
 * @generated from message temporal.api.workflow.v1.VersioningOverride
 */
export type VersioningOverride = Message<"temporal.api.workflow.v1.VersioningOverride"> & {
  /**
   * Indicates whether to override the workflow to be AutoUpgrade or Pinned.
   *
   * @generated from oneof temporal.api.workflow.v1.VersioningOverride.override
   */
  override: {
    /**
     * Send the next workflow task to the Version specified in the override.
     *
     * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverride pinned = 3;
     */
    value: VersioningOverride_PinnedOverride;
    case: "pinned";
  } | {
    /**
     * Send the next workflow task to the Current Deployment Version
     * of its Task Queue when the next workflow task is dispatched.
     *
     * @generated from field: bool auto_upgrade = 4;
     */
    value: boolean;
    case: "autoUpgrade";
  } | { case: undefined; value?: undefined };

  /**
   * Required.
   * Deprecated. Use `override`.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1 [deprecated = true];
   * @deprecated
   */
  behavior: VersioningBehavior;

  /**
   * Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
   * Identifies the worker deployment to pin the workflow to.
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
   * Identifies the worker deployment version to pin the workflow to, in the format
   * "<deployment_name>.<build_id>".
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: string pinned_version = 9 [deprecated = true];
   * @deprecated
   */
  pinnedVersion: string;
};

/**
 * Describes the message temporal.api.workflow.v1.VersioningOverride.
 * Use `create(VersioningOverrideSchema)` to create a new message.
 */
export const VersioningOverrideSchema: GenMessage<VersioningOverride> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 16);

/**
 * @generated from message temporal.api.workflow.v1.VersioningOverride.PinnedOverride
 */
export type VersioningOverride_PinnedOverride = Message<"temporal.api.workflow.v1.VersioningOverride.PinnedOverride"> & {
  /**
   * Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
   * See `PinnedOverrideBehavior` for details.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior behavior = 1;
   */
  behavior: VersioningOverride_PinnedOverrideBehavior;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion version = 2;
   */
  version?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.workflow.v1.VersioningOverride.PinnedOverride.
 * Use `create(VersioningOverride_PinnedOverrideSchema)` to create a new message.
 */
export const VersioningOverride_PinnedOverrideSchema: GenMessage<VersioningOverride_PinnedOverride> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 16, 0);

/**
 * Used to specify different sub-types of Pinned override that we plan to add in the future.
 *
 * @generated from enum temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior
 */
export enum VersioningOverride_PinnedOverrideBehavior {
  /**
   * Unspecified.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Override workflow behavior to be Pinned.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,
}

/**
 * Describes the enum temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior.
 */
export const VersioningOverride_PinnedOverrideBehaviorSchema: GenEnum<VersioningOverride_PinnedOverrideBehavior> = /*@__PURE__*/
  enumDesc(file_temporal_api_workflow_v1_message, 16, 0);

/**
 * When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
 * there is already an existing running workflow, OnConflictOptions defines actions to be taken on
 * the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
 * history event in the running workflow with the changes requested in this object.
 *
 * @generated from message temporal.api.workflow.v1.OnConflictOptions
 */
export type OnConflictOptions = Message<"temporal.api.workflow.v1.OnConflictOptions"> & {
  /**
   * Attaches the request ID to the running workflow.
   *
   * @generated from field: bool attach_request_id = 1;
   */
  attachRequestId: boolean;

  /**
   * Attaches the completion callbacks to the running workflow.
   *
   * @generated from field: bool attach_completion_callbacks = 2;
   */
  attachCompletionCallbacks: boolean;

  /**
   * Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
   *
   * @generated from field: bool attach_links = 3;
   */
  attachLinks: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.OnConflictOptions.
 * Use `create(OnConflictOptionsSchema)` to create a new message.
 */
export const OnConflictOptionsSchema: GenMessage<OnConflictOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 17);

/**
 * RequestIdInfo contains details of a request ID.
 *
 * @generated from message temporal.api.workflow.v1.RequestIdInfo
 */
export type RequestIdInfo = Message<"temporal.api.workflow.v1.RequestIdInfo"> & {
  /**
   * The event type of the history event generated by the request.
   *
   * @generated from field: temporal.api.enums.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * The event id of the history event generated by the request. It's possible the event ID is not
   * known (unflushed buffered event). In this case, the value will be zero or a negative value,
   * representing an invalid ID.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId: bigint;

  /**
   * Indicate if the request is still buffered. If so, the event ID is not known and its value
   * will be an invalid event ID.
   *
   * @generated from field: bool buffered = 3;
   */
  buffered: boolean;
};

/**
 * Describes the message temporal.api.workflow.v1.RequestIdInfo.
 * Use `create(RequestIdInfoSchema)` to create a new message.
 */
export const RequestIdInfoSchema: GenMessage<RequestIdInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 18);

/**
 * PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation
 */
export type PostResetOperation = Message<"temporal.api.workflow.v1.PostResetOperation"> & {
  /**
   * @generated from oneof temporal.api.workflow.v1.PostResetOperation.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow signal_workflow = 1;
     */
    value: PostResetOperation_SignalWorkflow;
    case: "signalWorkflow";
  } | {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions update_workflow_options = 2;
     */
    value: PostResetOperation_UpdateWorkflowOptions;
    case: "updateWorkflowOptions";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.
 * Use `create(PostResetOperationSchema)` to create a new message.
 */
export const PostResetOperationSchema: GenMessage<PostResetOperation> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19);

/**
 * SignalWorkflow represents sending a signal after a workflow reset.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.SignalWorkflow
 */
export type PostResetOperation_SignalWorkflow = Message<"temporal.api.workflow.v1.PostResetOperation.SignalWorkflow"> & {
  /**
   * The workflow author-defined name of the signal to send to the workflow.
   *
   * @generated from field: string signal_name = 1;
   */
  signalName: string;

  /**
   * Serialized value(s) to provide with the signal.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads;

  /**
   * Headers that are passed with the signal to the processing workflow.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  /**
   * Links to be associated with the WorkflowExecutionSignaled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 4;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
 * Use `create(PostResetOperation_SignalWorkflowSchema)` to create a new message.
 */
export const PostResetOperation_SignalWorkflowSchema: GenMessage<PostResetOperation_SignalWorkflow> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19, 0);

/**
 * UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
 * Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions
 */
export type PostResetOperation_UpdateWorkflowOptions = Message<"temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions"> & {
  /**
   * Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 1;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
 * Use `create(PostResetOperation_UpdateWorkflowOptionsSchema)` to create a new message.
 */
export const PostResetOperation_UpdateWorkflowOptionsSchema: GenMessage<PostResetOperation_UpdateWorkflowOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflow_v1_message, 19, 1);

