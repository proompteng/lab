// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/common/v1/message.proto (package temporal.api.common.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Empty } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { EncodingType } from "../../enums/v1/common_pb.js";
import { file_temporal_api_enums_v1_common } from "../../enums/v1/common_pb.js";
import type { EventType } from "../../enums/v1/event_type_pb.js";
import { file_temporal_api_enums_v1_event_type } from "../../enums/v1/event_type_pb.js";
import type { ResetReapplyExcludeType, ResetReapplyType } from "../../enums/v1/reset_pb.js";
import { file_temporal_api_enums_v1_reset } from "../../enums/v1/reset_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/common/v1/message.proto.
 */
export const file_temporal_api_common_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiR0ZW1wb3JhbC9hcGkvY29tbW9uL3YxL21lc3NhZ2UucHJvdG8SFnRlbXBvcmFsLmFwaS5jb21tb24udjEiVAoIRGF0YUJsb2ISOgoNZW5jb2RpbmdfdHlwZRgBIAEoDjIjLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5FbmNvZGluZ1R5cGUSDAoEZGF0YRgCIAEoDCI9CghQYXlsb2FkcxIxCghwYXlsb2FkcxgBIAMoCzIfLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZCKJAQoHUGF5bG9hZBI/CghtZXRhZGF0YRgBIAMoCzItLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZC5NZXRhZGF0YUVudHJ5EgwKBGRhdGEYAiABKAwaLwoNTWV0YWRhdGFFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAw6AjgBIr4BChBTZWFyY2hBdHRyaWJ1dGVzElMKDmluZGV4ZWRfZmllbGRzGAEgAygLMjsudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzLkluZGV4ZWRGaWVsZHNFbnRyeRpVChJJbmRleGVkRmllbGRzRW50cnkSCwoDa2V5GAEgASgJEi4KBXZhbHVlGAIgASgLMh8udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkOgI4ASKQAQoETWVtbxI4CgZmaWVsZHMYASADKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8uRmllbGRzRW50cnkaTgoLRmllbGRzRW50cnkSCwoDa2V5GAEgASgJEi4KBXZhbHVlGAIgASgLMh8udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkOgI4ASKUAQoGSGVhZGVyEjoKBmZpZWxkcxgBIAMoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuSGVhZGVyLkZpZWxkc0VudHJ5Gk4KC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIuCgV2YWx1ZRgCIAEoCzIfLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZDoCOAEiOAoRV29ya2Zsb3dFeGVjdXRpb24SEwoLd29ya2Zsb3dfaWQYASABKAkSDgoGcnVuX2lkGAIgASgJIhwKDFdvcmtmbG93VHlwZRIMCgRuYW1lGAEgASgJIhwKDEFjdGl2aXR5VHlwZRIMCgRuYW1lGAEgASgJItEBCgtSZXRyeVBvbGljeRIzChBpbml0aWFsX2ludGVydmFsGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEhsKE2JhY2tvZmZfY29lZmZpY2llbnQYAiABKAESMwoQbWF4aW11bV9pbnRlcnZhbBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIYChBtYXhpbXVtX2F0dGVtcHRzGAQgASgFEiEKGW5vbl9yZXRyeWFibGVfZXJyb3JfdHlwZXMYBSADKAkiRgoQTWV0ZXJpbmdNZXRhZGF0YRIyCipub25maXJzdF9sb2NhbF9hY3Rpdml0eV9leGVjdXRpb25fYXR0ZW1wdHMYDSABKA0iPgoSV29ya2VyVmVyc2lvblN0YW1wEhAKCGJ1aWxkX2lkGAEgASgJEhYKDnVzZV92ZXJzaW9uaW5nGAMgASgIImUKGVdvcmtlclZlcnNpb25DYXBhYmlsaXRpZXMSEAoIYnVpbGRfaWQYASABKAkSFgoOdXNlX3ZlcnNpb25pbmcYAiABKAgSHgoWZGVwbG95bWVudF9zZXJpZXNfbmFtZRgEIAEoCSLtAgoMUmVzZXRPcHRpb25zEjUKE2ZpcnN0X3dvcmtmbG93X3Rhc2sYASABKAsyFi5nb29nbGUucHJvdG9idWYuRW1wdHlIABI0ChJsYXN0X3dvcmtmbG93X3Rhc2sYAiABKAsyFi5nb29nbGUucHJvdG9idWYuRW1wdHlIABIaChB3b3JrZmxvd190YXNrX2lkGAMgASgDSAASEgoIYnVpbGRfaWQYBCABKAlIABJHChJyZXNldF9yZWFwcGx5X3R5cGUYCiABKA4yJy50ZW1wb3JhbC5hcGkuZW51bXMudjEuUmVzZXRSZWFwcGx5VHlwZUICGAESGAoQY3VycmVudF9ydW5fb25seRgLIAEoCBJTChtyZXNldF9yZWFwcGx5X2V4Y2x1ZGVfdHlwZXMYDCADKA4yLi50ZW1wb3JhbC5hcGkuZW51bXMudjEuUmVzZXRSZWFwcGx5RXhjbHVkZVR5cGVCCAoGdGFyZ2V0IuQCCghDYWxsYmFjaxI3CgVuZXh1cxgCIAEoCzImLnRlbXBvcmFsLmFwaS5jb21tb24udjEuQ2FsbGJhY2suTmV4dXNIABI9CghpbnRlcm5hbBgDIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuQ2FsbGJhY2suSW50ZXJuYWxIABIrCgVsaW5rcxhkIAMoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTGluaxqHAQoFTmV4dXMSCwoDdXJsGAEgASgJEkIKBmhlYWRlchgCIAMoCzIyLnRlbXBvcmFsLmFwaS5jb21tb24udjEuQ2FsbGJhY2suTmV4dXMuSGVhZGVyRW50cnkaLQoLSGVhZGVyRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARoYCghJbnRlcm5hbBIMCgRkYXRhGAEgASgMQgkKB3ZhcmlhbnRKBAgBEAIi6QQKBExpbmsSRAoOd29ya2Zsb3dfZXZlbnQYASABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsuV29ya2Zsb3dFdmVudEgAEjoKCWJhdGNoX2pvYhgCIAEoCzIlLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTGluay5CYXRjaEpvYkgAGrcDCg1Xb3JrZmxvd0V2ZW50EhEKCW5hbWVzcGFjZRgBIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRIOCgZydW5faWQYAyABKAkSTgoJZXZlbnRfcmVmGGQgASgLMjkudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5MaW5rLldvcmtmbG93RXZlbnQuRXZlbnRSZWZlcmVuY2VIABJXCg5yZXF1ZXN0X2lkX3JlZhhlIAEoCzI9LnRlbXBvcmFsLmFwaS5jb21tb24udjEuTGluay5Xb3JrZmxvd0V2ZW50LlJlcXVlc3RJZFJlZmVyZW5jZUgAGlgKDkV2ZW50UmVmZXJlbmNlEhAKCGV2ZW50X2lkGAEgASgDEjQKCmV2ZW50X3R5cGUYAiABKA4yIC50ZW1wb3JhbC5hcGkuZW51bXMudjEuRXZlbnRUeXBlGl4KElJlcXVlc3RJZFJlZmVyZW5jZRISCgpyZXF1ZXN0X2lkGAEgASgJEjQKCmV2ZW50X3R5cGUYAiABKA4yIC50ZW1wb3JhbC5hcGkuZW51bXMudjEuRXZlbnRUeXBlQgsKCXJlZmVyZW5jZRoaCghCYXRjaEpvYhIOCgZqb2JfaWQYASABKAlCCQoHdmFyaWFudCJPCghQcmlvcml0eRIUCgxwcmlvcml0eV9rZXkYASABKAUSFAoMZmFpcm5lc3Nfa2V5GAIgASgJEhcKD2ZhaXJuZXNzX3dlaWdodBgDIAEoAiI7Cg5Xb3JrZXJTZWxlY3RvchIdChN3b3JrZXJfaW5zdGFuY2Vfa2V5GAEgASgJSABCCgoIc2VsZWN0b3JCiQEKGWlvLnRlbXBvcmFsLmFwaS5jb21tb24udjFCDE1lc3NhZ2VQcm90b1ABWiNnby50ZW1wb3JhbC5pby9hcGkvY29tbW9uL3YxO2NvbW1vbqoCGFRlbXBvcmFsaW8uQXBpLkNvbW1vbi5WMeoCG1RlbXBvcmFsaW86OkFwaTo6Q29tbW9uOjpWMWIGcHJvdG8z", [file_google_protobuf_duration, file_google_protobuf_empty, file_temporal_api_enums_v1_common, file_temporal_api_enums_v1_event_type, file_temporal_api_enums_v1_reset]);

/**
 * @generated from message temporal.api.common.v1.DataBlob
 */
export type DataBlob = Message<"temporal.api.common.v1.DataBlob"> & {
  /**
   * @generated from field: temporal.api.enums.v1.EncodingType encoding_type = 1;
   */
  encodingType: EncodingType;

  /**
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message temporal.api.common.v1.DataBlob.
 * Use `create(DataBlobSchema)` to create a new message.
 */
export const DataBlobSchema: GenMessage<DataBlob> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 0);

/**
 * See `Payload`
 *
 * @generated from message temporal.api.common.v1.Payloads
 */
export type Payloads = Message<"temporal.api.common.v1.Payloads"> & {
  /**
   * @generated from field: repeated temporal.api.common.v1.Payload payloads = 1;
   */
  payloads: Payload[];
};

/**
 * Describes the message temporal.api.common.v1.Payloads.
 * Use `create(PayloadsSchema)` to create a new message.
 */
export const PayloadsSchema: GenMessage<Payloads> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 1);

/**
 * Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
 * metadata which describes this binary data (format, encoding, encryption, etc). Serialization
 * of the data may be user-defined.
 *
 * @generated from message temporal.api.common.v1.Payload
 */
export type Payload = Message<"temporal.api.common.v1.Payload"> & {
  /**
   * @generated from field: map<string, bytes> metadata = 1;
   */
  metadata: { [key: string]: Uint8Array };

  /**
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message temporal.api.common.v1.Payload.
 * Use `create(PayloadSchema)` to create a new message.
 */
export const PayloadSchema: GenMessage<Payload> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 2);

/**
 * A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
 * The payload is not serialized in a user-defined way.
 *
 * @generated from message temporal.api.common.v1.SearchAttributes
 */
export type SearchAttributes = Message<"temporal.api.common.v1.SearchAttributes"> & {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> indexed_fields = 1;
   */
  indexedFields: { [key: string]: Payload };
};

/**
 * Describes the message temporal.api.common.v1.SearchAttributes.
 * Use `create(SearchAttributesSchema)` to create a new message.
 */
export const SearchAttributesSchema: GenMessage<SearchAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 3);

/**
 * A user-defined set of *unindexed* fields that are exposed when listing/searching workflows
 *
 * @generated from message temporal.api.common.v1.Memo
 */
export type Memo = Message<"temporal.api.common.v1.Memo"> & {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> fields = 1;
   */
  fields: { [key: string]: Payload };
};

/**
 * Describes the message temporal.api.common.v1.Memo.
 * Use `create(MemoSchema)` to create a new message.
 */
export const MemoSchema: GenMessage<Memo> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 4);

/**
 * Contains metadata that can be attached to a variety of requests, like starting a workflow, and
 * can be propagated between, for example, workflows and activities.
 *
 * @generated from message temporal.api.common.v1.Header
 */
export type Header = Message<"temporal.api.common.v1.Header"> & {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> fields = 1;
   */
  fields: { [key: string]: Payload };
};

/**
 * Describes the message temporal.api.common.v1.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export const HeaderSchema: GenMessage<Header> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 5);

/**
 * Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
 * uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
 * run id as a way of saying "target the latest run of the workflow".
 *
 * @generated from message temporal.api.common.v1.WorkflowExecution
 */
export type WorkflowExecution = Message<"temporal.api.common.v1.WorkflowExecution"> & {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * @generated from field: string run_id = 2;
   */
  runId: string;
};

/**
 * Describes the message temporal.api.common.v1.WorkflowExecution.
 * Use `create(WorkflowExecutionSchema)` to create a new message.
 */
export const WorkflowExecutionSchema: GenMessage<WorkflowExecution> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 6);

/**
 * Represents the identifier used by a workflow author to define the workflow. Typically, the
 * name of a function. This is sometimes referred to as the workflow's "name"
 *
 * @generated from message temporal.api.common.v1.WorkflowType
 */
export type WorkflowType = Message<"temporal.api.common.v1.WorkflowType"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message temporal.api.common.v1.WorkflowType.
 * Use `create(WorkflowTypeSchema)` to create a new message.
 */
export const WorkflowTypeSchema: GenMessage<WorkflowType> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 7);

/**
 * Represents the identifier used by a activity author to define the activity. Typically, the
 * name of a function. This is sometimes referred to as the activity's "name"
 *
 * @generated from message temporal.api.common.v1.ActivityType
 */
export type ActivityType = Message<"temporal.api.common.v1.ActivityType"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message temporal.api.common.v1.ActivityType.
 * Use `create(ActivityTypeSchema)` to create a new message.
 */
export const ActivityTypeSchema: GenMessage<ActivityType> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 8);

/**
 * How retries ought to be handled, usable by both workflows and activities
 *
 * @generated from message temporal.api.common.v1.RetryPolicy
 */
export type RetryPolicy = Message<"temporal.api.common.v1.RetryPolicy"> & {
  /**
   * Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries.
   *
   * @generated from field: google.protobuf.Duration initial_interval = 1;
   */
  initialInterval?: Duration;

  /**
   * Coefficient used to calculate the next retry interval.
   * The next retry interval is previous interval multiplied by the coefficient.
   * Must be 1 or larger.
   *
   * @generated from field: double backoff_coefficient = 2;
   */
  backoffCoefficient: number;

  /**
   * Maximum interval between retries. Exponential backoff leads to interval increase.
   * This value is the cap of the increase. Default is 100x of the initial interval.
   *
   * @generated from field: google.protobuf.Duration maximum_interval = 3;
   */
  maximumInterval?: Duration;

  /**
   * Maximum number of attempts. When exceeded the retries stop even if not expired yet.
   * 1 disables retries. 0 means unlimited (up to the timeouts)
   *
   * @generated from field: int32 maximum_attempts = 4;
   */
  maximumAttempts: number;

  /**
   * Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
   * this is not a substring match, the error *type* (not message) must match exactly.
   *
   * @generated from field: repeated string non_retryable_error_types = 5;
   */
  nonRetryableErrorTypes: string[];
};

/**
 * Describes the message temporal.api.common.v1.RetryPolicy.
 * Use `create(RetryPolicySchema)` to create a new message.
 */
export const RetryPolicySchema: GenMessage<RetryPolicy> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 9);

/**
 * Metadata relevant for metering purposes
 *
 * @generated from message temporal.api.common.v1.MeteringMetadata
 */
export type MeteringMetadata = Message<"temporal.api.common.v1.MeteringMetadata"> & {
  /**
   * Count of local activities which have begun an execution attempt during this workflow task,
   * and whose first attempt occurred in some previous task. This is used for metering
   * purposes, and does not affect workflow state.
   *
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: Negative values make no sense to represent. --)
   *
   * @generated from field: uint32 nonfirst_local_activity_execution_attempts = 13;
   */
  nonfirstLocalActivityExecutionAttempts: number;
};

/**
 * Describes the message temporal.api.common.v1.MeteringMetadata.
 * Use `create(MeteringMetadataSchema)` to create a new message.
 */
export const MeteringMetadataSchema: GenMessage<MeteringMetadata> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 10);

/**
 * Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
 * Identifies the version(s) of a worker that processed a task
 *
 * @generated from message temporal.api.common.v1.WorkerVersionStamp
 */
export type WorkerVersionStamp = Message<"temporal.api.common.v1.WorkerVersionStamp"> & {
  /**
   * An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
   * message is included in requests which previously used that.
   *
   * @generated from field: string build_id = 1;
   */
  buildId: string;

  /**
   * If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
   * marker for workflow reset points and the BuildIDs search attribute.
   *
   * @generated from field: bool use_versioning = 3;
   */
  useVersioning: boolean;
};

/**
 * Describes the message temporal.api.common.v1.WorkerVersionStamp.
 * Use `create(WorkerVersionStampSchema)` to create a new message.
 */
export const WorkerVersionStampSchema: GenMessage<WorkerVersionStamp> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 11);

/**
 * Identifies the version that a worker is compatible with when polling or identifying itself,
 * and whether or not this worker is opting into the build-id based versioning feature. This is
 * used by matching to determine which workers ought to receive what tasks.
 * Deprecated. Use WorkerDeploymentOptions instead.
 *
 * @generated from message temporal.api.common.v1.WorkerVersionCapabilities
 */
export type WorkerVersionCapabilities = Message<"temporal.api.common.v1.WorkerVersionCapabilities"> & {
  /**
   * An opaque whole-worker identifier
   *
   * @generated from field: string build_id = 1;
   */
  buildId: string;

  /**
   * If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
   * tasks.
   *
   * @generated from field: bool use_versioning = 2;
   */
  useVersioning: boolean;

  /**
   * Must be sent if user has set a deployment series name (versioning-3).
   *
   * @generated from field: string deployment_series_name = 4;
   */
  deploymentSeriesName: string;
};

/**
 * Describes the message temporal.api.common.v1.WorkerVersionCapabilities.
 * Use `create(WorkerVersionCapabilitiesSchema)` to create a new message.
 */
export const WorkerVersionCapabilitiesSchema: GenMessage<WorkerVersionCapabilities> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 12);

/**
 * Describes where and how to reset a workflow, used for batch reset currently
 * and may be used for single-workflow reset later.
 *
 * @generated from message temporal.api.common.v1.ResetOptions
 */
export type ResetOptions = Message<"temporal.api.common.v1.ResetOptions"> & {
  /**
   * Which workflow task to reset to.
   *
   * @generated from oneof temporal.api.common.v1.ResetOptions.target
   */
  target: {
    /**
     * Resets to the first workflow task completed or started event.
     *
     * @generated from field: google.protobuf.Empty first_workflow_task = 1;
     */
    value: Empty;
    case: "firstWorkflowTask";
  } | {
    /**
     * Resets to the last workflow task completed or started event.
     *
     * @generated from field: google.protobuf.Empty last_workflow_task = 2;
     */
    value: Empty;
    case: "lastWorkflowTask";
  } | {
    /**
     * The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
     * `WORKFLOW_TASK_STARTED` event to reset to.
     * Note that this option doesn't make sense when used as part of a batch request.
     *
     * @generated from field: int64 workflow_task_id = 3;
     */
    value: bigint;
    case: "workflowTaskId";
  } | {
    /**
     * Resets to the first workflow task processed by this build id.
     * If the workflow was not processed by the build id, or the workflow task can't be
     * determined, no reset will be performed.
     * Note that by default, this reset is allowed to be to a prior run in a chain of
     * continue-as-new.
     *
     * @generated from field: string build_id = 4;
     */
    value: string;
    case: "buildId";
  } | { case: undefined; value?: undefined };

  /**
   * Deprecated. Use `options`.
   * Default: RESET_REAPPLY_TYPE_SIGNAL
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 10 [deprecated = true];
   * @deprecated
   */
  resetReapplyType: ResetReapplyType;

  /**
   * If true, limit the reset to only within the current run. (Applies to build_id targets and
   * possibly others in the future.)
   *
   * @generated from field: bool current_run_only = 11;
   */
  currentRunOnly: boolean;

  /**
   * Event types not to be reapplied
   *
   * @generated from field: repeated temporal.api.enums.v1.ResetReapplyExcludeType reset_reapply_exclude_types = 12;
   */
  resetReapplyExcludeTypes: ResetReapplyExcludeType[];
};

/**
 * Describes the message temporal.api.common.v1.ResetOptions.
 * Use `create(ResetOptionsSchema)` to create a new message.
 */
export const ResetOptionsSchema: GenMessage<ResetOptions> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 13);

/**
 * Callback to attach to various events in the system, e.g. workflow run completion.
 *
 * @generated from message temporal.api.common.v1.Callback
 */
export type Callback = Message<"temporal.api.common.v1.Callback"> & {
  /**
   * @generated from oneof temporal.api.common.v1.Callback.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.common.v1.Callback.Nexus nexus = 2;
     */
    value: Callback_Nexus;
    case: "nexus";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Callback.Internal internal = 3;
     */
    value: Callback_Internal;
    case: "internal";
  } | { case: undefined; value?: undefined };

  /**
   * Links associated with the callback. It can be used to link to underlying resources of the
   * callback.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 100;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.common.v1.Callback.
 * Use `create(CallbackSchema)` to create a new message.
 */
export const CallbackSchema: GenMessage<Callback> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 14);

/**
 * @generated from message temporal.api.common.v1.Callback.Nexus
 */
export type Callback_Nexus = Message<"temporal.api.common.v1.Callback.Nexus"> & {
  /**
   * Callback URL.
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * Header to attach to callback request.
   *
   * @generated from field: map<string, string> header = 2;
   */
  header: { [key: string]: string };
};

/**
 * Describes the message temporal.api.common.v1.Callback.Nexus.
 * Use `create(Callback_NexusSchema)` to create a new message.
 */
export const Callback_NexusSchema: GenMessage<Callback_Nexus> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 14, 0);

/**
 * Callbacks to be delivered internally within the system.
 * This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
 * The only reason that this is exposed is because callbacks are replicated across clusters via the
 * WorkflowExecutionStarted event, which is defined in the public API.
 *
 * @generated from message temporal.api.common.v1.Callback.Internal
 */
export type Callback_Internal = Message<"temporal.api.common.v1.Callback.Internal"> & {
  /**
   * Opaque internal data.
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;
};

/**
 * Describes the message temporal.api.common.v1.Callback.Internal.
 * Use `create(Callback_InternalSchema)` to create a new message.
 */
export const Callback_InternalSchema: GenMessage<Callback_Internal> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 14, 1);

/**
 * Link can be associated with history events. It might contain information about an external entity
 * related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
 * in this case, a history event in workflow A could contain a Link to the workflow started event in
 * workflow B, and vice-versa.
 *
 * @generated from message temporal.api.common.v1.Link
 */
export type Link = Message<"temporal.api.common.v1.Link"> & {
  /**
   * @generated from oneof temporal.api.common.v1.Link.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent workflow_event = 1;
     */
    value: Link_WorkflowEvent;
    case: "workflowEvent";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Link.BatchJob batch_job = 2;
     */
    value: Link_BatchJob;
    case: "batchJob";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.common.v1.Link.
 * Use `create(LinkSchema)` to create a new message.
 */
export const LinkSchema: GenMessage<Link> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 15);

/**
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent
 */
export type Link_WorkflowEvent = Message<"temporal.api.common.v1.Link.WorkflowEvent"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Additional information about the workflow event.
   * Eg: the caller workflow can send the history event details that made the Nexus call.
   *
   * @generated from oneof temporal.api.common.v1.Link.WorkflowEvent.reference
   */
  reference: {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent.EventReference event_ref = 100;
     */
    value: Link_WorkflowEvent_EventReference;
    case: "eventRef";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference request_id_ref = 101;
     */
    value: Link_WorkflowEvent_RequestIdReference;
    case: "requestIdRef";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.common.v1.Link.WorkflowEvent.
 * Use `create(Link_WorkflowEventSchema)` to create a new message.
 */
export const Link_WorkflowEventSchema: GenMessage<Link_WorkflowEvent> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 15, 0);

/**
 * EventReference is a direct reference to a history event through the event ID.
 *
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent.EventReference
 */
export type Link_WorkflowEvent_EventReference = Message<"temporal.api.common.v1.Link.WorkflowEvent.EventReference"> & {
  /**
   * @generated from field: int64 event_id = 1;
   */
  eventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.EventType event_type = 2;
   */
  eventType: EventType;
};

/**
 * Describes the message temporal.api.common.v1.Link.WorkflowEvent.EventReference.
 * Use `create(Link_WorkflowEvent_EventReferenceSchema)` to create a new message.
 */
export const Link_WorkflowEvent_EventReferenceSchema: GenMessage<Link_WorkflowEvent_EventReference> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 15, 0, 0);

/**
 * RequestIdReference is a indirect reference to a history event through the request ID.
 *
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference
 */
export type Link_WorkflowEvent_RequestIdReference = Message<"temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference"> & {
  /**
   * @generated from field: string request_id = 1;
   */
  requestId: string;

  /**
   * @generated from field: temporal.api.enums.v1.EventType event_type = 2;
   */
  eventType: EventType;
};

/**
 * Describes the message temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference.
 * Use `create(Link_WorkflowEvent_RequestIdReferenceSchema)` to create a new message.
 */
export const Link_WorkflowEvent_RequestIdReferenceSchema: GenMessage<Link_WorkflowEvent_RequestIdReference> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 15, 0, 1);

/**
 * A link to a built-in batch job.
 * Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
 * This link can be put on workflow history events generated by actions taken by a batch job.
 *
 * @generated from message temporal.api.common.v1.Link.BatchJob
 */
export type Link_BatchJob = Message<"temporal.api.common.v1.Link.BatchJob"> & {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Describes the message temporal.api.common.v1.Link.BatchJob.
 * Use `create(Link_BatchJobSchema)` to create a new message.
 */
export const Link_BatchJobSchema: GenMessage<Link_BatchJob> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 15, 1);

/**
 * Priority contains metadata that controls relative ordering of task processing
 * when tasks are backed up in a queue. Initially, Priority will be used in
 * matching (workflow and activity) task queues. Later it may be used in history
 * task queues and in rate limiting decisions.
 *
 * Priority is attached to workflows and activities. By default, activities
 * inherit Priority from the workflow that created them, but may override fields
 * when an activity is started or modified.
 *
 * Despite being named "Priority", this message also contains fields that
 * control "fairness" mechanisms.
 *
 * For all fields, the field not present or equal to zero/empty string means to
 * inherit the value from the calling workflow, or if there is no calling
 * workflow, then use the default value.
 *
 * For all fields other than fairness_key, the zero value isn't meaningful so
 * there's no confusion between inherit/default and a meaningful value. For
 * fairness_key, the empty string will be interpreted as "inherit". This means
 * that if a workflow has a non-empty fairness key, you can't override the
 * fairness key of its activity to the empty string.
 *
 * The overall semantics of Priority are:
 * 1. First, consider "priority": higher priority (lower number) goes first.
 * 2. Then, consider fairness: try to dispatch tasks for different fairness keys
 *    in proportion to their weight.
 *
 * Applications may use any subset of mechanisms that are useful to them and
 * leave the other fields to use default values.
 *
 * Not all queues in the system may support the "full" semantics of all priority
 * fields. (Currently only support in matching task queues is planned.)
 *
 * @generated from message temporal.api.common.v1.Priority
 */
export type Priority = Message<"temporal.api.common.v1.Priority"> & {
  /**
   * Priority key is a positive integer from 1 to n, where smaller integers
   * correspond to higher priorities (tasks run sooner). In general, tasks in
   * a queue should be processed in close to priority order, although small
   * deviations are possible.
   *
   * The maximum priority value (minimum priority) is determined by server
   * configuration, and defaults to 5.
   *
   * If priority is not present (or zero), then the effective priority will be
   * the default priority, which is calculated by (min+max)/2. With the
   * default max of 5, and min of 1, that comes out to 3.
   *
   * @generated from field: int32 priority_key = 1;
   */
  priorityKey: number;

  /**
   * Fairness key is a short string that's used as a key for a fairness
   * balancing mechanism. It may correspond to a tenant id, or to a fixed
   * string like "high" or "low". The default is the empty string.
   *
   * The fairness mechanism attempts to dispatch tasks for a given key in
   * proportion to its weight. For example, using a thousand distinct tenant
   * ids, each with a weight of 1.0 (the default) will result in each tenant
   * getting a roughly equal share of task dispatch throughput.
   *
   * (Note: this does not imply equal share of worker capacity! Fairness
   * decisions are made based on queue statistics, not
   * current worker load.)
   *
   * As another example, using keys "high" and "low" with weight 9.0 and 1.0
   * respectively will prefer dispatching "high" tasks over "low" tasks at a
   * 9:1 ratio, while allowing either key to use all worker capacity if the
   * other is not present.
   *
   * All fairness mechanisms, including rate limits, are best-effort and
   * probabilistic. The results may not match what a "perfect" algorithm with
   * infinite resources would produce. The more unique keys are used, the less
   * accurate the results will be.
   *
   * Fairness keys are limited to 64 bytes.
   *
   * @generated from field: string fairness_key = 2;
   */
  fairnessKey: string;

  /**
   * Fairness weight for a task can come from multiple sources for
   * flexibility. From highest to lowest precedence:
   * 1. Weights for a small set of keys can be overridden in task queue
   *    configuration with an API.
   * 2. It can be attached to the workflow/activity in this field.
   * 3. The default weight of 1.0 will be used.
   *
   * Weight values are clamped to the range [0.001, 1000].
   *
   * @generated from field: float fairness_weight = 3;
   */
  fairnessWeight: number;
};

/**
 * Describes the message temporal.api.common.v1.Priority.
 * Use `create(PrioritySchema)` to create a new message.
 */
export const PrioritySchema: GenMessage<Priority> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 16);

/**
 * This is used to send commands to a specific worker or a group of workers.
 * Right now, it is used to send commands to a specific worker instance.
 * Will be extended to be able to send command to multiple workers.
 *
 * @generated from message temporal.api.common.v1.WorkerSelector
 */
export type WorkerSelector = Message<"temporal.api.common.v1.WorkerSelector"> & {
  /**
   * Options are:
   * - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
   * - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
   * - etc.
   *   All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
   * string query = 5;
   * string task_queue = 6;
   * ...
   *
   * @generated from oneof temporal.api.common.v1.WorkerSelector.selector
   */
  selector: {
    /**
     * Worker instance key to which the command should be sent.
     *
     * @generated from field: string worker_instance_key = 1;
     */
    value: string;
    case: "workerInstanceKey";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.common.v1.WorkerSelector.
 * Use `create(WorkerSelectorSchema)` to create a new message.
 */
export const WorkerSelectorSchema: GenMessage<WorkerSelector> = /*@__PURE__*/
  messageDesc(file_temporal_api_common_v1_message, 17);

