// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/command/v1/message.proto (package temporal.api.command.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf'
import { Duration, Message, proto3, protoInt64 } from '@bufbuild/protobuf'
import {
  ActivityType,
  Header,
  Memo,
  Payload,
  Payloads,
  Priority,
  RetryPolicy,
  SearchAttributes,
  WorkflowExecution,
  WorkflowType,
} from '../../common/v1/message_pbts'
import { TaskQueue } from '../../taskqueue/v1/message_pbts'
import { Failure } from '../../failure/v1/message_pbts'
import { ContinueAsNewInitiator, ParentClosePolicy, WorkflowIdReusePolicy } from '../../enums/v1/workflow_pbts'
import { CommandType } from '../../enums/v1/command_type_pbts'
import { UserMetadata } from '../../sdk/v1/user_metadata_pbts'

/**
 * @generated from message temporal.api.command.v1.ScheduleActivityTaskCommandAttributes
 */
export class ScheduleActivityTaskCommandAttributes extends Message<ScheduleActivityTaskCommandAttributes> {
  /**
   * @generated from field: string activity_id = 1;
   */
  activityId = ''

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue

  /**
   * @generated from field: temporal.api.common.v1.Header header = 5;
   */
  header?: Header

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 6;
   */
  input?: Payloads

  /**
   * Indicates how long the caller is willing to wait for activity completion. The "schedule" time
   * is when the activity is initially scheduled, not when the most recent retry is scheduled.
   * Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
   * specified. When not specified, defaults to the workflow execution timeout.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 7;
   */
  scheduleToCloseTimeout?: Duration

  /**
   * Limits the time an activity task can stay in a task queue before a worker picks it up. The
   * "schedule" time is when the most recent retry is scheduled. This timeout should usually not
   * be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
   * always non retryable, as all a retry would achieve is to put it back into the same queue.
   * Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
   * specified. More info:
   * https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 8;
   */
  scheduleToStartTimeout?: Duration

  /**
   * Maximum time an activity is allowed to execute after being picked up by a worker. This
   * timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 9;
   */
  startToCloseTimeout?: Duration

  /**
   * Maximum permitted time between successful worker heartbeats.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 10;
   */
  heartbeatTimeout?: Duration

  /**
   * Activities are provided by a default retry policy which is controlled through the service's
   * dynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has
   * elapsed. To disable retries set retry_policy.maximum_attempts to 1.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 11;
   */
  retryPolicy?: RetryPolicy

  /**
   * Request to start the activity directly bypassing matching service and worker polling
   * The slot for executing the activity should be reserved when setting this field to true.
   *
   * @generated from field: bool request_eager_execution = 12;
   */
  requestEagerExecution = false

  /**
   * If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
   * Assignment rules of the activity's Task Queue will be used to determine the Build ID.
   *
   * @generated from field: bool use_workflow_build_id = 13;
   */
  useWorkflowBuildId = false

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 14;
   */
  priority?: Priority

  constructor(data?: PartialMessage<ScheduleActivityTaskCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.ScheduleActivityTaskCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'activity_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'activity_type', kind: 'message', T: ActivityType },
    { no: 4, name: 'task_queue', kind: 'message', T: TaskQueue },
    { no: 5, name: 'header', kind: 'message', T: Header },
    { no: 6, name: 'input', kind: 'message', T: Payloads },
    { no: 7, name: 'schedule_to_close_timeout', kind: 'message', T: Duration },
    { no: 8, name: 'schedule_to_start_timeout', kind: 'message', T: Duration },
    { no: 9, name: 'start_to_close_timeout', kind: 'message', T: Duration },
    { no: 10, name: 'heartbeat_timeout', kind: 'message', T: Duration },
    { no: 11, name: 'retry_policy', kind: 'message', T: RetryPolicy },
    { no: 12, name: 'request_eager_execution', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: 'use_workflow_build_id', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: 'priority', kind: 'message', T: Priority },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleActivityTaskCommandAttributes {
    return new ScheduleActivityTaskCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleActivityTaskCommandAttributes {
    return new ScheduleActivityTaskCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleActivityTaskCommandAttributes {
    return new ScheduleActivityTaskCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: ScheduleActivityTaskCommandAttributes | PlainMessage<ScheduleActivityTaskCommandAttributes> | undefined,
    b: ScheduleActivityTaskCommandAttributes | PlainMessage<ScheduleActivityTaskCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(ScheduleActivityTaskCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes
 */
export class RequestCancelActivityTaskCommandAttributes extends Message<RequestCancelActivityTaskCommandAttributes> {
  /**
   * The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId = protoInt64.zero

  constructor(data?: PartialMessage<RequestCancelActivityTaskCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'scheduled_event_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): RequestCancelActivityTaskCommandAttributes {
    return new RequestCancelActivityTaskCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelActivityTaskCommandAttributes {
    return new RequestCancelActivityTaskCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelActivityTaskCommandAttributes {
    return new RequestCancelActivityTaskCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | RequestCancelActivityTaskCommandAttributes
      | PlainMessage<RequestCancelActivityTaskCommandAttributes>
      | undefined,
    b:
      | RequestCancelActivityTaskCommandAttributes
      | PlainMessage<RequestCancelActivityTaskCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(RequestCancelActivityTaskCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.StartTimerCommandAttributes
 */
export class StartTimerCommandAttributes extends Message<StartTimerCommandAttributes> {
  /**
   * An id for the timer, currently live timers must have different ids. Typically autogenerated
   * by the SDK.
   *
   * @generated from field: string timer_id = 1;
   */
  timerId = ''

  /**
   * How long until the timer fires, producing a `TIMER_FIRED` event.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_fire_timeout = 2;
   */
  startToFireTimeout?: Duration

  constructor(data?: PartialMessage<StartTimerCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.StartTimerCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'timer_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'start_to_fire_timeout', kind: 'message', T: Duration },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartTimerCommandAttributes {
    return new StartTimerCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartTimerCommandAttributes {
    return new StartTimerCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartTimerCommandAttributes {
    return new StartTimerCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: StartTimerCommandAttributes | PlainMessage<StartTimerCommandAttributes> | undefined,
    b: StartTimerCommandAttributes | PlainMessage<StartTimerCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(StartTimerCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes
 */
export class CompleteWorkflowExecutionCommandAttributes extends Message<CompleteWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: temporal.api.common.v1.Payloads result = 1;
   */
  result?: Payloads

  constructor(data?: PartialMessage<CompleteWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'result', kind: 'message', T: Payloads },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CompleteWorkflowExecutionCommandAttributes {
    return new CompleteWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CompleteWorkflowExecutionCommandAttributes {
    return new CompleteWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CompleteWorkflowExecutionCommandAttributes {
    return new CompleteWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | CompleteWorkflowExecutionCommandAttributes
      | PlainMessage<CompleteWorkflowExecutionCommandAttributes>
      | undefined,
    b:
      | CompleteWorkflowExecutionCommandAttributes
      | PlainMessage<CompleteWorkflowExecutionCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(CompleteWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.FailWorkflowExecutionCommandAttributes
 */
export class FailWorkflowExecutionCommandAttributes extends Message<FailWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure

  constructor(data?: PartialMessage<FailWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.FailWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'failure', kind: 'message', T: Failure },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FailWorkflowExecutionCommandAttributes {
    return new FailWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FailWorkflowExecutionCommandAttributes {
    return new FailWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FailWorkflowExecutionCommandAttributes {
    return new FailWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: FailWorkflowExecutionCommandAttributes | PlainMessage<FailWorkflowExecutionCommandAttributes> | undefined,
    b: FailWorkflowExecutionCommandAttributes | PlainMessage<FailWorkflowExecutionCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(FailWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.CancelTimerCommandAttributes
 */
export class CancelTimerCommandAttributes extends Message<CancelTimerCommandAttributes> {
  /**
   * The same timer id from the start timer command
   *
   * @generated from field: string timer_id = 1;
   */
  timerId = ''

  constructor(data?: PartialMessage<CancelTimerCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.CancelTimerCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'timer_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelTimerCommandAttributes {
    return new CancelTimerCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelTimerCommandAttributes {
    return new CancelTimerCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelTimerCommandAttributes {
    return new CancelTimerCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: CancelTimerCommandAttributes | PlainMessage<CancelTimerCommandAttributes> | undefined,
    b: CancelTimerCommandAttributes | PlainMessage<CancelTimerCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(CancelTimerCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes
 */
export class CancelWorkflowExecutionCommandAttributes extends Message<CancelWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads

  constructor(data?: PartialMessage<CancelWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'details', kind: 'message', T: Payloads },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelWorkflowExecutionCommandAttributes {
    return new CancelWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelWorkflowExecutionCommandAttributes {
    return new CancelWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CancelWorkflowExecutionCommandAttributes {
    return new CancelWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: CancelWorkflowExecutionCommandAttributes | PlainMessage<CancelWorkflowExecutionCommandAttributes> | undefined,
    b: CancelWorkflowExecutionCommandAttributes | PlainMessage<CancelWorkflowExecutionCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(CancelWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes
 */
export class RequestCancelExternalWorkflowExecutionCommandAttributes extends Message<RequestCancelExternalWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId = ''

  /**
   * @generated from field: string run_id = 3;
   */
  runId = ''

  /**
   * Deprecated.
   *
   * @generated from field: string control = 4 [deprecated = true];
   * @deprecated
   */
  control = ''

  /**
   * Set this to true if the workflow being cancelled is a child of the workflow originating this
   * command. The request will be rejected if it is set to true and the target workflow is *not*
   * a child of the requesting workflow.
   *
   * @generated from field: bool child_workflow_only = 5;
   */
  childWorkflowOnly = false

  /**
   * Reason for requesting the cancellation
   *
   * @generated from field: string reason = 6;
   */
  reason = ''

  constructor(data?: PartialMessage<RequestCancelExternalWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'workflow_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'run_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'control', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 5, name: 'child_workflow_only', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: 'reason', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): RequestCancelExternalWorkflowExecutionCommandAttributes {
    return new RequestCancelExternalWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelExternalWorkflowExecutionCommandAttributes {
    return new RequestCancelExternalWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelExternalWorkflowExecutionCommandAttributes {
    return new RequestCancelExternalWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | RequestCancelExternalWorkflowExecutionCommandAttributes
      | PlainMessage<RequestCancelExternalWorkflowExecutionCommandAttributes>
      | undefined,
    b:
      | RequestCancelExternalWorkflowExecutionCommandAttributes
      | PlainMessage<RequestCancelExternalWorkflowExecutionCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(RequestCancelExternalWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes
 */
export class SignalExternalWorkflowExecutionCommandAttributes extends Message<SignalExternalWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution

  /**
   * The workflow author-defined name of the signal to send to the workflow.
   *
   * @generated from field: string signal_name = 3;
   */
  signalName = ''

  /**
   * Serialized value(s) to provide with the signal.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads

  /**
   * Deprecated
   *
   * @generated from field: string control = 5 [deprecated = true];
   * @deprecated
   */
  control = ''

  /**
   * Set this to true if the workflow being cancelled is a child of the workflow originating this
   * command. The request will be rejected if it is set to true and the target workflow is *not*
   * a child of the requesting workflow.
   *
   * @generated from field: bool child_workflow_only = 6;
   */
  childWorkflowOnly = false

  /**
   * Headers that are passed by the workflow that is sending a signal to the external
   * workflow that is receiving this signal.
   *
   * @generated from field: temporal.api.common.v1.Header header = 7;
   */
  header?: Header

  constructor(data?: PartialMessage<SignalExternalWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'execution', kind: 'message', T: WorkflowExecution },
    { no: 3, name: 'signal_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'input', kind: 'message', T: Payloads },
    { no: 5, name: 'control', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 6, name: 'child_workflow_only', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: 'header', kind: 'message', T: Header },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): SignalExternalWorkflowExecutionCommandAttributes {
    return new SignalExternalWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): SignalExternalWorkflowExecutionCommandAttributes {
    return new SignalExternalWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): SignalExternalWorkflowExecutionCommandAttributes {
    return new SignalExternalWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | SignalExternalWorkflowExecutionCommandAttributes
      | PlainMessage<SignalExternalWorkflowExecutionCommandAttributes>
      | undefined,
    b:
      | SignalExternalWorkflowExecutionCommandAttributes
      | PlainMessage<SignalExternalWorkflowExecutionCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(SignalExternalWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes
 */
export class UpsertWorkflowSearchAttributesCommandAttributes extends Message<UpsertWorkflowSearchAttributesCommandAttributes> {
  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 1;
   */
  searchAttributes?: SearchAttributes

  constructor(data?: PartialMessage<UpsertWorkflowSearchAttributesCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'search_attributes', kind: 'message', T: SearchAttributes },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): UpsertWorkflowSearchAttributesCommandAttributes {
    return new UpsertWorkflowSearchAttributesCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): UpsertWorkflowSearchAttributesCommandAttributes {
    return new UpsertWorkflowSearchAttributesCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): UpsertWorkflowSearchAttributesCommandAttributes {
    return new UpsertWorkflowSearchAttributesCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | UpsertWorkflowSearchAttributesCommandAttributes
      | PlainMessage<UpsertWorkflowSearchAttributesCommandAttributes>
      | undefined,
    b:
      | UpsertWorkflowSearchAttributesCommandAttributes
      | PlainMessage<UpsertWorkflowSearchAttributesCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(UpsertWorkflowSearchAttributesCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes
 */
export class ModifyWorkflowPropertiesCommandAttributes extends Message<ModifyWorkflowPropertiesCommandAttributes> {
  /**
   * If set, update the workflow memo with the provided values. The values will be merged with
   * the existing memo. If the user wants to delete values, a default/empty Payload should be
   * used as the value for the key being deleted.
   *
   * @generated from field: temporal.api.common.v1.Memo upserted_memo = 1;
   */
  upsertedMemo?: Memo

  constructor(data?: PartialMessage<ModifyWorkflowPropertiesCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'upserted_memo', kind: 'message', T: Memo },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ModifyWorkflowPropertiesCommandAttributes {
    return new ModifyWorkflowPropertiesCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyWorkflowPropertiesCommandAttributes {
    return new ModifyWorkflowPropertiesCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ModifyWorkflowPropertiesCommandAttributes {
    return new ModifyWorkflowPropertiesCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: ModifyWorkflowPropertiesCommandAttributes | PlainMessage<ModifyWorkflowPropertiesCommandAttributes> | undefined,
    b: ModifyWorkflowPropertiesCommandAttributes | PlainMessage<ModifyWorkflowPropertiesCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(ModifyWorkflowPropertiesCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.RecordMarkerCommandAttributes
 */
export class RecordMarkerCommandAttributes extends Message<RecordMarkerCommandAttributes> {
  /**
   * @generated from field: string marker_name = 1;
   */
  markerName = ''

  /**
   * @generated from field: map<string, temporal.api.common.v1.Payloads> details = 2;
   */
  details: { [key: string]: Payloads } = {}

  /**
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header

  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 4;
   */
  failure?: Failure

  constructor(data?: PartialMessage<RecordMarkerCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.RecordMarkerCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'marker_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'details', kind: 'map', K: 9 /* ScalarType.STRING */, V: { kind: 'message', T: Payloads } },
    { no: 3, name: 'header', kind: 'message', T: Header },
    { no: 4, name: 'failure', kind: 'message', T: Failure },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordMarkerCommandAttributes {
    return new RecordMarkerCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordMarkerCommandAttributes {
    return new RecordMarkerCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordMarkerCommandAttributes {
    return new RecordMarkerCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: RecordMarkerCommandAttributes | PlainMessage<RecordMarkerCommandAttributes> | undefined,
    b: RecordMarkerCommandAttributes | PlainMessage<RecordMarkerCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(RecordMarkerCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes
 */
export class ContinueAsNewWorkflowExecutionCommandAttributes extends Message<ContinueAsNewWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 1;
   */
  workflowType?: WorkflowType

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 3;
   */
  input?: Payloads

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 4;
   */
  workflowRunTimeout?: Duration

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 5;
   */
  workflowTaskTimeout?: Duration

  /**
   * How long the workflow start will be delayed - not really a "backoff" in the traditional sense.
   *
   * @generated from field: google.protobuf.Duration backoff_start_interval = 6;
   */
  backoffStartInterval?: Duration

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 7;
   */
  retryPolicy?: RetryPolicy

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.enums.v1.ContinueAsNewInitiator initiator = 8;
   */
  initiator = ContinueAsNewInitiator.UNSPECIFIED

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 9;
   */
  failure?: Failure

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 10;
   */
  lastCompletionResult?: Payloads

  /**
   * Should be removed. Not necessarily unused but unclear and not exposed by SDKs.
   *
   * @generated from field: string cron_schedule = 11;
   */
  cronSchedule = ''

  /**
   * @generated from field: temporal.api.common.v1.Header header = 12;
   */
  header?: Header

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 13;
   */
  memo?: Memo

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 14;
   */
  searchAttributes?: SearchAttributes

  /**
   * If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
   * the assignment rules will be used to independently assign a Build ID to the new execution.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 15 [deprecated = true];
   * @deprecated
   */
  inheritBuildId = false

  constructor(data?: PartialMessage<ContinueAsNewWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'workflow_type', kind: 'message', T: WorkflowType },
    { no: 2, name: 'task_queue', kind: 'message', T: TaskQueue },
    { no: 3, name: 'input', kind: 'message', T: Payloads },
    { no: 4, name: 'workflow_run_timeout', kind: 'message', T: Duration },
    { no: 5, name: 'workflow_task_timeout', kind: 'message', T: Duration },
    { no: 6, name: 'backoff_start_interval', kind: 'message', T: Duration },
    { no: 7, name: 'retry_policy', kind: 'message', T: RetryPolicy },
    { no: 8, name: 'initiator', kind: 'enum', T: proto3.getEnumType(ContinueAsNewInitiator) },
    { no: 9, name: 'failure', kind: 'message', T: Failure },
    { no: 10, name: 'last_completion_result', kind: 'message', T: Payloads },
    { no: 11, name: 'cron_schedule', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 12, name: 'header', kind: 'message', T: Header },
    { no: 13, name: 'memo', kind: 'message', T: Memo },
    { no: 14, name: 'search_attributes', kind: 'message', T: SearchAttributes },
    { no: 15, name: 'inherit_build_id', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ContinueAsNewWorkflowExecutionCommandAttributes {
    return new ContinueAsNewWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ContinueAsNewWorkflowExecutionCommandAttributes {
    return new ContinueAsNewWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ContinueAsNewWorkflowExecutionCommandAttributes {
    return new ContinueAsNewWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | ContinueAsNewWorkflowExecutionCommandAttributes
      | PlainMessage<ContinueAsNewWorkflowExecutionCommandAttributes>
      | undefined,
    b:
      | ContinueAsNewWorkflowExecutionCommandAttributes
      | PlainMessage<ContinueAsNewWorkflowExecutionCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(ContinueAsNewWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes
 */
export class StartChildWorkflowExecutionCommandAttributes extends Message<StartChildWorkflowExecutionCommandAttributes> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = ''

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId = ''

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 9;
   */
  parentClosePolicy = ParentClosePolicy.UNSPECIFIED

  /**
   * @generated from field: string control = 10;
   */
  control = ''

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy = WorkflowIdReusePolicy.UNSPECIFIED

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 12;
   */
  retryPolicy?: RetryPolicy

  /**
   * Establish a cron schedule for the child workflow.
   *
   * @generated from field: string cron_schedule = 13;
   */
  cronSchedule = ''

  /**
   * @generated from field: temporal.api.common.v1.Header header = 14;
   */
  header?: Header

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 15;
   */
  memo?: Memo

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 16;
   */
  searchAttributes?: SearchAttributes

  /**
   * If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
   * rules of the child's Task Queue will be used to independently assign a Build ID to it.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 17 [deprecated = true];
   * @deprecated
   */
  inheritBuildId = false

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 18;
   */
  priority?: Priority

  constructor(data?: PartialMessage<StartChildWorkflowExecutionCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'namespace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'workflow_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'workflow_type', kind: 'message', T: WorkflowType },
    { no: 4, name: 'task_queue', kind: 'message', T: TaskQueue },
    { no: 5, name: 'input', kind: 'message', T: Payloads },
    { no: 6, name: 'workflow_execution_timeout', kind: 'message', T: Duration },
    { no: 7, name: 'workflow_run_timeout', kind: 'message', T: Duration },
    { no: 8, name: 'workflow_task_timeout', kind: 'message', T: Duration },
    { no: 9, name: 'parent_close_policy', kind: 'enum', T: proto3.getEnumType(ParentClosePolicy) },
    { no: 10, name: 'control', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 11, name: 'workflow_id_reuse_policy', kind: 'enum', T: proto3.getEnumType(WorkflowIdReusePolicy) },
    { no: 12, name: 'retry_policy', kind: 'message', T: RetryPolicy },
    { no: 13, name: 'cron_schedule', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 14, name: 'header', kind: 'message', T: Header },
    { no: 15, name: 'memo', kind: 'message', T: Memo },
    { no: 16, name: 'search_attributes', kind: 'message', T: SearchAttributes },
    { no: 17, name: 'inherit_build_id', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: 'priority', kind: 'message', T: Priority },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): StartChildWorkflowExecutionCommandAttributes {
    return new StartChildWorkflowExecutionCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): StartChildWorkflowExecutionCommandAttributes {
    return new StartChildWorkflowExecutionCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): StartChildWorkflowExecutionCommandAttributes {
    return new StartChildWorkflowExecutionCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | StartChildWorkflowExecutionCommandAttributes
      | PlainMessage<StartChildWorkflowExecutionCommandAttributes>
      | undefined,
    b:
      | StartChildWorkflowExecutionCommandAttributes
      | PlainMessage<StartChildWorkflowExecutionCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(StartChildWorkflowExecutionCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.ProtocolMessageCommandAttributes
 */
export class ProtocolMessageCommandAttributes extends Message<ProtocolMessageCommandAttributes> {
  /**
   * The message ID of the message to which this command is a pointer.
   *
   * @generated from field: string message_id = 1;
   */
  messageId = ''

  constructor(data?: PartialMessage<ProtocolMessageCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.ProtocolMessageCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'message_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProtocolMessageCommandAttributes {
    return new ProtocolMessageCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProtocolMessageCommandAttributes {
    return new ProtocolMessageCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProtocolMessageCommandAttributes {
    return new ProtocolMessageCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: ProtocolMessageCommandAttributes | PlainMessage<ProtocolMessageCommandAttributes> | undefined,
    b: ProtocolMessageCommandAttributes | PlainMessage<ProtocolMessageCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(ProtocolMessageCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.ScheduleNexusOperationCommandAttributes
 */
export class ScheduleNexusOperationCommandAttributes extends Message<ScheduleNexusOperationCommandAttributes> {
  /**
   * Endpoint name, must exist in the endpoint registry or this command will fail.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint = ''

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service = ''

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation = ''

  /**
   * Input for the operation. The server converts this into Nexus request content and the appropriate content headers
   * internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
   * content is transformed back to the original Payload sent in this command.
   *
   * @generated from field: temporal.api.common.v1.Payload input = 4;
   */
  input?: Payload

  /**
   * Schedule-to-close timeout for this operation.
   * Indicates how long the caller is willing to wait for operation completion.
   * Calls are retried internally by the server.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration

  /**
   * Header to attach to the Nexus request.
   * Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
   * transmitted to external services as-is.
   * This is useful for propagating tracing information.
   * Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
   * transmitted to Nexus operations that may be external and are not traditional payloads.
   *
   * @generated from field: map<string, string> nexus_header = 6;
   */
  nexusHeader: { [key: string]: string } = {}

  constructor(data?: PartialMessage<ScheduleNexusOperationCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.ScheduleNexusOperationCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'endpoint', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'service', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'operation', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'input', kind: 'message', T: Payload },
    { no: 5, name: 'schedule_to_close_timeout', kind: 'message', T: Duration },
    {
      no: 6,
      name: 'nexus_header',
      kind: 'map',
      K: 9 /* ScalarType.STRING */,
      V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleNexusOperationCommandAttributes {
    return new ScheduleNexusOperationCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleNexusOperationCommandAttributes {
    return new ScheduleNexusOperationCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ScheduleNexusOperationCommandAttributes {
    return new ScheduleNexusOperationCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a: ScheduleNexusOperationCommandAttributes | PlainMessage<ScheduleNexusOperationCommandAttributes> | undefined,
    b: ScheduleNexusOperationCommandAttributes | PlainMessage<ScheduleNexusOperationCommandAttributes> | undefined,
  ): boolean {
    return proto3.util.equals(ScheduleNexusOperationCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes
 */
export class RequestCancelNexusOperationCommandAttributes extends Message<RequestCancelNexusOperationCommandAttributes> {
  /**
   * The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
   * The operation may ignore cancellation and end up with any completion state.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId = protoInt64.zero

  constructor(data?: PartialMessage<RequestCancelNexusOperationCommandAttributes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'scheduled_event_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): RequestCancelNexusOperationCommandAttributes {
    return new RequestCancelNexusOperationCommandAttributes().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelNexusOperationCommandAttributes {
    return new RequestCancelNexusOperationCommandAttributes().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): RequestCancelNexusOperationCommandAttributes {
    return new RequestCancelNexusOperationCommandAttributes().fromJsonString(jsonString, options)
  }

  static equals(
    a:
      | RequestCancelNexusOperationCommandAttributes
      | PlainMessage<RequestCancelNexusOperationCommandAttributes>
      | undefined,
    b:
      | RequestCancelNexusOperationCommandAttributes
      | PlainMessage<RequestCancelNexusOperationCommandAttributes>
      | undefined,
  ): boolean {
    return proto3.util.equals(RequestCancelNexusOperationCommandAttributes, a, b)
  }
}

/**
 * @generated from message temporal.api.command.v1.Command
 */
export class Command extends Message<Command> {
  /**
   * @generated from field: temporal.api.enums.v1.CommandType command_type = 1;
   */
  commandType = CommandType.UNSPECIFIED

  /**
   * Metadata on the command. This is sometimes carried over to the history event if one is
   * created as a result of the command. Most commands won't have this information, and how this
   * information is used is dependent upon the interface that reads it.
   *
   * Current well-known uses:
   *  * start_child_workflow_execution_command_attributes - populates
   *    temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details
   *    are used by user interfaces to show fixed as-of-start workflow summary and details.
   *  * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer
   *    started where the summary is used to identify the timer.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 301;
   */
  userMetadata?: UserMetadata

  /**
   * The command details. The type must match that in `command_type`.
   *
   * @generated from oneof temporal.api.command.v1.Command.attributes
   */
  attributes:
    | {
        /**
         * @generated from field: temporal.api.command.v1.ScheduleActivityTaskCommandAttributes schedule_activity_task_command_attributes = 2;
         */
        value: ScheduleActivityTaskCommandAttributes
        case: 'scheduleActivityTaskCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.StartTimerCommandAttributes start_timer_command_attributes = 3;
         */
        value: StartTimerCommandAttributes
        case: 'startTimerCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes complete_workflow_execution_command_attributes = 4;
         */
        value: CompleteWorkflowExecutionCommandAttributes
        case: 'completeWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.FailWorkflowExecutionCommandAttributes fail_workflow_execution_command_attributes = 5;
         */
        value: FailWorkflowExecutionCommandAttributes
        case: 'failWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes request_cancel_activity_task_command_attributes = 6;
         */
        value: RequestCancelActivityTaskCommandAttributes
        case: 'requestCancelActivityTaskCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.CancelTimerCommandAttributes cancel_timer_command_attributes = 7;
         */
        value: CancelTimerCommandAttributes
        case: 'cancelTimerCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes cancel_workflow_execution_command_attributes = 8;
         */
        value: CancelWorkflowExecutionCommandAttributes
        case: 'cancelWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes request_cancel_external_workflow_execution_command_attributes = 9;
         */
        value: RequestCancelExternalWorkflowExecutionCommandAttributes
        case: 'requestCancelExternalWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.RecordMarkerCommandAttributes record_marker_command_attributes = 10;
         */
        value: RecordMarkerCommandAttributes
        case: 'recordMarkerCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes continue_as_new_workflow_execution_command_attributes = 11;
         */
        value: ContinueAsNewWorkflowExecutionCommandAttributes
        case: 'continueAsNewWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes start_child_workflow_execution_command_attributes = 12;
         */
        value: StartChildWorkflowExecutionCommandAttributes
        case: 'startChildWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes signal_external_workflow_execution_command_attributes = 13;
         */
        value: SignalExternalWorkflowExecutionCommandAttributes
        case: 'signalExternalWorkflowExecutionCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes upsert_workflow_search_attributes_command_attributes = 14;
         */
        value: UpsertWorkflowSearchAttributesCommandAttributes
        case: 'upsertWorkflowSearchAttributesCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.ProtocolMessageCommandAttributes protocol_message_command_attributes = 15;
         */
        value: ProtocolMessageCommandAttributes
        case: 'protocolMessageCommandAttributes'
      }
    | {
        /**
         * 16 is available for use - it was used as part of a prototype that never made it into a release
         *
         * @generated from field: temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes modify_workflow_properties_command_attributes = 17;
         */
        value: ModifyWorkflowPropertiesCommandAttributes
        case: 'modifyWorkflowPropertiesCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.ScheduleNexusOperationCommandAttributes schedule_nexus_operation_command_attributes = 18;
         */
        value: ScheduleNexusOperationCommandAttributes
        case: 'scheduleNexusOperationCommandAttributes'
      }
    | {
        /**
         * @generated from field: temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes request_cancel_nexus_operation_command_attributes = 19;
         */
        value: RequestCancelNexusOperationCommandAttributes
        case: 'requestCancelNexusOperationCommandAttributes'
      }
    | { case: undefined; value?: undefined } = { case: undefined }

  constructor(data?: PartialMessage<Command>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.command.v1.Command'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'command_type', kind: 'enum', T: proto3.getEnumType(CommandType) },
    { no: 301, name: 'user_metadata', kind: 'message', T: UserMetadata },
    {
      no: 2,
      name: 'schedule_activity_task_command_attributes',
      kind: 'message',
      T: ScheduleActivityTaskCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 3,
      name: 'start_timer_command_attributes',
      kind: 'message',
      T: StartTimerCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 4,
      name: 'complete_workflow_execution_command_attributes',
      kind: 'message',
      T: CompleteWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 5,
      name: 'fail_workflow_execution_command_attributes',
      kind: 'message',
      T: FailWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 6,
      name: 'request_cancel_activity_task_command_attributes',
      kind: 'message',
      T: RequestCancelActivityTaskCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 7,
      name: 'cancel_timer_command_attributes',
      kind: 'message',
      T: CancelTimerCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 8,
      name: 'cancel_workflow_execution_command_attributes',
      kind: 'message',
      T: CancelWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 9,
      name: 'request_cancel_external_workflow_execution_command_attributes',
      kind: 'message',
      T: RequestCancelExternalWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 10,
      name: 'record_marker_command_attributes',
      kind: 'message',
      T: RecordMarkerCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 11,
      name: 'continue_as_new_workflow_execution_command_attributes',
      kind: 'message',
      T: ContinueAsNewWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 12,
      name: 'start_child_workflow_execution_command_attributes',
      kind: 'message',
      T: StartChildWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 13,
      name: 'signal_external_workflow_execution_command_attributes',
      kind: 'message',
      T: SignalExternalWorkflowExecutionCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 14,
      name: 'upsert_workflow_search_attributes_command_attributes',
      kind: 'message',
      T: UpsertWorkflowSearchAttributesCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 15,
      name: 'protocol_message_command_attributes',
      kind: 'message',
      T: ProtocolMessageCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 17,
      name: 'modify_workflow_properties_command_attributes',
      kind: 'message',
      T: ModifyWorkflowPropertiesCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 18,
      name: 'schedule_nexus_operation_command_attributes',
      kind: 'message',
      T: ScheduleNexusOperationCommandAttributes,
      oneof: 'attributes',
    },
    {
      no: 19,
      name: 'request_cancel_nexus_operation_command_attributes',
      kind: 'message',
      T: RequestCancelNexusOperationCommandAttributes,
      oneof: 'attributes',
    },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Command {
    return new Command().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJsonString(jsonString, options)
  }

  static equals(
    a: Command | PlainMessage<Command> | undefined,
    b: Command | PlainMessage<Command> | undefined,
  ): boolean {
    return proto3.util.equals(Command, a, b)
  }
}
