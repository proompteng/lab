// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/command/v1/message.proto (package temporal.api.command.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration } from "@bufbuild/protobuf/wkt";
import type { ContinueAsNewInitiator, ParentClosePolicy, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { CommandType } from "../../enums/v1/command_type_pb.js";
import { file_temporal_api_enums_v1_command_type } from "../../enums/v1/command_type_pb.js";
import type { ActivityType, Header, Memo, Payload, Payloads, Priority, RetryPolicy, SearchAttributes, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { Failure } from "../../failure/v1/message_pb.js";
import { file_temporal_api_failure_v1_message } from "../../failure/v1/message_pb.js";
import type { TaskQueue } from "../../taskqueue/v1/message_pb.js";
import { file_temporal_api_taskqueue_v1_message } from "../../taskqueue/v1/message_pb.js";
import type { UserMetadata } from "../../sdk/v1/user_metadata_pb.js";
import { file_temporal_api_sdk_v1_user_metadata } from "../../sdk/v1/user_metadata_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/command/v1/message.proto.
 */
export const file_temporal_api_command_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiV0ZW1wb3JhbC9hcGkvY29tbWFuZC92MS9tZXNzYWdlLnByb3RvEhd0ZW1wb3JhbC5hcGkuY29tbWFuZC52MSK2BQolU2NoZWR1bGVBY3Rpdml0eVRhc2tDb21tYW5kQXR0cmlidXRlcxITCgthY3Rpdml0eV9pZBgBIAEoCRI7Cg1hY3Rpdml0eV90eXBlGAIgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5BY3Rpdml0eVR5cGUSOAoKdGFza19xdWV1ZRgEIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEi4KBmhlYWRlchgFIAEoCzIeLnRlbXBvcmFsLmFwaS5jb21tb24udjEuSGVhZGVyEi8KBWlucHV0GAYgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI8ChlzY2hlZHVsZV90b19jbG9zZV90aW1lb3V0GAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjwKGXNjaGVkdWxlX3RvX3N0YXJ0X3RpbWVvdXQYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOQoWc3RhcnRfdG9fY2xvc2VfdGltZW91dBgJIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI0ChFoZWFydGJlYXRfdGltZW91dBgKIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI5CgxyZXRyeV9wb2xpY3kYCyABKAsyIy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlJldHJ5UG9saWN5Eh8KF3JlcXVlc3RfZWFnZXJfZXhlY3V0aW9uGAwgASgIEh0KFXVzZV93b3JrZmxvd19idWlsZF9pZBgNIAEoCBIyCghwcmlvcml0eRgOIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUHJpb3JpdHlKBAgDEAQiSAoqUmVxdWVzdENhbmNlbEFjdGl2aXR5VGFza0NvbW1hbmRBdHRyaWJ1dGVzEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgBIAEoAyJpChtTdGFydFRpbWVyQ29tbWFuZEF0dHJpYnV0ZXMSEAoIdGltZXJfaWQYASABKAkSOAoVc3RhcnRfdG9fZmlyZV90aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIl4KKkNvbXBsZXRlV29ya2Zsb3dFeGVjdXRpb25Db21tYW5kQXR0cmlidXRlcxIwCgZyZXN1bHQYASABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzIlsKJkZhaWxXb3JrZmxvd0V4ZWN1dGlvbkNvbW1hbmRBdHRyaWJ1dGVzEjEKB2ZhaWx1cmUYASABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlIjAKHENhbmNlbFRpbWVyQ29tbWFuZEF0dHJpYnV0ZXMSEAoIdGltZXJfaWQYASABKAkiXQooQ2FuY2VsV29ya2Zsb3dFeGVjdXRpb25Db21tYW5kQXR0cmlidXRlcxIxCgdkZXRhaWxzGAEgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcyKzAQo3UmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25Db21tYW5kQXR0cmlidXRlcxIRCgluYW1lc3BhY2UYASABKAkSEwoLd29ya2Zsb3dfaWQYAiABKAkSDgoGcnVuX2lkGAMgASgJEhMKB2NvbnRyb2wYBCABKAlCAhgBEhsKE2NoaWxkX3dvcmtmbG93X29ubHkYBSABKAgSDgoGcmVhc29uGAYgASgJIqsCCjBTaWduYWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uQ29tbWFuZEF0dHJpYnV0ZXMSEQoJbmFtZXNwYWNlGAEgASgJEjwKCWV4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SEwoLc2lnbmFsX25hbWUYAyABKAkSLwoFaW5wdXQYBCABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhMKB2NvbnRyb2wYBSABKAlCAhgBEhsKE2NoaWxkX3dvcmtmbG93X29ubHkYBiABKAgSLgoGaGVhZGVyGAcgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXIidgovVXBzZXJ0V29ya2Zsb3dTZWFyY2hBdHRyaWJ1dGVzQ29tbWFuZEF0dHJpYnV0ZXMSQwoRc2VhcmNoX2F0dHJpYnV0ZXMYASABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMiYAopTW9kaWZ5V29ya2Zsb3dQcm9wZXJ0aWVzQ29tbWFuZEF0dHJpYnV0ZXMSMwoNdXBzZXJ0ZWRfbWVtbxgBIAEoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTWVtbyK/AgodUmVjb3JkTWFya2VyQ29tbWFuZEF0dHJpYnV0ZXMSEwoLbWFya2VyX25hbWUYASABKAkSVAoHZGV0YWlscxgCIAMoCzJDLnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlJlY29yZE1hcmtlckNvbW1hbmRBdHRyaWJ1dGVzLkRldGFpbHNFbnRyeRIuCgZoZWFkZXIYAyABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIxCgdmYWlsdXJlGAQgASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZRpQCgxEZXRhaWxzRW50cnkSCwoDa2V5GAEgASgJEi8KBXZhbHVlGAIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkczoCOAEizwYKL0NvbnRpbnVlQXNOZXdXb3JrZmxvd0V4ZWN1dGlvbkNvbW1hbmRBdHRyaWJ1dGVzEjsKDXdvcmtmbG93X3R5cGUYASABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93VHlwZRI4Cgp0YXNrX3F1ZXVlGAIgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUSLwoFaW5wdXQYAyABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEjcKFHdvcmtmbG93X3J1bl90aW1lb3V0GAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjgKFXdvcmtmbG93X3Rhc2tfdGltZW91dBgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI5ChZiYWNrb2ZmX3N0YXJ0X2ludGVydmFsGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjkKDHJldHJ5X3BvbGljeRgHIAEoCzIjLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUmV0cnlQb2xpY3kSQAoJaW5pdGlhdG9yGAggASgOMi0udGVtcG9yYWwuYXBpLmVudW1zLnYxLkNvbnRpbnVlQXNOZXdJbml0aWF0b3ISMQoHZmFpbHVyZRgJIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSQAoWbGFzdF9jb21wbGV0aW9uX3Jlc3VsdBgKIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSFQoNY3Jvbl9zY2hlZHVsZRgLIAEoCRIuCgZoZWFkZXIYDCABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIqCgRtZW1vGA0gASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGA4gASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzEhwKEGluaGVyaXRfYnVpbGRfaWQYDyABKAhCAhgBIp0HCixTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25Db21tYW5kQXR0cmlidXRlcxIRCgluYW1lc3BhY2UYASABKAkSEwoLd29ya2Zsb3dfaWQYAiABKAkSOwoNd29ya2Zsb3dfdHlwZRgDIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEjgKCnRhc2tfcXVldWUYBCABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRIvCgVpbnB1dBgFIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSPQoad29ya2Zsb3dfZXhlY3V0aW9uX3RpbWVvdXQYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SNwoUd29ya2Zsb3dfcnVuX3RpbWVvdXQYByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOAoVd29ya2Zsb3dfdGFza190aW1lb3V0GAggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkUKE3BhcmVudF9jbG9zZV9wb2xpY3kYCSABKA4yKC50ZW1wb3JhbC5hcGkuZW51bXMudjEuUGFyZW50Q2xvc2VQb2xpY3kSDwoHY29udHJvbBgKIAEoCRJOChh3b3JrZmxvd19pZF9yZXVzZV9wb2xpY3kYCyABKA4yLC50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5EjkKDHJldHJ5X3BvbGljeRgMIAEoCzIjLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUmV0cnlQb2xpY3kSFQoNY3Jvbl9zY2hlZHVsZRgNIAEoCRIuCgZoZWFkZXIYDiABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIqCgRtZW1vGA8gASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGBAgASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzEhwKEGluaGVyaXRfYnVpbGRfaWQYESABKAhCAhgBEjIKCHByaW9yaXR5GBIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eSI2CiBQcm90b2NvbE1lc3NhZ2VDb21tYW5kQXR0cmlidXRlcxISCgptZXNzYWdlX2lkGAEgASgJIuoCCidTY2hlZHVsZU5leHVzT3BlcmF0aW9uQ29tbWFuZEF0dHJpYnV0ZXMSEAoIZW5kcG9pbnQYASABKAkSDwoHc2VydmljZRgCIAEoCRIRCglvcGVyYXRpb24YAyABKAkSLgoFaW5wdXQYBCABKAsyHy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWQSPAoZc2NoZWR1bGVfdG9fY2xvc2VfdGltZW91dBgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJnCgxuZXh1c19oZWFkZXIYBiADKAsyUS50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5TY2hlZHVsZU5leHVzT3BlcmF0aW9uQ29tbWFuZEF0dHJpYnV0ZXMuTmV4dXNIZWFkZXJFbnRyeRoyChBOZXh1c0hlYWRlckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiSgosUmVxdWVzdENhbmNlbE5leHVzT3BlcmF0aW9uQ29tbWFuZEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDIsIRCgdDb21tYW5kEjgKDGNvbW1hbmRfdHlwZRgBIAEoDjIiLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5Db21tYW5kVHlwZRI5Cg11c2VyX21ldGFkYXRhGK0CIAEoCzIhLnRlbXBvcmFsLmFwaS5zZGsudjEuVXNlck1ldGFkYXRhEnMKKXNjaGVkdWxlX2FjdGl2aXR5X3Rhc2tfY29tbWFuZF9hdHRyaWJ1dGVzGAIgASgLMj4udGVtcG9yYWwuYXBpLmNvbW1hbmQudjEuU2NoZWR1bGVBY3Rpdml0eVRhc2tDb21tYW5kQXR0cmlidXRlc0gAEl4KHnN0YXJ0X3RpbWVyX2NvbW1hbmRfYXR0cmlidXRlcxgDIAEoCzI0LnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlN0YXJ0VGltZXJDb21tYW5kQXR0cmlidXRlc0gAEn0KLmNvbXBsZXRlX3dvcmtmbG93X2V4ZWN1dGlvbl9jb21tYW5kX2F0dHJpYnV0ZXMYBCABKAsyQy50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5Db21wbGV0ZVdvcmtmbG93RXhlY3V0aW9uQ29tbWFuZEF0dHJpYnV0ZXNIABJ1CipmYWlsX3dvcmtmbG93X2V4ZWN1dGlvbl9jb21tYW5kX2F0dHJpYnV0ZXMYBSABKAsyPy50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5GYWlsV29ya2Zsb3dFeGVjdXRpb25Db21tYW5kQXR0cmlidXRlc0gAEn4KL3JlcXVlc3RfY2FuY2VsX2FjdGl2aXR5X3Rhc2tfY29tbWFuZF9hdHRyaWJ1dGVzGAYgASgLMkMudGVtcG9yYWwuYXBpLmNvbW1hbmQudjEuUmVxdWVzdENhbmNlbEFjdGl2aXR5VGFza0NvbW1hbmRBdHRyaWJ1dGVzSAASYAofY2FuY2VsX3RpbWVyX2NvbW1hbmRfYXR0cmlidXRlcxgHIAEoCzI1LnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLkNhbmNlbFRpbWVyQ29tbWFuZEF0dHJpYnV0ZXNIABJ5CixjYW5jZWxfd29ya2Zsb3dfZXhlY3V0aW9uX2NvbW1hbmRfYXR0cmlidXRlcxgIIAEoCzJBLnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLkNhbmNlbFdvcmtmbG93RXhlY3V0aW9uQ29tbWFuZEF0dHJpYnV0ZXNIABKZAQo9cmVxdWVzdF9jYW5jZWxfZXh0ZXJuYWxfd29ya2Zsb3dfZXhlY3V0aW9uX2NvbW1hbmRfYXR0cmlidXRlcxgJIAEoCzJQLnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlJlcXVlc3RDYW5jZWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uQ29tbWFuZEF0dHJpYnV0ZXNIABJiCiByZWNvcmRfbWFya2VyX2NvbW1hbmRfYXR0cmlidXRlcxgKIAEoCzI2LnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlJlY29yZE1hcmtlckNvbW1hbmRBdHRyaWJ1dGVzSAASiQEKNWNvbnRpbnVlX2FzX25ld193b3JrZmxvd19leGVjdXRpb25fY29tbWFuZF9hdHRyaWJ1dGVzGAsgASgLMkgudGVtcG9yYWwuYXBpLmNvbW1hbmQudjEuQ29udGludWVBc05ld1dvcmtmbG93RXhlY3V0aW9uQ29tbWFuZEF0dHJpYnV0ZXNIABKCAQoxc3RhcnRfY2hpbGRfd29ya2Zsb3dfZXhlY3V0aW9uX2NvbW1hbmRfYXR0cmlidXRlcxgMIAEoCzJFLnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkNvbW1hbmRBdHRyaWJ1dGVzSAASigEKNXNpZ25hbF9leHRlcm5hbF93b3JrZmxvd19leGVjdXRpb25fY29tbWFuZF9hdHRyaWJ1dGVzGA0gASgLMkkudGVtcG9yYWwuYXBpLmNvbW1hbmQudjEuU2lnbmFsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbkNvbW1hbmRBdHRyaWJ1dGVzSAASiAEKNHVwc2VydF93b3JrZmxvd19zZWFyY2hfYXR0cmlidXRlc19jb21tYW5kX2F0dHJpYnV0ZXMYDiABKAsySC50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5VcHNlcnRXb3JrZmxvd1NlYXJjaEF0dHJpYnV0ZXNDb21tYW5kQXR0cmlidXRlc0gAEmgKI3Byb3RvY29sX21lc3NhZ2VfY29tbWFuZF9hdHRyaWJ1dGVzGA8gASgLMjkudGVtcG9yYWwuYXBpLmNvbW1hbmQudjEuUHJvdG9jb2xNZXNzYWdlQ29tbWFuZEF0dHJpYnV0ZXNIABJ7Ci1tb2RpZnlfd29ya2Zsb3dfcHJvcGVydGllc19jb21tYW5kX2F0dHJpYnV0ZXMYESABKAsyQi50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5Nb2RpZnlXb3JrZmxvd1Byb3BlcnRpZXNDb21tYW5kQXR0cmlidXRlc0gAEncKK3NjaGVkdWxlX25leHVzX29wZXJhdGlvbl9jb21tYW5kX2F0dHJpYnV0ZXMYEiABKAsyQC50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5TY2hlZHVsZU5leHVzT3BlcmF0aW9uQ29tbWFuZEF0dHJpYnV0ZXNIABKCAQoxcmVxdWVzdF9jYW5jZWxfbmV4dXNfb3BlcmF0aW9uX2NvbW1hbmRfYXR0cmlidXRlcxgTIAEoCzJFLnRlbXBvcmFsLmFwaS5jb21tYW5kLnYxLlJlcXVlc3RDYW5jZWxOZXh1c09wZXJhdGlvbkNvbW1hbmRBdHRyaWJ1dGVzSABCDAoKYXR0cmlidXRlc0KOAQoaaW8udGVtcG9yYWwuYXBpLmNvbW1hbmQudjFCDE1lc3NhZ2VQcm90b1ABWiVnby50ZW1wb3JhbC5pby9hcGkvY29tbWFuZC92MTtjb21tYW5kqgIZVGVtcG9yYWxpby5BcGkuQ29tbWFuZC5WMeoCHFRlbXBvcmFsaW86OkFwaTo6Q29tbWFuZDo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_temporal_api_enums_v1_workflow, file_temporal_api_enums_v1_command_type, file_temporal_api_common_v1_message, file_temporal_api_failure_v1_message, file_temporal_api_taskqueue_v1_message, file_temporal_api_sdk_v1_user_metadata]);

/**
 * @generated from message temporal.api.command.v1.ScheduleActivityTaskCommandAttributes
 */
export type ScheduleActivityTaskCommandAttributes = Message<"temporal.api.command.v1.ScheduleActivityTaskCommandAttributes"> & {
  /**
   * @generated from field: string activity_id = 1;
   */
  activityId: string;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 5;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 6;
   */
  input?: Payloads;

  /**
   * Indicates how long the caller is willing to wait for activity completion. The "schedule" time
   * is when the activity is initially scheduled, not when the most recent retry is scheduled.
   * Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
   * specified. When not specified, defaults to the workflow execution timeout.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 7;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Limits the time an activity task can stay in a task queue before a worker picks it up. The
   * "schedule" time is when the most recent retry is scheduled. This timeout should usually not
   * be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
   * always non retryable, as all a retry would achieve is to put it back into the same queue.
   * Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
   * specified. More info:
   * https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 8;
   */
  scheduleToStartTimeout?: Duration;

  /**
   * Maximum time an activity is allowed to execute after being picked up by a worker. This
   * timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 9;
   */
  startToCloseTimeout?: Duration;

  /**
   * Maximum permitted time between successful worker heartbeats.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 10;
   */
  heartbeatTimeout?: Duration;

  /**
   * Activities are provided by a default retry policy which is controlled through the service's
   * dynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has
   * elapsed. To disable retries set retry_policy.maximum_attempts to 1.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 11;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Request to start the activity directly bypassing matching service and worker polling
   * The slot for executing the activity should be reserved when setting this field to true.
   *
   * @generated from field: bool request_eager_execution = 12;
   */
  requestEagerExecution: boolean;

  /**
   * If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
   * Assignment rules of the activity's Task Queue will be used to determine the Build ID.
   *
   * @generated from field: bool use_workflow_build_id = 13;
   */
  useWorkflowBuildId: boolean;

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 14;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.command.v1.ScheduleActivityTaskCommandAttributes.
 * Use `create(ScheduleActivityTaskCommandAttributesSchema)` to create a new message.
 */
export const ScheduleActivityTaskCommandAttributesSchema: GenMessage<ScheduleActivityTaskCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 0);

/**
 * @generated from message temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes
 */
export type RequestCancelActivityTaskCommandAttributes = Message<"temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes"> & {
  /**
   * The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;
};

/**
 * Describes the message temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes.
 * Use `create(RequestCancelActivityTaskCommandAttributesSchema)` to create a new message.
 */
export const RequestCancelActivityTaskCommandAttributesSchema: GenMessage<RequestCancelActivityTaskCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 1);

/**
 * @generated from message temporal.api.command.v1.StartTimerCommandAttributes
 */
export type StartTimerCommandAttributes = Message<"temporal.api.command.v1.StartTimerCommandAttributes"> & {
  /**
   * An id for the timer, currently live timers must have different ids. Typically autogenerated
   * by the SDK.
   *
   * @generated from field: string timer_id = 1;
   */
  timerId: string;

  /**
   * How long until the timer fires, producing a `TIMER_FIRED` event.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_fire_timeout = 2;
   */
  startToFireTimeout?: Duration;
};

/**
 * Describes the message temporal.api.command.v1.StartTimerCommandAttributes.
 * Use `create(StartTimerCommandAttributesSchema)` to create a new message.
 */
export const StartTimerCommandAttributesSchema: GenMessage<StartTimerCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 2);

/**
 * @generated from message temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes
 */
export type CompleteWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.Payloads result = 1;
   */
  result?: Payloads;
};

/**
 * Describes the message temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes.
 * Use `create(CompleteWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const CompleteWorkflowExecutionCommandAttributesSchema: GenMessage<CompleteWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 3);

/**
 * @generated from message temporal.api.command.v1.FailWorkflowExecutionCommandAttributes
 */
export type FailWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.FailWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure;
};

/**
 * Describes the message temporal.api.command.v1.FailWorkflowExecutionCommandAttributes.
 * Use `create(FailWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const FailWorkflowExecutionCommandAttributesSchema: GenMessage<FailWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 4);

/**
 * @generated from message temporal.api.command.v1.CancelTimerCommandAttributes
 */
export type CancelTimerCommandAttributes = Message<"temporal.api.command.v1.CancelTimerCommandAttributes"> & {
  /**
   * The same timer id from the start timer command
   *
   * @generated from field: string timer_id = 1;
   */
  timerId: string;
};

/**
 * Describes the message temporal.api.command.v1.CancelTimerCommandAttributes.
 * Use `create(CancelTimerCommandAttributesSchema)` to create a new message.
 */
export const CancelTimerCommandAttributesSchema: GenMessage<CancelTimerCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 5);

/**
 * @generated from message temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes
 */
export type CancelWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads;
};

/**
 * Describes the message temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes.
 * Use `create(CancelWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const CancelWorkflowExecutionCommandAttributesSchema: GenMessage<CancelWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 6);

/**
 * @generated from message temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes
 */
export type RequestCancelExternalWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 4 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Set this to true if the workflow being cancelled is a child of the workflow originating this
   * command. The request will be rejected if it is set to true and the target workflow is *not*
   * a child of the requesting workflow.
   *
   * @generated from field: bool child_workflow_only = 5;
   */
  childWorkflowOnly: boolean;

  /**
   * Reason for requesting the cancellation
   *
   * @generated from field: string reason = 6;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes.
 * Use `create(RequestCancelExternalWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const RequestCancelExternalWorkflowExecutionCommandAttributesSchema: GenMessage<RequestCancelExternalWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 7);

/**
 * @generated from message temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes
 */
export type SignalExternalWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The workflow author-defined name of the signal to send to the workflow.
   *
   * @generated from field: string signal_name = 3;
   */
  signalName: string;

  /**
   * Serialized value(s) to provide with the signal.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * Deprecated
   *
   * @generated from field: string control = 5 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Set this to true if the workflow being cancelled is a child of the workflow originating this
   * command. The request will be rejected if it is set to true and the target workflow is *not*
   * a child of the requesting workflow.
   *
   * @generated from field: bool child_workflow_only = 6;
   */
  childWorkflowOnly: boolean;

  /**
   * Headers that are passed by the workflow that is sending a signal to the external 
   * workflow that is receiving this signal.
   *
   * @generated from field: temporal.api.common.v1.Header header = 7;
   */
  header?: Header;
};

/**
 * Describes the message temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes.
 * Use `create(SignalExternalWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const SignalExternalWorkflowExecutionCommandAttributesSchema: GenMessage<SignalExternalWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 8);

/**
 * @generated from message temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes
 */
export type UpsertWorkflowSearchAttributesCommandAttributes = Message<"temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 1;
   */
  searchAttributes?: SearchAttributes;
};

/**
 * Describes the message temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes.
 * Use `create(UpsertWorkflowSearchAttributesCommandAttributesSchema)` to create a new message.
 */
export const UpsertWorkflowSearchAttributesCommandAttributesSchema: GenMessage<UpsertWorkflowSearchAttributesCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 9);

/**
 * @generated from message temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes
 */
export type ModifyWorkflowPropertiesCommandAttributes = Message<"temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes"> & {
  /**
   * If set, update the workflow memo with the provided values. The values will be merged with
   * the existing memo. If the user wants to delete values, a default/empty Payload should be
   * used as the value for the key being deleted.
   *
   * @generated from field: temporal.api.common.v1.Memo upserted_memo = 1;
   */
  upsertedMemo?: Memo;
};

/**
 * Describes the message temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes.
 * Use `create(ModifyWorkflowPropertiesCommandAttributesSchema)` to create a new message.
 */
export const ModifyWorkflowPropertiesCommandAttributesSchema: GenMessage<ModifyWorkflowPropertiesCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 10);

/**
 * @generated from message temporal.api.command.v1.RecordMarkerCommandAttributes
 */
export type RecordMarkerCommandAttributes = Message<"temporal.api.command.v1.RecordMarkerCommandAttributes"> & {
  /**
   * @generated from field: string marker_name = 1;
   */
  markerName: string;

  /**
   * @generated from field: map<string, temporal.api.common.v1.Payloads> details = 2;
   */
  details: { [key: string]: Payloads };

  /**
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 4;
   */
  failure?: Failure;
};

/**
 * Describes the message temporal.api.command.v1.RecordMarkerCommandAttributes.
 * Use `create(RecordMarkerCommandAttributesSchema)` to create a new message.
 */
export const RecordMarkerCommandAttributesSchema: GenMessage<RecordMarkerCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 11);

/**
 * @generated from message temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes
 */
export type ContinueAsNewWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 1;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 3;
   */
  input?: Payloads;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 4;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 5;
   */
  workflowTaskTimeout?: Duration;

  /**
   * How long the workflow start will be delayed - not really a "backoff" in the traditional sense.
   *
   * @generated from field: google.protobuf.Duration backoff_start_interval = 6;
   */
  backoffStartInterval?: Duration;

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 7;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.enums.v1.ContinueAsNewInitiator initiator = 8;
   */
  initiator: ContinueAsNewInitiator;

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 9;
   */
  failure?: Failure;

  /**
   * Should be removed
   *
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 10;
   */
  lastCompletionResult?: Payloads;

  /**
   * Should be removed. Not necessarily unused but unclear and not exposed by SDKs.
   *
   * @generated from field: string cron_schedule = 11;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 12;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 13;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 14;
   */
  searchAttributes?: SearchAttributes;

  /**
   * If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
   * the assignment rules will be used to independently assign a Build ID to the new execution.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 15 [deprecated = true];
   * @deprecated
   */
  inheritBuildId: boolean;
};

/**
 * Describes the message temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes.
 * Use `create(ContinueAsNewWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const ContinueAsNewWorkflowExecutionCommandAttributesSchema: GenMessage<ContinueAsNewWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 12);

/**
 * @generated from message temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes
 */
export type StartChildWorkflowExecutionCommandAttributes = Message<"temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 9;
   */
  parentClosePolicy: ParentClosePolicy;

  /**
   * @generated from field: string control = 10;
   */
  control: string;

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 12;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Establish a cron schedule for the child workflow.
   *
   * @generated from field: string cron_schedule = 13;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 14;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 15;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 16;
   */
  searchAttributes?: SearchAttributes;

  /**
   * If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
   * rules of the child's Task Queue will be used to independently assign a Build ID to it.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 17 [deprecated = true];
   * @deprecated
   */
  inheritBuildId: boolean;

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 18;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes.
 * Use `create(StartChildWorkflowExecutionCommandAttributesSchema)` to create a new message.
 */
export const StartChildWorkflowExecutionCommandAttributesSchema: GenMessage<StartChildWorkflowExecutionCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 13);

/**
 * @generated from message temporal.api.command.v1.ProtocolMessageCommandAttributes
 */
export type ProtocolMessageCommandAttributes = Message<"temporal.api.command.v1.ProtocolMessageCommandAttributes"> & {
  /**
   * The message ID of the message to which this command is a pointer.
   *
   * @generated from field: string message_id = 1;
   */
  messageId: string;
};

/**
 * Describes the message temporal.api.command.v1.ProtocolMessageCommandAttributes.
 * Use `create(ProtocolMessageCommandAttributesSchema)` to create a new message.
 */
export const ProtocolMessageCommandAttributesSchema: GenMessage<ProtocolMessageCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 14);

/**
 * @generated from message temporal.api.command.v1.ScheduleNexusOperationCommandAttributes
 */
export type ScheduleNexusOperationCommandAttributes = Message<"temporal.api.command.v1.ScheduleNexusOperationCommandAttributes"> & {
  /**
   * Endpoint name, must exist in the endpoint registry or this command will fail.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service: string;

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation: string;

  /**
   * Input for the operation. The server converts this into Nexus request content and the appropriate content headers
   * internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
   * content is transformed back to the original Payload sent in this command.
   *
   * @generated from field: temporal.api.common.v1.Payload input = 4;
   */
  input?: Payload;

  /**
   * Schedule-to-close timeout for this operation.
   * Indicates how long the caller is willing to wait for operation completion.
   * Calls are retried internally by the server.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Header to attach to the Nexus request.
   * Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
   * transmitted to external services as-is.
   * This is useful for propagating tracing information.
   * Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
   * transmitted to Nexus operations that may be external and are not traditional payloads.
   *
   * @generated from field: map<string, string> nexus_header = 6;
   */
  nexusHeader: { [key: string]: string };
};

/**
 * Describes the message temporal.api.command.v1.ScheduleNexusOperationCommandAttributes.
 * Use `create(ScheduleNexusOperationCommandAttributesSchema)` to create a new message.
 */
export const ScheduleNexusOperationCommandAttributesSchema: GenMessage<ScheduleNexusOperationCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 15);

/**
 * @generated from message temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes
 */
export type RequestCancelNexusOperationCommandAttributes = Message<"temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes"> & {
  /**
   * The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
   * The operation may ignore cancellation and end up with any completion state.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;
};

/**
 * Describes the message temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes.
 * Use `create(RequestCancelNexusOperationCommandAttributesSchema)` to create a new message.
 */
export const RequestCancelNexusOperationCommandAttributesSchema: GenMessage<RequestCancelNexusOperationCommandAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 16);

/**
 * @generated from message temporal.api.command.v1.Command
 */
export type Command = Message<"temporal.api.command.v1.Command"> & {
  /**
   * @generated from field: temporal.api.enums.v1.CommandType command_type = 1;
   */
  commandType: CommandType;

  /**
   * Metadata on the command. This is sometimes carried over to the history event if one is
   * created as a result of the command. Most commands won't have this information, and how this
   * information is used is dependent upon the interface that reads it.
   *
   * Current well-known uses:
   *  * start_child_workflow_execution_command_attributes - populates
   *    temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details
   *    are used by user interfaces to show fixed as-of-start workflow summary and details.
   *  * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer
   *    started where the summary is used to identify the timer.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 301;
   */
  userMetadata?: UserMetadata;

  /**
   * The command details. The type must match that in `command_type`.
   *
   * @generated from oneof temporal.api.command.v1.Command.attributes
   */
  attributes: {
    /**
     * @generated from field: temporal.api.command.v1.ScheduleActivityTaskCommandAttributes schedule_activity_task_command_attributes = 2;
     */
    value: ScheduleActivityTaskCommandAttributes;
    case: "scheduleActivityTaskCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.StartTimerCommandAttributes start_timer_command_attributes = 3;
     */
    value: StartTimerCommandAttributes;
    case: "startTimerCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes complete_workflow_execution_command_attributes = 4;
     */
    value: CompleteWorkflowExecutionCommandAttributes;
    case: "completeWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.FailWorkflowExecutionCommandAttributes fail_workflow_execution_command_attributes = 5;
     */
    value: FailWorkflowExecutionCommandAttributes;
    case: "failWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes request_cancel_activity_task_command_attributes = 6;
     */
    value: RequestCancelActivityTaskCommandAttributes;
    case: "requestCancelActivityTaskCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.CancelTimerCommandAttributes cancel_timer_command_attributes = 7;
     */
    value: CancelTimerCommandAttributes;
    case: "cancelTimerCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes cancel_workflow_execution_command_attributes = 8;
     */
    value: CancelWorkflowExecutionCommandAttributes;
    case: "cancelWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes request_cancel_external_workflow_execution_command_attributes = 9;
     */
    value: RequestCancelExternalWorkflowExecutionCommandAttributes;
    case: "requestCancelExternalWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.RecordMarkerCommandAttributes record_marker_command_attributes = 10;
     */
    value: RecordMarkerCommandAttributes;
    case: "recordMarkerCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes continue_as_new_workflow_execution_command_attributes = 11;
     */
    value: ContinueAsNewWorkflowExecutionCommandAttributes;
    case: "continueAsNewWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes start_child_workflow_execution_command_attributes = 12;
     */
    value: StartChildWorkflowExecutionCommandAttributes;
    case: "startChildWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes signal_external_workflow_execution_command_attributes = 13;
     */
    value: SignalExternalWorkflowExecutionCommandAttributes;
    case: "signalExternalWorkflowExecutionCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes upsert_workflow_search_attributes_command_attributes = 14;
     */
    value: UpsertWorkflowSearchAttributesCommandAttributes;
    case: "upsertWorkflowSearchAttributesCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.ProtocolMessageCommandAttributes protocol_message_command_attributes = 15;
     */
    value: ProtocolMessageCommandAttributes;
    case: "protocolMessageCommandAttributes";
  } | {
    /**
     * 16 is available for use - it was used as part of a prototype that never made it into a release
     *
     * @generated from field: temporal.api.command.v1.ModifyWorkflowPropertiesCommandAttributes modify_workflow_properties_command_attributes = 17;
     */
    value: ModifyWorkflowPropertiesCommandAttributes;
    case: "modifyWorkflowPropertiesCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.ScheduleNexusOperationCommandAttributes schedule_nexus_operation_command_attributes = 18;
     */
    value: ScheduleNexusOperationCommandAttributes;
    case: "scheduleNexusOperationCommandAttributes";
  } | {
    /**
     * @generated from field: temporal.api.command.v1.RequestCancelNexusOperationCommandAttributes request_cancel_nexus_operation_command_attributes = 19;
     */
    value: RequestCancelNexusOperationCommandAttributes;
    case: "requestCancelNexusOperationCommandAttributes";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.command.v1.Command.
 * Use `create(CommandSchema)` to create a new message.
 */
export const CommandSchema: GenMessage<Command> = /*@__PURE__*/
  messageDesc(file_temporal_api_command_v1_message, 17);

