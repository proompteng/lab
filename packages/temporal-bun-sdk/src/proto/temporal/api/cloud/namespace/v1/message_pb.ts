// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/cloud/namespace/v1/message.proto (package temporal.api.cloud.namespace.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { ResourceState } from "../../resource/v1/message_pb.js";
import { file_temporal_api_cloud_resource_v1_message } from "../../resource/v1/message_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { GCSSpec, S3Spec } from "../../sink/v1/message_pb.js";
import { file_temporal_api_cloud_sink_v1_message } from "../../sink/v1/message_pb.js";
import type { ConnectivityRule } from "../../connectivityrule/v1/message_pb.js";
import { file_temporal_api_cloud_connectivityrule_v1_message } from "../../connectivityrule/v1/message_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/cloud/namespace/v1/message.proto.
 */
export const file_temporal_api_cloud_namespace_v1_message: GenFile = /*@__PURE__*/
  fileDesc("Ci10ZW1wb3JhbC9hcGkvY2xvdWQvbmFtZXNwYWNlL3YxL21lc3NhZ2UucHJvdG8SH3RlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEigQEKFUNlcnRpZmljYXRlRmlsdGVyU3BlYxITCgtjb21tb25fbmFtZRgBIAEoCRIUCgxvcmdhbml6YXRpb24YAiABKAkSGwoTb3JnYW5pemF0aW9uYWxfdW5pdBgDIAEoCRIgChhzdWJqZWN0X2FsdGVybmF0aXZlX25hbWUYBCABKAkiuwEKDE10bHNBdXRoU3BlYxIpCh1hY2NlcHRlZF9jbGllbnRfY2FfZGVwcmVjYXRlZBgBIAEoCUICGAESGgoSYWNjZXB0ZWRfY2xpZW50X2NhGAQgASgMElMKE2NlcnRpZmljYXRlX2ZpbHRlcnMYAiADKAsyNi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkNlcnRpZmljYXRlRmlsdGVyU3BlYxIPCgdlbmFibGVkGAMgASgIIiEKDkFwaUtleUF1dGhTcGVjEg8KB2VuYWJsZWQYASABKAgiMQoNTGlmZWN5Y2xlU3BlYxIgChhlbmFibGVfZGVsZXRlX3Byb3RlY3Rpb24YASABKAgi9AIKD0NvZGVjU2VydmVyU3BlYxIQCghlbmRwb2ludBgBIAEoCRIZChFwYXNzX2FjY2Vzc190b2tlbhgCIAEoCBIoCiBpbmNsdWRlX2Nyb3NzX29yaWdpbl9jcmVkZW50aWFscxgDIAEoCBJhChRjdXN0b21fZXJyb3JfbWVzc2FnZRgEIAEoCzJDLnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEuQ29kZWNTZXJ2ZXJTcGVjLkN1c3RvbUVycm9yTWVzc2FnZRqmAQoSQ3VzdG9tRXJyb3JNZXNzYWdlEmEKB2RlZmF1bHQYASABKAsyUC50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkNvZGVjU2VydmVyU3BlYy5DdXN0b21FcnJvck1lc3NhZ2UuRXJyb3JNZXNzYWdlGi0KDEVycm9yTWVzc2FnZRIPCgdtZXNzYWdlGAEgASgJEgwKBGxpbmsYAiABKAkiOAoUSGlnaEF2YWlsYWJpbGl0eVNwZWMSIAoYZGlzYWJsZV9tYW5hZ2VkX2ZhaWxvdmVyGAEgASgIIt8BCgxDYXBhY2l0eVNwZWMSSwoJb25fZGVtYW5kGAEgASgLMjYudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eVNwZWMuT25EZW1hbmRIABJQCgtwcm92aXNpb25lZBgCIAEoCzI5LnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEuQ2FwYWNpdHlTcGVjLlByb3Zpc2lvbmVkSAAaCgoIT25EZW1hbmQaHAoLUHJvdmlzaW9uZWQSDQoFdmFsdWUYASABKAFCBgoEc3BlYyLcBQoIQ2FwYWNpdHkSRwoJb25fZGVtYW5kGAEgASgLMjIudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eS5PbkRlbWFuZEgAEkwKC3Byb3Zpc2lvbmVkGAIgASgLMjUudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eS5Qcm92aXNpb25lZEgAEkkKDmxhdGVzdF9yZXF1ZXN0GAMgASgLMjEudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eS5SZXF1ZXN0GgoKCE9uRGVtYW5kGiQKC1Byb3Zpc2lvbmVkEhUKDWN1cnJlbnRfdmFsdWUYASABKAEaqwMKB1JlcXVlc3QSRgoFc3RhdGUYASABKA4yNy50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkNhcGFjaXR5LlJlcXVlc3QuU3RhdGUSLgoKc3RhcnRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLAoIZW5kX3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhoKEmFzeW5jX29wZXJhdGlvbl9pZBgEIAEoCRI7CgRzcGVjGAUgASgLMi0udGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eVNwZWMioAEKBVN0YXRlEiYKIlNUQVRFX0NBUEFDSVRZX1JFUVVFU1RfVU5TUEVDSUZJRUQQABIkCiBTVEFURV9DQVBBQ0lUWV9SRVFVRVNUX0NPTVBMRVRFRBABEiYKIlNUQVRFX0NBUEFDSVRZX1JFUVVFU1RfSU5fUFJPR1JFU1MQAhIhCh1TVEFURV9DQVBBQ0lUWV9SRVFVRVNUX0ZBSUxFRBADQg4KDGN1cnJlbnRfbW9kZSLPCQoNTmFtZXNwYWNlU3BlYxIMCgRuYW1lGAEgASgJEg8KB3JlZ2lvbnMYAiADKAkSFgoOcmV0ZW50aW9uX2RheXMYAyABKAUSQAoJbXRsc19hdXRoGAQgASgLMi0udGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5NdGxzQXV0aFNwZWMSRQoMYXBpX2tleV9hdXRoGAcgASgLMi8udGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5BcGlLZXlBdXRoU3BlYxJwChhjdXN0b21fc2VhcmNoX2F0dHJpYnV0ZXMYBSADKAsySi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLk5hbWVzcGFjZVNwZWMuQ3VzdG9tU2VhcmNoQXR0cmlidXRlc0VudHJ5QgIYARJfChFzZWFyY2hfYXR0cmlidXRlcxgIIAMoCzJELnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEuTmFtZXNwYWNlU3BlYy5TZWFyY2hBdHRyaWJ1dGVzRW50cnkSRgoMY29kZWNfc2VydmVyGAYgASgLMjAudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5Db2RlY1NlcnZlclNwZWMSQQoJbGlmZWN5Y2xlGAkgASgLMi4udGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5MaWZlY3ljbGVTcGVjElAKEWhpZ2hfYXZhaWxhYmlsaXR5GAogASgLMjUudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5IaWdoQXZhaWxhYmlsaXR5U3BlYxIdChVjb25uZWN0aXZpdHlfcnVsZV9pZHMYCyADKAkSRAoNY2FwYWNpdHlfc3BlYxgMIAEoCzItLnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEuQ2FwYWNpdHlTcGVjGj0KG0N1c3RvbVNlYXJjaEF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGnsKFVNlYXJjaEF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSUQoFdmFsdWUYAiABKA4yQi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLk5hbWVzcGFjZVNwZWMuU2VhcmNoQXR0cmlidXRlVHlwZToCOAEirAIKE1NlYXJjaEF0dHJpYnV0ZVR5cGUSJQohU0VBUkNIX0FUVFJJQlVURV9UWVBFX1VOU1BFQ0lGSUVEEAASHgoaU0VBUkNIX0FUVFJJQlVURV9UWVBFX1RFWFQQARIhCh1TRUFSQ0hfQVRUUklCVVRFX1RZUEVfS0VZV09SRBACEh0KGVNFQVJDSF9BVFRSSUJVVEVfVFlQRV9JTlQQAxIgChxTRUFSQ0hfQVRUUklCVVRFX1RZUEVfRE9VQkxFEAQSHgoaU0VBUkNIX0FUVFJJQlVURV9UWVBFX0JPT0wQBRIiCh5TRUFSQ0hfQVRUUklCVVRFX1RZUEVfREFURVRJTUUQBhImCiJTRUFSQ0hfQVRUUklCVVRFX1RZUEVfS0VZV09SRF9MSVNUEAciUQoJRW5kcG9pbnRzEhMKC3dlYl9hZGRyZXNzGAEgASgJEhkKEW10bHNfZ3JwY19hZGRyZXNzGAIgASgJEhQKDGdycGNfYWRkcmVzcxgDIAEoCSIqCgZMaW1pdHMSIAoYYWN0aW9uc19wZXJfc2Vjb25kX2xpbWl0GAEgASgFIlgKEkFXU1ByaXZhdGVMaW5rSW5mbxIeChZhbGxvd2VkX3ByaW5jaXBhbF9hcm5zGAEgAygJEiIKGnZwY19lbmRwb2ludF9zZXJ2aWNlX25hbWVzGAIgAygJInQKE1ByaXZhdGVDb25uZWN0aXZpdHkSDgoGcmVnaW9uGAEgASgJEk0KEGF3c19wcml2YXRlX2xpbmsYAiABKAsyMy50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkFXU1ByaXZhdGVMaW5rSW5mbyKDCAoJTmFtZXNwYWNlEhEKCW5hbWVzcGFjZRgBIAEoCRIYChByZXNvdXJjZV92ZXJzaW9uGAIgASgJEjwKBHNwZWMYAyABKAsyLi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLk5hbWVzcGFjZVNwZWMSHAoQc3RhdGVfZGVwcmVjYXRlZBgEIAEoCUICGAESPAoFc3RhdGUYDSABKA4yLS50ZW1wb3JhbC5hcGkuY2xvdWQucmVzb3VyY2UudjEuUmVzb3VyY2VTdGF0ZRIaChJhc3luY19vcGVyYXRpb25faWQYBSABKAkSPQoJZW5kcG9pbnRzGAYgASgLMioudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5FbmRwb2ludHMSFQoNYWN0aXZlX3JlZ2lvbhgHIAEoCRI3CgZsaW1pdHMYCCABKAsyJy50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkxpbWl0cxJUChZwcml2YXRlX2Nvbm5lY3Rpdml0aWVzGAkgAygLMjQudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5Qcml2YXRlQ29ubmVjdGl2aXR5EjAKDGNyZWF0ZWRfdGltZRgKIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNgoSbGFzdF9tb2RpZmllZF90aW1lGAsgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJTCg1yZWdpb25fc3RhdHVzGAwgAygLMjwudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5OYW1lc3BhY2UuUmVnaW9uU3RhdHVzRW50cnkSVAoSY29ubmVjdGl2aXR5X3J1bGVzGA4gAygLMjgudGVtcG9yYWwuYXBpLmNsb3VkLmNvbm5lY3Rpdml0eXJ1bGUudjEuQ29ubmVjdGl2aXR5UnVsZRJCCgR0YWdzGA8gAygLMjQudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5OYW1lc3BhY2UuVGFnc0VudHJ5EjsKCGNhcGFjaXR5GBAgASgLMikudGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5DYXBhY2l0eRprChFSZWdpb25TdGF0dXNFbnRyeRILCgNrZXkYASABKAkSRQoFdmFsdWUYAiABKAsyNi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLk5hbWVzcGFjZVJlZ2lvblN0YXR1czoCOAEaKwoJVGFnc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEimwIKFU5hbWVzcGFjZVJlZ2lvblN0YXR1cxIcChBzdGF0ZV9kZXByZWNhdGVkGAEgASgJQgIYARJLCgVzdGF0ZRgDIAEoDjI8LnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjEuTmFtZXNwYWNlUmVnaW9uU3RhdHVzLlN0YXRlEhoKEmFzeW5jX29wZXJhdGlvbl9pZBgCIAEoCSJ7CgVTdGF0ZRIVChFTVEFURV9VTlNQRUNJRklFRBAAEhAKDFNUQVRFX0FERElORxABEhAKDFNUQVRFX0FDVElWRRACEhEKDVNUQVRFX1BBU1NJVkUQAxISCg5TVEFURV9SRU1PVklORxAEEhAKDFNUQVRFX0ZBSUxFRBAFIpEBCg5FeHBvcnRTaW5rU3BlYxIMCgRuYW1lGAEgASgJEg8KB2VuYWJsZWQYAiABKAgSLgoCczMYAyABKAsyIi50ZW1wb3JhbC5hcGkuY2xvdWQuc2luay52MS5TM1NwZWMSMAoDZ2NzGAQgASgLMiMudGVtcG9yYWwuYXBpLmNsb3VkLnNpbmsudjEuR0NTU3BlYyL2AwoKRXhwb3J0U2luaxIMCgRuYW1lGAEgASgJEhgKEHJlc291cmNlX3ZlcnNpb24YAiABKAkSPAoFc3RhdGUYAyABKA4yLS50ZW1wb3JhbC5hcGkuY2xvdWQucmVzb3VyY2UudjEuUmVzb3VyY2VTdGF0ZRI9CgRzcGVjGAQgASgLMi8udGVtcG9yYWwuYXBpLmNsb3VkLm5hbWVzcGFjZS52MS5FeHBvcnRTaW5rU3BlYxJCCgZoZWFsdGgYBSABKA4yMi50ZW1wb3JhbC5hcGkuY2xvdWQubmFtZXNwYWNlLnYxLkV4cG9ydFNpbmsuSGVhbHRoEhUKDWVycm9yX21lc3NhZ2UYBiABKAkSOwoXbGF0ZXN0X2RhdGFfZXhwb3J0X3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjoKFmxhc3RfaGVhbHRoX2NoZWNrX3RpbWUYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIm8KBkhlYWx0aBIWChJIRUFMVEhfVU5TUEVDSUZJRUQQABINCglIRUFMVEhfT0sQARIZChVIRUFMVEhfRVJST1JfSU5URVJOQUwQAhIjCh9IRUFMVEhfRVJST1JfVVNFUl9DT05GSUdVUkFUSU9OEANCsQEKImlvLnRlbXBvcmFsLmFwaS5jbG91ZC5uYW1lc3BhY2UudjFCDE1lc3NhZ2VQcm90b1ABWi9nby50ZW1wb3JhbC5pby9hcGkvY2xvdWQvbmFtZXNwYWNlL3YxO25hbWVzcGFjZaoCIVRlbXBvcmFsaW8uQXBpLkNsb3VkLk5hbWVzcGFjZS5WMeoCJVRlbXBvcmFsaW86OkFwaTo6Q2xvdWQ6Ok5hbWVzcGFjZTo6VjFiBnByb3RvMw", [file_temporal_api_cloud_resource_v1_message, file_google_protobuf_timestamp, file_temporal_api_cloud_sink_v1_message, file_temporal_api_cloud_connectivityrule_v1_message]);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CertificateFilterSpec
 */
export type CertificateFilterSpec = Message<"temporal.api.cloud.namespace.v1.CertificateFilterSpec"> & {
  /**
   * The common_name in the certificate.
   * Optional, default is empty.
   *
   * @generated from field: string common_name = 1;
   */
  commonName: string;

  /**
   * The organization in the certificate.
   * Optional, default is empty.
   *
   * @generated from field: string organization = 2;
   */
  organization: string;

  /**
   * The organizational_unit in the certificate.
   * Optional, default is empty.
   *
   * @generated from field: string organizational_unit = 3;
   */
  organizationalUnit: string;

  /**
   * The subject_alternative_name in the certificate.
   * Optional, default is empty.
   *
   * @generated from field: string subject_alternative_name = 4;
   */
  subjectAlternativeName: string;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CertificateFilterSpec.
 * Use `create(CertificateFilterSpecSchema)` to create a new message.
 */
export const CertificateFilterSpecSchema: GenMessage<CertificateFilterSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.MtlsAuthSpec
 */
export type MtlsAuthSpec = Message<"temporal.api.cloud.namespace.v1.MtlsAuthSpec"> & {
  /**
   * The base64 encoded ca cert(s) in PEM format that the clients can use for authentication and authorization.
   * This must only be one value, but the CA can have a chain.
   *
   * (-- api-linter: core::0140::base64=disabled --)
   * Deprecated: Not supported after v0.2.0 api version. Use accepted_client_ca instead.
   * temporal:versioning:max_version=v0.2.0
   *
   * @generated from field: string accepted_client_ca_deprecated = 1 [deprecated = true];
   * @deprecated
   */
  acceptedClientCaDeprecated: string;

  /**
   * The ca cert(s) in PEM format that the clients can use for authentication and authorization.
   * This must only be one value, but the CA can have a chain.
   * temporal:versioning:min_version=v0.2.0
   *
   * @generated from field: bytes accepted_client_ca = 4;
   */
  acceptedClientCa: Uint8Array;

  /**
   * Certificate filters which, if specified, only allow connections from client certificates whose distinguished name properties match at least one of the filters.
   * This allows limiting access to specific end-entity certificates.
   * Optional, default is empty.
   *
   * @generated from field: repeated temporal.api.cloud.namespace.v1.CertificateFilterSpec certificate_filters = 2;
   */
  certificateFilters: CertificateFilterSpec[];

  /**
   * Flag to enable mTLS auth (default: disabled).
   * Note: disabling mTLS auth will cause existing mTLS connections to fail.
   * temporal:versioning:min_version=v0.2.0
   *
   * @generated from field: bool enabled = 3;
   */
  enabled: boolean;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.MtlsAuthSpec.
 * Use `create(MtlsAuthSpecSchema)` to create a new message.
 */
export const MtlsAuthSpecSchema: GenMessage<MtlsAuthSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 1);

/**
 * @generated from message temporal.api.cloud.namespace.v1.ApiKeyAuthSpec
 */
export type ApiKeyAuthSpec = Message<"temporal.api.cloud.namespace.v1.ApiKeyAuthSpec"> & {
  /**
   * Flag to enable API key auth (default: disabled).
   * Note: disabling API key auth will cause existing API key connections to fail.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.ApiKeyAuthSpec.
 * Use `create(ApiKeyAuthSpecSchema)` to create a new message.
 */
export const ApiKeyAuthSpecSchema: GenMessage<ApiKeyAuthSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 2);

/**
 * @generated from message temporal.api.cloud.namespace.v1.LifecycleSpec
 */
export type LifecycleSpec = Message<"temporal.api.cloud.namespace.v1.LifecycleSpec"> & {
  /**
   * Flag to enable delete protection for the namespace.
   *
   * @generated from field: bool enable_delete_protection = 1;
   */
  enableDeleteProtection: boolean;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.LifecycleSpec.
 * Use `create(LifecycleSpecSchema)` to create a new message.
 */
export const LifecycleSpecSchema: GenMessage<LifecycleSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 3);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CodecServerSpec
 */
export type CodecServerSpec = Message<"temporal.api.cloud.namespace.v1.CodecServerSpec"> & {
  /**
   * The codec server endpoint.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Whether to pass the user access token with your endpoint.
   *
   * @generated from field: bool pass_access_token = 2;
   */
  passAccessToken: boolean;

  /**
   * Whether to include cross-origin credentials.
   *
   * @generated from field: bool include_cross_origin_credentials = 3;
   */
  includeCrossOriginCredentials: boolean;

  /**
   * A custom error message to display for remote codec server errors.
   * temporal:versioning:min_version=v0.5.1
   *
   * @generated from field: temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage custom_error_message = 4;
   */
  customErrorMessage?: CodecServerSpec_CustomErrorMessage;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CodecServerSpec.
 * Use `create(CodecServerSpecSchema)` to create a new message.
 */
export const CodecServerSpecSchema: GenMessage<CodecServerSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 4);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage
 */
export type CodecServerSpec_CustomErrorMessage = Message<"temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage"> & {
  /**
   * The error message to display by default for any remote codec server errors.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.ErrorMessage default = 1;
   */
  default?: CodecServerSpec_CustomErrorMessage_ErrorMessage;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.
 * Use `create(CodecServerSpec_CustomErrorMessageSchema)` to create a new message.
 */
export const CodecServerSpec_CustomErrorMessageSchema: GenMessage<CodecServerSpec_CustomErrorMessage> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 4, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.ErrorMessage
 */
export type CodecServerSpec_CustomErrorMessage_ErrorMessage = Message<"temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.ErrorMessage"> & {
  /**
   * A message to display.
   *
   * @generated from field: string message = 1;
   */
  message: string;

  /**
   * A link that is displayed along side the configured message.
   *
   * @generated from field: string link = 2;
   */
  link: string;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CodecServerSpec.CustomErrorMessage.ErrorMessage.
 * Use `create(CodecServerSpec_CustomErrorMessage_ErrorMessageSchema)` to create a new message.
 */
export const CodecServerSpec_CustomErrorMessage_ErrorMessageSchema: GenMessage<CodecServerSpec_CustomErrorMessage_ErrorMessage> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 4, 0, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.HighAvailabilitySpec
 */
export type HighAvailabilitySpec = Message<"temporal.api.cloud.namespace.v1.HighAvailabilitySpec"> & {
  /**
   * Flag to disable managed failover for the namespace.
   *
   * @generated from field: bool disable_managed_failover = 1;
   */
  disableManagedFailover: boolean;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.HighAvailabilitySpec.
 * Use `create(HighAvailabilitySpecSchema)` to create a new message.
 */
export const HighAvailabilitySpecSchema: GenMessage<HighAvailabilitySpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 5);

/**
 * temporal:versioning:min_version=v0.10.0
 *
 * @generated from message temporal.api.cloud.namespace.v1.CapacitySpec
 */
export type CapacitySpec = Message<"temporal.api.cloud.namespace.v1.CapacitySpec"> & {
  /**
   * @generated from oneof temporal.api.cloud.namespace.v1.CapacitySpec.spec
   */
  spec: {
    /**
     * The on-demand capacity mode configuration.
     *
     * @generated from field: temporal.api.cloud.namespace.v1.CapacitySpec.OnDemand on_demand = 1;
     */
    value: CapacitySpec_OnDemand;
    case: "onDemand";
  } | {
    /**
     * The provisioned capacity mode configuration.
     *
     * @generated from field: temporal.api.cloud.namespace.v1.CapacitySpec.Provisioned provisioned = 2;
     */
    value: CapacitySpec_Provisioned;
    case: "provisioned";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CapacitySpec.
 * Use `create(CapacitySpecSchema)` to create a new message.
 */
export const CapacitySpecSchema: GenMessage<CapacitySpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 6);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CapacitySpec.OnDemand
 */
export type CapacitySpec_OnDemand = Message<"temporal.api.cloud.namespace.v1.CapacitySpec.OnDemand"> & {
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CapacitySpec.OnDemand.
 * Use `create(CapacitySpec_OnDemandSchema)` to create a new message.
 */
export const CapacitySpec_OnDemandSchema: GenMessage<CapacitySpec_OnDemand> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 6, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.CapacitySpec.Provisioned
 */
export type CapacitySpec_Provisioned = Message<"temporal.api.cloud.namespace.v1.CapacitySpec.Provisioned"> & {
  /**
   * The units of provisioned capacity in TRU (Temporal Resource Units).
   * Each TRU unit assigned to the namespace will entitle it with additional APS limits as specified in the documentation.
   *
   * @generated from field: double value = 1;
   */
  value: number;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.CapacitySpec.Provisioned.
 * Use `create(CapacitySpec_ProvisionedSchema)` to create a new message.
 */
export const CapacitySpec_ProvisionedSchema: GenMessage<CapacitySpec_Provisioned> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 6, 1);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Capacity
 */
export type Capacity = Message<"temporal.api.cloud.namespace.v1.Capacity"> & {
  /**
   * @generated from oneof temporal.api.cloud.namespace.v1.Capacity.current_mode
   */
  currentMode: {
    /**
     * The status of on-demand capacity mode.
     *
     * @generated from field: temporal.api.cloud.namespace.v1.Capacity.OnDemand on_demand = 1;
     */
    value: Capacity_OnDemand;
    case: "onDemand";
  } | {
    /**
     * The status of provisioned capacity mode.
     *
     * @generated from field: temporal.api.cloud.namespace.v1.Capacity.Provisioned provisioned = 2;
     */
    value: Capacity_Provisioned;
    case: "provisioned";
  } | { case: undefined; value?: undefined };

  /**
   * The latest requested capacity for the namespace, if any.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.Capacity.Request latest_request = 3;
   */
  latestRequest?: Capacity_Request;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Capacity.
 * Use `create(CapacitySchema)` to create a new message.
 */
export const CapacitySchema: GenMessage<Capacity> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 7);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Capacity.OnDemand
 */
export type Capacity_OnDemand = Message<"temporal.api.cloud.namespace.v1.Capacity.OnDemand"> & {
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Capacity.OnDemand.
 * Use `create(Capacity_OnDemandSchema)` to create a new message.
 */
export const Capacity_OnDemandSchema: GenMessage<Capacity_OnDemand> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 7, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Capacity.Provisioned
 */
export type Capacity_Provisioned = Message<"temporal.api.cloud.namespace.v1.Capacity.Provisioned"> & {
  /**
   * The current provisioned capacity for the namespace in Temporal Resource Units.
   * Can be different from the requested capacity in latest_request if the request is still in progress.
   *
   * @generated from field: double current_value = 1;
   */
  currentValue: number;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Capacity.Provisioned.
 * Use `create(Capacity_ProvisionedSchema)` to create a new message.
 */
export const Capacity_ProvisionedSchema: GenMessage<Capacity_Provisioned> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 7, 1);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Capacity.Request
 */
export type Capacity_Request = Message<"temporal.api.cloud.namespace.v1.Capacity.Request"> & {
  /**
   * The current state of the capacity request (e.g. in-progress, completed, failed).
   *
   * @generated from field: temporal.api.cloud.namespace.v1.Capacity.Request.State state = 1;
   */
  state: Capacity_Request_State;

  /**
   * The date and time when the capacity request was created.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * The date and time when the capacity request was completed or failed.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 3;
   */
  endTime?: Timestamp;

  /**
   * The id of the async operation that is creating/updating/deleting the capacity, if any.
   *
   * @generated from field: string async_operation_id = 4;
   */
  asyncOperationId: string;

  /**
   * The requested capacity specification.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.CapacitySpec spec = 5;
   */
  spec?: CapacitySpec;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Capacity.Request.
 * Use `create(Capacity_RequestSchema)` to create a new message.
 */
export const Capacity_RequestSchema: GenMessage<Capacity_Request> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 7, 2);

/**
 * @generated from enum temporal.api.cloud.namespace.v1.Capacity.Request.State
 */
export enum Capacity_Request_State {
  /**
   * @generated from enum value: STATE_CAPACITY_REQUEST_UNSPECIFIED = 0;
   */
  CAPACITY_REQUEST_UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATE_CAPACITY_REQUEST_COMPLETED = 1;
   */
  CAPACITY_REQUEST_COMPLETED = 1,

  /**
   * @generated from enum value: STATE_CAPACITY_REQUEST_IN_PROGRESS = 2;
   */
  CAPACITY_REQUEST_IN_PROGRESS = 2,

  /**
   * @generated from enum value: STATE_CAPACITY_REQUEST_FAILED = 3;
   */
  CAPACITY_REQUEST_FAILED = 3,
}

/**
 * Describes the enum temporal.api.cloud.namespace.v1.Capacity.Request.State.
 */
export const Capacity_Request_StateSchema: GenEnum<Capacity_Request_State> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_namespace_v1_message, 7, 2, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.NamespaceSpec
 */
export type NamespaceSpec = Message<"temporal.api.cloud.namespace.v1.NamespaceSpec"> & {
  /**
   * The name to use for the namespace.
   * This will create a namespace that's available at '<name>.<account>.tmprl.cloud:7233'.
   * The name is immutable. Once set, it cannot be changed.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The ids of the regions where the namespace should be available.
   * The GetRegions API can be used to get the list of valid region ids.
   * Specifying more than one region makes the namespace "global", which is currently a preview only feature with restricted access.
   * Please reach out to Temporal support for more information on global namespaces.
   * When provisioned the global namespace will be active on the first region in the list and passive on the rest.
   * Number of supported regions is 2.
   * The regions is immutable. Once set, it cannot be changed.
   * Example: ["aws-us-west-2"].
   *
   * @generated from field: repeated string regions = 2;
   */
  regions: string[];

  /**
   * The number of days the workflows data will be retained for.
   * Changes to the retention period may impact your storage costs.
   * Any changes to the retention period will be applied to all new running workflows.
   *
   * @generated from field: int32 retention_days = 3;
   */
  retentionDays: number;

  /**
   * The mTLS auth configuration for the namespace.
   * If unspecified, mTLS will be disabled.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.MtlsAuthSpec mtls_auth = 4;
   */
  mtlsAuth?: MtlsAuthSpec;

  /**
   * The API key auth configuration for the namespace.
   * If unspecified, API keys will be disabled.
   * temporal:versioning:min_version=v0.2.0
   *
   * @generated from field: temporal.api.cloud.namespace.v1.ApiKeyAuthSpec api_key_auth = 7;
   */
  apiKeyAuth?: ApiKeyAuthSpec;

  /**
   * The custom search attributes to use for the namespace.
   * The name of the attribute is the key and the type is the value.
   * Supported attribute types: text, keyword, int, double, bool, datetime, keyword_list.
   * NOTE: currently deleting a search attribute is not supported.
   * Optional, default is empty.
   * Deprecated: Not supported after v0.3.0 api version. Use search_attributes instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: map<string, string> custom_search_attributes = 5 [deprecated = true];
   * @deprecated
   */
  customSearchAttributes: { [key: string]: string };

  /**
   * The custom search attributes to use for the namespace.
   * The name of the attribute is the key and the type is the value.
   * Note: currently deleting a search attribute is not supported.
   * Optional, default is empty.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=custom_search_attributes
   *
   * @generated from field: map<string, temporal.api.cloud.namespace.v1.NamespaceSpec.SearchAttributeType> search_attributes = 8;
   */
  searchAttributes: { [key: string]: NamespaceSpec_SearchAttributeType };

  /**
   * Codec server spec used by UI to decode payloads for all users interacting with this namespace.
   * Optional, default is unset.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.CodecServerSpec codec_server = 6;
   */
  codecServer?: CodecServerSpec;

  /**
   * The lifecycle configuration for the namespace.
   * temporal:versioning:min_version=v0.4.0
   *
   * @generated from field: temporal.api.cloud.namespace.v1.LifecycleSpec lifecycle = 9;
   */
  lifecycle?: LifecycleSpec;

  /**
   * The high availability configuration for the namespace.
   * temporal:versioning:min_version=v0.4.0
   *
   * @generated from field: temporal.api.cloud.namespace.v1.HighAvailabilitySpec high_availability = 10;
   */
  highAvailability?: HighAvailabilitySpec;

  /**
   * The private connectivity configuration for the namespace.
   * This will apply the connectivity rules specified to the namespace.
   * temporal:versioning:min_version=v0.6.0
   *
   * @generated from field: repeated string connectivity_rule_ids = 11;
   */
  connectivityRuleIds: string[];

  /**
   * The capacity configuration for the namespace.
   * There are two capacity modes: on-demand and provisioned.
   * On-demand capacity mode allows the namespace to scale automatically based on usage.
   * Provisioned capacity mode allows the user to specify a fixed amount of capacity (in TRUs) for the namespace.
   * Can be changed only when the last capacity request is not in progress.
   * temporal:versioning:min_version=v0.10.0
   *
   * @generated from field: temporal.api.cloud.namespace.v1.CapacitySpec capacity_spec = 12;
   */
  capacitySpec?: CapacitySpec;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.NamespaceSpec.
 * Use `create(NamespaceSpecSchema)` to create a new message.
 */
export const NamespaceSpecSchema: GenMessage<NamespaceSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 8);

/**
 * @generated from enum temporal.api.cloud.namespace.v1.NamespaceSpec.SearchAttributeType
 */
export enum NamespaceSpec_SearchAttributeType {
  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_TEXT = 1;
   */
  TEXT = 1,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_KEYWORD = 2;
   */
  KEYWORD = 2,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_INT = 3;
   */
  INT = 3,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_DOUBLE = 4;
   */
  DOUBLE = 4,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_BOOL = 5;
   */
  BOOL = 5,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_DATETIME = 6;
   */
  DATETIME = 6,

  /**
   * @generated from enum value: SEARCH_ATTRIBUTE_TYPE_KEYWORD_LIST = 7;
   */
  KEYWORD_LIST = 7,
}

/**
 * Describes the enum temporal.api.cloud.namespace.v1.NamespaceSpec.SearchAttributeType.
 */
export const NamespaceSpec_SearchAttributeTypeSchema: GenEnum<NamespaceSpec_SearchAttributeType> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_namespace_v1_message, 8, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Endpoints
 */
export type Endpoints = Message<"temporal.api.cloud.namespace.v1.Endpoints"> & {
  /**
   * The web UI address.
   *
   * @generated from field: string web_address = 1;
   */
  webAddress: string;

  /**
   * The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
   *
   * @generated from field: string mtls_grpc_address = 2;
   */
  mtlsGrpcAddress: string;

  /**
   * The gRPC address for API key client connections (may be empty if API keys are disabled).
   *
   * @generated from field: string grpc_address = 3;
   */
  grpcAddress: string;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Endpoints.
 * Use `create(EndpointsSchema)` to create a new message.
 */
export const EndpointsSchema: GenMessage<Endpoints> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 9);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Limits
 */
export type Limits = Message<"temporal.api.cloud.namespace.v1.Limits"> & {
  /**
   * The number of actions per second (APS) that is currently allowed for the namespace.
   * The namespace may be throttled if its APS exceeds the limit.
   *
   * @generated from field: int32 actions_per_second_limit = 1;
   */
  actionsPerSecondLimit: number;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Limits.
 * Use `create(LimitsSchema)` to create a new message.
 */
export const LimitsSchema: GenMessage<Limits> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 10);

/**
 * @generated from message temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo
 */
export type AWSPrivateLinkInfo = Message<"temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo"> & {
  /**
   * The list of principal arns that are allowed to access the namespace on the private link.
   *
   * @generated from field: repeated string allowed_principal_arns = 1;
   */
  allowedPrincipalArns: string[];

  /**
   * The list of vpc endpoint service names that are associated with the namespace.
   *
   * @generated from field: repeated string vpc_endpoint_service_names = 2;
   */
  vpcEndpointServiceNames: string[];
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo.
 * Use `create(AWSPrivateLinkInfoSchema)` to create a new message.
 */
export const AWSPrivateLinkInfoSchema: GenMessage<AWSPrivateLinkInfo> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 11);

/**
 * @generated from message temporal.api.cloud.namespace.v1.PrivateConnectivity
 */
export type PrivateConnectivity = Message<"temporal.api.cloud.namespace.v1.PrivateConnectivity"> & {
  /**
   * The id of the region where the private connectivity applies.
   *
   * @generated from field: string region = 1;
   */
  region: string;

  /**
   * The AWS PrivateLink info.
   * This will only be set for an aws region.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.AWSPrivateLinkInfo aws_private_link = 2;
   */
  awsPrivateLink?: AWSPrivateLinkInfo;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.PrivateConnectivity.
 * Use `create(PrivateConnectivitySchema)` to create a new message.
 */
export const PrivateConnectivitySchema: GenMessage<PrivateConnectivity> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 12);

/**
 * @generated from message temporal.api.cloud.namespace.v1.Namespace
 */
export type Namespace = Message<"temporal.api.cloud.namespace.v1.Namespace"> & {
  /**
   * The namespace identifier.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The current version of the namespace specification.
   * The next update operation will have to include this version.
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The namespace specification.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.NamespaceSpec spec = 3;
   */
  spec?: NamespaceSpec;

  /**
   * The current state of the namespace.
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 4 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the namespace.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 13;
   */
  state: ResourceState;

  /**
   * The id of the async operation that is creating/updating/deleting the namespace, if any.
   *
   * @generated from field: string async_operation_id = 5;
   */
  asyncOperationId: string;

  /**
   * The endpoints for the namespace.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.Endpoints endpoints = 6;
   */
  endpoints?: Endpoints;

  /**
   * The currently active region for the namespace.
   *
   * @generated from field: string active_region = 7;
   */
  activeRegion: string;

  /**
   * The limits set on the namespace currently.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.Limits limits = 8;
   */
  limits?: Limits;

  /**
   * The private connectivities for the namespace, if any.
   *
   * @generated from field: repeated temporal.api.cloud.namespace.v1.PrivateConnectivity private_connectivities = 9;
   */
  privateConnectivities: PrivateConnectivity[];

  /**
   * The date and time when the namespace was created.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 10;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the namespace was last modified.
   * Will not be set if the namespace has never been modified.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_time = 11;
   */
  lastModifiedTime?: Timestamp;

  /**
   * The status of each region where the namespace is available.
   * The id of the region is the key and the status is the value of the map.
   *
   * @generated from field: map<string, temporal.api.cloud.namespace.v1.NamespaceRegionStatus> region_status = 12;
   */
  regionStatus: { [key: string]: NamespaceRegionStatus };

  /**
   * The connectivity rules that are set on this namespace.
   *
   * @generated from field: repeated temporal.api.cloud.connectivityrule.v1.ConnectivityRule connectivity_rules = 14;
   */
  connectivityRules: ConnectivityRule[];

  /**
   * The tags for the namespace.
   *
   * @generated from field: map<string, string> tags = 15;
   */
  tags: { [key: string]: string };

  /**
   * The status of namespace's capacity, if any.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.Capacity capacity = 16;
   */
  capacity?: Capacity;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.Namespace.
 * Use `create(NamespaceSchema)` to create a new message.
 */
export const NamespaceSchema: GenMessage<Namespace> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 13);

/**
 * @generated from message temporal.api.cloud.namespace.v1.NamespaceRegionStatus
 */
export type NamespaceRegionStatus = Message<"temporal.api.cloud.namespace.v1.NamespaceRegionStatus"> & {
  /**
   * The current state of the namespace region.
   * Possible values: adding, active, passive, removing, failed.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 1 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the namespace region.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.namespace.v1.NamespaceRegionStatus.State state = 3;
   */
  state: NamespaceRegionStatus_State;

  /**
   * The id of the async operation that is making changes to where the namespace is available, if any.
   *
   * @generated from field: string async_operation_id = 2;
   */
  asyncOperationId: string;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.NamespaceRegionStatus.
 * Use `create(NamespaceRegionStatusSchema)` to create a new message.
 */
export const NamespaceRegionStatusSchema: GenMessage<NamespaceRegionStatus> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 14);

/**
 * @generated from enum temporal.api.cloud.namespace.v1.NamespaceRegionStatus.State
 */
export enum NamespaceRegionStatus_State {
  /**
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The region is being added to the namespace.
   *
   * @generated from enum value: STATE_ADDING = 1;
   */
  ADDING = 1,

  /**
   * The namespace is active in this region.
   *
   * @generated from enum value: STATE_ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * The namespace is passive in this region.
   *
   * @generated from enum value: STATE_PASSIVE = 3;
   */
  PASSIVE = 3,

  /**
   * The region is being removed from the namespace.
   *
   * @generated from enum value: STATE_REMOVING = 4;
   */
  REMOVING = 4,

  /**
   * The region failed to be added/removed, check failure_reason in the last async_operation status for more details.
   *
   * @generated from enum value: STATE_FAILED = 5;
   */
  FAILED = 5,
}

/**
 * Describes the enum temporal.api.cloud.namespace.v1.NamespaceRegionStatus.State.
 */
export const NamespaceRegionStatus_StateSchema: GenEnum<NamespaceRegionStatus_State> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_namespace_v1_message, 14, 0);

/**
 * @generated from message temporal.api.cloud.namespace.v1.ExportSinkSpec
 */
export type ExportSinkSpec = Message<"temporal.api.cloud.namespace.v1.ExportSinkSpec"> & {
  /**
   * The unique name of the export sink, it can't be changed once set.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A flag indicating whether the export sink is enabled or not.
   *
   * @generated from field: bool enabled = 2;
   */
  enabled: boolean;

  /**
   * The S3 configuration details when destination_type is S3.
   *
   * @generated from field: temporal.api.cloud.sink.v1.S3Spec s3 = 3;
   */
  s3?: S3Spec;

  /**
   * This is a feature under development. We will allow GCS sink support for GCP Namespaces.
   * The GCS configuration details when destination_type is GCS.
   *
   * @generated from field: temporal.api.cloud.sink.v1.GCSSpec gcs = 4;
   */
  gcs?: GCSSpec;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.ExportSinkSpec.
 * Use `create(ExportSinkSpecSchema)` to create a new message.
 */
export const ExportSinkSpecSchema: GenMessage<ExportSinkSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 15);

/**
 * @generated from message temporal.api.cloud.namespace.v1.ExportSink
 */
export type ExportSink = Message<"temporal.api.cloud.namespace.v1.ExportSink"> & {
  /**
   * The unique name of the export sink, once set it can't be changed
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The version of the export sink resource.
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The current state of the export sink.
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 3;
   */
  state: ResourceState;

  /**
   * The specification details of the export sink.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.ExportSinkSpec spec = 4;
   */
  spec?: ExportSinkSpec;

  /**
   * The health status of the export sink.
   *
   * @generated from field: temporal.api.cloud.namespace.v1.ExportSink.Health health = 5;
   */
  health: ExportSink_Health;

  /**
   * An error message describing any issues with the export sink, if applicable.
   *
   * @generated from field: string error_message = 6;
   */
  errorMessage: string;

  /**
   * The timestamp of the latest successful data export.
   *
   * @generated from field: google.protobuf.Timestamp latest_data_export_time = 7;
   */
  latestDataExportTime?: Timestamp;

  /**
   * The timestamp of the last health check performed on the export sink.
   *
   * @generated from field: google.protobuf.Timestamp last_health_check_time = 8;
   */
  lastHealthCheckTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.namespace.v1.ExportSink.
 * Use `create(ExportSinkSchema)` to create a new message.
 */
export const ExportSinkSchema: GenMessage<ExportSink> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_namespace_v1_message, 16);

/**
 * @generated from enum temporal.api.cloud.namespace.v1.ExportSink.Health
 */
export enum ExportSink_Health {
  /**
   * @generated from enum value: HEALTH_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HEALTH_OK = 1;
   */
  OK = 1,

  /**
   * @generated from enum value: HEALTH_ERROR_INTERNAL = 2;
   */
  ERROR_INTERNAL = 2,

  /**
   * @generated from enum value: HEALTH_ERROR_USER_CONFIGURATION = 3;
   */
  ERROR_USER_CONFIGURATION = 3,
}

/**
 * Describes the enum temporal.api.cloud.namespace.v1.ExportSink.Health.
 */
export const ExportSink_HealthSchema: GenEnum<ExportSink_Health> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_namespace_v1_message, 16, 0);

