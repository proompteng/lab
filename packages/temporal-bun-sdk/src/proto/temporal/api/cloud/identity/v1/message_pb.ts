// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/cloud/identity/v1/message.proto (package temporal.api.cloud.identity.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { ResourceState } from "../../resource/v1/message_pb.js";
import { file_temporal_api_cloud_resource_v1_message } from "../../resource/v1/message_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/cloud/identity/v1/message.proto.
 */
export const file_temporal_api_cloud_identity_v1_message: GenFile = /*@__PURE__*/
  fileDesc("Cix0ZW1wb3JhbC9hcGkvY2xvdWQvaWRlbnRpdHkvdjEvbWVzc2FnZS5wcm90bxIedGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxIv8BCg1BY2NvdW50QWNjZXNzEhsKD3JvbGVfZGVwcmVjYXRlZBgBIAEoCUICGAESQAoEcm9sZRgCIAEoDjIyLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5BY2NvdW50QWNjZXNzLlJvbGUijgEKBFJvbGUSFAoQUk9MRV9VTlNQRUNJRklFRBAAEg4KClJPTEVfT1dORVIQARIOCgpST0xFX0FETUlOEAISEgoOUk9MRV9ERVZFTE9QRVIQAxIWChJST0xFX0ZJTkFOQ0VfQURNSU4QBBINCglST0xFX1JFQUQQBRIVChFST0xFX01FVFJJQ1NfUkVBRBAGIu8BCg9OYW1lc3BhY2VBY2Nlc3MSIQoVcGVybWlzc2lvbl9kZXByZWNhdGVkGAEgASgJQgIYARJOCgpwZXJtaXNzaW9uGAIgASgOMjoudGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLk5hbWVzcGFjZUFjY2Vzcy5QZXJtaXNzaW9uImkKClBlcm1pc3Npb24SGgoWUEVSTUlTU0lPTl9VTlNQRUNJRklFRBAAEhQKEFBFUk1JU1NJT05fQURNSU4QARIUChBQRVJNSVNTSU9OX1dSSVRFEAISEwoPUEVSTUlTU0lPTl9SRUFEEAMilQIKBkFjY2VzcxJFCg5hY2NvdW50X2FjY2VzcxgBIAEoCzItLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5BY2NvdW50QWNjZXNzElkKEm5hbWVzcGFjZV9hY2Nlc3NlcxgCIAMoCzI9LnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5BY2Nlc3MuTmFtZXNwYWNlQWNjZXNzZXNFbnRyeRppChZOYW1lc3BhY2VBY2Nlc3Nlc0VudHJ5EgsKA2tleRgBIAEoCRI+CgV2YWx1ZRgCIAEoCzIvLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5OYW1lc3BhY2VBY2Nlc3M6AjgBImsKFU5hbWVzcGFjZVNjb3BlZEFjY2VzcxIRCgluYW1lc3BhY2UYASABKAkSPwoGYWNjZXNzGAIgASgLMi8udGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLk5hbWVzcGFjZUFjY2VzcyJRCghVc2VyU3BlYxINCgVlbWFpbBgBIAEoCRI2CgZhY2Nlc3MYAiABKAsyJi50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjEuQWNjZXNzInAKCkludml0YXRpb24SMAoMY3JlYXRlZF90aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIwCgxleHBpcmVkX3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIoYDCgRVc2VyEgoKAmlkGAEgASgJEhgKEHJlc291cmNlX3ZlcnNpb24YAiABKAkSNgoEc3BlYxgDIAEoCzIoLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5Vc2VyU3BlYxIcChBzdGF0ZV9kZXByZWNhdGVkGAQgASgJQgIYARI8CgVzdGF0ZRgJIAEoDjItLnRlbXBvcmFsLmFwaS5jbG91ZC5yZXNvdXJjZS52MS5SZXNvdXJjZVN0YXRlEhoKEmFzeW5jX29wZXJhdGlvbl9pZBgFIAEoCRI+CgppbnZpdGF0aW9uGAYgASgLMioudGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLkludml0YXRpb24SMAoMY3JlYXRlZF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI2ChJsYXN0X21vZGlmaWVkX3RpbWUYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIigKD0dvb2dsZUdyb3VwU3BlYxIVCg1lbWFpbF9hZGRyZXNzGAEgASgJIh8KDVNDSU1Hcm91cFNwZWMSDgoGaWRwX2lkGAEgASgJIhAKDkNsb3VkR3JvdXBTcGVjIsACCg1Vc2VyR3JvdXBTcGVjEhQKDGRpc3BsYXlfbmFtZRgBIAEoCRI2CgZhY2Nlc3MYAiABKAsyJi50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjEuQWNjZXNzEkcKDGdvb2dsZV9ncm91cBgDIAEoCzIvLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5Hb29nbGVHcm91cFNwZWNIABJDCgpzY2ltX2dyb3VwGAQgASgLMi0udGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLlNDSU1Hcm91cFNwZWNIABJFCgtjbG91ZF9ncm91cBgFIAEoCzIuLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5DbG91ZEdyb3VwU3BlY0gAQgwKCmdyb3VwX3R5cGUi0AIKCVVzZXJHcm91cBIKCgJpZBgBIAEoCRIYChByZXNvdXJjZV92ZXJzaW9uGAIgASgJEjsKBHNwZWMYAyABKAsyLS50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjEuVXNlckdyb3VwU3BlYxIcChBzdGF0ZV9kZXByZWNhdGVkGAQgASgJQgIYARI8CgVzdGF0ZRgIIAEoDjItLnRlbXBvcmFsLmFwaS5jbG91ZC5yZXNvdXJjZS52MS5SZXNvdXJjZVN0YXRlEhoKEmFzeW5jX29wZXJhdGlvbl9pZBgFIAEoCRIwCgxjcmVhdGVkX3RpbWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjYKEmxhc3RfbW9kaWZpZWRfdGltZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiNQoRVXNlckdyb3VwTWVtYmVySWQSEQoHdXNlcl9pZBgBIAEoCUgAQg0KC21lbWJlcl90eXBlIokBCg9Vc2VyR3JvdXBNZW1iZXISRAoJbWVtYmVyX2lkGAEgASgLMjEudGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLlVzZXJHcm91cE1lbWJlcklkEjAKDGNyZWF0ZWRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi2gIKDlNlcnZpY2VBY2NvdW50EgoKAmlkGAEgASgJEhgKEHJlc291cmNlX3ZlcnNpb24YAiABKAkSQAoEc3BlYxgDIAEoCzIyLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5TZXJ2aWNlQWNjb3VudFNwZWMSHAoQc3RhdGVfZGVwcmVjYXRlZBgEIAEoCUICGAESPAoFc3RhdGUYCCABKA4yLS50ZW1wb3JhbC5hcGkuY2xvdWQucmVzb3VyY2UudjEuUmVzb3VyY2VTdGF0ZRIaChJhc3luY19vcGVyYXRpb25faWQYBSABKAkSMAoMY3JlYXRlZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI2ChJsYXN0X21vZGlmaWVkX3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIscBChJTZXJ2aWNlQWNjb3VudFNwZWMSDAoEbmFtZRgBIAEoCRI2CgZhY2Nlc3MYAiABKAsyJi50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjEuQWNjZXNzElYKF25hbWVzcGFjZV9zY29wZWRfYWNjZXNzGAQgASgLMjUudGVtcG9yYWwuYXBpLmNsb3VkLmlkZW50aXR5LnYxLk5hbWVzcGFjZVNjb3BlZEFjY2VzcxITCgtkZXNjcmlwdGlvbhgDIAEoCSLKAgoGQXBpS2V5EgoKAmlkGAEgASgJEhgKEHJlc291cmNlX3ZlcnNpb24YAiABKAkSOAoEc3BlYxgDIAEoCzIqLnRlbXBvcmFsLmFwaS5jbG91ZC5pZGVudGl0eS52MS5BcGlLZXlTcGVjEhwKEHN0YXRlX2RlcHJlY2F0ZWQYBCABKAlCAhgBEjwKBXN0YXRlGAggASgOMi0udGVtcG9yYWwuYXBpLmNsb3VkLnJlc291cmNlLnYxLlJlc291cmNlU3RhdGUSGgoSYXN5bmNfb3BlcmF0aW9uX2lkGAUgASgJEjAKDGNyZWF0ZWRfdGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASNgoSbGFzdF9tb2RpZmllZF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCLuAQoKQXBpS2V5U3BlYxIQCghvd25lcl9pZBgBIAEoCRIhChVvd25lcl90eXBlX2RlcHJlY2F0ZWQYAiABKAlCAhgBEj0KCm93bmVyX3R5cGUYByABKA4yKS50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjEuT3duZXJUeXBlEhQKDGRpc3BsYXlfbmFtZRgDIAEoCRITCgtkZXNjcmlwdGlvbhgEIAEoCRIvCgtleHBpcnlfdGltZRgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEAoIZGlzYWJsZWQYBiABKAgqXAoJT3duZXJUeXBlEhoKFk9XTkVSX1RZUEVfVU5TUEVDSUZJRUQQABITCg9PV05FUl9UWVBFX1VTRVIQARIeChpPV05FUl9UWVBFX1NFUlZJQ0VfQUNDT1VOVBACQqwBCiFpby50ZW1wb3JhbC5hcGkuY2xvdWQuaWRlbnRpdHkudjFCDE1lc3NhZ2VQcm90b1ABWi1nby50ZW1wb3JhbC5pby9hcGkvY2xvdWQvaWRlbnRpdHkvdjE7aWRlbnRpdHmqAiBUZW1wb3JhbGlvLkFwaS5DbG91ZC5JZGVudGl0eS5WMeoCJFRlbXBvcmFsaW86OkFwaTo6Q2xvdWQ6OklkZW50aXR5OjpWMWIGcHJvdG8z", [file_temporal_api_cloud_resource_v1_message, file_google_protobuf_timestamp]);

/**
 * @generated from message temporal.api.cloud.identity.v1.AccountAccess
 */
export type AccountAccess = Message<"temporal.api.cloud.identity.v1.AccountAccess"> & {
  /**
   * The role on the account, should be one of [owner, admin, developer, financeadmin, read, metricsread]
   * owner - gives full access to the account, including users, namespaces, and billing
   * admin - gives full access the account, including users and namespaces
   * developer - gives access to create namespaces on the account
   * financeadmin - gives read only access and write access for billing
   * read - gives read only access to the account
   * metricsread - gives read only access to all namespace metrics
   * Deprecated: Not supported after v0.3.0 api version. Use role instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string role_deprecated = 1 [deprecated = true];
   * @deprecated
   */
  roleDeprecated: string;

  /**
   * The role on the account.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=role_deprecated
   *
   * @generated from field: temporal.api.cloud.identity.v1.AccountAccess.Role role = 2;
   */
  role: AccountAccess_Role;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.AccountAccess.
 * Use `create(AccountAccessSchema)` to create a new message.
 */
export const AccountAccessSchema: GenMessage<AccountAccess> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 0);

/**
 * @generated from enum temporal.api.cloud.identity.v1.AccountAccess.Role
 */
export enum AccountAccess_Role {
  /**
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Gives full access to the account, including users, namespaces, and billing.
   *
   * @generated from enum value: ROLE_OWNER = 1;
   */
  OWNER = 1,

  /**
   * Gives full access to the account, including users and namespaces.
   *
   * @generated from enum value: ROLE_ADMIN = 2;
   */
  ADMIN = 2,

  /**
   * Gives access to create namespaces on the account.
   *
   * @generated from enum value: ROLE_DEVELOPER = 3;
   */
  DEVELOPER = 3,

  /**
   * Gives read only access and write access for billing.
   *
   * @generated from enum value: ROLE_FINANCE_ADMIN = 4;
   */
  FINANCE_ADMIN = 4,

  /**
   * Gives read only access to the account.
   *
   * @generated from enum value: ROLE_READ = 5;
   */
  READ = 5,

  /**
   * Gives read only access to the account metrics.
   *
   * @generated from enum value: ROLE_METRICS_READ = 6;
   */
  METRICS_READ = 6,
}

/**
 * Describes the enum temporal.api.cloud.identity.v1.AccountAccess.Role.
 */
export const AccountAccess_RoleSchema: GenEnum<AccountAccess_Role> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_identity_v1_message, 0, 0);

/**
 * @generated from message temporal.api.cloud.identity.v1.NamespaceAccess
 */
export type NamespaceAccess = Message<"temporal.api.cloud.identity.v1.NamespaceAccess"> & {
  /**
   * The permission to the namespace, should be one of [admin, write, read]
   * admin - gives full access to the namespace, including assigning namespace access to other users
   * write - gives write access to the namespace configuration and workflows within the namespace
   * read - gives read only access to the namespace configuration and workflows within the namespace
   * Deprecated: Not supported after v0.3.0 api version. Use permission instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string permission_deprecated = 1 [deprecated = true];
   * @deprecated
   */
  permissionDeprecated: string;

  /**
   * The permission to the namespace.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=permission_deprecated
   *
   * @generated from field: temporal.api.cloud.identity.v1.NamespaceAccess.Permission permission = 2;
   */
  permission: NamespaceAccess_Permission;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.NamespaceAccess.
 * Use `create(NamespaceAccessSchema)` to create a new message.
 */
export const NamespaceAccessSchema: GenMessage<NamespaceAccess> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 1);

/**
 * @generated from enum temporal.api.cloud.identity.v1.NamespaceAccess.Permission
 */
export enum NamespaceAccess_Permission {
  /**
   * @generated from enum value: PERMISSION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Gives full access to the namespace, including assigning namespace access to other users.
   *
   * @generated from enum value: PERMISSION_ADMIN = 1;
   */
  ADMIN = 1,

  /**
   * Gives write access to the namespace configuration and workflows within the namespace.
   *
   * @generated from enum value: PERMISSION_WRITE = 2;
   */
  WRITE = 2,

  /**
   * Gives read only access to the namespace configuration and workflows within the namespace.
   *
   * @generated from enum value: PERMISSION_READ = 3;
   */
  READ = 3,
}

/**
 * Describes the enum temporal.api.cloud.identity.v1.NamespaceAccess.Permission.
 */
export const NamespaceAccess_PermissionSchema: GenEnum<NamespaceAccess_Permission> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_identity_v1_message, 1, 0);

/**
 * @generated from message temporal.api.cloud.identity.v1.Access
 */
export type Access = Message<"temporal.api.cloud.identity.v1.Access"> & {
  /**
   * The account access
   *
   * @generated from field: temporal.api.cloud.identity.v1.AccountAccess account_access = 1;
   */
  accountAccess?: AccountAccess;

  /**
   * The map of namespace accesses
   * The key is the namespace name and the value is the access to the namespace
   *
   * @generated from field: map<string, temporal.api.cloud.identity.v1.NamespaceAccess> namespace_accesses = 2;
   */
  namespaceAccesses: { [key: string]: NamespaceAccess };
};

/**
 * Describes the message temporal.api.cloud.identity.v1.Access.
 * Use `create(AccessSchema)` to create a new message.
 */
export const AccessSchema: GenMessage<Access> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 2);

/**
 * @generated from message temporal.api.cloud.identity.v1.NamespaceScopedAccess
 */
export type NamespaceScopedAccess = Message<"temporal.api.cloud.identity.v1.NamespaceScopedAccess"> & {
  /**
   * The namespace the service account is assigned to - immutable.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The namespace access assigned to the service account - mutable.
   *
   * @generated from field: temporal.api.cloud.identity.v1.NamespaceAccess access = 2;
   */
  access?: NamespaceAccess;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.NamespaceScopedAccess.
 * Use `create(NamespaceScopedAccessSchema)` to create a new message.
 */
export const NamespaceScopedAccessSchema: GenMessage<NamespaceScopedAccess> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 3);

/**
 * @generated from message temporal.api.cloud.identity.v1.UserSpec
 */
export type UserSpec = Message<"temporal.api.cloud.identity.v1.UserSpec"> & {
  /**
   * The email address associated to the user
   *
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * The access to assigned to the user
   *
   * @generated from field: temporal.api.cloud.identity.v1.Access access = 2;
   */
  access?: Access;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.UserSpec.
 * Use `create(UserSpecSchema)` to create a new message.
 */
export const UserSpecSchema: GenMessage<UserSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 4);

/**
 * @generated from message temporal.api.cloud.identity.v1.Invitation
 */
export type Invitation = Message<"temporal.api.cloud.identity.v1.Invitation"> & {
  /**
   * The date and time when the user was created
   *
   * @generated from field: google.protobuf.Timestamp created_time = 1;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the invitation expires or has expired
   *
   * @generated from field: google.protobuf.Timestamp expired_time = 2;
   */
  expiredTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.Invitation.
 * Use `create(InvitationSchema)` to create a new message.
 */
export const InvitationSchema: GenMessage<Invitation> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 5);

/**
 * @generated from message temporal.api.cloud.identity.v1.User
 */
export type User = Message<"temporal.api.cloud.identity.v1.User"> & {
  /**
   * The id of the user
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The current version of the user specification
   * The next update operation will have to include this version
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The user specification
   *
   * @generated from field: temporal.api.cloud.identity.v1.UserSpec spec = 3;
   */
  spec?: UserSpec;

  /**
   * The current state of the user
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 4 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the user.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 9;
   */
  state: ResourceState;

  /**
   * The id of the async operation that is creating/updating/deleting the user, if any
   *
   * @generated from field: string async_operation_id = 5;
   */
  asyncOperationId: string;

  /**
   * The details of the open invitation sent to the user, if any
   *
   * @generated from field: temporal.api.cloud.identity.v1.Invitation invitation = 6;
   */
  invitation?: Invitation;

  /**
   * The date and time when the user was created
   *
   * @generated from field: google.protobuf.Timestamp created_time = 7;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the user was last modified
   * Will not be set if the user has never been modified
   *
   * @generated from field: google.protobuf.Timestamp last_modified_time = 8;
   */
  lastModifiedTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.User.
 * Use `create(UserSchema)` to create a new message.
 */
export const UserSchema: GenMessage<User> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 6);

/**
 * @generated from message temporal.api.cloud.identity.v1.GoogleGroupSpec
 */
export type GoogleGroupSpec = Message<"temporal.api.cloud.identity.v1.GoogleGroupSpec"> & {
  /**
   * The email address of the Google group.
   * The email address is immutable. Once set during creation, it cannot be changed.
   *
   * @generated from field: string email_address = 1;
   */
  emailAddress: string;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.GoogleGroupSpec.
 * Use `create(GoogleGroupSpecSchema)` to create a new message.
 */
export const GoogleGroupSpecSchema: GenMessage<GoogleGroupSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 7);

/**
 * @generated from message temporal.api.cloud.identity.v1.SCIMGroupSpec
 */
export type SCIMGroupSpec = Message<"temporal.api.cloud.identity.v1.SCIMGroupSpec"> & {
  /**
   * The id used in the upstream identity provider.
   *
   * @generated from field: string idp_id = 1;
   */
  idpId: string;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.SCIMGroupSpec.
 * Use `create(SCIMGroupSpecSchema)` to create a new message.
 */
export const SCIMGroupSpecSchema: GenMessage<SCIMGroupSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 8);

/**
 * @generated from message temporal.api.cloud.identity.v1.CloudGroupSpec
 */
export type CloudGroupSpec = Message<"temporal.api.cloud.identity.v1.CloudGroupSpec"> & {
};

/**
 * Describes the message temporal.api.cloud.identity.v1.CloudGroupSpec.
 * Use `create(CloudGroupSpecSchema)` to create a new message.
 */
export const CloudGroupSpecSchema: GenMessage<CloudGroupSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 9);

/**
 * @generated from message temporal.api.cloud.identity.v1.UserGroupSpec
 */
export type UserGroupSpec = Message<"temporal.api.cloud.identity.v1.UserGroupSpec"> & {
  /**
   * The display name of the group.
   *
   * @generated from field: string display_name = 1;
   */
  displayName: string;

  /**
   * The access assigned to the group.
   *
   * @generated from field: temporal.api.cloud.identity.v1.Access access = 2;
   */
  access?: Access;

  /**
   * @generated from oneof temporal.api.cloud.identity.v1.UserGroupSpec.group_type
   */
  groupType: {
    /**
     * The specification of the google group that this group is associated with.
     *
     * @generated from field: temporal.api.cloud.identity.v1.GoogleGroupSpec google_group = 3;
     */
    value: GoogleGroupSpec;
    case: "googleGroup";
  } | {
    /**
     * The specification of the SCIM group that this group is associated with.
     * SCIM groups cannot be created or deleted directly, but their access can be managed.
     *
     * @generated from field: temporal.api.cloud.identity.v1.SCIMGroupSpec scim_group = 4;
     */
    value: SCIMGroupSpec;
    case: "scimGroup";
  } | {
    /**
     * The specification for a Cloud group. Cloud groups can manage members using
     * the add and remove member APIs.
     *
     * @generated from field: temporal.api.cloud.identity.v1.CloudGroupSpec cloud_group = 5;
     */
    value: CloudGroupSpec;
    case: "cloudGroup";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.cloud.identity.v1.UserGroupSpec.
 * Use `create(UserGroupSpecSchema)` to create a new message.
 */
export const UserGroupSpecSchema: GenMessage<UserGroupSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 10);

/**
 * @generated from message temporal.api.cloud.identity.v1.UserGroup
 */
export type UserGroup = Message<"temporal.api.cloud.identity.v1.UserGroup"> & {
  /**
   * The id of the group
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The current version of the group specification
   * The next update operation will have to include this version
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The group specification
   *
   * @generated from field: temporal.api.cloud.identity.v1.UserGroupSpec spec = 3;
   */
  spec?: UserGroupSpec;

  /**
   * The current state of the group.
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 4 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the group.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 8;
   */
  state: ResourceState;

  /**
   * The id of the async operation that is creating/updating/deleting the group, if any
   *
   * @generated from field: string async_operation_id = 5;
   */
  asyncOperationId: string;

  /**
   * The date and time when the group was created
   *
   * @generated from field: google.protobuf.Timestamp created_time = 6;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the group was last modified
   * Will not be set if the group has never been modified
   *
   * @generated from field: google.protobuf.Timestamp last_modified_time = 7;
   */
  lastModifiedTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.UserGroup.
 * Use `create(UserGroupSchema)` to create a new message.
 */
export const UserGroupSchema: GenMessage<UserGroup> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 11);

/**
 * @generated from message temporal.api.cloud.identity.v1.UserGroupMemberId
 */
export type UserGroupMemberId = Message<"temporal.api.cloud.identity.v1.UserGroupMemberId"> & {
  /**
   * @generated from oneof temporal.api.cloud.identity.v1.UserGroupMemberId.member_type
   */
  memberType: {
    /**
     * @generated from field: string user_id = 1;
     */
    value: string;
    case: "userId";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.cloud.identity.v1.UserGroupMemberId.
 * Use `create(UserGroupMemberIdSchema)` to create a new message.
 */
export const UserGroupMemberIdSchema: GenMessage<UserGroupMemberId> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 12);

/**
 * @generated from message temporal.api.cloud.identity.v1.UserGroupMember
 */
export type UserGroupMember = Message<"temporal.api.cloud.identity.v1.UserGroupMember"> & {
  /**
   * @generated from field: temporal.api.cloud.identity.v1.UserGroupMemberId member_id = 1;
   */
  memberId?: UserGroupMemberId;

  /**
   * @generated from field: google.protobuf.Timestamp created_time = 2;
   */
  createdTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.UserGroupMember.
 * Use `create(UserGroupMemberSchema)` to create a new message.
 */
export const UserGroupMemberSchema: GenMessage<UserGroupMember> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 13);

/**
 * @generated from message temporal.api.cloud.identity.v1.ServiceAccount
 */
export type ServiceAccount = Message<"temporal.api.cloud.identity.v1.ServiceAccount"> & {
  /**
   * The id of the service account.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The current version of the service account specification.
   * The next update operation will have to include this version.
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The service account specification.
   *
   * @generated from field: temporal.api.cloud.identity.v1.ServiceAccountSpec spec = 3;
   */
  spec?: ServiceAccountSpec;

  /**
   * The current state of the service account.
   * Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 4 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the service account.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 8;
   */
  state: ResourceState;

  /**
   * The id of the async operation that is creating/updating/deleting the service account, if any.
   *
   * @generated from field: string async_operation_id = 5;
   */
  asyncOperationId: string;

  /**
   * The date and time when the service account was created.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 6;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the service account was last modified
   * Will not be set if the service account has never been modified.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_time = 7;
   */
  lastModifiedTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.ServiceAccount.
 * Use `create(ServiceAccountSchema)` to create a new message.
 */
export const ServiceAccountSchema: GenMessage<ServiceAccount> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 14);

/**
 * @generated from message temporal.api.cloud.identity.v1.ServiceAccountSpec
 */
export type ServiceAccountSpec = Message<"temporal.api.cloud.identity.v1.ServiceAccountSpec"> & {
  /**
   * The name associated with the service account.
   * The name is mutable, but must be unique across all your active service accounts.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Note: one of `Access` or `NamespaceScopedAccess` must be provided, but not both.
   * The access assigned to the service account.
   * If set, creates an account scoped service account.
   * The access is mutable.
   *
   * @generated from field: temporal.api.cloud.identity.v1.Access access = 2;
   */
  access?: Access;

  /**
   * The namespace scoped access assigned to the service account.
   * If set, creates a namespace scoped service account (limited to a single namespace).
   * The namespace scoped access is partially mutable.
   * Refer to `NamespaceScopedAccess` for details.
   *
   * @generated from field: temporal.api.cloud.identity.v1.NamespaceScopedAccess namespace_scoped_access = 4;
   */
  namespaceScopedAccess?: NamespaceScopedAccess;

  /**
   * The description associated with the service account - optional.
   * The description is mutable.
   *
   * @generated from field: string description = 3;
   */
  description: string;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.ServiceAccountSpec.
 * Use `create(ServiceAccountSpecSchema)` to create a new message.
 */
export const ServiceAccountSpecSchema: GenMessage<ServiceAccountSpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 15);

/**
 * @generated from message temporal.api.cloud.identity.v1.ApiKey
 */
export type ApiKey = Message<"temporal.api.cloud.identity.v1.ApiKey"> & {
  /**
   * The id of the API Key.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The current version of the API key specification.
   * The next update operation will have to include this version.
   *
   * @generated from field: string resource_version = 2;
   */
  resourceVersion: string;

  /**
   * The API key specification.
   *
   * @generated from field: temporal.api.cloud.identity.v1.ApiKeySpec spec = 3;
   */
  spec?: ApiKeySpec;

  /**
   * The current state of the API key.
   * Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
   * For any failed state, reach out to Temporal Cloud support for remediation.
   * Deprecated: Not supported after v0.3.0 api version. Use state instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string state_deprecated = 4 [deprecated = true];
   * @deprecated
   */
  stateDeprecated: string;

  /**
   * The current state of the API key.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=state_deprecated
   *
   * @generated from field: temporal.api.cloud.resource.v1.ResourceState state = 8;
   */
  state: ResourceState;

  /**
   * The id of the async operation that is creating/updating/deleting the API key, if any.
   *
   * @generated from field: string async_operation_id = 5;
   */
  asyncOperationId: string;

  /**
   * The date and time when the API key was created.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 6;
   */
  createdTime?: Timestamp;

  /**
   * The date and time when the API key was last modified.
   * Will not be set if the API key has never been modified.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_time = 7;
   */
  lastModifiedTime?: Timestamp;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.ApiKey.
 * Use `create(ApiKeySchema)` to create a new message.
 */
export const ApiKeySchema: GenMessage<ApiKey> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 16);

/**
 * @generated from message temporal.api.cloud.identity.v1.ApiKeySpec
 */
export type ApiKeySpec = Message<"temporal.api.cloud.identity.v1.ApiKeySpec"> & {
  /**
   * The id of the owner to create the API key for.
   * The owner id is immutable. Once set during creation, it cannot be changed.
   * The owner id is the id of the user when the owner type is user.
   * The owner id is the id of the service account when the owner type is service account.
   *
   * @generated from field: string owner_id = 1;
   */
  ownerId: string;

  /**
   * The type of the owner to create the API key for.
   * The owner type is immutable. Once set during creation, it cannot be changed.
   * Possible values: user, service-account.
   * Deprecated: Not supported after v0.3.0 api version. Use owner_type instead.
   * temporal:versioning:max_version=v0.3.0
   *
   * @generated from field: string owner_type_deprecated = 2 [deprecated = true];
   * @deprecated
   */
  ownerTypeDeprecated: string;

  /**
   * The type of the owner to create the API key for.
   * temporal:versioning:min_version=v0.3.0
   * temporal:enums:replaces=owner_type_deprecated
   *
   * @generated from field: temporal.api.cloud.identity.v1.OwnerType owner_type = 7;
   */
  ownerType: OwnerType;

  /**
   * The display name of the API key.
   *
   * @generated from field: string display_name = 3;
   */
  displayName: string;

  /**
   * The description of the API key.
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * The expiry time of the API key.
   *
   * @generated from field: google.protobuf.Timestamp expiry_time = 5;
   */
  expiryTime?: Timestamp;

  /**
   * True if the API key is disabled.
   *
   * @generated from field: bool disabled = 6;
   */
  disabled: boolean;
};

/**
 * Describes the message temporal.api.cloud.identity.v1.ApiKeySpec.
 * Use `create(ApiKeySpecSchema)` to create a new message.
 */
export const ApiKeySpecSchema: GenMessage<ApiKeySpec> = /*@__PURE__*/
  messageDesc(file_temporal_api_cloud_identity_v1_message, 17);

/**
 * @generated from enum temporal.api.cloud.identity.v1.OwnerType
 */
export enum OwnerType {
  /**
   * @generated from enum value: OWNER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The owner is a user.
   *
   * @generated from enum value: OWNER_TYPE_USER = 1;
   */
  USER = 1,

  /**
   * The owner is a service account.
   *
   * @generated from enum value: OWNER_TYPE_SERVICE_ACCOUNT = 2;
   */
  SERVICE_ACCOUNT = 2,
}

/**
 * Describes the enum temporal.api.cloud.identity.v1.OwnerType.
 */
export const OwnerTypeSchema: GenEnum<OwnerType> = /*@__PURE__*/
  enumDesc(file_temporal_api_cloud_identity_v1_message, 0);

