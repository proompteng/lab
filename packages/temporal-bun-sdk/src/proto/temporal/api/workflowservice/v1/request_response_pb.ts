// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/workflowservice/v1/request_response.proto (package temporal.api.workflowservice.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { BatchOperationState, BatchOperationType } from "../../enums/v1/batch_operation_pb.js";
import { file_temporal_api_enums_v1_batch_operation } from "../../enums/v1/batch_operation_pb.js";
import type { IndexedValueType } from "../../enums/v1/common_pb.js";
import { file_temporal_api_enums_v1_common } from "../../enums/v1/common_pb.js";
import type { HistoryEventFilterType, VersioningBehavior, WorkflowExecutionStatus, WorkflowIdConflictPolicy, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { ArchivalState } from "../../enums/v1/namespace_pb.js";
import { file_temporal_api_enums_v1_namespace } from "../../enums/v1/namespace_pb.js";
import type { WorkflowTaskFailedCause } from "../../enums/v1/failed_cause_pb.js";
import { file_temporal_api_enums_v1_failed_cause } from "../../enums/v1/failed_cause_pb.js";
import type { QueryRejectCondition, QueryResultType } from "../../enums/v1/query_pb.js";
import { file_temporal_api_enums_v1_query } from "../../enums/v1/query_pb.js";
import type { ResetReapplyExcludeType, ResetReapplyType } from "../../enums/v1/reset_pb.js";
import { file_temporal_api_enums_v1_reset } from "../../enums/v1/reset_pb.js";
import type { DescribeTaskQueueMode, RateLimitSource, TaskQueueType, TaskReachability } from "../../enums/v1/task_queue_pb.js";
import { file_temporal_api_enums_v1_task_queue } from "../../enums/v1/task_queue_pb.js";
import type { DeploymentReachability } from "../../enums/v1/deployment_pb.js";
import { file_temporal_api_enums_v1_deployment } from "../../enums/v1/deployment_pb.js";
import type { UpdateWorkflowExecutionLifecycleStage } from "../../enums/v1/update_pb.js";
import { file_temporal_api_enums_v1_update } from "../../enums/v1/update_pb.js";
import type { ActivityOptions } from "../../activity/v1/message_pb.js";
import { file_temporal_api_activity_v1_message } from "../../activity/v1/message_pb.js";
import type { ActivityType, Callback, DataBlob, Header, Link, Memo, MeteringMetadata, Payload, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerSelector, WorkerVersionCapabilities, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { History } from "../../history/v1/message_pb.js";
import { file_temporal_api_history_v1_message } from "../../history/v1/message_pb.js";
import type { CallbackInfo, OnConflictOptions, PendingActivityInfo, PendingChildExecutionInfo, PendingNexusOperationInfo, PendingWorkflowTaskInfo, PostResetOperation, VersioningOverride, WorkflowExecutionConfig, WorkflowExecutionExtendedInfo, WorkflowExecutionInfo, WorkflowExecutionOptions } from "../../workflow/v1/message_pb.js";
import { file_temporal_api_workflow_v1_message } from "../../workflow/v1/message_pb.js";
import type { Command } from "../../command/v1/message_pb.js";
import { file_temporal_api_command_v1_message } from "../../command/v1/message_pb.js";
import type { Deployment, DeploymentInfo, DeploymentListInfo, RoutingConfig, UpdateDeploymentMetadata, VersionMetadata, WorkerDeploymentInfo, WorkerDeploymentInfo_WorkerDeploymentVersionSummary, WorkerDeploymentOptions, WorkerDeploymentVersion, WorkerDeploymentVersionInfo } from "../../deployment/v1/message_pb.js";
import { file_temporal_api_deployment_v1_message } from "../../deployment/v1/message_pb.js";
import type { Failure } from "../../failure/v1/message_pb.js";
import { file_temporal_api_failure_v1_message } from "../../failure/v1/message_pb.js";
import type { StartTimeFilter, StatusFilter, WorkflowExecutionFilter, WorkflowTypeFilter } from "../../filter/v1/message_pb.js";
import { file_temporal_api_filter_v1_message } from "../../filter/v1/message_pb.js";
import type { Message as Message$1 } from "../../protocol/v1/message_pb.js";
import { file_temporal_api_protocol_v1_message } from "../../protocol/v1/message_pb.js";
import type { NamespaceConfig, NamespaceFilter, NamespaceInfo, UpdateNamespaceInfo } from "../../namespace/v1/message_pb.js";
import { file_temporal_api_namespace_v1_message } from "../../namespace/v1/message_pb.js";
import type { QueryRejected, WorkflowQuery, WorkflowQueryResult } from "../../query/v1/message_pb.js";
import { file_temporal_api_query_v1_message } from "../../query/v1/message_pb.js";
import type { ClusterReplicationConfig, FailoverStatus, NamespaceReplicationConfig } from "../../replication/v1/message_pb.js";
import { file_temporal_api_replication_v1_message } from "../../replication/v1/message_pb.js";
import type { WorkflowRule, WorkflowRuleSpec } from "../../rules/v1/message_pb.js";
import { file_temporal_api_rules_v1_message } from "../../rules/v1/message_pb.js";
import type { WorkerConfig } from "../../sdk/v1/worker_config_pb.js";
import { file_temporal_api_sdk_v1_worker_config } from "../../sdk/v1/worker_config_pb.js";
import type { Schedule, ScheduleInfo, ScheduleListEntry, SchedulePatch } from "../../schedule/v1/message_pb.js";
import { file_temporal_api_schedule_v1_message } from "../../schedule/v1/message_pb.js";
import type { BuildIdAssignmentRule, BuildIdReachability, CompatibleBuildIdRedirectRule, CompatibleVersionSet, PollerInfo, PollerScalingDecision, RateLimit, StickyExecutionAttributes, TaskQueue, TaskQueueConfig, TaskQueueMetadata, TaskQueuePartitionMetadata, TaskQueueStats, TaskQueueStatus, TaskQueueVersionInfo, TaskQueueVersioningInfo, TaskQueueVersionSelection, TimestampedBuildIdAssignmentRule, TimestampedCompatibleBuildIdRedirectRule } from "../../taskqueue/v1/message_pb.js";
import { file_temporal_api_taskqueue_v1_message } from "../../taskqueue/v1/message_pb.js";
import type { Outcome, Request, UpdateRef, WaitPolicy } from "../../update/v1/message_pb.js";
import { file_temporal_api_update_v1_message } from "../../update/v1/message_pb.js";
import type { VersionInfo } from "../../version/v1/message_pb.js";
import { file_temporal_api_version_v1_message } from "../../version/v1/message_pb.js";
import type { BatchOperationCancellation, BatchOperationDeletion, BatchOperationInfo, BatchOperationReset, BatchOperationResetActivities, BatchOperationSignal, BatchOperationTermination, BatchOperationUnpauseActivities, BatchOperationUpdateActivityOptions, BatchOperationUpdateWorkflowExecutionOptions } from "../../batch/v1/message_pb.js";
import { file_temporal_api_batch_v1_message } from "../../batch/v1/message_pb.js";
import type { WorkflowTaskCompletedMetadata } from "../../sdk/v1/task_complete_metadata_pb.js";
import { file_temporal_api_sdk_v1_task_complete_metadata } from "../../sdk/v1/task_complete_metadata_pb.js";
import type { UserMetadata } from "../../sdk/v1/user_metadata_pb.js";
import { file_temporal_api_sdk_v1_user_metadata } from "../../sdk/v1/user_metadata_pb.js";
import type { HandlerError, Request as Request$1, Response } from "../../nexus/v1/message_pb.js";
import { file_temporal_api_nexus_v1_message } from "../../nexus/v1/message_pb.js";
import type { WorkerHeartbeat, WorkerInfo } from "../../worker/v1/message_pb.js";
import { file_temporal_api_worker_v1_message } from "../../worker/v1/message_pb.js";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/workflowservice/v1/request_response.proto.
 */
export const file_temporal_api_workflowservice_v1_request_response: GenFile = /*@__PURE__*/
  fileDesc("CjZ0ZW1wb3JhbC9hcGkvd29ya2Zsb3dzZXJ2aWNlL3YxL3JlcXVlc3RfcmVzcG9uc2UucHJvdG8SH3RlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEiiAUKGFJlZ2lzdGVyTmFtZXNwYWNlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEwoLZGVzY3JpcHRpb24YAiABKAkSEwoLb3duZXJfZW1haWwYAyABKAkSRgojd29ya2Zsb3dfZXhlY3V0aW9uX3JldGVudGlvbl9wZXJpb2QYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRwoIY2x1c3RlcnMYBSADKAsyNS50ZW1wb3JhbC5hcGkucmVwbGljYXRpb24udjEuQ2x1c3RlclJlcGxpY2F0aW9uQ29uZmlnEhsKE2FjdGl2ZV9jbHVzdGVyX25hbWUYBiABKAkSUQoEZGF0YRgHIAMoCzJDLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVnaXN0ZXJOYW1lc3BhY2VSZXF1ZXN0LkRhdGFFbnRyeRIWCg5zZWN1cml0eV90b2tlbhgIIAEoCRIbChNpc19nbG9iYWxfbmFtZXNwYWNlGAkgASgIEkQKFmhpc3RvcnlfYXJjaGl2YWxfc3RhdGUYCiABKA4yJC50ZW1wb3JhbC5hcGkuZW51bXMudjEuQXJjaGl2YWxTdGF0ZRIcChRoaXN0b3J5X2FyY2hpdmFsX3VyaRgLIAEoCRJHChl2aXNpYmlsaXR5X2FyY2hpdmFsX3N0YXRlGAwgASgOMiQudGVtcG9yYWwuYXBpLmVudW1zLnYxLkFyY2hpdmFsU3RhdGUSHwoXdmlzaWJpbGl0eV9hcmNoaXZhbF91cmkYDSABKAkaKwoJRGF0YUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiGwoZUmVnaXN0ZXJOYW1lc3BhY2VSZXNwb25zZSKJAQoVTGlzdE5hbWVzcGFjZXNSZXF1ZXN0EhEKCXBhZ2Vfc2l6ZRgBIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAwSRAoQbmFtZXNwYWNlX2ZpbHRlchgDIAEoCzIqLnRlbXBvcmFsLmFwaS5uYW1lc3BhY2UudjEuTmFtZXNwYWNlRmlsdGVyIoEBChZMaXN0TmFtZXNwYWNlc1Jlc3BvbnNlEk4KCm5hbWVzcGFjZXMYASADKAsyOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlTmFtZXNwYWNlUmVzcG9uc2USFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgMIjkKGERlc2NyaWJlTmFtZXNwYWNlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSCgoCaWQYAiABKAki7AIKGURlc2NyaWJlTmFtZXNwYWNlUmVzcG9uc2USQAoObmFtZXNwYWNlX2luZm8YASABKAsyKC50ZW1wb3JhbC5hcGkubmFtZXNwYWNlLnYxLk5hbWVzcGFjZUluZm8SOgoGY29uZmlnGAIgASgLMioudGVtcG9yYWwuYXBpLm5hbWVzcGFjZS52MS5OYW1lc3BhY2VDb25maWcSUwoScmVwbGljYXRpb25fY29uZmlnGAMgASgLMjcudGVtcG9yYWwuYXBpLnJlcGxpY2F0aW9uLnYxLk5hbWVzcGFjZVJlcGxpY2F0aW9uQ29uZmlnEhgKEGZhaWxvdmVyX3ZlcnNpb24YBCABKAMSGwoTaXNfZ2xvYmFsX25hbWVzcGFjZRgFIAEoCBJFChBmYWlsb3Zlcl9oaXN0b3J5GAYgAygLMisudGVtcG9yYWwuYXBpLnJlcGxpY2F0aW9uLnYxLkZhaWxvdmVyU3RhdHVzIs8CChZVcGRhdGVOYW1lc3BhY2VSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRJDCgt1cGRhdGVfaW5mbxgCIAEoCzIuLnRlbXBvcmFsLmFwaS5uYW1lc3BhY2UudjEuVXBkYXRlTmFtZXNwYWNlSW5mbxI6CgZjb25maWcYAyABKAsyKi50ZW1wb3JhbC5hcGkubmFtZXNwYWNlLnYxLk5hbWVzcGFjZUNvbmZpZxJTChJyZXBsaWNhdGlvbl9jb25maWcYBCABKAsyNy50ZW1wb3JhbC5hcGkucmVwbGljYXRpb24udjEuTmFtZXNwYWNlUmVwbGljYXRpb25Db25maWcSFgoOc2VjdXJpdHlfdG9rZW4YBSABKAkSGQoRZGVsZXRlX2JhZF9iaW5hcnkYBiABKAkSGQoRcHJvbW90ZV9uYW1lc3BhY2UYByABKAgiowIKF1VwZGF0ZU5hbWVzcGFjZVJlc3BvbnNlEkAKDm5hbWVzcGFjZV9pbmZvGAEgASgLMigudGVtcG9yYWwuYXBpLm5hbWVzcGFjZS52MS5OYW1lc3BhY2VJbmZvEjoKBmNvbmZpZxgCIAEoCzIqLnRlbXBvcmFsLmFwaS5uYW1lc3BhY2UudjEuTmFtZXNwYWNlQ29uZmlnElMKEnJlcGxpY2F0aW9uX2NvbmZpZxgDIAEoCzI3LnRlbXBvcmFsLmFwaS5yZXBsaWNhdGlvbi52MS5OYW1lc3BhY2VSZXBsaWNhdGlvbkNvbmZpZxIYChBmYWlsb3Zlcl92ZXJzaW9uGAQgASgDEhsKE2lzX2dsb2JhbF9uYW1lc3BhY2UYBSABKAgiRgoZRGVwcmVjYXRlTmFtZXNwYWNlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSFgoOc2VjdXJpdHlfdG9rZW4YAiABKAkiHAoaRGVwcmVjYXRlTmFtZXNwYWNlUmVzcG9uc2UihwwKHVN0YXJ0V29ya2Zsb3dFeGVjdXRpb25SZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRI7Cg13b3JrZmxvd190eXBlGAMgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSOAoKdGFza19xdWV1ZRgEIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEi8KBWlucHV0GAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI9Chp3b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI3ChR3b3JrZmxvd19ydW5fdGltZW91dBgHIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4ChV3b3JrZmxvd190YXNrX3RpbWVvdXQYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SEAoIaWRlbnRpdHkYCSABKAkSEgoKcmVxdWVzdF9pZBgKIAEoCRJOChh3b3JrZmxvd19pZF9yZXVzZV9wb2xpY3kYCyABKA4yLC50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5ElQKG3dvcmtmbG93X2lkX2NvbmZsaWN0X3BvbGljeRgWIAEoDjIvLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kSOQoMcmV0cnlfcG9saWN5GAwgASgLMiMudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5SZXRyeVBvbGljeRIVCg1jcm9uX3NjaGVkdWxlGA0gASgJEioKBG1lbW8YDiABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYDyABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMSLgoGaGVhZGVyGBAgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISHwoXcmVxdWVzdF9lYWdlcl9leGVjdXRpb24YESABKAgSOwoRY29udGludWVkX2ZhaWx1cmUYEiABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEkAKFmxhc3RfY29tcGxldGlvbl9yZXN1bHQYEyABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEjcKFHdvcmtmbG93X3N0YXJ0X2RlbGF5GBQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEj4KFGNvbXBsZXRpb25fY2FsbGJhY2tzGBUgAygLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5DYWxsYmFjaxI4Cg11c2VyX21ldGFkYXRhGBcgASgLMiEudGVtcG9yYWwuYXBpLnNkay52MS5Vc2VyTWV0YWRhdGESKwoFbGlua3MYGCADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsSSQoTdmVyc2lvbmluZ19vdmVycmlkZRgZIAEoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUSSAoTb25fY29uZmxpY3Rfb3B0aW9ucxgaIAEoCzIrLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5PbkNvbmZsaWN0T3B0aW9ucxIyCghwcmlvcml0eRgbIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUHJpb3JpdHkSXAofZWFnZXJfd29ya2VyX2RlcGxveW1lbnRfb3B0aW9ucxgcIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRPcHRpb25zIooCCh5TdGFydFdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2USDgoGcnVuX2lkGAEgASgJEg8KB3N0YXJ0ZWQYAyABKAgSPgoGc3RhdHVzGAUgASgOMi4udGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93RXhlY3V0aW9uU3RhdHVzElsKE2VhZ2VyX3dvcmtmbG93X3Rhc2sYAiABKAsyPi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlBvbGxXb3JrZmxvd1Rhc2tRdWV1ZVJlc3BvbnNlEioKBGxpbmsYBCABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsiqgIKIkdldFdvcmtmbG93RXhlY3V0aW9uSGlzdG9yeVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjwKCWV4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SGQoRbWF4aW11bV9wYWdlX3NpemUYAyABKAUSFwoPbmV4dF9wYWdlX3Rva2VuGAQgASgMEhYKDndhaXRfbmV3X2V2ZW50GAUgASgIElAKGWhpc3RvcnlfZXZlbnRfZmlsdGVyX3R5cGUYBiABKA4yLS50ZW1wb3JhbC5hcGkuZW51bXMudjEuSGlzdG9yeUV2ZW50RmlsdGVyVHlwZRIVCg1za2lwX2FyY2hpdmFsGAcgASgIIroBCiNHZXRXb3JrZmxvd0V4ZWN1dGlvbkhpc3RvcnlSZXNwb25zZRIxCgdoaXN0b3J5GAEgASgLMiAudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuSGlzdG9yeRI1CgtyYXdfaGlzdG9yeRgCIAMoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuRGF0YUJsb2ISFwoPbmV4dF9wYWdlX3Rva2VuGAMgASgMEhAKCGFyY2hpdmVkGAQgASgIIrABCilHZXRXb3JrZmxvd0V4ZWN1dGlvbkhpc3RvcnlSZXZlcnNlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSPAoJZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIZChFtYXhpbXVtX3BhZ2Vfc2l6ZRgDIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YBCABKAwieAoqR2V0V29ya2Zsb3dFeGVjdXRpb25IaXN0b3J5UmV2ZXJzZVJlc3BvbnNlEjEKB2hpc3RvcnkYASABKAsyIC50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5IaXN0b3J5EhcKD25leHRfcGFnZV90b2tlbhgDIAEoDCLHAgocUG9sbFdvcmtmbG93VGFza1F1ZXVlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSOAoKdGFza19xdWV1ZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEhAKCGlkZW50aXR5GAMgASgJEhsKD2JpbmFyeV9jaGVja3N1bRgEIAEoCUICGAESWgobd29ya2VyX3ZlcnNpb25fY2FwYWJpbGl0aWVzGAUgASgLMjEudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJWZXJzaW9uQ2FwYWJpbGl0aWVzQgIYARJPChJkZXBsb3ltZW50X29wdGlvbnMYBiABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50T3B0aW9ucyKRBwodUG9sbFdvcmtmbG93VGFza1F1ZXVlUmVzcG9uc2USEgoKdGFza190b2tlbhgBIAEoDBJFChJ3b3JrZmxvd19leGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEjsKDXdvcmtmbG93X3R5cGUYAyABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93VHlwZRIhChlwcmV2aW91c19zdGFydGVkX2V2ZW50X2lkGAQgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYBSABKAMSDwoHYXR0ZW1wdBgGIAEoBRIaChJiYWNrbG9nX2NvdW50X2hpbnQYByABKAMSMQoHaGlzdG9yeRgIIAEoCzIgLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkhpc3RvcnkSFwoPbmV4dF9wYWdlX3Rva2VuGAkgASgMEjMKBXF1ZXJ5GAogASgLMiQudGVtcG9yYWwuYXBpLnF1ZXJ5LnYxLldvcmtmbG93UXVlcnkSSwodd29ya2Zsb3dfZXhlY3V0aW9uX3Rhc2tfcXVldWUYCyABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRIyCg5zY2hlZHVsZWRfdGltZRgMIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMAoMc3RhcnRlZF90aW1lGA0gASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJcCgdxdWVyaWVzGA4gAygLMksudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsV29ya2Zsb3dUYXNrUXVldWVSZXNwb25zZS5RdWVyaWVzRW50cnkSMwoIbWVzc2FnZXMYDyADKAsyIS50ZW1wb3JhbC5hcGkucHJvdG9jb2wudjEuTWVzc2FnZRJRChdwb2xsZXJfc2NhbGluZ19kZWNpc2lvbhgQIAEoCzIwLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuUG9sbGVyU2NhbGluZ0RlY2lzaW9uGlQKDFF1ZXJpZXNFbnRyeRILCgNrZXkYASABKAkSMwoFdmFsdWUYAiABKAsyJC50ZW1wb3JhbC5hcGkucXVlcnkudjEuV29ya2Zsb3dRdWVyeToCOAEitQkKI1Jlc3BvbmRXb3JrZmxvd1Rhc2tDb21wbGV0ZWRSZXF1ZXN0EhIKCnRhc2tfdG9rZW4YASABKAwSMgoIY29tbWFuZHMYAiADKAsyIC50ZW1wb3JhbC5hcGkuY29tbWFuZC52MS5Db21tYW5kEhAKCGlkZW50aXR5GAMgASgJEk8KEXN0aWNreV9hdHRyaWJ1dGVzGAQgASgLMjQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5TdGlja3lFeGVjdXRpb25BdHRyaWJ1dGVzEiAKGHJldHVybl9uZXdfd29ya2Zsb3dfdGFzaxgFIAEoCBImCh5mb3JjZV9jcmVhdGVfbmV3X3dvcmtmbG93X3Rhc2sYBiABKAgSGwoPYmluYXJ5X2NoZWNrc3VtGAcgASgJQgIYARJtCg1xdWVyeV9yZXN1bHRzGAggAygLMlYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kV29ya2Zsb3dUYXNrQ29tcGxldGVkUmVxdWVzdC5RdWVyeVJlc3VsdHNFbnRyeRIRCgluYW1lc3BhY2UYCSABKAkSTAoUd29ya2VyX3ZlcnNpb25fc3RhbXAYCiABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESMwoIbWVzc2FnZXMYCyADKAsyIS50ZW1wb3JhbC5hcGkucHJvdG9jb2wudjEuTWVzc2FnZRJICgxzZGtfbWV0YWRhdGEYDCABKAsyMi50ZW1wb3JhbC5hcGkuc2RrLnYxLldvcmtmbG93VGFza0NvbXBsZXRlZE1ldGFkYXRhEkMKEW1ldGVyaW5nX21ldGFkYXRhGA0gASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZXRlcmluZ01ldGFkYXRhEmcKDGNhcGFiaWxpdGllcxgOIAEoCzJRLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZFdvcmtmbG93VGFza0NvbXBsZXRlZFJlcXVlc3QuQ2FwYWJpbGl0aWVzEj4KCmRlcGxveW1lbnQYDyABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50QgIYARJGChN2ZXJzaW9uaW5nX2JlaGF2aW9yGBAgASgOMikudGVtcG9yYWwuYXBpLmVudW1zLnYxLlZlcnNpb25pbmdCZWhhdmlvchJPChJkZXBsb3ltZW50X29wdGlvbnMYESABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50T3B0aW9ucxpfChFRdWVyeVJlc3VsdHNFbnRyeRILCgNrZXkYASABKAkSOQoFdmFsdWUYAiABKAsyKi50ZW1wb3JhbC5hcGkucXVlcnkudjEuV29ya2Zsb3dRdWVyeVJlc3VsdDoCOAEaRQoMQ2FwYWJpbGl0aWVzEjUKLWRpc2NhcmRfc3BlY3VsYXRpdmVfd29ya2Zsb3dfdGFza193aXRoX2V2ZW50cxgBIAEoCCL1AQokUmVzcG9uZFdvcmtmbG93VGFza0NvbXBsZXRlZFJlc3BvbnNlElUKDXdvcmtmbG93X3Rhc2sYASABKAsyPi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlBvbGxXb3JrZmxvd1Rhc2tRdWV1ZVJlc3BvbnNlElYKDmFjdGl2aXR5X3Rhc2tzGAIgAygLMj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsQWN0aXZpdHlUYXNrUXVldWVSZXNwb25zZRIeChZyZXNldF9oaXN0b3J5X2V2ZW50X2lkGAMgASgDIvgDCiBSZXNwb25kV29ya2Zsb3dUYXNrRmFpbGVkUmVxdWVzdBISCgp0YXNrX3Rva2VuGAEgASgMEj0KBWNhdXNlGAIgASgOMi4udGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93VGFza0ZhaWxlZENhdXNlEjEKB2ZhaWx1cmUYAyABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhAKCGlkZW50aXR5GAQgASgJEhsKD2JpbmFyeV9jaGVja3N1bRgFIAEoCUICGAESEQoJbmFtZXNwYWNlGAYgASgJEjMKCG1lc3NhZ2VzGAcgAygLMiEudGVtcG9yYWwuYXBpLnByb3RvY29sLnYxLk1lc3NhZ2USRgoOd29ya2VyX3ZlcnNpb24YCCABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESPgoKZGVwbG95bWVudBgJIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRCAhgBEk8KEmRlcGxveW1lbnRfb3B0aW9ucxgKIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRPcHRpb25zIiMKIVJlc3BvbmRXb3JrZmxvd1Rhc2tGYWlsZWRSZXNwb25zZSL1AgocUG9sbEFjdGl2aXR5VGFza1F1ZXVlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSOAoKdGFza19xdWV1ZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEhAKCGlkZW50aXR5GAMgASgJEkkKE3Rhc2tfcXVldWVfbWV0YWRhdGEYBCABKAsyLC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZU1ldGFkYXRhEloKG3dvcmtlcl92ZXJzaW9uX2NhcGFiaWxpdGllcxgFIAEoCzIxLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvbkNhcGFiaWxpdGllc0ICGAESTwoSZGVwbG95bWVudF9vcHRpb25zGAYgASgLMjMudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudE9wdGlvbnMi7wcKHVBvbGxBY3Rpdml0eVRhc2tRdWV1ZVJlc3BvbnNlEhIKCnRhc2tfdG9rZW4YASABKAwSGgoSd29ya2Zsb3dfbmFtZXNwYWNlGAIgASgJEjsKDXdvcmtmbG93X3R5cGUYAyABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93VHlwZRJFChJ3b3JrZmxvd19leGVjdXRpb24YBCABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEjsKDWFjdGl2aXR5X3R5cGUYBSABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkFjdGl2aXR5VHlwZRITCgthY3Rpdml0eV9pZBgGIAEoCRIuCgZoZWFkZXIYByABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIvCgVpbnB1dBgIIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSOwoRaGVhcnRiZWF0X2RldGFpbHMYCSABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEjIKDnNjaGVkdWxlZF90aW1lGAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJCCh5jdXJyZW50X2F0dGVtcHRfc2NoZWR1bGVkX3RpbWUYCyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjAKDHN0YXJ0ZWRfdGltZRgMIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDwoHYXR0ZW1wdBgNIAEoBRI8ChlzY2hlZHVsZV90b19jbG9zZV90aW1lb3V0GA4gASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjkKFnN0YXJ0X3RvX2Nsb3NlX3RpbWVvdXQYDyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SNAoRaGVhcnRiZWF0X3RpbWVvdXQYECABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOQoMcmV0cnlfcG9saWN5GBEgASgLMiMudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5SZXRyeVBvbGljeRJRChdwb2xsZXJfc2NhbGluZ19kZWNpc2lvbhgSIAEoCzIwLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuUG9sbGVyU2NhbGluZ0RlY2lzaW9uEjIKCHByaW9yaXR5GBMgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eSKQAQoiUmVjb3JkQWN0aXZpdHlUYXNrSGVhcnRiZWF0UmVxdWVzdBISCgp0YXNrX3Rva2VuGAEgASgMEjEKB2RldGFpbHMYAiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhAKCGlkZW50aXR5GAMgASgJEhEKCW5hbWVzcGFjZRgEIAEoCSJwCiNSZWNvcmRBY3Rpdml0eVRhc2tIZWFydGJlYXRSZXNwb25zZRIYChBjYW5jZWxfcmVxdWVzdGVkGAEgASgIEhcKD2FjdGl2aXR5X3BhdXNlZBgCIAEoCBIWCg5hY3Rpdml0eV9yZXNldBgDIAEoCCK6AQomUmVjb3JkQWN0aXZpdHlUYXNrSGVhcnRiZWF0QnlJZFJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhMKC3dvcmtmbG93X2lkGAIgASgJEg4KBnJ1bl9pZBgDIAEoCRITCgthY3Rpdml0eV9pZBgEIAEoCRIxCgdkZXRhaWxzGAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIQCghpZGVudGl0eRgGIAEoCSJ0CidSZWNvcmRBY3Rpdml0eVRhc2tIZWFydGJlYXRCeUlkUmVzcG9uc2USGAoQY2FuY2VsX3JlcXVlc3RlZBgBIAEoCBIXCg9hY3Rpdml0eV9wYXVzZWQYAiABKAgSFgoOYWN0aXZpdHlfcmVzZXQYAyABKAgi6QIKI1Jlc3BvbmRBY3Rpdml0eVRhc2tDb21wbGV0ZWRSZXF1ZXN0EhIKCnRhc2tfdG9rZW4YASABKAwSMAoGcmVzdWx0GAIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIQCghpZGVudGl0eRgDIAEoCRIRCgluYW1lc3BhY2UYBCABKAkSRgoOd29ya2VyX3ZlcnNpb24YBSABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESPgoKZGVwbG95bWVudBgGIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRCAhgBEk8KEmRlcGxveW1lbnRfb3B0aW9ucxgHIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRPcHRpb25zIiYKJFJlc3BvbmRBY3Rpdml0eVRhc2tDb21wbGV0ZWRSZXNwb25zZSK6AQonUmVzcG9uZEFjdGl2aXR5VGFza0NvbXBsZXRlZEJ5SWRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRIOCgZydW5faWQYAyABKAkSEwoLYWN0aXZpdHlfaWQYBCABKAkSMAoGcmVzdWx0GAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIQCghpZGVudGl0eRgGIAEoCSIqCihSZXNwb25kQWN0aXZpdHlUYXNrQ29tcGxldGVkQnlJZFJlc3BvbnNlIqkDCiBSZXNwb25kQWN0aXZpdHlUYXNrRmFpbGVkUmVxdWVzdBISCgp0YXNrX3Rva2VuGAEgASgMEjEKB2ZhaWx1cmUYAiABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhAKCGlkZW50aXR5GAMgASgJEhEKCW5hbWVzcGFjZRgEIAEoCRJAChZsYXN0X2hlYXJ0YmVhdF9kZXRhaWxzGAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxJGCg53b3JrZXJfdmVyc2lvbhgGIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYARI+CgpkZXBsb3ltZW50GAcgASgLMiYudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudEICGAESTwoSZGVwbG95bWVudF9vcHRpb25zGAggASgLMjMudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudE9wdGlvbnMiVwohUmVzcG9uZEFjdGl2aXR5VGFza0ZhaWxlZFJlc3BvbnNlEjIKCGZhaWx1cmVzGAEgAygLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZSL6AQokUmVzcG9uZEFjdGl2aXR5VGFza0ZhaWxlZEJ5SWRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRIOCgZydW5faWQYAyABKAkSEwoLYWN0aXZpdHlfaWQYBCABKAkSMQoHZmFpbHVyZRgFIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSEAoIaWRlbnRpdHkYBiABKAkSQAoWbGFzdF9oZWFydGJlYXRfZGV0YWlscxgHIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMiWwolUmVzcG9uZEFjdGl2aXR5VGFza0ZhaWxlZEJ5SWRSZXNwb25zZRIyCghmYWlsdXJlcxgBIAMoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUi6QIKIlJlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZFJlcXVlc3QSEgoKdGFza190b2tlbhgBIAEoDBIxCgdkZXRhaWxzGAIgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIQCghpZGVudGl0eRgDIAEoCRIRCgluYW1lc3BhY2UYBCABKAkSRgoOd29ya2VyX3ZlcnNpb24YBSABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESPgoKZGVwbG95bWVudBgGIAEoCzImLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRCAhgBEk8KEmRlcGxveW1lbnRfb3B0aW9ucxgHIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRPcHRpb25zIiUKI1Jlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZFJlc3BvbnNlIosCCiZSZXNwb25kQWN0aXZpdHlUYXNrQ2FuY2VsZWRCeUlkUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEwoLd29ya2Zsb3dfaWQYAiABKAkSDgoGcnVuX2lkGAMgASgJEhMKC2FjdGl2aXR5X2lkGAQgASgJEjEKB2RldGFpbHMYBSABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhAKCGlkZW50aXR5GAYgASgJEk8KEmRlcGxveW1lbnRfb3B0aW9ucxgHIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRPcHRpb25zIikKJ1Jlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZEJ5SWRSZXNwb25zZSKEAgolUmVxdWVzdENhbmNlbFdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIQCghpZGVudGl0eRgDIAEoCRISCgpyZXF1ZXN0X2lkGAQgASgJEh4KFmZpcnN0X2V4ZWN1dGlvbl9ydW5faWQYBSABKAkSDgoGcmVhc29uGAYgASgJEisKBWxpbmtzGAcgAygLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5MaW5rIigKJlJlcXVlc3RDYW5jZWxXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIt4CCh5TaWduYWxXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SEwoLc2lnbmFsX25hbWUYAyABKAkSLwoFaW5wdXQYBCABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhAKCGlkZW50aXR5GAUgASgJEhIKCnJlcXVlc3RfaWQYBiABKAkSEwoHY29udHJvbBgHIAEoCUICGAESLgoGaGVhZGVyGAggASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISKwoFbGlua3MYCiADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmtKBAgJEAoiIQofU2lnbmFsV29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZSLxCQonU2lnbmFsV2l0aFN0YXJ0V29ya2Zsb3dFeGVjdXRpb25SZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRI7Cg13b3JrZmxvd190eXBlGAMgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSOAoKdGFza19xdWV1ZRgEIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEi8KBWlucHV0GAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI9Chp3b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI3ChR3b3JrZmxvd19ydW5fdGltZW91dBgHIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4ChV3b3JrZmxvd190YXNrX3RpbWVvdXQYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SEAoIaWRlbnRpdHkYCSABKAkSEgoKcmVxdWVzdF9pZBgKIAEoCRJOChh3b3JrZmxvd19pZF9yZXVzZV9wb2xpY3kYCyABKA4yLC50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5ElQKG3dvcmtmbG93X2lkX2NvbmZsaWN0X3BvbGljeRgWIAEoDjIvLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kSEwoLc2lnbmFsX25hbWUYDCABKAkSNgoMc2lnbmFsX2lucHV0GA0gASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxITCgdjb250cm9sGA4gASgJQgIYARI5CgxyZXRyeV9wb2xpY3kYDyABKAsyIy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlJldHJ5UG9saWN5EhUKDWNyb25fc2NoZWR1bGUYECABKAkSKgoEbWVtbxgRIAEoCzIcLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTWVtbxJDChFzZWFyY2hfYXR0cmlidXRlcxgSIAEoCzIoLnRlbXBvcmFsLmFwaS5jb21tb24udjEuU2VhcmNoQXR0cmlidXRlcxIuCgZoZWFkZXIYEyABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchI3ChR3b3JrZmxvd19zdGFydF9kZWxheRgUIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4Cg11c2VyX21ldGFkYXRhGBcgASgLMiEudGVtcG9yYWwuYXBpLnNkay52MS5Vc2VyTWV0YWRhdGESKwoFbGlua3MYGCADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsSSQoTdmVyc2lvbmluZ19vdmVycmlkZRgZIAEoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUSMgoIcHJpb3JpdHkYGiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlByaW9yaXR5SgQIFRAWIksKKFNpZ25hbFdpdGhTdGFydFdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2USDgoGcnVuX2lkGAEgASgJEg8KB3N0YXJ0ZWQYAiABKAgiwQMKHVJlc2V0V29ya2Zsb3dFeGVjdXRpb25SZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRJFChJ3b3JrZmxvd19leGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEg4KBnJlYXNvbhgDIAEoCRIlCh13b3JrZmxvd190YXNrX2ZpbmlzaF9ldmVudF9pZBgEIAEoAxISCgpyZXF1ZXN0X2lkGAUgASgJEkcKEnJlc2V0X3JlYXBwbHlfdHlwZRgGIAEoDjInLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5SZXNldFJlYXBwbHlUeXBlQgIYARJTChtyZXNldF9yZWFwcGx5X2V4Y2x1ZGVfdHlwZXMYByADKA4yLi50ZW1wb3JhbC5hcGkuZW51bXMudjEuUmVzZXRSZWFwcGx5RXhjbHVkZVR5cGUSSwoVcG9zdF9yZXNldF9vcGVyYXRpb25zGAggAygLMiwudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlBvc3RSZXNldE9wZXJhdGlvbhIQCghpZGVudGl0eRgJIAEoCSIwCh5SZXNldFdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2USDgoGcnVuX2lkGAEgASgJIp8CCiFUZXJtaW5hdGVXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SDgoGcmVhc29uGAMgASgJEjEKB2RldGFpbHMYBCABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhAKCGlkZW50aXR5GAUgASgJEh4KFmZpcnN0X2V4ZWN1dGlvbl9ydW5faWQYBiABKAkSKwoFbGlua3MYByADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsiJAoiVGVybWluYXRlV29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZSJ6Ch5EZWxldGVXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24iIQofRGVsZXRlV29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZSLJAgohTGlzdE9wZW5Xb3JrZmxvd0V4ZWN1dGlvbnNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIZChFtYXhpbXVtX3BhZ2Vfc2l6ZRgCIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAyABKAwSQgoRc3RhcnRfdGltZV9maWx0ZXIYBCABKAsyJy50ZW1wb3JhbC5hcGkuZmlsdGVyLnYxLlN0YXJ0VGltZUZpbHRlchJLChBleGVjdXRpb25fZmlsdGVyGAUgASgLMi8udGVtcG9yYWwuYXBpLmZpbHRlci52MS5Xb3JrZmxvd0V4ZWN1dGlvbkZpbHRlckgAEkEKC3R5cGVfZmlsdGVyGAYgASgLMioudGVtcG9yYWwuYXBpLmZpbHRlci52MS5Xb3JrZmxvd1R5cGVGaWx0ZXJIAEIJCgdmaWx0ZXJzIoIBCiJMaXN0T3BlbldvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlEkMKCmV4ZWN1dGlvbnMYASADKAsyLy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25JbmZvEhcKD25leHRfcGFnZV90b2tlbhgCIAEoDCKKAwojTGlzdENsb3NlZFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhkKEW1heGltdW1fcGFnZV9zaXplGAIgASgFEhcKD25leHRfcGFnZV90b2tlbhgDIAEoDBJCChFzdGFydF90aW1lX2ZpbHRlchgEIAEoCzInLnRlbXBvcmFsLmFwaS5maWx0ZXIudjEuU3RhcnRUaW1lRmlsdGVyEksKEGV4ZWN1dGlvbl9maWx0ZXIYBSABKAsyLy50ZW1wb3JhbC5hcGkuZmlsdGVyLnYxLldvcmtmbG93RXhlY3V0aW9uRmlsdGVySAASQQoLdHlwZV9maWx0ZXIYBiABKAsyKi50ZW1wb3JhbC5hcGkuZmlsdGVyLnYxLldvcmtmbG93VHlwZUZpbHRlckgAEj0KDXN0YXR1c19maWx0ZXIYByABKAsyJC50ZW1wb3JhbC5hcGkuZmlsdGVyLnYxLlN0YXR1c0ZpbHRlckgAQgkKB2ZpbHRlcnMihAEKJExpc3RDbG9zZWRXb3JrZmxvd0V4ZWN1dGlvbnNSZXNwb25zZRJDCgpleGVjdXRpb25zGAEgAygLMi8udGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uSW5mbxIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAwibQodTGlzdFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAyABKAwSDQoFcXVlcnkYBCABKAkifgoeTGlzdFdvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlEkMKCmV4ZWN1dGlvbnMYASADKAsyLy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25JbmZvEhcKD25leHRfcGFnZV90b2tlbhgCIAEoDCJ1CiVMaXN0QXJjaGl2ZWRXb3JrZmxvd0V4ZWN1dGlvbnNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIRCglwYWdlX3NpemUYAiABKAUSFwoPbmV4dF9wYWdlX3Rva2VuGAMgASgMEg0KBXF1ZXJ5GAQgASgJIoYBCiZMaXN0QXJjaGl2ZWRXb3JrZmxvd0V4ZWN1dGlvbnNSZXNwb25zZRJDCgpleGVjdXRpb25zGAEgAygLMi8udGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uSW5mbxIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAwibQodU2NhbldvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAyABKAwSDQoFcXVlcnkYBCABKAkifgoeU2NhbldvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlEkMKCmV4ZWN1dGlvbnMYASADKAsyLy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25JbmZvEhcKD25leHRfcGFnZV90b2tlbhgCIAEoDCJCCh5Db3VudFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEg0KBXF1ZXJ5GAIgASgJIu0BCh9Db3VudFdvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlEg0KBWNvdW50GAEgASgDEmEKBmdyb3VwcxgCIAMoCzJRLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuQ291bnRXb3JrZmxvd0V4ZWN1dGlvbnNSZXNwb25zZS5BZ2dyZWdhdGlvbkdyb3VwGlgKEEFnZ3JlZ2F0aW9uR3JvdXASNQoMZ3JvdXBfdmFsdWVzGAEgAygLMh8udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkEg0KBWNvdW50GAIgASgDIhwKGkdldFNlYXJjaEF0dHJpYnV0ZXNSZXF1ZXN0IskBChtHZXRTZWFyY2hBdHRyaWJ1dGVzUmVzcG9uc2USVAoEa2V5cxgBIAMoCzJGLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0U2VhcmNoQXR0cmlidXRlc1Jlc3BvbnNlLktleXNFbnRyeRpUCglLZXlzRW50cnkSCwoDa2V5GAEgASgJEjYKBXZhbHVlGAIgASgOMicudGVtcG9yYWwuYXBpLmVudW1zLnYxLkluZGV4ZWRWYWx1ZVR5cGU6AjgBItACCiBSZXNwb25kUXVlcnlUYXNrQ29tcGxldGVkUmVxdWVzdBISCgp0YXNrX3Rva2VuGAEgASgMEj4KDmNvbXBsZXRlZF90eXBlGAIgASgOMiYudGVtcG9yYWwuYXBpLmVudW1zLnYxLlF1ZXJ5UmVzdWx0VHlwZRI2CgxxdWVyeV9yZXN1bHQYAyABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhUKDWVycm9yX21lc3NhZ2UYBCABKAkSEQoJbmFtZXNwYWNlGAYgASgJEjEKB2ZhaWx1cmUYByABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEj0KBWNhdXNlGAggASgOMi4udGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93VGFza0ZhaWxlZENhdXNlSgQIBRAGIiMKIVJlc3BvbmRRdWVyeVRhc2tDb21wbGV0ZWRSZXNwb25zZSJuChtSZXNldFN0aWNreVRhc2tRdWV1ZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjwKCWV4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24iHgocUmVzZXRTdGlja3lUYXNrUXVldWVSZXNwb25zZSKqAQoVU2h1dGRvd25Xb3JrZXJSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIZChFzdGlja3lfdGFza19xdWV1ZRgCIAEoCRIQCghpZGVudGl0eRgDIAEoCRIOCgZyZWFzb24YBCABKAkSQQoQd29ya2VyX2hlYXJ0YmVhdBgFIAEoCzInLnRlbXBvcmFsLmFwaS53b3JrZXIudjEuV29ya2VySGVhcnRiZWF0IhgKFlNodXRkb3duV29ya2VyUmVzcG9uc2Ui6QEKFFF1ZXJ5V29ya2Zsb3dSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI8CglleGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEjMKBXF1ZXJ5GAMgASgLMiQudGVtcG9yYWwuYXBpLnF1ZXJ5LnYxLldvcmtmbG93UXVlcnkSSwoWcXVlcnlfcmVqZWN0X2NvbmRpdGlvbhgEIAEoDjIrLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5RdWVyeVJlamVjdENvbmRpdGlvbiKNAQoVUXVlcnlXb3JrZmxvd1Jlc3BvbnNlEjYKDHF1ZXJ5X3Jlc3VsdBgBIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSPAoOcXVlcnlfcmVqZWN0ZWQYAiABKAsyJC50ZW1wb3JhbC5hcGkucXVlcnkudjEuUXVlcnlSZWplY3RlZCJzCiBEZXNjcmliZVdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSPAoJZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbiKZBQohRGVzY3JpYmVXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlEksKEGV4ZWN1dGlvbl9jb25maWcYASABKAsyMS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25Db25maWcSUAoXd29ya2Zsb3dfZXhlY3V0aW9uX2luZm8YAiABKAsyLy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuV29ya2Zsb3dFeGVjdXRpb25JbmZvEkkKEnBlbmRpbmdfYWN0aXZpdGllcxgDIAMoCzItLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5QZW5kaW5nQWN0aXZpdHlJbmZvEk0KEHBlbmRpbmdfY2hpbGRyZW4YBCADKAsyMy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ0NoaWxkRXhlY3V0aW9uSW5mbxJQChVwZW5kaW5nX3dvcmtmbG93X3Rhc2sYBSABKAsyMS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ1dvcmtmbG93VGFza0luZm8SOQoJY2FsbGJhY2tzGAYgAygLMiYudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLkNhbGxiYWNrSW5mbxJVChhwZW5kaW5nX25leHVzX29wZXJhdGlvbnMYByADKAsyMy50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUGVuZGluZ05leHVzT3BlcmF0aW9uSW5mbxJXChZ3b3JrZmxvd19leHRlbmRlZF9pbmZvGAggASgLMjcudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uRXh0ZW5kZWRJbmZvIpAEChhEZXNjcmliZVRhc2tRdWV1ZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjgKCnRhc2tfcXVldWUYAiABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRI9Cg90YXNrX3F1ZXVlX3R5cGUYAyABKA4yJC50ZW1wb3JhbC5hcGkuZW51bXMudjEuVGFza1F1ZXVlVHlwZRIUCgxyZXBvcnRfc3RhdHMYCCABKAgSFQoNcmVwb3J0X2NvbmZpZxgLIAEoCBIlChlpbmNsdWRlX3Rhc2tfcXVldWVfc3RhdHVzGAQgASgIQgIYARJCCghhcGlfbW9kZRgFIAEoDjIsLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5EZXNjcmliZVRhc2tRdWV1ZU1vZGVCAhgBEkoKCHZlcnNpb25zGAYgASgLMjQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVWZXJzaW9uU2VsZWN0aW9uQgIYARJCChB0YXNrX3F1ZXVlX3R5cGVzGAcgAygOMiQudGVtcG9yYWwuYXBpLmVudW1zLnYxLlRhc2tRdWV1ZVR5cGVCAhgBEhoKDnJlcG9ydF9wb2xsZXJzGAkgASgIQgIYARIkChhyZXBvcnRfdGFza19yZWFjaGFiaWxpdHkYCiABKAhCAhgBIuwHChlEZXNjcmliZVRhc2tRdWV1ZVJlc3BvbnNlEjYKB3BvbGxlcnMYASADKAsyJS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlBvbGxlckluZm8SOAoFc3RhdHMYBSABKAsyKS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVN0YXRzEnEKFXN0YXRzX2J5X3ByaW9yaXR5X2tleRgIIAMoCzJSLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVzY3JpYmVUYXNrUXVldWVSZXNwb25zZS5TdGF0c0J5UHJpb3JpdHlLZXlFbnRyeRJLCg92ZXJzaW9uaW5nX2luZm8YBCABKAsyMi50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVZlcnNpb25pbmdJbmZvEjoKBmNvbmZpZxgGIAEoCzIqLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlQ29uZmlnEmsKFGVmZmVjdGl2ZV9yYXRlX2xpbWl0GAcgASgLMk0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVRhc2tRdWV1ZVJlc3BvbnNlLkVmZmVjdGl2ZVJhdGVMaW1pdBJJChF0YXNrX3F1ZXVlX3N0YXR1cxgCIAEoCzIqLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlU3RhdHVzQgIYARJnCg12ZXJzaW9uc19pbmZvGAMgAygLMkwudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVRhc2tRdWV1ZVJlc3BvbnNlLlZlcnNpb25zSW5mb0VudHJ5QgIYARpkChdTdGF0c0J5UHJpb3JpdHlLZXlFbnRyeRILCgNrZXkYASABKAUSOAoFdmFsdWUYAiABKAsyKS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVN0YXRzOgI4ARp0ChJFZmZlY3RpdmVSYXRlTGltaXQSGwoTcmVxdWVzdHNfcGVyX3NlY29uZBgBIAEoAhJBChFyYXRlX2xpbWl0X3NvdXJjZRgCIAEoDjImLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5SYXRlTGltaXRTb3VyY2UaZAoRVmVyc2lvbnNJbmZvRW50cnkSCwoDa2V5GAEgASgJEj4KBXZhbHVlGAIgASgLMi8udGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVWZXJzaW9uSW5mbzoCOAEiFwoVR2V0Q2x1c3RlckluZm9SZXF1ZXN0ItEDChZHZXRDbHVzdGVySW5mb1Jlc3BvbnNlEmgKEXN1cHBvcnRlZF9jbGllbnRzGAEgAygLMk0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRDbHVzdGVySW5mb1Jlc3BvbnNlLlN1cHBvcnRlZENsaWVudHNFbnRyeRIWCg5zZXJ2ZXJfdmVyc2lvbhgCIAEoCRISCgpjbHVzdGVyX2lkGAMgASgJEjoKDHZlcnNpb25faW5mbxgEIAEoCzIkLnRlbXBvcmFsLmFwaS52ZXJzaW9uLnYxLlZlcnNpb25JbmZvEhQKDGNsdXN0ZXJfbmFtZRgFIAEoCRIbChNoaXN0b3J5X3NoYXJkX2NvdW50GAYgASgFEhkKEXBlcnNpc3RlbmNlX3N0b3JlGAcgASgJEhgKEHZpc2liaWxpdHlfc3RvcmUYCCABKAkSIAoYaW5pdGlhbF9mYWlsb3Zlcl92ZXJzaW9uGAkgASgDEiIKGmZhaWxvdmVyX3ZlcnNpb25faW5jcmVtZW50GAogASgDGjcKFVN1cHBvcnRlZENsaWVudHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIhYKFEdldFN5c3RlbUluZm9SZXF1ZXN0IvQDChVHZXRTeXN0ZW1JbmZvUmVzcG9uc2USFgoOc2VydmVyX3ZlcnNpb24YASABKAkSWQoMY2FwYWJpbGl0aWVzGAIgASgLMkMudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRTeXN0ZW1JbmZvUmVzcG9uc2UuQ2FwYWJpbGl0aWVzGucCCgxDYXBhYmlsaXRpZXMSHwoXc2lnbmFsX2FuZF9xdWVyeV9oZWFkZXIYASABKAgSJgoeaW50ZXJuYWxfZXJyb3JfZGlmZmVyZW50aWF0aW9uGAIgASgIEioKImFjdGl2aXR5X2ZhaWx1cmVfaW5jbHVkZV9oZWFydGJlYXQYAyABKAgSGgoSc3VwcG9ydHNfc2NoZWR1bGVzGAQgASgIEiIKGmVuY29kZWRfZmFpbHVyZV9hdHRyaWJ1dGVzGAUgASgIEiEKGWJ1aWxkX2lkX2Jhc2VkX3ZlcnNpb25pbmcYBiABKAgSEwoLdXBzZXJ0X21lbW8YByABKAgSHAoUZWFnZXJfd29ya2Zsb3dfc3RhcnQYCCABKAgSFAoMc2RrX21ldGFkYXRhGAkgASgIEicKH2NvdW50X2dyb3VwX2J5X2V4ZWN1dGlvbl9zdGF0dXMYCiABKAgSDQoFbmV4dXMYCyABKAgibQoeTGlzdFRhc2tRdWV1ZVBhcnRpdGlvbnNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI4Cgp0YXNrX3F1ZXVlGAIgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUi3wEKH0xpc3RUYXNrUXVldWVQYXJ0aXRpb25zUmVzcG9uc2USXQoeYWN0aXZpdHlfdGFza19xdWV1ZV9wYXJ0aXRpb25zGAEgAygLMjUudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVQYXJ0aXRpb25NZXRhZGF0YRJdCh53b3JrZmxvd190YXNrX3F1ZXVlX3BhcnRpdGlvbnMYAiADKAsyNS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVBhcnRpdGlvbk1ldGFkYXRhIswCChVDcmVhdGVTY2hlZHVsZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhMKC3NjaGVkdWxlX2lkGAIgASgJEjQKCHNjaGVkdWxlGAMgASgLMiIudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlEj4KDWluaXRpYWxfcGF0Y2gYBCABKAsyJy50ZW1wb3JhbC5hcGkuc2NoZWR1bGUudjEuU2NoZWR1bGVQYXRjaBIQCghpZGVudGl0eRgFIAEoCRISCgpyZXF1ZXN0X2lkGAYgASgJEioKBG1lbW8YByABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYCCABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMiMAoWQ3JlYXRlU2NoZWR1bGVSZXNwb25zZRIWCg5jb25mbGljdF90b2tlbhgBIAEoDCJBChdEZXNjcmliZVNjaGVkdWxlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEwoLc2NoZWR1bGVfaWQYAiABKAkijwIKGERlc2NyaWJlU2NoZWR1bGVSZXNwb25zZRI0CghzY2hlZHVsZRgBIAEoCzIiLnRlbXBvcmFsLmFwaS5zY2hlZHVsZS52MS5TY2hlZHVsZRI0CgRpbmZvGAIgASgLMiYudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlSW5mbxIqCgRtZW1vGAMgASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGAQgASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzEhYKDmNvbmZsaWN0X3Rva2VuGAUgASgMIvgBChVVcGRhdGVTY2hlZHVsZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhMKC3NjaGVkdWxlX2lkGAIgASgJEjQKCHNjaGVkdWxlGAMgASgLMiIudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlEhYKDmNvbmZsaWN0X3Rva2VuGAQgASgMEhAKCGlkZW50aXR5GAUgASgJEhIKCnJlcXVlc3RfaWQYBiABKAkSQwoRc2VhcmNoX2F0dHJpYnV0ZXMYByABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMiGAoWVXBkYXRlU2NoZWR1bGVSZXNwb25zZSKcAQoUUGF0Y2hTY2hlZHVsZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhMKC3NjaGVkdWxlX2lkGAIgASgJEjYKBXBhdGNoGAMgASgLMicudGVtcG9yYWwuYXBpLnNjaGVkdWxlLnYxLlNjaGVkdWxlUGF0Y2gSEAoIaWRlbnRpdHkYBCABKAkSEgoKcmVxdWVzdF9pZBgFIAEoCSIXChVQYXRjaFNjaGVkdWxlUmVzcG9uc2UiqAEKIExpc3RTY2hlZHVsZU1hdGNoaW5nVGltZXNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgtzY2hlZHVsZV9pZBgCIAEoCRIuCgpzdGFydF90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIsCghlbmRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiUwohTGlzdFNjaGVkdWxlTWF0Y2hpbmdUaW1lc1Jlc3BvbnNlEi4KCnN0YXJ0X3RpbWUYASADKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIlEKFURlbGV0ZVNjaGVkdWxlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEwoLc2NoZWR1bGVfaWQYAiABKAkSEAoIaWRlbnRpdHkYAyABKAkiGAoWRGVsZXRlU2NoZWR1bGVSZXNwb25zZSJsChRMaXN0U2NoZWR1bGVzUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSGQoRbWF4aW11bV9wYWdlX3NpemUYAiABKAUSFwoPbmV4dF9wYWdlX3Rva2VuGAMgASgMEg0KBXF1ZXJ5GAQgASgJInAKFUxpc3RTY2hlZHVsZXNSZXNwb25zZRI+CglzY2hlZHVsZXMYASADKAsyKy50ZW1wb3JhbC5hcGkuc2NoZWR1bGUudjEuU2NoZWR1bGVMaXN0RW50cnkSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgMIoYFCidVcGRhdGVXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhIKCnRhc2tfcXVldWUYAiABKAkSLQojYWRkX25ld19idWlsZF9pZF9pbl9uZXdfZGVmYXVsdF9zZXQYAyABKAlIABKHAQobYWRkX25ld19jb21wYXRpYmxlX2J1aWxkX2lkGAQgASgLMmAudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eVJlcXVlc3QuQWRkTmV3Q29tcGF0aWJsZVZlcnNpb25IABIhChdwcm9tb3RlX3NldF9ieV9idWlsZF9pZBgFIAEoCUgAEiUKG3Byb21vdGVfYnVpbGRfaWRfd2l0aGluX3NldBgGIAEoCUgAEmgKCm1lcmdlX3NldHMYByABKAsyUi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlckJ1aWxkSWRDb21wYXRpYmlsaXR5UmVxdWVzdC5NZXJnZVNldHNIABpvChdBZGROZXdDb21wYXRpYmxlVmVyc2lvbhIUCgxuZXdfYnVpbGRfaWQYASABKAkSJAocZXhpc3RpbmdfY29tcGF0aWJsZV9idWlsZF9pZBgCIAEoCRIYChBtYWtlX3NldF9kZWZhdWx0GAMgASgIGkkKCU1lcmdlU2V0cxIcChRwcmltYXJ5X3NldF9idWlsZF9pZBgBIAEoCRIeChZzZWNvbmRhcnlfc2V0X2J1aWxkX2lkGAIgASgJQgsKCW9wZXJhdGlvbiJACihVcGRhdGVXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eVJlc3BvbnNlSgQIARACUg52ZXJzaW9uX3NldF9pZCJfCiRHZXRXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhIKCnRhc2tfcXVldWUYAiABKAkSEAoIbWF4X3NldHMYAyABKAUidAolR2V0V29ya2VyQnVpbGRJZENvbXBhdGliaWxpdHlSZXNwb25zZRJLChJtYWpvcl92ZXJzaW9uX3NldHMYASADKAsyLy50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkNvbXBhdGlibGVWZXJzaW9uU2V0IrUNCiJVcGRhdGVXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRISCgp0YXNrX3F1ZXVlGAIgASgJEhYKDmNvbmZsaWN0X3Rva2VuGAMgASgMEoEBChZpbnNlcnRfYXNzaWdubWVudF9ydWxlGAQgASgLMl8udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXF1ZXN0Lkluc2VydEJ1aWxkSWRBc3NpZ25tZW50UnVsZUgAEoMBChdyZXBsYWNlX2Fzc2lnbm1lbnRfcnVsZRgFIAEoCzJgLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyVmVyc2lvbmluZ1J1bGVzUmVxdWVzdC5SZXBsYWNlQnVpbGRJZEFzc2lnbm1lbnRSdWxlSAASgQEKFmRlbGV0ZV9hc3NpZ25tZW50X3J1bGUYBiABKAsyXy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlc1JlcXVlc3QuRGVsZXRlQnVpbGRJZEFzc2lnbm1lbnRSdWxlSAASjAEKHGFkZF9jb21wYXRpYmxlX3JlZGlyZWN0X3J1bGUYByABKAsyZC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlc1JlcXVlc3QuQWRkQ29tcGF0aWJsZUJ1aWxkSWRSZWRpcmVjdFJ1bGVIABKUAQogcmVwbGFjZV9jb21wYXRpYmxlX3JlZGlyZWN0X3J1bGUYCCABKAsyaC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlc1JlcXVlc3QuUmVwbGFjZUNvbXBhdGlibGVCdWlsZElkUmVkaXJlY3RSdWxlSAASkgEKH2RlbGV0ZV9jb21wYXRpYmxlX3JlZGlyZWN0X3J1bGUYCSABKAsyZy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlc1JlcXVlc3QuRGVsZXRlQ29tcGF0aWJsZUJ1aWxkSWRSZWRpcmVjdFJ1bGVIABJsCg9jb21taXRfYnVpbGRfaWQYCiABKAsyUS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlc1JlcXVlc3QuQ29tbWl0QnVpbGRJZEgAGnEKG0luc2VydEJ1aWxkSWRBc3NpZ25tZW50UnVsZRISCgpydWxlX2luZGV4GAEgASgFEj4KBHJ1bGUYAiABKAsyMC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkJ1aWxkSWRBc3NpZ25tZW50UnVsZRqBAQocUmVwbGFjZUJ1aWxkSWRBc3NpZ25tZW50UnVsZRISCgpydWxlX2luZGV4GAEgASgFEj4KBHJ1bGUYAiABKAsyMC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkJ1aWxkSWRBc3NpZ25tZW50UnVsZRINCgVmb3JjZRgDIAEoCBpAChtEZWxldGVCdWlsZElkQXNzaWdubWVudFJ1bGUSEgoKcnVsZV9pbmRleBgBIAEoBRINCgVmb3JjZRgCIAEoCBpqCiBBZGRDb21wYXRpYmxlQnVpbGRJZFJlZGlyZWN0UnVsZRJGCgRydWxlGAEgASgLMjgudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5Db21wYXRpYmxlQnVpbGRJZFJlZGlyZWN0UnVsZRpuCiRSZXBsYWNlQ29tcGF0aWJsZUJ1aWxkSWRSZWRpcmVjdFJ1bGUSRgoEcnVsZRgBIAEoCzI4LnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuQ29tcGF0aWJsZUJ1aWxkSWRSZWRpcmVjdFJ1bGUaPgojRGVsZXRlQ29tcGF0aWJsZUJ1aWxkSWRSZWRpcmVjdFJ1bGUSFwoPc291cmNlX2J1aWxkX2lkGAEgASgJGjcKDUNvbW1pdEJ1aWxkSWQSFwoPdGFyZ2V0X2J1aWxkX2lkGAEgASgJEg0KBWZvcmNlGAIgASgIQgsKCW9wZXJhdGlvbiL8AQojVXBkYXRlV29ya2VyVmVyc2lvbmluZ1J1bGVzUmVzcG9uc2USVQoQYXNzaWdubWVudF9ydWxlcxgBIAMoCzI7LnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGltZXN0YW1wZWRCdWlsZElkQXNzaWdubWVudFJ1bGUSZgoZY29tcGF0aWJsZV9yZWRpcmVjdF9ydWxlcxgCIAMoCzJDLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGltZXN0YW1wZWRDb21wYXRpYmxlQnVpbGRJZFJlZGlyZWN0UnVsZRIWCg5jb25mbGljdF90b2tlbhgDIAEoDCJICh9HZXRXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRISCgp0YXNrX3F1ZXVlGAIgASgJIvkBCiBHZXRXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXNwb25zZRJVChBhc3NpZ25tZW50X3J1bGVzGAEgAygLMjsudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UaW1lc3RhbXBlZEJ1aWxkSWRBc3NpZ25tZW50UnVsZRJmChljb21wYXRpYmxlX3JlZGlyZWN0X3J1bGVzGAIgAygLMkMudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UaW1lc3RhbXBlZENvbXBhdGlibGVCdWlsZElkUmVkaXJlY3RSdWxlEhYKDmNvbmZsaWN0X3Rva2VuGAMgASgMIpwBCiBHZXRXb3JrZXJUYXNrUmVhY2hhYmlsaXR5UmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEQoJYnVpbGRfaWRzGAIgAygJEhMKC3Rhc2tfcXVldWVzGAMgAygJEj0KDHJlYWNoYWJpbGl0eRgEIAEoDjInLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5UYXNrUmVhY2hhYmlsaXR5InIKIUdldFdvcmtlclRhc2tSZWFjaGFiaWxpdHlSZXNwb25zZRJNChVidWlsZF9pZF9yZWFjaGFiaWxpdHkYASADKAsyLi50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLkJ1aWxkSWRSZWFjaGFiaWxpdHkihQIKHlVwZGF0ZVdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIeChZmaXJzdF9leGVjdXRpb25fcnVuX2lkGAMgASgJEjcKC3dhaXRfcG9saWN5GAQgASgLMiIudGVtcG9yYWwuYXBpLnVwZGF0ZS52MS5XYWl0UG9saWN5EjAKB3JlcXVlc3QYBSABKAsyHy50ZW1wb3JhbC5hcGkudXBkYXRlLnYxLlJlcXVlc3Qi1wEKH1VwZGF0ZVdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2USNQoKdXBkYXRlX3JlZhgBIAEoCzIhLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuVXBkYXRlUmVmEjAKB291dGNvbWUYAiABKAsyHy50ZW1wb3JhbC5hcGkudXBkYXRlLnYxLk91dGNvbWUSSwoFc3RhZ2UYAyABKA4yPC50ZW1wb3JhbC5hcGkuZW51bXMudjEuVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25MaWZlY3ljbGVTdGFnZSL0BwoaU3RhcnRCYXRjaE9wZXJhdGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhgKEHZpc2liaWxpdHlfcXVlcnkYAiABKAkSDgoGam9iX2lkGAMgASgJEg4KBnJlYXNvbhgEIAEoCRI9CgpleGVjdXRpb25zGAUgAygLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIhChltYXhfb3BlcmF0aW9uc19wZXJfc2Vjb25kGAYgASgCElEKFXRlcm1pbmF0aW9uX29wZXJhdGlvbhgKIAEoCzIwLnRlbXBvcmFsLmFwaS5iYXRjaC52MS5CYXRjaE9wZXJhdGlvblRlcm1pbmF0aW9uSAASRwoQc2lnbmFsX29wZXJhdGlvbhgLIAEoCzIrLnRlbXBvcmFsLmFwaS5iYXRjaC52MS5CYXRjaE9wZXJhdGlvblNpZ25hbEgAElMKFmNhbmNlbGxhdGlvbl9vcGVyYXRpb24YDCABKAsyMS50ZW1wb3JhbC5hcGkuYmF0Y2gudjEuQmF0Y2hPcGVyYXRpb25DYW5jZWxsYXRpb25IABJLChJkZWxldGlvbl9vcGVyYXRpb24YDSABKAsyLS50ZW1wb3JhbC5hcGkuYmF0Y2gudjEuQmF0Y2hPcGVyYXRpb25EZWxldGlvbkgAEkUKD3Jlc2V0X29wZXJhdGlvbhgOIAEoCzIqLnRlbXBvcmFsLmFwaS5iYXRjaC52MS5CYXRjaE9wZXJhdGlvblJlc2V0SAAScAohdXBkYXRlX3dvcmtmbG93X29wdGlvbnNfb3BlcmF0aW9uGA8gASgLMkMudGVtcG9yYWwuYXBpLmJhdGNoLnYxLkJhdGNoT3BlcmF0aW9uVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25PcHRpb25zSAASXgocdW5wYXVzZV9hY3Rpdml0aWVzX29wZXJhdGlvbhgQIAEoCzI2LnRlbXBvcmFsLmFwaS5iYXRjaC52MS5CYXRjaE9wZXJhdGlvblVucGF1c2VBY3Rpdml0aWVzSAASWgoacmVzZXRfYWN0aXZpdGllc19vcGVyYXRpb24YESABKAsyNC50ZW1wb3JhbC5hcGkuYmF0Y2gudjEuQmF0Y2hPcGVyYXRpb25SZXNldEFjdGl2aXRpZXNIABJnCiF1cGRhdGVfYWN0aXZpdHlfb3B0aW9uc19vcGVyYXRpb24YEiABKAsyOi50ZW1wb3JhbC5hcGkuYmF0Y2gudjEuQmF0Y2hPcGVyYXRpb25VcGRhdGVBY3Rpdml0eU9wdGlvbnNIAEILCglvcGVyYXRpb24iHQobU3RhcnRCYXRjaE9wZXJhdGlvblJlc3BvbnNlImAKGVN0b3BCYXRjaE9wZXJhdGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEg4KBmpvYl9pZBgCIAEoCRIOCgZyZWFzb24YAyABKAkSEAoIaWRlbnRpdHkYBCABKAkiHAoaU3RvcEJhdGNoT3BlcmF0aW9uUmVzcG9uc2UiQgodRGVzY3JpYmVCYXRjaE9wZXJhdGlvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEg4KBmpvYl9pZBgCIAEoCSKSAwoeRGVzY3JpYmVCYXRjaE9wZXJhdGlvblJlc3BvbnNlEkEKDm9wZXJhdGlvbl90eXBlGAEgASgOMikudGVtcG9yYWwuYXBpLmVudW1zLnYxLkJhdGNoT3BlcmF0aW9uVHlwZRIOCgZqb2JfaWQYAiABKAkSOQoFc3RhdGUYAyABKA4yKi50ZW1wb3JhbC5hcGkuZW51bXMudjEuQmF0Y2hPcGVyYXRpb25TdGF0ZRIuCgpzdGFydF90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIuCgpjbG9zZV90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIdChV0b3RhbF9vcGVyYXRpb25fY291bnQYBiABKAMSIAoYY29tcGxldGVfb3BlcmF0aW9uX2NvdW50GAcgASgDEh8KF2ZhaWx1cmVfb3BlcmF0aW9uX2NvdW50GAggASgDEhAKCGlkZW50aXR5GAkgASgJEg4KBnJlYXNvbhgKIAEoCSJbChpMaXN0QmF0Y2hPcGVyYXRpb25zUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEQoJcGFnZV9zaXplGAIgASgFEhcKD25leHRfcGFnZV90b2tlbhgDIAEoDCJ5ChtMaXN0QmF0Y2hPcGVyYXRpb25zUmVzcG9uc2USQQoOb3BlcmF0aW9uX2luZm8YASADKAsyKS50ZW1wb3JhbC5hcGkuYmF0Y2gudjEuQmF0Y2hPcGVyYXRpb25JbmZvEhcKD25leHRfcGFnZV90b2tlbhgCIAEoDCK5AQoiUG9sbFdvcmtmbG93RXhlY3V0aW9uVXBkYXRlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSNQoKdXBkYXRlX3JlZhgCIAEoCzIhLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuVXBkYXRlUmVmEhAKCGlkZW50aXR5GAMgASgJEjcKC3dhaXRfcG9saWN5GAQgASgLMiIudGVtcG9yYWwuYXBpLnVwZGF0ZS52MS5XYWl0UG9saWN5ItsBCiNQb2xsV29ya2Zsb3dFeGVjdXRpb25VcGRhdGVSZXNwb25zZRIwCgdvdXRjb21lGAEgASgLMh8udGVtcG9yYWwuYXBpLnVwZGF0ZS52MS5PdXRjb21lEksKBXN0YWdlGAIgASgOMjwudGVtcG9yYWwuYXBpLmVudW1zLnYxLlVwZGF0ZVdvcmtmbG93RXhlY3V0aW9uTGlmZWN5Y2xlU3RhZ2USNQoKdXBkYXRlX3JlZhgDIAEoCzIhLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuVXBkYXRlUmVmIuoCChlQb2xsTmV4dXNUYXNrUXVldWVSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIQCghpZGVudGl0eRgCIAEoCRI4Cgp0YXNrX3F1ZXVlGAMgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUSWgobd29ya2VyX3ZlcnNpb25fY2FwYWJpbGl0aWVzGAQgASgLMjEudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJWZXJzaW9uQ2FwYWJpbGl0aWVzQgIYARJPChJkZXBsb3ltZW50X29wdGlvbnMYBiABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50T3B0aW9ucxJBChB3b3JrZXJfaGVhcnRiZWF0GAcgAygLMicudGVtcG9yYWwuYXBpLndvcmtlci52MS5Xb3JrZXJIZWFydGJlYXQitAEKGlBvbGxOZXh1c1Rhc2tRdWV1ZVJlc3BvbnNlEhIKCnRhc2tfdG9rZW4YASABKAwSLwoHcmVxdWVzdBgCIAEoCzIeLnRlbXBvcmFsLmFwaS5uZXh1cy52MS5SZXF1ZXN0ElEKF3BvbGxlcl9zY2FsaW5nX2RlY2lzaW9uGAMgASgLMjAudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5Qb2xsZXJTY2FsaW5nRGVjaXNpb24ijgEKIFJlc3BvbmROZXh1c1Rhc2tDb21wbGV0ZWRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIQCghpZGVudGl0eRgCIAEoCRISCgp0YXNrX3Rva2VuGAMgASgMEjEKCHJlc3BvbnNlGAQgASgLMh8udGVtcG9yYWwuYXBpLm5leHVzLnYxLlJlc3BvbnNlIiMKIVJlc3BvbmROZXh1c1Rhc2tDb21wbGV0ZWRSZXNwb25zZSKMAQodUmVzcG9uZE5leHVzVGFza0ZhaWxlZFJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhAKCGlkZW50aXR5GAIgASgJEhIKCnRhc2tfdG9rZW4YAyABKAwSMgoFZXJyb3IYBCABKAsyIy50ZW1wb3JhbC5hcGkubmV4dXMudjEuSGFuZGxlckVycm9yIiAKHlJlc3BvbmROZXh1c1Rhc2tGYWlsZWRSZXNwb25zZSLfAgocRXhlY3V0ZU11bHRpT3BlcmF0aW9uUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSWwoKb3BlcmF0aW9ucxgCIAMoCzJHLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRXhlY3V0ZU11bHRpT3BlcmF0aW9uUmVxdWVzdC5PcGVyYXRpb24azgEKCU9wZXJhdGlvbhJYCg5zdGFydF93b3JrZmxvdxgBIAEoCzI+LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU3RhcnRXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3RIABJaCg91cGRhdGVfd29ya2Zsb3cYAiABKAsyPy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdEgAQgsKCW9wZXJhdGlvbiLMAgodRXhlY3V0ZU11bHRpT3BlcmF0aW9uUmVzcG9uc2USWgoJcmVzcG9uc2VzGAEgAygLMkcudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5FeGVjdXRlTXVsdGlPcGVyYXRpb25SZXNwb25zZS5SZXNwb25zZRrOAQoIUmVzcG9uc2USWQoOc3RhcnRfd29ya2Zsb3cYASABKAsyPy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlN0YXJ0V29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZUgAElsKD3VwZGF0ZV93b3JrZmxvdxgCIAEoCzJALnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZUgAQgoKCHJlc3BvbnNlItACChxVcGRhdGVBY3Rpdml0eU9wdGlvbnNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI8CglleGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEhAKCGlkZW50aXR5GAMgASgJEkMKEGFjdGl2aXR5X29wdGlvbnMYBCABKAsyKS50ZW1wb3JhbC5hcGkuYWN0aXZpdHkudjEuQWN0aXZpdHlPcHRpb25zEi8KC3VwZGF0ZV9tYXNrGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzaxIMCgJpZBgGIAEoCUgAEg4KBHR5cGUYByABKAlIABITCgltYXRjaF9hbGwYCSABKAhIABIYChByZXN0b3JlX29yaWdpbmFsGAggASgIQgoKCGFjdGl2aXR5ImQKHVVwZGF0ZUFjdGl2aXR5T3B0aW9uc1Jlc3BvbnNlEkMKEGFjdGl2aXR5X29wdGlvbnMYASABKAsyKS50ZW1wb3JhbC5hcGkuYWN0aXZpdHkudjEuQWN0aXZpdHlPcHRpb25zIrMBChRQYXVzZUFjdGl2aXR5UmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSPAoJZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIQCghpZGVudGl0eRgDIAEoCRIMCgJpZBgEIAEoCUgAEg4KBHR5cGUYBSABKAlIABIOCgZyZWFzb24YBiABKAlCCgoIYWN0aXZpdHkiFwoVUGF1c2VBY3Rpdml0eVJlc3BvbnNlIpgCChZVbnBhdXNlQWN0aXZpdHlSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI8CglleGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEhAKCGlkZW50aXR5GAMgASgJEgwKAmlkGAQgASgJSAASDgoEdHlwZRgFIAEoCUgAEhUKC3VucGF1c2VfYWxsGAYgASgISAASFgoOcmVzZXRfYXR0ZW1wdHMYByABKAgSFwoPcmVzZXRfaGVhcnRiZWF0GAggASgIEikKBmppdHRlchgJIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIKCghhY3Rpdml0eSIZChdVbnBhdXNlQWN0aXZpdHlSZXNwb25zZSKzAgoUUmVzZXRBY3Rpdml0eVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjwKCWV4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SEAoIaWRlbnRpdHkYAyABKAkSDAoCaWQYBCABKAlIABIOCgR0eXBlGAUgASgJSAASEwoJbWF0Y2hfYWxsGAogASgISAASFwoPcmVzZXRfaGVhcnRiZWF0GAYgASgIEhMKC2tlZXBfcGF1c2VkGAcgASgIEikKBmppdHRlchgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIgChhyZXN0b3JlX29yaWdpbmFsX29wdGlvbnMYCSABKAhCCgoIYWN0aXZpdHkiFwoVUmVzZXRBY3Rpdml0eVJlc3BvbnNlIpwCCiVVcGRhdGVXb3JrZmxvd0V4ZWN1dGlvbk9wdGlvbnNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRJFChJ3b3JrZmxvd19leGVjdXRpb24YAiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uElYKGndvcmtmbG93X2V4ZWN1dGlvbl9vcHRpb25zGAMgASgLMjIudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uT3B0aW9ucxIvCgt1cGRhdGVfbWFzaxgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sSEAoIaWRlbnRpdHkYBSABKAkigAEKJlVwZGF0ZVdvcmtmbG93RXhlY3V0aW9uT3B0aW9uc1Jlc3BvbnNlElYKGndvcmtmbG93X2V4ZWN1dGlvbl9vcHRpb25zGAEgASgLMjIudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLldvcmtmbG93RXhlY3V0aW9uT3B0aW9ucyJqChlEZXNjcmliZURlcGxveW1lbnRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI6CgpkZXBsb3ltZW50GAIgASgLMiYudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudCJhChpEZXNjcmliZURlcGxveW1lbnRSZXNwb25zZRJDCg9kZXBsb3ltZW50X2luZm8YASABKAsyKi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50SW5mbyLCAQomRGVzY3JpYmVXb3JrZXJEZXBsb3ltZW50VmVyc2lvblJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhMKB3ZlcnNpb24YAiABKAlCAhgBEk8KEmRlcGxveW1lbnRfdmVyc2lvbhgDIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uEh8KF3JlcG9ydF90YXNrX3F1ZXVlX3N0YXRzGAQgASgIIowFCidEZXNjcmliZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uUmVzcG9uc2USXwoed29ya2VyX2RlcGxveW1lbnRfdmVyc2lvbl9pbmZvGAEgASgLMjcudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuV29ya2VyRGVwbG95bWVudFZlcnNpb25JbmZvEnYKE3ZlcnNpb25fdGFza19xdWV1ZXMYAiADKAsyWS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlV29ya2VyRGVwbG95bWVudFZlcnNpb25SZXNwb25zZS5WZXJzaW9uVGFza1F1ZXVlGocDChBWZXJzaW9uVGFza1F1ZXVlEgwKBG5hbWUYASABKAkSMgoEdHlwZRgCIAEoDjIkLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5UYXNrUXVldWVUeXBlEjgKBXN0YXRzGAMgASgLMikudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVTdGF0cxKQAQoVc3RhdHNfYnlfcHJpb3JpdHlfa2V5GAQgAygLMnEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uUmVzcG9uc2UuVmVyc2lvblRhc2tRdWV1ZS5TdGF0c0J5UHJpb3JpdHlLZXlFbnRyeRpkChdTdGF0c0J5UHJpb3JpdHlLZXlFbnRyeRILCgNrZXkYASABKAUSOAoFdmFsdWUYAiABKAsyKS50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZVN0YXRzOgI4ASJNCh9EZXNjcmliZVdvcmtlckRlcGxveW1lbnRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIXCg9kZXBsb3ltZW50X25hbWUYAiABKAkijAEKIERlc2NyaWJlV29ya2VyRGVwbG95bWVudFJlc3BvbnNlEhYKDmNvbmZsaWN0X3Rva2VuGAEgASgMElAKFndvcmtlcl9kZXBsb3ltZW50X2luZm8YAiABKAsyMC50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50SW5mbyJsChZMaXN0RGVwbG95bWVudHNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIRCglwYWdlX3NpemUYAiABKAUSFwoPbmV4dF9wYWdlX3Rva2VuGAMgASgMEhMKC3Nlcmllc19uYW1lGAQgASgJIncKF0xpc3REZXBsb3ltZW50c1Jlc3BvbnNlEhcKD25leHRfcGFnZV90b2tlbhgBIAEoDBJDCgtkZXBsb3ltZW50cxgCIAMoCzIuLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLkRlcGxveW1lbnRMaXN0SW5mbyLNAQobU2V0Q3VycmVudERlcGxveW1lbnRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRI6CgpkZXBsb3ltZW50GAIgASgLMiYudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudBIQCghpZGVudGl0eRgDIAEoCRJNCg91cGRhdGVfbWV0YWRhdGEYBCABKAsyNC50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5VcGRhdGVEZXBsb3ltZW50TWV0YWRhdGEiuQEKHFNldEN1cnJlbnREZXBsb3ltZW50UmVzcG9uc2USSwoXY3VycmVudF9kZXBsb3ltZW50X2luZm8YASABKAsyKi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50SW5mbxJMChhwcmV2aW91c19kZXBsb3ltZW50X2luZm8YAiABKAsyKi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50SW5mbyLlAQooU2V0V29ya2VyRGVwbG95bWVudEN1cnJlbnRWZXJzaW9uUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSFwoPZGVwbG95bWVudF9uYW1lGAIgASgJEhMKB3ZlcnNpb24YAyABKAlCAhgBEhAKCGJ1aWxkX2lkGAcgASgJEhYKDmNvbmZsaWN0X3Rva2VuGAQgASgMEhAKCGlkZW50aXR5GAUgASgJEiIKGmlnbm9yZV9taXNzaW5nX3Rhc2tfcXVldWVzGAYgASgIEhgKEGFsbG93X25vX3BvbGxlcnMYCSABKAgiuwEKKVNldFdvcmtlckRlcGxveW1lbnRDdXJyZW50VmVyc2lvblJlc3BvbnNlEhYKDmNvbmZsaWN0X3Rva2VuGAEgASgMEhwKEHByZXZpb3VzX3ZlcnNpb24YAiABKAlCAhgBElgKG3ByZXZpb3VzX2RlcGxveW1lbnRfdmVyc2lvbhgDIAEoCzIzLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRWZXJzaW9uIvkBCihTZXRXb3JrZXJEZXBsb3ltZW50UmFtcGluZ1ZlcnNpb25SZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIXCg9kZXBsb3ltZW50X25hbWUYAiABKAkSEwoHdmVyc2lvbhgDIAEoCUICGAESEAoIYnVpbGRfaWQYCCABKAkSEgoKcGVyY2VudGFnZRgEIAEoAhIWCg5jb25mbGljdF90b2tlbhgFIAEoDBIQCghpZGVudGl0eRgGIAEoCRIiChppZ25vcmVfbWlzc2luZ190YXNrX3F1ZXVlcxgHIAEoCBIYChBhbGxvd19ub19wb2xsZXJzGAogASgIItgBCilTZXRXb3JrZXJEZXBsb3ltZW50UmFtcGluZ1ZlcnNpb25SZXNwb25zZRIWCg5jb25mbGljdF90b2tlbhgBIAEoDBIcChBwcmV2aW91c192ZXJzaW9uGAIgASgJQgIYARJYChtwcmV2aW91c19kZXBsb3ltZW50X3ZlcnNpb24YBCABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhIbChNwcmV2aW91c19wZXJjZW50YWdlGAMgASgCIl0KHExpc3RXb3JrZXJEZXBsb3ltZW50c1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAyABKAwinwUKHUxpc3RXb3JrZXJEZXBsb3ltZW50c1Jlc3BvbnNlEhcKD25leHRfcGFnZV90b2tlbhgBIAEoDBJyChJ3b3JrZXJfZGVwbG95bWVudHMYAiADKAsyVi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RXb3JrZXJEZXBsb3ltZW50c1Jlc3BvbnNlLldvcmtlckRlcGxveW1lbnRTdW1tYXJ5GvADChdXb3JrZXJEZXBsb3ltZW50U3VtbWFyeRIMCgRuYW1lGAEgASgJEi8KC2NyZWF0ZV90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJBCg5yb3V0aW5nX2NvbmZpZxgDIAEoCzIpLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLlJvdXRpbmdDb25maWcSbwoWbGF0ZXN0X3ZlcnNpb25fc3VtbWFyeRgEIAEoCzJPLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRJbmZvLldvcmtlckRlcGxveW1lbnRWZXJzaW9uU3VtbWFyeRJwChdjdXJyZW50X3ZlcnNpb25fc3VtbWFyeRgFIAEoCzJPLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRJbmZvLldvcmtlckRlcGxveW1lbnRWZXJzaW9uU3VtbWFyeRJwChdyYW1waW5nX3ZlcnNpb25fc3VtbWFyeRgGIAEoCzJPLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLldvcmtlckRlcGxveW1lbnRJbmZvLldvcmtlckRlcGxveW1lbnRWZXJzaW9uU3VtbWFyeSLIAQokRGVsZXRlV29ya2VyRGVwbG95bWVudFZlcnNpb25SZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgd2ZXJzaW9uGAIgASgJQgIYARJPChJkZXBsb3ltZW50X3ZlcnNpb24YBSABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhIVCg1za2lwX2RyYWluYWdlGAMgASgIEhAKCGlkZW50aXR5GAQgASgJIicKJURlbGV0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uUmVzcG9uc2UiXQodRGVsZXRlV29ya2VyRGVwbG95bWVudFJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhcKD2RlcGxveW1lbnRfbmFtZRgCIAEoCRIQCghpZGVudGl0eRgDIAEoCSIgCh5EZWxldGVXb3JrZXJEZXBsb3ltZW50UmVzcG9uc2UiogMKLFVwZGF0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uTWV0YWRhdGFSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgd2ZXJzaW9uGAIgASgJQgIYARJPChJkZXBsb3ltZW50X3ZlcnNpb24YBSABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhJ4Cg51cHNlcnRfZW50cmllcxgDIAMoCzJgLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyRGVwbG95bWVudFZlcnNpb25NZXRhZGF0YVJlcXVlc3QuVXBzZXJ0RW50cmllc0VudHJ5EhYKDnJlbW92ZV9lbnRyaWVzGAQgAygJEhAKCGlkZW50aXR5GAYgASgJGlUKElVwc2VydEVudHJpZXNFbnRyeRILCgNrZXkYASABKAkSLgoFdmFsdWUYAiABKAsyHy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWQ6AjgBIm4KLVVwZGF0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uTWV0YWRhdGFSZXNwb25zZRI9CghtZXRhZGF0YRgBIAEoCzIrLnRlbXBvcmFsLmFwaS5kZXBsb3ltZW50LnYxLlZlcnNpb25NZXRhZGF0YSK9AQohU2V0V29ya2VyRGVwbG95bWVudE1hbmFnZXJSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIXCg9kZXBsb3ltZW50X25hbWUYAiABKAkSGgoQbWFuYWdlcl9pZGVudGl0eRgDIAEoCUgAEg4KBHNlbGYYBCABKAhIABIWCg5jb25mbGljdF90b2tlbhgFIAEoDBIQCghpZGVudGl0eRgGIAEoCUIWChRuZXdfbWFuYWdlcl9pZGVudGl0eSJfCiJTZXRXb3JrZXJEZXBsb3ltZW50TWFuYWdlclJlc3BvbnNlEhYKDmNvbmZsaWN0X3Rva2VuGAEgASgMEiEKGXByZXZpb3VzX21hbmFnZXJfaWRlbnRpdHkYAiABKAkiRQobR2V0Q3VycmVudERlcGxveW1lbnRSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRITCgtzZXJpZXNfbmFtZRgCIAEoCSJrChxHZXRDdXJyZW50RGVwbG95bWVudFJlc3BvbnNlEksKF2N1cnJlbnRfZGVwbG95bWVudF9pbmZvGAEgASgLMioudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudEluZm8icQogR2V0RGVwbG95bWVudFJlYWNoYWJpbGl0eVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjoKCmRlcGxveW1lbnQYAiABKAsyJi50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5EZXBsb3ltZW50IuMBCiFHZXREZXBsb3ltZW50UmVhY2hhYmlsaXR5UmVzcG9uc2USQwoPZGVwbG95bWVudF9pbmZvGAEgASgLMioudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudEluZm8SQwoMcmVhY2hhYmlsaXR5GAIgASgOMi0udGVtcG9yYWwuYXBpLmVudW1zLnYxLkRlcGxveW1lbnRSZWFjaGFiaWxpdHkSNAoQbGFzdF91cGRhdGVfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAitAEKGUNyZWF0ZVdvcmtmbG93UnVsZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEjUKBHNwZWMYAiABKAsyJy50ZW1wb3JhbC5hcGkucnVsZXMudjEuV29ya2Zsb3dSdWxlU3BlYxISCgpmb3JjZV9zY2FuGAMgASgIEhIKCnJlcXVlc3RfaWQYBCABKAkSEAoIaWRlbnRpdHkYBSABKAkSEwoLZGVzY3JpcHRpb24YBiABKAkiXwoaQ3JlYXRlV29ya2Zsb3dSdWxlUmVzcG9uc2USMQoEcnVsZRgBIAEoCzIjLnRlbXBvcmFsLmFwaS5ydWxlcy52MS5Xb3JrZmxvd1J1bGUSDgoGam9iX2lkGAIgASgJIkEKG0Rlc2NyaWJlV29ya2Zsb3dSdWxlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSDwoHcnVsZV9pZBgCIAEoCSJRChxEZXNjcmliZVdvcmtmbG93UnVsZVJlc3BvbnNlEjEKBHJ1bGUYASABKAsyIy50ZW1wb3JhbC5hcGkucnVsZXMudjEuV29ya2Zsb3dSdWxlIj8KGURlbGV0ZVdvcmtmbG93UnVsZVJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEg8KB3J1bGVfaWQYAiABKAkiHAoaRGVsZXRlV29ya2Zsb3dSdWxlUmVzcG9uc2UiRgoYTGlzdFdvcmtmbG93UnVsZXNSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAwiaAoZTGlzdFdvcmtmbG93UnVsZXNSZXNwb25zZRIyCgVydWxlcxgBIAMoCzIjLnRlbXBvcmFsLmFwaS5ydWxlcy52MS5Xb3JrZmxvd1J1bGUSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgMIs4BChpUcmlnZ2VyV29ya2Zsb3dSdWxlUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSPAoJZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhIMCgJpZBgEIAEoCUgAEjcKBHNwZWMYBSABKAsyJy50ZW1wb3JhbC5hcGkucnVsZXMudjEuV29ya2Zsb3dSdWxlU3BlY0gAEhAKCGlkZW50aXR5GAMgASgJQgYKBHJ1bGUiLgobVHJpZ2dlcldvcmtmbG93UnVsZVJlc3BvbnNlEg8KB2FwcGxpZWQYASABKAgihgEKHFJlY29yZFdvcmtlckhlYXJ0YmVhdFJlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhAKCGlkZW50aXR5GAIgASgJEkEKEHdvcmtlcl9oZWFydGJlYXQYAyADKAsyJy50ZW1wb3JhbC5hcGkud29ya2VyLnYxLldvcmtlckhlYXJ0YmVhdCIfCh1SZWNvcmRXb3JrZXJIZWFydGJlYXRSZXNwb25zZSJiChJMaXN0V29ya2Vyc1JlcXVlc3QSEQoJbmFtZXNwYWNlGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRIXCg9uZXh0X3BhZ2VfdG9rZW4YAyABKAwSDQoFcXVlcnkYBCABKAkiaAoTTGlzdFdvcmtlcnNSZXNwb25zZRI4Cgx3b3JrZXJzX2luZm8YASADKAsyIi50ZW1wb3JhbC5hcGkud29ya2VyLnYxLldvcmtlckluZm8SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgMItUFChxVcGRhdGVUYXNrUXVldWVDb25maWdSZXF1ZXN0EhEKCW5hbWVzcGFjZRgBIAEoCRIQCghpZGVudGl0eRgCIAEoCRISCgp0YXNrX3F1ZXVlGAMgASgJEj0KD3Rhc2tfcXVldWVfdHlwZRgEIAEoDjIkLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5UYXNrUXVldWVUeXBlEm4KF3VwZGF0ZV9xdWV1ZV9yYXRlX2xpbWl0GAUgASgLMk0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVUYXNrUXVldWVDb25maWdSZXF1ZXN0LlJhdGVMaW1pdFVwZGF0ZRJ9CiZ1cGRhdGVfZmFpcm5lc3Nfa2V5X3JhdGVfbGltaXRfZGVmYXVsdBgGIAEoCzJNLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlVGFza1F1ZXVlQ29uZmlnUmVxdWVzdC5SYXRlTGltaXRVcGRhdGUShAEKHXNldF9mYWlybmVzc193ZWlnaHRfb3ZlcnJpZGVzGAcgAygLMl0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVUYXNrUXVldWVDb25maWdSZXF1ZXN0LlNldEZhaXJuZXNzV2VpZ2h0T3ZlcnJpZGVzRW50cnkSJwofdW5zZXRfZmFpcm5lc3Nfd2VpZ2h0X292ZXJyaWRlcxgIIAMoCRpbCg9SYXRlTGltaXRVcGRhdGUSOAoKcmF0ZV9saW1pdBgBIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuUmF0ZUxpbWl0Eg4KBnJlYXNvbhgCIAEoCRpBCh9TZXRGYWlybmVzc1dlaWdodE92ZXJyaWRlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoAjoCOAEiWwodVXBkYXRlVGFza1F1ZXVlQ29uZmlnUmVzcG9uc2USOgoGY29uZmlnGAEgASgLMioudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWVDb25maWciiQEKGEZldGNoV29ya2VyQ29uZmlnUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEAoIaWRlbnRpdHkYAiABKAkSDgoGcmVhc29uGAMgASgJEjgKCHNlbGVjdG9yGAYgASgLMiYudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJTZWxlY3RvciJVChlGZXRjaFdvcmtlckNvbmZpZ1Jlc3BvbnNlEjgKDXdvcmtlcl9jb25maWcYASABKAsyIS50ZW1wb3JhbC5hcGkuc2RrLnYxLldvcmtlckNvbmZpZyL1AQoZVXBkYXRlV29ya2VyQ29uZmlnUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSEAoIaWRlbnRpdHkYAiABKAkSDgoGcmVhc29uGAMgASgJEjgKDXdvcmtlcl9jb25maWcYBCABKAsyIS50ZW1wb3JhbC5hcGkuc2RrLnYxLldvcmtlckNvbmZpZxIvCgt1cGRhdGVfbWFzaxgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sSOAoIc2VsZWN0b3IYBiABKAsyJi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclNlbGVjdG9yImQKGlVwZGF0ZVdvcmtlckNvbmZpZ1Jlc3BvbnNlEjoKDXdvcmtlcl9jb25maWcYASABKAsyIS50ZW1wb3JhbC5hcGkuc2RrLnYxLldvcmtlckNvbmZpZ0gAQgoKCHJlc3BvbnNlIkcKFURlc2NyaWJlV29ya2VyUmVxdWVzdBIRCgluYW1lc3BhY2UYASABKAkSGwoTd29ya2VyX2luc3RhbmNlX2tleRgCIAEoCSJRChZEZXNjcmliZVdvcmtlclJlc3BvbnNlEjcKC3dvcmtlcl9pbmZvGAEgASgLMiIudGVtcG9yYWwuYXBpLndvcmtlci52MS5Xb3JrZXJJbmZvQr4BCiJpby50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxQhRSZXF1ZXN0UmVzcG9uc2VQcm90b1ABWjVnby50ZW1wb3JhbC5pby9hcGkvd29ya2Zsb3dzZXJ2aWNlL3YxO3dvcmtmbG93c2VydmljZaoCIVRlbXBvcmFsaW8uQXBpLldvcmtmbG93U2VydmljZS5WMeoCJFRlbXBvcmFsaW86OkFwaTo6V29ya2Zsb3dTZXJ2aWNlOjpWMWIGcHJvdG8z", [file_temporal_api_enums_v1_batch_operation, file_temporal_api_enums_v1_common, file_temporal_api_enums_v1_workflow, file_temporal_api_enums_v1_namespace, file_temporal_api_enums_v1_failed_cause, file_temporal_api_enums_v1_query, file_temporal_api_enums_v1_reset, file_temporal_api_enums_v1_task_queue, file_temporal_api_enums_v1_deployment, file_temporal_api_enums_v1_update, file_temporal_api_activity_v1_message, file_temporal_api_common_v1_message, file_temporal_api_history_v1_message, file_temporal_api_workflow_v1_message, file_temporal_api_command_v1_message, file_temporal_api_deployment_v1_message, file_temporal_api_failure_v1_message, file_temporal_api_filter_v1_message, file_temporal_api_protocol_v1_message, file_temporal_api_namespace_v1_message, file_temporal_api_query_v1_message, file_temporal_api_replication_v1_message, file_temporal_api_rules_v1_message, file_temporal_api_sdk_v1_worker_config, file_temporal_api_schedule_v1_message, file_temporal_api_taskqueue_v1_message, file_temporal_api_update_v1_message, file_temporal_api_version_v1_message, file_temporal_api_batch_v1_message, file_temporal_api_sdk_v1_task_complete_metadata, file_temporal_api_sdk_v1_user_metadata, file_temporal_api_nexus_v1_message, file_temporal_api_worker_v1_message, file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * @generated from message temporal.api.workflowservice.v1.RegisterNamespaceRequest
 */
export type RegisterNamespaceRequest = Message<"temporal.api.workflowservice.v1.RegisterNamespaceRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: string owner_email = 3;
   */
  ownerEmail: string;

  /**
   * @generated from field: google.protobuf.Duration workflow_execution_retention_period = 4;
   */
  workflowExecutionRetentionPeriod?: Duration;

  /**
   * @generated from field: repeated temporal.api.replication.v1.ClusterReplicationConfig clusters = 5;
   */
  clusters: ClusterReplicationConfig[];

  /**
   * @generated from field: string active_cluster_name = 6;
   */
  activeClusterName: string;

  /**
   * A key-value map for any customized purpose.
   *
   * @generated from field: map<string, string> data = 7;
   */
  data: { [key: string]: string };

  /**
   * @generated from field: string security_token = 8;
   */
  securityToken: string;

  /**
   * @generated from field: bool is_global_namespace = 9;
   */
  isGlobalNamespace: boolean;

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState history_archival_state = 10;
   */
  historyArchivalState: ArchivalState;

  /**
   * @generated from field: string history_archival_uri = 11;
   */
  historyArchivalUri: string;

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState visibility_archival_state = 12;
   */
  visibilityArchivalState: ArchivalState;

  /**
   * @generated from field: string visibility_archival_uri = 13;
   */
  visibilityArchivalUri: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RegisterNamespaceRequest.
 * Use `create(RegisterNamespaceRequestSchema)` to create a new message.
 */
export const RegisterNamespaceRequestSchema: GenMessage<RegisterNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.RegisterNamespaceResponse
 */
export type RegisterNamespaceResponse = Message<"temporal.api.workflowservice.v1.RegisterNamespaceResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RegisterNamespaceResponse.
 * Use `create(RegisterNamespaceResponseSchema)` to create a new message.
 */
export const RegisterNamespaceResponseSchema: GenMessage<RegisterNamespaceResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 1);

/**
 * @generated from message temporal.api.workflowservice.v1.ListNamespacesRequest
 */
export type ListNamespacesRequest = Message<"temporal.api.workflowservice.v1.ListNamespacesRequest"> & {
  /**
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceFilter namespace_filter = 3;
   */
  namespaceFilter?: NamespaceFilter;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListNamespacesRequest.
 * Use `create(ListNamespacesRequestSchema)` to create a new message.
 */
export const ListNamespacesRequestSchema: GenMessage<ListNamespacesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 2);

/**
 * @generated from message temporal.api.workflowservice.v1.ListNamespacesResponse
 */
export type ListNamespacesResponse = Message<"temporal.api.workflowservice.v1.ListNamespacesResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflowservice.v1.DescribeNamespaceResponse namespaces = 1;
   */
  namespaces: DescribeNamespaceResponse[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListNamespacesResponse.
 * Use `create(ListNamespacesResponseSchema)` to create a new message.
 */
export const ListNamespacesResponseSchema: GenMessage<ListNamespacesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 3);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeNamespaceRequest
 */
export type DescribeNamespaceRequest = Message<"temporal.api.workflowservice.v1.DescribeNamespaceRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string id = 2;
   */
  id: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeNamespaceRequest.
 * Use `create(DescribeNamespaceRequestSchema)` to create a new message.
 */
export const DescribeNamespaceRequestSchema: GenMessage<DescribeNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 4);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeNamespaceResponse
 */
export type DescribeNamespaceResponse = Message<"temporal.api.workflowservice.v1.DescribeNamespaceResponse"> & {
  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
   */
  namespaceInfo?: NamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 2;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: int64 failover_version = 4;
   */
  failoverVersion: bigint;

  /**
   * @generated from field: bool is_global_namespace = 5;
   */
  isGlobalNamespace: boolean;

  /**
   * Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
   * states to ensure that the list does not grow unbounded.
   *
   * @generated from field: repeated temporal.api.replication.v1.FailoverStatus failover_history = 6;
   */
  failoverHistory: FailoverStatus[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeNamespaceResponse.
 * Use `create(DescribeNamespaceResponseSchema)` to create a new message.
 */
export const DescribeNamespaceResponseSchema: GenMessage<DescribeNamespaceResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 5);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateNamespaceRequest
 */
export type UpdateNamespaceRequest = Message<"temporal.api.workflowservice.v1.UpdateNamespaceRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.namespace.v1.UpdateNamespaceInfo update_info = 2;
   */
  updateInfo?: UpdateNamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 3;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 4;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: string security_token = 5;
   */
  securityToken: string;

  /**
   * @generated from field: string delete_bad_binary = 6;
   */
  deleteBadBinary: string;

  /**
   * promote local namespace to global namespace. Ignored if namespace is already global namespace.
   *
   * @generated from field: bool promote_namespace = 7;
   */
  promoteNamespace: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateNamespaceRequest.
 * Use `create(UpdateNamespaceRequestSchema)` to create a new message.
 */
export const UpdateNamespaceRequestSchema: GenMessage<UpdateNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 6);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateNamespaceResponse
 */
export type UpdateNamespaceResponse = Message<"temporal.api.workflowservice.v1.UpdateNamespaceResponse"> & {
  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
   */
  namespaceInfo?: NamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 2;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: int64 failover_version = 4;
   */
  failoverVersion: bigint;

  /**
   * @generated from field: bool is_global_namespace = 5;
   */
  isGlobalNamespace: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateNamespaceResponse.
 * Use `create(UpdateNamespaceResponseSchema)` to create a new message.
 */
export const UpdateNamespaceResponseSchema: GenMessage<UpdateNamespaceResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 7);

/**
 * Deprecated.
 *
 * @generated from message temporal.api.workflowservice.v1.DeprecateNamespaceRequest
 */
export type DeprecateNamespaceRequest = Message<"temporal.api.workflowservice.v1.DeprecateNamespaceRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string security_token = 2;
   */
  securityToken: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeprecateNamespaceRequest.
 * Use `create(DeprecateNamespaceRequestSchema)` to create a new message.
 */
export const DeprecateNamespaceRequestSchema: GenMessage<DeprecateNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 8);

/**
 * Deprecated.
 *
 * @generated from message temporal.api.workflowservice.v1.DeprecateNamespaceResponse
 */
export type DeprecateNamespaceResponse = Message<"temporal.api.workflowservice.v1.DeprecateNamespaceResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeprecateNamespaceResponse.
 * Use `create(DeprecateNamespaceResponseSchema)` to create a new message.
 */
export const DeprecateNamespaceResponseSchema: GenMessage<DeprecateNamespaceResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 9);

/**
 * @generated from message temporal.api.workflowservice.v1.StartWorkflowExecutionRequest
 */
export type StartWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.StartWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow. These are passed as arguments to the workflow function.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 9;
   */
  identity: string;

  /**
   * A unique identifier for this start request. Typically UUIDv4.
   *
   * @generated from field: string request_id = 10;
   */
  requestId: string;

  /**
   * Defines whether to allow re-using the workflow id from a previously *closed* workflow.
   * The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * Defines how to resolve a workflow id conflict with a *running* workflow.
   * The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
   */
  workflowIdConflictPolicy: WorkflowIdConflictPolicy;

  /**
   * The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 12;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 13;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 14;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 15;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 16;
   */
  header?: Header;

  /**
   * Request to get the first workflow task inline in the response bypassing matching service and worker polling.
   * If set to `true` the caller is expected to have a worker available and capable of processing the task.
   * The returned task will be marked as started and is expected to be completed by the specified
   * `workflow_task_timeout`.
   *
   * @generated from field: bool request_eager_execution = 17;
   */
  requestEagerExecution: boolean;

  /**
   * These values will be available as ContinuedFailure and LastCompletionResult in the
   * WorkflowExecutionStarted event and through SDKs. The are currently only used by the
   * server itself (for the schedules feature) and are not intended to be exposed in
   * StartWorkflowExecution.
   *
   * @generated from field: temporal.api.failure.v1.Failure continued_failure = 18;
   */
  continuedFailure?: Failure;

  /**
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 19;
   */
  lastCompletionResult?: Payloads;

  /**
   * Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
   * If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
   * of the delay will be ignored.
   *
   * @generated from field: google.protobuf.Duration workflow_start_delay = 20;
   */
  workflowStartDelay?: Duration;

  /**
   * Callbacks to be called by the server when this workflow reaches a terminal state.
   * If the workflow continues-as-new, these callbacks will be carried over to the new execution.
   * Callback addresses must be whitelisted in the server's dynamic configuration.
   *
   * @generated from field: repeated temporal.api.common.v1.Callback completion_callbacks = 21;
   */
  completionCallbacks: Callback[];

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 23;
   */
  userMetadata?: UserMetadata;

  /**
   * Links to be associated with the workflow.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 24;
   */
  links: Link[];

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 25;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Defines actions to be done to the existing running workflow when the conflict policy
   * WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
   * empty object (ie., all options with default value), it won't do anything to the existing
   * running workflow. If set, it will add a history event to the running workflow.
   *
   * @generated from field: temporal.api.workflow.v1.OnConflictOptions on_conflict_options = 26;
   */
  onConflictOptions?: OnConflictOptions;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 27;
   */
  priority?: Priority;

  /**
   * Deployment Options of the worker who will process the eager task. Passed when `request_eager_execution=true`.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions eager_worker_deployment_options = 28;
   */
  eagerWorkerDeploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.StartWorkflowExecutionRequest.
 * Use `create(StartWorkflowExecutionRequestSchema)` to create a new message.
 */
export const StartWorkflowExecutionRequestSchema: GenMessage<StartWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 10);

/**
 * @generated from message temporal.api.workflowservice.v1.StartWorkflowExecutionResponse
 */
export type StartWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.StartWorkflowExecutionResponse"> & {
  /**
   * The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * If true, a new workflow was started.
   *
   * @generated from field: bool started = 3;
   */
  started: boolean;

  /**
   * Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING
   * unless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs).
   *
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
   */
  status: WorkflowExecutionStatus;

  /**
   * When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
   * return the first workflow task to be eagerly executed.
   * The caller is expected to have a worker available to process the task.
   *
   * @generated from field: temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse eager_workflow_task = 2;
   */
  eagerWorkflowTask?: PollWorkflowTaskQueueResponse;

  /**
   * Link to the workflow event.
   *
   * @generated from field: temporal.api.common.v1.Link link = 4;
   */
  link?: Link;
};

/**
 * Describes the message temporal.api.workflowservice.v1.StartWorkflowExecutionResponse.
 * Use `create(StartWorkflowExecutionResponseSchema)` to create a new message.
 */
export const StartWorkflowExecutionResponseSchema: GenMessage<StartWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 11);

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest
 */
export type GetWorkflowExecutionHistoryRequest = Message<"temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: int32 maximum_page_size = 3;
   */
  maximumPageSize: number;

  /**
   * If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
   * these, it should be passed here to fetch the next page.
   *
   * @generated from field: bytes next_page_token = 4;
   */
  nextPageToken: Uint8Array;

  /**
   * If set to true, the RPC call will not resolve until there is a new event which matches
   * the `history_event_filter_type`, or a timeout is hit.
   *
   * @generated from field: bool wait_new_event = 5;
   */
  waitNewEvent: boolean;

  /**
   * Filter returned events such that they match the specified filter type.
   * Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
   *
   * @generated from field: temporal.api.enums.v1.HistoryEventFilterType history_event_filter_type = 6;
   */
  historyEventFilterType: HistoryEventFilterType;

  /**
   * @generated from field: bool skip_archival = 7;
   */
  skipArchival: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest.
 * Use `create(GetWorkflowExecutionHistoryRequestSchema)` to create a new message.
 */
export const GetWorkflowExecutionHistoryRequestSchema: GenMessage<GetWorkflowExecutionHistoryRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 12);

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse
 */
export type GetWorkflowExecutionHistoryResponse = Message<"temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse"> & {
  /**
   * @generated from field: temporal.api.history.v1.History history = 1;
   */
  history?: History;

  /**
   * Raw history is an alternate representation of history that may be returned if configured on
   * the frontend. This is not supported by all SDKs. Either this or `history` will be set.
   *
   * @generated from field: repeated temporal.api.common.v1.DataBlob raw_history = 2;
   */
  rawHistory: DataBlob[];

  /**
   * Will be set if there are more history events than were included in this response
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: bool archived = 4;
   */
  archived: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse.
 * Use `create(GetWorkflowExecutionHistoryResponseSchema)` to create a new message.
 */
export const GetWorkflowExecutionHistoryResponseSchema: GenMessage<GetWorkflowExecutionHistoryResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 13);

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest
 */
export type GetWorkflowExecutionHistoryReverseRequest = Message<"temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: int32 maximum_page_size = 3;
   */
  maximumPageSize: number;

  /**
   * @generated from field: bytes next_page_token = 4;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest.
 * Use `create(GetWorkflowExecutionHistoryReverseRequestSchema)` to create a new message.
 */
export const GetWorkflowExecutionHistoryReverseRequestSchema: GenMessage<GetWorkflowExecutionHistoryReverseRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 14);

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse
 */
export type GetWorkflowExecutionHistoryReverseResponse = Message<"temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse"> & {
  /**
   * @generated from field: temporal.api.history.v1.History history = 1;
   */
  history?: History;

  /**
   * Will be set if there are more history events than were included in this response
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse.
 * Use `create(GetWorkflowExecutionHistoryReverseResponseSchema)` to create a new message.
 */
export const GetWorkflowExecutionHistoryReverseResponseSchema: GenMessage<GetWorkflowExecutionHistoryReverseResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 15);

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest
 */
export type PollWorkflowTaskQueueRequest = Message<"temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * The identity of the worker/client who is polling this task queue
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Deprecated. Use deployment_options instead.
   * Each worker process should provide an ID unique to the specific set of code it is running
   * "checksum" in this field name isn't very accurate, it should be though of as an id.
   *
   * @generated from field: string binary_checksum = 4 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * Deprecated. Use deployment_options instead.
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   * Experimental. Worker Deployments are experimental and might significantly change in the future.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest.
 * Use `create(PollWorkflowTaskQueueRequestSchema)` to create a new message.
 */
export const PollWorkflowTaskQueueRequestSchema: GenMessage<PollWorkflowTaskQueueRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 16);

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse
 */
export type PollWorkflowTaskQueueResponse = Message<"temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse"> & {
  /**
   * A unique identifier for this task
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * The last workflow task started event which was processed by some worker for this execution.
   * Will be zero if no task has ever started.
   *
   * @generated from field: int64 previous_started_event_id = 4;
   */
  previousStartedEventId: bigint;

  /**
   * The id of the most recent workflow task started event, which will have been generated as a
   * result of this poll request being served. Will be zero if the task
   * does not contain any events which would advance history (no new WFT started).
   * Currently this can happen for queries.
   *
   * @generated from field: int64 started_event_id = 5;
   */
  startedEventId: bigint;

  /**
   * Starting at 1, the number of attempts to complete this task by any worker.
   *
   * @generated from field: int32 attempt = 6;
   */
  attempt: number;

  /**
   * A hint that there are more tasks already present in this task queue
   * partition. Can be used to prioritize draining a sticky queue.
   *
   * Specifically, the returned number is the number of tasks remaining in
   * the in-memory buffer for this partition, which is currently capped at
   * 1000. Because sticky queues only have one partition, this number is
   * more useful when draining them. Normal queues, typically having more than one
   * partition, will return a number representing only some portion of the
   * overall backlog. Subsequent RPCs may not hit the same partition as
   * this call.
   *
   * @generated from field: int64 backlog_count_hint = 7;
   */
  backlogCountHint: bigint;

  /**
   * The history for this workflow, which will either be complete or partial. Partial histories
   * are sent to workers who have signaled that they are using a sticky queue when completing
   * a workflow task.
   *
   * @generated from field: temporal.api.history.v1.History history = 8;
   */
  history?: History;

  /**
   * Will be set if there are more history events than were included in this response. Such events
   * should be fetched via `GetWorkflowExecutionHistory`.
   *
   * @generated from field: bytes next_page_token = 9;
   */
  nextPageToken: Uint8Array;

  /**
   * Legacy queries appear in this field. The query must be responded to via
   * `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
   * closed workflows) then the `history` field will be populated with the entire history. It
   * may also be populated if this task originates on a non-sticky queue.
   *
   * @generated from field: temporal.api.query.v1.WorkflowQuery query = 10;
   */
  query?: WorkflowQuery;

  /**
   * The task queue this task originated from, which will always be the original non-sticky name
   * for the queue, even if this response came from polling a sticky queue.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue workflow_execution_task_queue = 11;
   */
  workflowExecutionTaskQueue?: TaskQueue;

  /**
   * When this task was scheduled by the server
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 12;
   */
  scheduledTime?: Timestamp;

  /**
   * When the current workflow task started event was generated, meaning the current attempt.
   *
   * @generated from field: google.protobuf.Timestamp started_time = 13;
   */
  startedTime?: Timestamp;

  /**
   * Queries that should be executed after applying the history in this task. Responses should be
   * attached to `RespondWorkflowTaskCompletedRequest::query_results`
   *
   * @generated from field: map<string, temporal.api.query.v1.WorkflowQuery> queries = 14;
   */
  queries: { [key: string]: WorkflowQuery };

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 15;
   */
  messages: Message$1[];

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 16;
   */
  pollerScalingDecision?: PollerScalingDecision;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse.
 * Use `create(PollWorkflowTaskQueueResponseSchema)` to create a new message.
 */
export const PollWorkflowTaskQueueResponseSchema: GenMessage<PollWorkflowTaskQueueResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 17);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest
 */
export type RespondWorkflowTaskCompletedRequest = Message<"temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest"> & {
  /**
   * The task token as received in `PollWorkflowTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * A list of commands generated when driving the workflow code in response to the new task
   *
   * @generated from field: repeated temporal.api.command.v1.Command commands = 2;
   */
  commands: Command[];

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * May be set by workers to indicate that the worker desires future tasks to be provided with
   * incremental history on a sticky queue.
   *
   * @generated from field: temporal.api.taskqueue.v1.StickyExecutionAttributes sticky_attributes = 4;
   */
  stickyAttributes?: StickyExecutionAttributes;

  /**
   * If set, the worker wishes to immediately receive the next workflow task as a response to
   * this completion. This can save on polling round-trips.
   *
   * @generated from field: bool return_new_workflow_task = 5;
   */
  returnNewWorkflowTask: boolean;

  /**
   * Can be used to *force* creation of a new workflow task, even if no commands have resolved or
   * one would not otherwise have been generated. This is used when the worker knows it is doing
   * something useful, but cannot complete it within the workflow task timeout. Local activities
   * which run for longer than the task timeout being the prime example.
   *
   * @generated from field: bool force_create_new_workflow_task = 6;
   */
  forceCreateNewWorkflowTask: boolean;

  /**
   * Deprecated. Use `deployment_options` instead.
   * Worker process' unique binary id
   *
   * @generated from field: string binary_checksum = 7 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * Responses to the `queries` field in the task being responded to
   *
   * @generated from field: map<string, temporal.api.query.v1.WorkflowQueryResult> query_results = 8;
   */
  queryResults: { [key: string]: WorkflowQueryResult };

  /**
   * @generated from field: string namespace = 9;
   */
  namespace: string;

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` and `versioning_behavior` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version_stamp = 10 [deprecated = true];
   * @deprecated
   */
  workerVersionStamp?: WorkerVersionStamp;

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 11;
   */
  messages: Message$1[];

  /**
   * Data the SDK wishes to record for itself, but server need not interpret, and does not
   * directly impact workflow state.
   *
   * @generated from field: temporal.api.sdk.v1.WorkflowTaskCompletedMetadata sdk_metadata = 12;
   */
  sdkMetadata?: WorkflowTaskCompletedMetadata;

  /**
   * Local usage data collected for metering
   *
   * @generated from field: temporal.api.common.v1.MeteringMetadata metering_metadata = 13;
   */
  meteringMetadata?: MeteringMetadata;

  /**
   * All capabilities the SDK supports.
   *
   * @generated from field: temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities capabilities = 14;
   */
  capabilities?: RespondWorkflowTaskCompletedRequest_Capabilities;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 15 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Versioning behavior of this workflow execution as set on the worker that completed this task.
   * UNSPECIFIED means versioning is not enabled in the worker.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior versioning_behavior = 16;
   */
  versioningBehavior: VersioningBehavior;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 17;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.
 * Use `create(RespondWorkflowTaskCompletedRequestSchema)` to create a new message.
 */
export const RespondWorkflowTaskCompletedRequestSchema: GenMessage<RespondWorkflowTaskCompletedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 18);

/**
 * SDK capability details.
 *
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities
 */
export type RespondWorkflowTaskCompletedRequest_Capabilities = Message<"temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities"> & {
  /**
   * True if the SDK can handle speculative workflow task with command events. If true, the
   * server may choose, at its discretion, to discard a speculative workflow task even if that
   * speculative task included command events the SDK had not previously processed.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "with" used to describe the workflow task. --)
   *
   * @generated from field: bool discard_speculative_workflow_task_with_events = 1;
   */
  discardSpeculativeWorkflowTaskWithEvents: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities.
 * Use `create(RespondWorkflowTaskCompletedRequest_CapabilitiesSchema)` to create a new message.
 */
export const RespondWorkflowTaskCompletedRequest_CapabilitiesSchema: GenMessage<RespondWorkflowTaskCompletedRequest_Capabilities> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 18, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedResponse
 */
export type RespondWorkflowTaskCompletedResponse = Message<"temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedResponse"> & {
  /**
   * See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
   *
   * @generated from field: temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse workflow_task = 1;
   */
  workflowTask?: PollWorkflowTaskQueueResponse;

  /**
   * See `ScheduleActivityTaskCommandAttributes::request_eager_execution`
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.PollActivityTaskQueueResponse activity_tasks = 2;
   */
  activityTasks: PollActivityTaskQueueResponse[];

  /**
   * If non zero, indicates the server has discarded the workflow task that was being responded to.
   * Will be the event ID of the last workflow task started event in the history before the new workflow task.
   * Server is only expected to discard a workflow task if it could not have modified the workflow state.
   *
   * @generated from field: int64 reset_history_event_id = 3;
   */
  resetHistoryEventId: bigint;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedResponse.
 * Use `create(RespondWorkflowTaskCompletedResponseSchema)` to create a new message.
 */
export const RespondWorkflowTaskCompletedResponseSchema: GenMessage<RespondWorkflowTaskCompletedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 19);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest
 */
export type RespondWorkflowTaskFailedRequest = Message<"temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest"> & {
  /**
   * The task token as received in `PollWorkflowTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * Why did the task fail? It's important to note that many of the variants in this enum cannot
   * apply to worker responses. See the type's doc for more.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowTaskFailedCause cause = 2;
   */
  cause: WorkflowTaskFailedCause;

  /**
   * Failure details
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 3;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 4;
   */
  identity: string;

  /**
   * Deprecated. Use `deployment_options` instead.
   * Worker process' unique binary id
   *
   * @generated from field: string binary_checksum = 5 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * @generated from field: string namespace = 6;
   */
  namespace: string;

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 7;
   */
  messages: Message$1[];

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 8 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 9 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 10;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest.
 * Use `create(RespondWorkflowTaskFailedRequestSchema)` to create a new message.
 */
export const RespondWorkflowTaskFailedRequestSchema: GenMessage<RespondWorkflowTaskFailedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 20);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedResponse
 */
export type RespondWorkflowTaskFailedResponse = Message<"temporal.api.workflowservice.v1.RespondWorkflowTaskFailedResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedResponse.
 * Use `create(RespondWorkflowTaskFailedResponseSchema)` to create a new message.
 */
export const RespondWorkflowTaskFailedResponseSchema: GenMessage<RespondWorkflowTaskFailedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 21);

/**
 * @generated from message temporal.api.workflowservice.v1.PollActivityTaskQueueRequest
 */
export type PollActivityTaskQueueRequest = Message<"temporal.api.workflowservice.v1.PollActivityTaskQueueRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueMetadata task_queue_metadata = 4;
   */
  taskQueueMetadata?: TaskQueueMetadata;

  /**
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollActivityTaskQueueRequest.
 * Use `create(PollActivityTaskQueueRequestSchema)` to create a new message.
 */
export const PollActivityTaskQueueRequestSchema: GenMessage<PollActivityTaskQueueRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 22);

/**
 * @generated from message temporal.api.workflowservice.v1.PollActivityTaskQueueResponse
 */
export type PollActivityTaskQueueResponse = Message<"temporal.api.workflowservice.v1.PollActivityTaskQueueResponse"> & {
  /**
   * A unique identifier for this task
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * The namespace the workflow which requested this activity lives in
   *
   * @generated from field: string workflow_namespace = 2;
   */
  workflowNamespace: string;

  /**
   * Type of the requesting workflow
   *
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * Execution info of the requesting workflow
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 5;
   */
  activityType?: ActivityType;

  /**
   * The autogenerated or user specified identifier of this activity. Can be used to complete the
   * activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
   * has resolved, but unique IDs for every activity invocation is a good idea.
   *
   * @generated from field: string activity_id = 6;
   */
  activityId: string;

  /**
   * Headers specified by the scheduling workflow. Commonly used to propagate contextual info
   * from the workflow to its activities. For example, tracing contexts.
   *
   * @generated from field: temporal.api.common.v1.Header header = 7;
   */
  header?: Header;

  /**
   * Arguments to the activity invocation
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 8;
   */
  input?: Payloads;

  /**
   * Details of the last heartbeat that was recorded for this activity as of the time this task
   * was delivered.
   *
   * @generated from field: temporal.api.common.v1.Payloads heartbeat_details = 9;
   */
  heartbeatDetails?: Payloads;

  /**
   * When was this task first scheduled
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 10;
   */
  scheduledTime?: Timestamp;

  /**
   * When was this task attempt scheduled
   *
   * @generated from field: google.protobuf.Timestamp current_attempt_scheduled_time = 11;
   */
  currentAttemptScheduledTime?: Timestamp;

  /**
   * When was this task started (this attempt)
   *
   * @generated from field: google.protobuf.Timestamp started_time = 12;
   */
  startedTime?: Timestamp;

  /**
   * Starting at 1, the number of attempts to perform this activity
   *
   * @generated from field: int32 attempt = 13;
   */
  attempt: number;

  /**
   * First scheduled -> final result reported timeout
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 14;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Current attempt start -> final result reported timeout
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 15;
   */
  startToCloseTimeout?: Duration;

  /**
   * Window within which the activity must report a heartbeat, or be timed out.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 16;
   */
  heartbeatTimeout?: Duration;

  /**
   * This is the retry policy the service uses which may be different from the one provided
   * (or not) during activity scheduling. The service can override the provided one if some
   * values are not specified or exceed configured system limits.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 17;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 18;
   */
  pollerScalingDecision?: PollerScalingDecision;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 19;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollActivityTaskQueueResponse.
 * Use `create(PollActivityTaskQueueResponseSchema)` to create a new message.
 */
export const PollActivityTaskQueueResponseSchema: GenMessage<PollActivityTaskQueueResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 23);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest
 */
export type RecordActivityTaskHeartbeatRequest = Message<"temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest"> & {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * Arbitrary data, of which the most recent call is kept, to store for this activity
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: string namespace = 4;
   */
  namespace: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest.
 * Use `create(RecordActivityTaskHeartbeatRequestSchema)` to create a new message.
 */
export const RecordActivityTaskHeartbeatRequestSchema: GenMessage<RecordActivityTaskHeartbeatRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 24);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatResponse
 */
export type RecordActivityTaskHeartbeatResponse = Message<"temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatResponse"> & {
  /**
   * Will be set to true if the activity has been asked to cancel itself. The SDK should then
   * notify the activity of cancellation if it is still running.
   *
   * @generated from field: bool cancel_requested = 1;
   */
  cancelRequested: boolean;

  /**
   * Will be set to true if the activity is paused.
   *
   * @generated from field: bool activity_paused = 2;
   */
  activityPaused: boolean;

  /**
   * Will be set to true if the activity was reset.
   * Applies only to the current run.
   *
   * @generated from field: bool activity_reset = 3;
   */
  activityReset: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatResponse.
 * Use `create(RecordActivityTaskHeartbeatResponseSchema)` to create a new message.
 */
export const RecordActivityTaskHeartbeatResponseSchema: GenMessage<RecordActivityTaskHeartbeatResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 25);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdRequest
 */
export type RecordActivityTaskHeartbeatByIdRequest = Message<"temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Id of the activity we're heartbeating
   *
   * @generated from field: string activity_id = 4;
   */
  activityId: string;

  /**
   * Arbitrary data, of which the most recent call is kept, to store for this activity
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 5;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdRequest.
 * Use `create(RecordActivityTaskHeartbeatByIdRequestSchema)` to create a new message.
 */
export const RecordActivityTaskHeartbeatByIdRequestSchema: GenMessage<RecordActivityTaskHeartbeatByIdRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 26);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdResponse
 */
export type RecordActivityTaskHeartbeatByIdResponse = Message<"temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdResponse"> & {
  /**
   * Will be set to true if the activity has been asked to cancel itself. The SDK should then
   * notify the activity of cancellation if it is still running.
   *
   * @generated from field: bool cancel_requested = 1;
   */
  cancelRequested: boolean;

  /**
   * Will be set to true if the activity is paused.
   *
   * @generated from field: bool activity_paused = 2;
   */
  activityPaused: boolean;

  /**
   * Will be set to true if the activity was reset.
   * Applies only to the current run.
   *
   * @generated from field: bool activity_reset = 3;
   */
  activityReset: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdResponse.
 * Use `create(RecordActivityTaskHeartbeatByIdResponseSchema)` to create a new message.
 */
export const RecordActivityTaskHeartbeatByIdResponseSchema: GenMessage<RecordActivityTaskHeartbeatByIdResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 27);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest
 */
export type RespondActivityTaskCompletedRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest"> & {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * The result of successfully executing the activity
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 2;
   */
  result?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: string namespace = 4;
   */
  namespace: string;

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 6 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest.
 * Use `create(RespondActivityTaskCompletedRequestSchema)` to create a new message.
 */
export const RespondActivityTaskCompletedRequestSchema: GenMessage<RespondActivityTaskCompletedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 28);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedResponse
 */
export type RespondActivityTaskCompletedResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCompletedResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCompletedResponse.
 * Use `create(RespondActivityTaskCompletedResponseSchema)` to create a new message.
 */
export const RespondActivityTaskCompletedResponseSchema: GenMessage<RespondActivityTaskCompletedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 29);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdRequest
 */
export type RespondActivityTaskCompletedByIdRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Id of the activity to complete
   *
   * @generated from field: string activity_id = 4;
   */
  activityId: string;

  /**
   * The serialized result of activity execution
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 5;
   */
  result?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdRequest.
 * Use `create(RespondActivityTaskCompletedByIdRequestSchema)` to create a new message.
 */
export const RespondActivityTaskCompletedByIdRequestSchema: GenMessage<RespondActivityTaskCompletedByIdRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 30);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdResponse
 */
export type RespondActivityTaskCompletedByIdResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdResponse.
 * Use `create(RespondActivityTaskCompletedByIdResponseSchema)` to create a new message.
 */
export const RespondActivityTaskCompletedByIdResponseSchema: GenMessage<RespondActivityTaskCompletedByIdResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 31);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest
 */
export type RespondActivityTaskFailedRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest"> & {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * Detailed failure information
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 2;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: string namespace = 4;
   */
  namespace: string;

  /**
   * Additional details to be stored as last activity heartbeat
   *
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 5;
   */
  lastHeartbeatDetails?: Payloads;

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 7 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 8;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest.
 * Use `create(RespondActivityTaskFailedRequestSchema)` to create a new message.
 */
export const RespondActivityTaskFailedRequestSchema: GenMessage<RespondActivityTaskFailedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 32);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedResponse
 */
export type RespondActivityTaskFailedResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskFailedResponse"> & {
  /**
   * Server validation failures could include
   * last_heartbeat_details payload is too large, request failure is too large
   *
   * @generated from field: repeated temporal.api.failure.v1.Failure failures = 1;
   */
  failures: Failure[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskFailedResponse.
 * Use `create(RespondActivityTaskFailedResponseSchema)` to create a new message.
 */
export const RespondActivityTaskFailedResponseSchema: GenMessage<RespondActivityTaskFailedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 33);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdRequest
 */
export type RespondActivityTaskFailedByIdRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Id of the activity to fail
   *
   * @generated from field: string activity_id = 4;
   */
  activityId: string;

  /**
   * Detailed failure information
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 5;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity: string;

  /**
   * Additional details to be stored as last activity heartbeat
   *
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 7;
   */
  lastHeartbeatDetails?: Payloads;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdRequest.
 * Use `create(RespondActivityTaskFailedByIdRequestSchema)` to create a new message.
 */
export const RespondActivityTaskFailedByIdRequestSchema: GenMessage<RespondActivityTaskFailedByIdRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 34);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdResponse
 */
export type RespondActivityTaskFailedByIdResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdResponse"> & {
  /**
   * Server validation failures could include
   * last_heartbeat_details payload is too large, request failure is too large
   *
   * @generated from field: repeated temporal.api.failure.v1.Failure failures = 1;
   */
  failures: Failure[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdResponse.
 * Use `create(RespondActivityTaskFailedByIdResponseSchema)` to create a new message.
 */
export const RespondActivityTaskFailedByIdResponseSchema: GenMessage<RespondActivityTaskFailedByIdResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 35);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest
 */
export type RespondActivityTaskCanceledRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest"> & {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * Serialized additional information to attach to the cancellation
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: string namespace = 4;
   */
  namespace: string;

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 6 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest.
 * Use `create(RespondActivityTaskCanceledRequestSchema)` to create a new message.
 */
export const RespondActivityTaskCanceledRequestSchema: GenMessage<RespondActivityTaskCanceledRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 36);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledResponse
 */
export type RespondActivityTaskCanceledResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCanceledResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCanceledResponse.
 * Use `create(RespondActivityTaskCanceledResponseSchema)` to create a new message.
 */
export const RespondActivityTaskCanceledResponseSchema: GenMessage<RespondActivityTaskCanceledResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 37);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdRequest
 */
export type RespondActivityTaskCanceledByIdRequest = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId: string;

  /**
   * Id of the activity to confirm is cancelled
   *
   * @generated from field: string activity_id = 4;
   */
  activityId: string;

  /**
   * Serialized additional information to attach to the cancellation
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 5;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity: string;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdRequest.
 * Use `create(RespondActivityTaskCanceledByIdRequestSchema)` to create a new message.
 */
export const RespondActivityTaskCanceledByIdRequestSchema: GenMessage<RespondActivityTaskCanceledByIdRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 38);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdResponse
 */
export type RespondActivityTaskCanceledByIdResponse = Message<"temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdResponse.
 * Use `create(RespondActivityTaskCanceledByIdResponseSchema)` to create a new message.
 */
export const RespondActivityTaskCanceledByIdResponseSchema: GenMessage<RespondActivityTaskCanceledByIdResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 39);

/**
 * @generated from message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest
 */
export type RequestCancelWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Used to de-dupe cancellation requests
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;

  /**
   * If set, this call will error if the most recent (if no run id is set on
   * `workflow_execution`), or specified (if it is) workflow execution is not part of the same
   * execution chain as this id.
   *
   * @generated from field: string first_execution_run_id = 5;
   */
  firstExecutionRunId: string;

  /**
   * Reason for requesting the cancellation
   *
   * @generated from field: string reason = 6;
   */
  reason: string;

  /**
   * Links to be associated with the WorkflowExecutionCanceled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 7;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
 * Use `create(RequestCancelWorkflowExecutionRequestSchema)` to create a new message.
 */
export const RequestCancelWorkflowExecutionRequestSchema: GenMessage<RequestCancelWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 40);

/**
 * @generated from message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionResponse
 */
export type RequestCancelWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionResponse.
 * Use `create(RequestCancelWorkflowExecutionResponseSchema)` to create a new message.
 */
export const RequestCancelWorkflowExecutionResponseSchema: GenMessage<RequestCancelWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 41);

/**
 * Keep the parameters in sync with:
 *   - temporal.api.batch.v1.BatchOperationSignal.
 *   - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
 *
 * @generated from message temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest
 */
export type SignalWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal_name = 3;
   */
  signalName: string;

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * Used to de-dupe sent signals
   *
   * @generated from field: string request_id = 6;
   */
  requestId: string;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 7 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Headers that are passed with the signal to the processing workflow.
   * These can include things like auth or tracing tokens.
   *
   * @generated from field: temporal.api.common.v1.Header header = 8;
   */
  header?: Header;

  /**
   * Links to be associated with the WorkflowExecutionSignaled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 10;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 * Use `create(SignalWorkflowExecutionRequestSchema)` to create a new message.
 */
export const SignalWorkflowExecutionRequestSchema: GenMessage<SignalWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 42);

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWorkflowExecutionResponse
 */
export type SignalWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.SignalWorkflowExecutionResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.SignalWorkflowExecutionResponse.
 * Use `create(SignalWorkflowExecutionResponseSchema)` to create a new message.
 */
export const SignalWorkflowExecutionResponseSchema: GenMessage<SignalWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 43);

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest
 */
export type SignalWithStartWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * The task queue to start this workflow on, if it will be started
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow. These are passed as arguments to the workflow function.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 9;
   */
  identity: string;

  /**
   * Used to de-dupe signal w/ start requests
   *
   * @generated from field: string request_id = 10;
   */
  requestId: string;

  /**
   * Defines whether to allow re-using the workflow id from a previously *closed* workflow.
   * The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * Defines how to resolve a workflow id conflict with a *running* workflow.
   * The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
   * Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
   */
  workflowIdConflictPolicy: WorkflowIdConflictPolicy;

  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal_name = 12;
   */
  signalName: string;

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads signal_input = 13;
   */
  signalInput?: Payloads;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 14 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Retry policy for the workflow
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 15;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 16;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 17;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 18;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 19;
   */
  header?: Header;

  /**
   * Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
   * Note that the signal will be delivered with the first workflow task. If the workflow gets
   * another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
   * and the rest of the delay period will be ignored, even if that request also had a delay.
   * Signal via SignalWorkflowExecution will not unblock the workflow.
   *
   * @generated from field: google.protobuf.Duration workflow_start_delay = 20;
   */
  workflowStartDelay?: Duration;

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 23;
   */
  userMetadata?: UserMetadata;

  /**
   * Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 24;
   */
  links: Link[];

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 25;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 26;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest.
 * Use `create(SignalWithStartWorkflowExecutionRequestSchema)` to create a new message.
 */
export const SignalWithStartWorkflowExecutionRequestSchema: GenMessage<SignalWithStartWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 44);

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionResponse
 */
export type SignalWithStartWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionResponse"> & {
  /**
   * The run id of the workflow that was started - or just signaled, if it was already running.
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * If true, a new workflow was started.
   *
   * @generated from field: bool started = 2;
   */
  started: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionResponse.
 * Use `create(SignalWithStartWorkflowExecutionResponseSchema)` to create a new message.
 */
export const SignalWithStartWorkflowExecutionResponseSchema: GenMessage<SignalWithStartWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 45);

/**
 * @generated from message temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest
 */
export type ResetWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The workflow to reset. If this contains a run ID then the workflow will be reset back to the
   * provided event ID in that run. Otherwise it will be reset to the provided event ID in the
   * current run. In all cases the current run will be terminated and a new run started.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
   * `WORKFLOW_TASK_STARTED` event to reset to.
   *
   * @generated from field: int64 workflow_task_finish_event_id = 4;
   */
  workflowTaskFinishEventId: bigint;

  /**
   * Used to de-dupe reset requests
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;

  /**
   * Deprecated. Use `options`.
   * Default: RESET_REAPPLY_TYPE_SIGNAL
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 6 [deprecated = true];
   * @deprecated
   */
  resetReapplyType: ResetReapplyType;

  /**
   * Event types not to be reapplied
   *
   * @generated from field: repeated temporal.api.enums.v1.ResetReapplyExcludeType reset_reapply_exclude_types = 7;
   */
  resetReapplyExcludeTypes: ResetReapplyExcludeType[];

  /**
   * Operations to perform after the workflow has been reset. These operations will be applied
   * to the *new* run of the workflow execution in the order they are provided.
   * All operations are applied to the workflow before the first new workflow task is generated
   *
   * @generated from field: repeated temporal.api.workflow.v1.PostResetOperation post_reset_operations = 8;
   */
  postResetOperations: PostResetOperation[];

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 9;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
 * Use `create(ResetWorkflowExecutionRequestSchema)` to create a new message.
 */
export const ResetWorkflowExecutionRequestSchema: GenMessage<ResetWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 46);

/**
 * @generated from message temporal.api.workflowservice.v1.ResetWorkflowExecutionResponse
 */
export type ResetWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.ResetWorkflowExecutionResponse"> & {
  /**
   * @generated from field: string run_id = 1;
   */
  runId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetWorkflowExecutionResponse.
 * Use `create(ResetWorkflowExecutionResponseSchema)` to create a new message.
 */
export const ResetWorkflowExecutionResponseSchema: GenMessage<ResetWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 47);

/**
 * @generated from message temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest
 */
export type TerminateWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * Serialized additional information to attach to the termination event
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 4;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * If set, this call will error if the most recent (if no run id is set on
   * `workflow_execution`), or specified (if it is) workflow execution is not part of the same
   * execution chain as this id.
   *
   * @generated from field: string first_execution_run_id = 6;
   */
  firstExecutionRunId: string;

  /**
   * Links to be associated with the WorkflowExecutionTerminated event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 7;
   */
  links: Link[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
 * Use `create(TerminateWorkflowExecutionRequestSchema)` to create a new message.
 */
export const TerminateWorkflowExecutionRequestSchema: GenMessage<TerminateWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 48);

/**
 * @generated from message temporal.api.workflowservice.v1.TerminateWorkflowExecutionResponse
 */
export type TerminateWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.TerminateWorkflowExecutionResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.TerminateWorkflowExecutionResponse.
 * Use `create(TerminateWorkflowExecutionResponseSchema)` to create a new message.
 */
export const TerminateWorkflowExecutionResponseSchema: GenMessage<TerminateWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 49);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest
 */
export type DeleteWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Workflow Execution to delete. If run_id is not specified, the latest one is used.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
 * Use `create(DeleteWorkflowExecutionRequestSchema)` to create a new message.
 */
export const DeleteWorkflowExecutionRequestSchema: GenMessage<DeleteWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 50);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowExecutionResponse
 */
export type DeleteWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.DeleteWorkflowExecutionResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkflowExecutionResponse.
 * Use `create(DeleteWorkflowExecutionResponseSchema)` to create a new message.
 */
export const DeleteWorkflowExecutionResponseSchema: GenMessage<DeleteWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 51);

/**
 * @generated from message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest
 */
export type ListOpenWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
   */
  startTimeFilter?: StartTimeFilter;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest.filters
   */
  filters: {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
     */
    value: WorkflowExecutionFilter;
    case: "executionFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
     */
    value: WorkflowTypeFilter;
    case: "typeFilter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest.
 * Use `create(ListOpenWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const ListOpenWorkflowExecutionsRequestSchema: GenMessage<ListOpenWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 52);

/**
 * @generated from message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsResponse
 */
export type ListOpenWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsResponse.
 * Use `create(ListOpenWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const ListOpenWorkflowExecutionsResponseSchema: GenMessage<ListOpenWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 53);

/**
 * @generated from message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest
 */
export type ListClosedWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
   */
  startTimeFilter?: StartTimeFilter;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest.filters
   */
  filters: {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
     */
    value: WorkflowExecutionFilter;
    case: "executionFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
     */
    value: WorkflowTypeFilter;
    case: "typeFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.StatusFilter status_filter = 7;
     */
    value: StatusFilter;
    case: "statusFilter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest.
 * Use `create(ListClosedWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const ListClosedWorkflowExecutionsRequestSchema: GenMessage<ListClosedWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 54);

/**
 * @generated from message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsResponse
 */
export type ListClosedWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsResponse.
 * Use `create(ListClosedWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const ListClosedWorkflowExecutionsResponseSchema: GenMessage<ListClosedWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 55);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowExecutionsRequest
 */
export type ListWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.ListWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkflowExecutionsRequest.
 * Use `create(ListWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const ListWorkflowExecutionsRequestSchema: GenMessage<ListWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 56);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowExecutionsResponse
 */
export type ListWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.ListWorkflowExecutionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkflowExecutionsResponse.
 * Use `create(ListWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const ListWorkflowExecutionsResponseSchema: GenMessage<ListWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 57);

/**
 * @generated from message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsRequest
 */
export type ListArchivedWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsRequest.
 * Use `create(ListArchivedWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const ListArchivedWorkflowExecutionsRequestSchema: GenMessage<ListArchivedWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 58);

/**
 * @generated from message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsResponse
 */
export type ListArchivedWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsResponse.
 * Use `create(ListArchivedWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const ListArchivedWorkflowExecutionsResponseSchema: GenMessage<ListArchivedWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 59);

/**
 * Deprecated: Use with `ListWorkflowExecutions`.
 *
 * @generated from message temporal.api.workflowservice.v1.ScanWorkflowExecutionsRequest
 */
export type ScanWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.ScanWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ScanWorkflowExecutionsRequest.
 * Use `create(ScanWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const ScanWorkflowExecutionsRequestSchema: GenMessage<ScanWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 60);

/**
 * Deprecated: Use with `ListWorkflowExecutions`.
 *
 * @generated from message temporal.api.workflowservice.v1.ScanWorkflowExecutionsResponse
 */
export type ScanWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.ScanWorkflowExecutionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ScanWorkflowExecutionsResponse.
 * Use `create(ScanWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const ScanWorkflowExecutionsResponseSchema: GenMessage<ScanWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 61);

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsRequest
 */
export type CountWorkflowExecutionsRequest = Message<"temporal.api.workflowservice.v1.CountWorkflowExecutionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string query = 2;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CountWorkflowExecutionsRequest.
 * Use `create(CountWorkflowExecutionsRequestSchema)` to create a new message.
 */
export const CountWorkflowExecutionsRequestSchema: GenMessage<CountWorkflowExecutionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 62);

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse
 */
export type CountWorkflowExecutionsResponse = Message<"temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse"> & {
  /**
   * If `query` is not grouping by any field, the count is an approximate number
   * of workflows that matches the query.
   * If `query` is grouping by a field, the count is simply the sum of the counts
   * of the groups returned in the response. This number can be smaller than the
   * total number of workflows matching the query.
   *
   * @generated from field: int64 count = 1;
   */
  count: bigint;

  /**
   * `groups` contains the groups if the request is grouping by a field.
   * The list might not be complete, and the counts of each group is approximate.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup groups = 2;
   */
  groups: CountWorkflowExecutionsResponse_AggregationGroup[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.
 * Use `create(CountWorkflowExecutionsResponseSchema)` to create a new message.
 */
export const CountWorkflowExecutionsResponseSchema: GenMessage<CountWorkflowExecutionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 63);

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup
 */
export type CountWorkflowExecutionsResponse_AggregationGroup = Message<"temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup"> & {
  /**
   * @generated from field: repeated temporal.api.common.v1.Payload group_values = 1;
   */
  groupValues: Payload[];

  /**
   * @generated from field: int64 count = 2;
   */
  count: bigint;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup.
 * Use `create(CountWorkflowExecutionsResponse_AggregationGroupSchema)` to create a new message.
 */
export const CountWorkflowExecutionsResponse_AggregationGroupSchema: GenMessage<CountWorkflowExecutionsResponse_AggregationGroup> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 63, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.GetSearchAttributesRequest
 */
export type GetSearchAttributesRequest = Message<"temporal.api.workflowservice.v1.GetSearchAttributesRequest"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetSearchAttributesRequest.
 * Use `create(GetSearchAttributesRequestSchema)` to create a new message.
 */
export const GetSearchAttributesRequestSchema: GenMessage<GetSearchAttributesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 64);

/**
 * @generated from message temporal.api.workflowservice.v1.GetSearchAttributesResponse
 */
export type GetSearchAttributesResponse = Message<"temporal.api.workflowservice.v1.GetSearchAttributesResponse"> & {
  /**
   * @generated from field: map<string, temporal.api.enums.v1.IndexedValueType> keys = 1;
   */
  keys: { [key: string]: IndexedValueType };
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetSearchAttributesResponse.
 * Use `create(GetSearchAttributesResponseSchema)` to create a new message.
 */
export const GetSearchAttributesResponseSchema: GenMessage<GetSearchAttributesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 65);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondQueryTaskCompletedRequest
 */
export type RespondQueryTaskCompletedRequest = Message<"temporal.api.workflowservice.v1.RespondQueryTaskCompletedRequest"> & {
  /**
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * @generated from field: temporal.api.enums.v1.QueryResultType completed_type = 2;
   */
  completedType: QueryResultType;

  /**
   * The result of the query.
   * Mutually exclusive with `error_message` and `failure`. Set when the query succeeds.
   *
   * @generated from field: temporal.api.common.v1.Payloads query_result = 3;
   */
  queryResult?: Payloads;

  /**
   * A plain error message that must be set if completed_type is QUERY_RESULT_TYPE_FAILED.
   * SDKs should also fill in the more complete `failure` field to provide the full context and
   * support encryption of failure information.
   * `error_message` will be duplicated if the `failure` field is present to support callers
   * that pre-date the addition of that field, regardless of whether or not a custom failure
   * converter is used.
   * Mutually exclusive with `query_result`. Set when the query fails.
   *
   * @generated from field: string error_message = 4;
   */
  errorMessage: string;

  /**
   * @generated from field: string namespace = 6;
   */
  namespace: string;

  /**
   * The full reason for this query failure. This field is newer than `error_message` and can be
   * encoded by the SDK's failure converter to support E2E encryption of messages and stack
   * traces.
   * Mutually exclusive with `query_result`. Set when the query fails.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 7;
   */
  failure?: Failure;

  /**
   * Why did the task fail? It's important to note that many of the variants in this enum cannot
   * apply to worker responses. See the type's doc for more.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowTaskFailedCause cause = 8;
   */
  cause: WorkflowTaskFailedCause;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondQueryTaskCompletedRequest.
 * Use `create(RespondQueryTaskCompletedRequestSchema)` to create a new message.
 */
export const RespondQueryTaskCompletedRequestSchema: GenMessage<RespondQueryTaskCompletedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 66);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondQueryTaskCompletedResponse
 */
export type RespondQueryTaskCompletedResponse = Message<"temporal.api.workflowservice.v1.RespondQueryTaskCompletedResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondQueryTaskCompletedResponse.
 * Use `create(RespondQueryTaskCompletedResponseSchema)` to create a new message.
 */
export const RespondQueryTaskCompletedResponseSchema: GenMessage<RespondQueryTaskCompletedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 67);

/**
 * @generated from message temporal.api.workflowservice.v1.ResetStickyTaskQueueRequest
 */
export type ResetStickyTaskQueueRequest = Message<"temporal.api.workflowservice.v1.ResetStickyTaskQueueRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetStickyTaskQueueRequest.
 * Use `create(ResetStickyTaskQueueRequestSchema)` to create a new message.
 */
export const ResetStickyTaskQueueRequestSchema: GenMessage<ResetStickyTaskQueueRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 68);

/**
 * @generated from message temporal.api.workflowservice.v1.ResetStickyTaskQueueResponse
 */
export type ResetStickyTaskQueueResponse = Message<"temporal.api.workflowservice.v1.ResetStickyTaskQueueResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetStickyTaskQueueResponse.
 * Use `create(ResetStickyTaskQueueResponseSchema)` to create a new message.
 */
export const ResetStickyTaskQueueResponseSchema: GenMessage<ResetStickyTaskQueueResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 69);

/**
 * @generated from message temporal.api.workflowservice.v1.ShutdownWorkerRequest
 */
export type ShutdownWorkerRequest = Message<"temporal.api.workflowservice.v1.ShutdownWorkerRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string sticky_task_queue = 2;
   */
  stickyTaskQueue: string;

  /**
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * @generated from field: string reason = 4;
   */
  reason: string;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 5;
   */
  workerHeartbeat?: WorkerHeartbeat;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ShutdownWorkerRequest.
 * Use `create(ShutdownWorkerRequestSchema)` to create a new message.
 */
export const ShutdownWorkerRequestSchema: GenMessage<ShutdownWorkerRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 70);

/**
 * @generated from message temporal.api.workflowservice.v1.ShutdownWorkerResponse
 */
export type ShutdownWorkerResponse = Message<"temporal.api.workflowservice.v1.ShutdownWorkerResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.ShutdownWorkerResponse.
 * Use `create(ShutdownWorkerResponseSchema)` to create a new message.
 */
export const ShutdownWorkerResponseSchema: GenMessage<ShutdownWorkerResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 71);

/**
 * @generated from message temporal.api.workflowservice.v1.QueryWorkflowRequest
 */
export type QueryWorkflowRequest = Message<"temporal.api.workflowservice.v1.QueryWorkflowRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.query.v1.WorkflowQuery query = 3;
   */
  query?: WorkflowQuery;

  /**
   * QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
   * Default: QUERY_REJECT_CONDITION_NONE.
   *
   * @generated from field: temporal.api.enums.v1.QueryRejectCondition query_reject_condition = 4;
   */
  queryRejectCondition: QueryRejectCondition;
};

/**
 * Describes the message temporal.api.workflowservice.v1.QueryWorkflowRequest.
 * Use `create(QueryWorkflowRequestSchema)` to create a new message.
 */
export const QueryWorkflowRequestSchema: GenMessage<QueryWorkflowRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 72);

/**
 * @generated from message temporal.api.workflowservice.v1.QueryWorkflowResponse
 */
export type QueryWorkflowResponse = Message<"temporal.api.workflowservice.v1.QueryWorkflowResponse"> & {
  /**
   * @generated from field: temporal.api.common.v1.Payloads query_result = 1;
   */
  queryResult?: Payloads;

  /**
   * @generated from field: temporal.api.query.v1.QueryRejected query_rejected = 2;
   */
  queryRejected?: QueryRejected;
};

/**
 * Describes the message temporal.api.workflowservice.v1.QueryWorkflowResponse.
 * Use `create(QueryWorkflowResponseSchema)` to create a new message.
 */
export const QueryWorkflowResponseSchema: GenMessage<QueryWorkflowResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 73);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest
 */
export type DescribeWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest.
 * Use `create(DescribeWorkflowExecutionRequestSchema)` to create a new message.
 */
export const DescribeWorkflowExecutionRequestSchema: GenMessage<DescribeWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 74);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse
 */
export type DescribeWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse"> & {
  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionConfig execution_config = 1;
   */
  executionConfig?: WorkflowExecutionConfig;

  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionInfo workflow_execution_info = 2;
   */
  workflowExecutionInfo?: WorkflowExecutionInfo;

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingActivityInfo pending_activities = 3;
   */
  pendingActivities: PendingActivityInfo[];

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingChildExecutionInfo pending_children = 4;
   */
  pendingChildren: PendingChildExecutionInfo[];

  /**
   * @generated from field: temporal.api.workflow.v1.PendingWorkflowTaskInfo pending_workflow_task = 5;
   */
  pendingWorkflowTask?: PendingWorkflowTaskInfo;

  /**
   * @generated from field: repeated temporal.api.workflow.v1.CallbackInfo callbacks = 6;
   */
  callbacks: CallbackInfo[];

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingNexusOperationInfo pending_nexus_operations = 7;
   */
  pendingNexusOperations: PendingNexusOperationInfo[];

  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo workflow_extended_info = 8;
   */
  workflowExtendedInfo?: WorkflowExecutionExtendedInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse.
 * Use `create(DescribeWorkflowExecutionResponseSchema)` to create a new message.
 */
export const DescribeWorkflowExecutionResponseSchema: GenMessage<DescribeWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 75);

/**
 * (-- api-linter: core::0203::optional=disabled
 *     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueRequest
 */
export type DescribeTaskQueueRequest = Message<"temporal.api.workflowservice.v1.DescribeTaskQueueRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Sticky queues are not supported in deprecated ENHANCED mode.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
   * Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
   *
   * @generated from field: temporal.api.enums.v1.TaskQueueType task_queue_type = 3;
   */
  taskQueueType: TaskQueueType;

  /**
   * Report stats for the requested task queue type(s).
   *
   * @generated from field: bool report_stats = 8;
   */
  reportStats: boolean;

  /**
   * Report Task Queue Config
   *
   * @generated from field: bool report_config = 11;
   */
  reportConfig: boolean;

  /**
   * Deprecated, use `report_stats` instead.
   * If true, the task queue status will be included in the response.
   *
   * @generated from field: bool include_task_queue_status = 4 [deprecated = true];
   * @deprecated
   */
  includeTaskQueueStatus: boolean;

  /**
   * Deprecated. ENHANCED mode is also being deprecated.
   * Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
   * Consult the documentation for each field to understand which mode it is supported in.
   *
   * @generated from field: temporal.api.enums.v1.DescribeTaskQueueMode api_mode = 5 [deprecated = true];
   * @deprecated
   */
  apiMode: DescribeTaskQueueMode;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
   * mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
   * unversioned queue will be returned.
   * (-- api-linter: core::0140::prepositions --)
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueVersionSelection versions = 6 [deprecated = true];
   * @deprecated
   */
  versions?: TaskQueueVersionSelection;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Task queue types to report info about. If not specified, all types are considered.
   *
   * @generated from field: repeated temporal.api.enums.v1.TaskQueueType task_queue_types = 7 [deprecated = true];
   * @deprecated
   */
  taskQueueTypes: TaskQueueType[];

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Report list of pollers for requested task queue types and versions.
   *
   * @generated from field: bool report_pollers = 9 [deprecated = true];
   * @deprecated
   */
  reportPollers: boolean;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Report task reachability for the requested versions and all task types (task reachability is not reported
   * per task type).
   *
   * @generated from field: bool report_task_reachability = 10 [deprecated = true];
   * @deprecated
   */
  reportTaskReachability: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeTaskQueueRequest.
 * Use `create(DescribeTaskQueueRequestSchema)` to create a new message.
 */
export const DescribeTaskQueueRequestSchema: GenMessage<DescribeTaskQueueRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 76);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueResponse
 */
export type DescribeTaskQueueResponse = Message<"temporal.api.workflowservice.v1.DescribeTaskQueueResponse"> & {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.PollerInfo pollers = 1;
   */
  pollers: PollerInfo[];

  /**
   * Statistics for the task queue.
   * Only set if `report_stats` is set on the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 5;
   */
  stats?: TaskQueueStats;

  /**
   * Task queue stats breakdown by priority key. Only contains actively used priority keys.
   * Only set if `report_stats` is set on the request.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueStats> stats_by_priority_key = 8;
   */
  statsByPriorityKey: { [key: number]: TaskQueueStats };

  /**
   * Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
   * When not present, it means the tasks are routed to Unversioned workers (workers with
   * UNVERSIONED or unspecified WorkerVersioningMode.)
   * Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
   * and SetWorkerDeploymentRampingVersion on Worker Deployments.
   * Note: This information is not relevant to Pinned workflow executions and their activities as
   * they are always routed to their Pinned Deployment Version. However, new workflow executions
   * are typically not Pinned until they complete their first task (unless they are started with
   * a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueVersioningInfo versioning_info = 4;
   */
  versioningInfo?: TaskQueueVersioningInfo;

  /**
   * Only populated if report_task_queue_config is set to true.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueConfig config = 6;
   */
  config?: TaskQueueConfig;

  /**
   * @generated from field: temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit effective_rate_limit = 7;
   */
  effectiveRateLimit?: DescribeTaskQueueResponse_EffectiveRateLimit;

  /**
   * Deprecated.
   * Status of the task queue. Only populated when `include_task_queue_status` is set to true in the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStatus task_queue_status = 2 [deprecated = true];
   * @deprecated
   */
  taskQueueStatus?: TaskQueueStatus;

  /**
   * Deprecated.
   * Only returned in ENHANCED mode.
   * This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
   *
   * @generated from field: map<string, temporal.api.taskqueue.v1.TaskQueueVersionInfo> versions_info = 3 [deprecated = true];
   * @deprecated
   */
  versionsInfo: { [key: string]: TaskQueueVersionInfo };
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeTaskQueueResponse.
 * Use `create(DescribeTaskQueueResponseSchema)` to create a new message.
 */
export const DescribeTaskQueueResponseSchema: GenMessage<DescribeTaskQueueResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 77);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit
 */
export type DescribeTaskQueueResponse_EffectiveRateLimit = Message<"temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit"> & {
  /**
   * The effective rate limit for the task queue.
   *
   * @generated from field: float requests_per_second = 1;
   */
  requestsPerSecond: number;

  /**
   * Source of the RateLimit Configuration,which can be one of the following values:
   * - SOURCE_API: The rate limit that is set via the TaskQueueConfig api.
   * - SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.
   * - SOURCE_SYSTEM: The rate limit is the default value set by the system
   *
   * @generated from field: temporal.api.enums.v1.RateLimitSource rate_limit_source = 2;
   */
  rateLimitSource: RateLimitSource;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit.
 * Use `create(DescribeTaskQueueResponse_EffectiveRateLimitSchema)` to create a new message.
 */
export const DescribeTaskQueueResponse_EffectiveRateLimitSchema: GenMessage<DescribeTaskQueueResponse_EffectiveRateLimit> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 77, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.GetClusterInfoRequest
 */
export type GetClusterInfoRequest = Message<"temporal.api.workflowservice.v1.GetClusterInfoRequest"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetClusterInfoRequest.
 * Use `create(GetClusterInfoRequestSchema)` to create a new message.
 */
export const GetClusterInfoRequestSchema: GenMessage<GetClusterInfoRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 78);

/**
 * GetClusterInfoResponse contains information about Temporal cluster.
 *
 * @generated from message temporal.api.workflowservice.v1.GetClusterInfoResponse
 */
export type GetClusterInfoResponse = Message<"temporal.api.workflowservice.v1.GetClusterInfoResponse"> & {
  /**
   * Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
   * Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
   *
   * @generated from field: map<string, string> supported_clients = 1;
   */
  supportedClients: { [key: string]: string };

  /**
   * @generated from field: string server_version = 2;
   */
  serverVersion: string;

  /**
   * @generated from field: string cluster_id = 3;
   */
  clusterId: string;

  /**
   * @generated from field: temporal.api.version.v1.VersionInfo version_info = 4;
   */
  versionInfo?: VersionInfo;

  /**
   * @generated from field: string cluster_name = 5;
   */
  clusterName: string;

  /**
   * @generated from field: int32 history_shard_count = 6;
   */
  historyShardCount: number;

  /**
   * @generated from field: string persistence_store = 7;
   */
  persistenceStore: string;

  /**
   * @generated from field: string visibility_store = 8;
   */
  visibilityStore: string;

  /**
   * @generated from field: int64 initial_failover_version = 9;
   */
  initialFailoverVersion: bigint;

  /**
   * @generated from field: int64 failover_version_increment = 10;
   */
  failoverVersionIncrement: bigint;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetClusterInfoResponse.
 * Use `create(GetClusterInfoResponseSchema)` to create a new message.
 */
export const GetClusterInfoResponseSchema: GenMessage<GetClusterInfoResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 79);

/**
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoRequest
 */
export type GetSystemInfoRequest = Message<"temporal.api.workflowservice.v1.GetSystemInfoRequest"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetSystemInfoRequest.
 * Use `create(GetSystemInfoRequestSchema)` to create a new message.
 */
export const GetSystemInfoRequestSchema: GenMessage<GetSystemInfoRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 80);

/**
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoResponse
 */
export type GetSystemInfoResponse = Message<"temporal.api.workflowservice.v1.GetSystemInfoResponse"> & {
  /**
   * Version of the server.
   *
   * @generated from field: string server_version = 1;
   */
  serverVersion: string;

  /**
   * All capabilities the system supports.
   *
   * @generated from field: temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities capabilities = 2;
   */
  capabilities?: GetSystemInfoResponse_Capabilities;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetSystemInfoResponse.
 * Use `create(GetSystemInfoResponseSchema)` to create a new message.
 */
export const GetSystemInfoResponseSchema: GenMessage<GetSystemInfoResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 81);

/**
 * System capability details.
 *
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities
 */
export type GetSystemInfoResponse_Capabilities = Message<"temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities"> & {
  /**
   * True if signal and query headers are supported.
   *
   * @generated from field: bool signal_and_query_header = 1;
   */
  signalAndQueryHeader: boolean;

  /**
   * True if internal errors are differentiated from other types of errors for purposes of
   * retrying non-internal errors.
   *
   * When unset/false, clients retry all failures. When true, clients should only retry
   * non-internal errors.
   *
   * @generated from field: bool internal_error_differentiation = 2;
   */
  internalErrorDifferentiation: boolean;

  /**
   * True if RespondActivityTaskFailed API supports including heartbeat details
   *
   * @generated from field: bool activity_failure_include_heartbeat = 3;
   */
  activityFailureIncludeHeartbeat: boolean;

  /**
   * Supports scheduled workflow features.
   *
   * @generated from field: bool supports_schedules = 4;
   */
  supportsSchedules: boolean;

  /**
   * True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
   *
   * @generated from field: bool encoded_failure_attributes = 5;
   */
  encodedFailureAttributes: boolean;

  /**
   * True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
   * (see:
   * https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
   *
   * @generated from field: bool build_id_based_versioning = 6;
   */
  buildIdBasedVersioning: boolean;

  /**
   * True if server supports upserting workflow memo
   *
   * @generated from field: bool upsert_memo = 7;
   */
  upsertMemo: boolean;

  /**
   * True if server supports eager workflow task dispatching for the StartWorkflowExecution API
   *
   * @generated from field: bool eager_workflow_start = 8;
   */
  eagerWorkflowStart: boolean;

  /**
   * True if the server knows about the sdk metadata field on WFT completions and will record
   * it in history
   *
   * @generated from field: bool sdk_metadata = 9;
   */
  sdkMetadata: boolean;

  /**
   * True if the server supports count group by execution status
   * (-- api-linter: core::0140::prepositions=disabled --)
   *
   * @generated from field: bool count_group_by_execution_status = 10;
   */
  countGroupByExecutionStatus: boolean;

  /**
   * True if the server supports Nexus operations.
   * This flag is dependent both on server version and for Nexus to be enabled via server configuration.
   *
   * @generated from field: bool nexus = 11;
   */
  nexus: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities.
 * Use `create(GetSystemInfoResponse_CapabilitiesSchema)` to create a new message.
 */
export const GetSystemInfoResponse_CapabilitiesSchema: GenMessage<GetSystemInfoResponse_Capabilities> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 81, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.ListTaskQueuePartitionsRequest
 */
export type ListTaskQueuePartitionsRequest = Message<"temporal.api.workflowservice.v1.ListTaskQueuePartitionsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListTaskQueuePartitionsRequest.
 * Use `create(ListTaskQueuePartitionsRequestSchema)` to create a new message.
 */
export const ListTaskQueuePartitionsRequestSchema: GenMessage<ListTaskQueuePartitionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 82);

/**
 * @generated from message temporal.api.workflowservice.v1.ListTaskQueuePartitionsResponse
 */
export type ListTaskQueuePartitionsResponse = Message<"temporal.api.workflowservice.v1.ListTaskQueuePartitionsResponse"> & {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata activity_task_queue_partitions = 1;
   */
  activityTaskQueuePartitions: TaskQueuePartitionMetadata[];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata workflow_task_queue_partitions = 2;
   */
  workflowTaskQueuePartitions: TaskQueuePartitionMetadata[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListTaskQueuePartitionsResponse.
 * Use `create(ListTaskQueuePartitionsResponseSchema)` to create a new message.
 */
export const ListTaskQueuePartitionsResponseSchema: GenMessage<ListTaskQueuePartitionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 83);

/**
 * (-- api-linter: core::0203::optional=disabled
 *     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
 *
 * @generated from message temporal.api.workflowservice.v1.CreateScheduleRequest
 */
export type CreateScheduleRequest = Message<"temporal.api.workflowservice.v1.CreateScheduleRequest"> & {
  /**
   * The namespace the schedule should be created in.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the new schedule.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;

  /**
   * The schedule spec, policies, action, and initial state.
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 3;
   */
  schedule?: Schedule;

  /**
   * Optional initial patch (e.g. to run the action once immediately).
   *
   * @generated from field: temporal.api.schedule.v1.SchedulePatch initial_patch = 4;
   */
  initialPatch?: SchedulePatch;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * A unique identifier for this create request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 6;
   */
  requestId: string;

  /**
   * Memo and search attributes to attach to the schedule itself.
   *
   * @generated from field: temporal.api.common.v1.Memo memo = 7;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 8;
   */
  searchAttributes?: SearchAttributes;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CreateScheduleRequest.
 * Use `create(CreateScheduleRequestSchema)` to create a new message.
 */
export const CreateScheduleRequestSchema: GenMessage<CreateScheduleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 84);

/**
 * @generated from message temporal.api.workflowservice.v1.CreateScheduleResponse
 */
export type CreateScheduleResponse = Message<"temporal.api.workflowservice.v1.CreateScheduleResponse"> & {
  /**
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CreateScheduleResponse.
 * Use `create(CreateScheduleResponseSchema)` to create a new message.
 */
export const CreateScheduleResponseSchema: GenMessage<CreateScheduleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 85);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeScheduleRequest
 */
export type DescribeScheduleRequest = Message<"temporal.api.workflowservice.v1.DescribeScheduleRequest"> & {
  /**
   * The namespace of the schedule to describe.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the schedule to describe.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeScheduleRequest.
 * Use `create(DescribeScheduleRequestSchema)` to create a new message.
 */
export const DescribeScheduleRequestSchema: GenMessage<DescribeScheduleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 86);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeScheduleResponse
 */
export type DescribeScheduleResponse = Message<"temporal.api.workflowservice.v1.DescribeScheduleResponse"> & {
  /**
   * The complete current schedule details. This may not match the schedule as
   * created because:
   * - some types of schedule specs may get compiled into others (e.g.
   *   CronString into StructuredCalendarSpec)
   * - some unspecified fields may be replaced by defaults
   * - some fields in the state are modified automatically
   * - the schedule may have been modified by UpdateSchedule or PatchSchedule
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 1;
   */
  schedule?: Schedule;

  /**
   * Extra schedule state info.
   *
   * @generated from field: temporal.api.schedule.v1.ScheduleInfo info = 2;
   */
  info?: ScheduleInfo;

  /**
   * The memo and search attributes that the schedule was created with.
   *
   * @generated from field: temporal.api.common.v1.Memo memo = 3;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 4;
   */
  searchAttributes?: SearchAttributes;

  /**
   * This value can be passed back to UpdateSchedule to ensure that the
   * schedule was not modified between a Describe and an Update, which could
   * lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeScheduleResponse.
 * Use `create(DescribeScheduleResponseSchema)` to create a new message.
 */
export const DescribeScheduleResponseSchema: GenMessage<DescribeScheduleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 87);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateScheduleRequest
 */
export type UpdateScheduleRequest = Message<"temporal.api.workflowservice.v1.UpdateScheduleRequest"> & {
  /**
   * The namespace of the schedule to update.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the schedule to update.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;

  /**
   * The new schedule. The four main fields of the schedule (spec, action,
   * policies, state) are replaced completely by the values in this message.
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 3;
   */
  schedule?: Schedule;

  /**
   * This can be the value of conflict_token from a DescribeScheduleResponse,
   * which will cause this request to fail if the schedule has been modified
   * between the Describe and this Update.
   * If missing, the schedule will be updated unconditionally.
   *
   * @generated from field: bytes conflict_token = 4;
   */
  conflictToken: Uint8Array;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * A unique identifier for this update request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 6;
   */
  requestId: string;

  /**
   * Schedule search attributes to be updated.
   * Do not set this field if you do not want to update the search attributes.
   * A non-null empty object will set the search attributes to an empty map.
   * Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
   * you must also set the `schedule` field; otherwise, it will unset the schedule.
   *
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 7;
   */
  searchAttributes?: SearchAttributes;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateScheduleRequest.
 * Use `create(UpdateScheduleRequestSchema)` to create a new message.
 */
export const UpdateScheduleRequestSchema: GenMessage<UpdateScheduleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 88);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateScheduleResponse
 */
export type UpdateScheduleResponse = Message<"temporal.api.workflowservice.v1.UpdateScheduleResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateScheduleResponse.
 * Use `create(UpdateScheduleResponseSchema)` to create a new message.
 */
export const UpdateScheduleResponseSchema: GenMessage<UpdateScheduleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 89);

/**
 * @generated from message temporal.api.workflowservice.v1.PatchScheduleRequest
 */
export type PatchScheduleRequest = Message<"temporal.api.workflowservice.v1.PatchScheduleRequest"> & {
  /**
   * The namespace of the schedule to patch.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the schedule to patch.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;

  /**
   * @generated from field: temporal.api.schedule.v1.SchedulePatch patch = 3;
   */
  patch?: SchedulePatch;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 4;
   */
  identity: string;

  /**
   * A unique identifier for this update request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 5;
   */
  requestId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PatchScheduleRequest.
 * Use `create(PatchScheduleRequestSchema)` to create a new message.
 */
export const PatchScheduleRequestSchema: GenMessage<PatchScheduleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 90);

/**
 * @generated from message temporal.api.workflowservice.v1.PatchScheduleResponse
 */
export type PatchScheduleResponse = Message<"temporal.api.workflowservice.v1.PatchScheduleResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.PatchScheduleResponse.
 * Use `create(PatchScheduleResponseSchema)` to create a new message.
 */
export const PatchScheduleResponseSchema: GenMessage<PatchScheduleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 91);

/**
 * @generated from message temporal.api.workflowservice.v1.ListScheduleMatchingTimesRequest
 */
export type ListScheduleMatchingTimesRequest = Message<"temporal.api.workflowservice.v1.ListScheduleMatchingTimesRequest"> & {
  /**
   * The namespace of the schedule to query.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the schedule to query.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;

  /**
   * Time range to query.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 4;
   */
  endTime?: Timestamp;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListScheduleMatchingTimesRequest.
 * Use `create(ListScheduleMatchingTimesRequestSchema)` to create a new message.
 */
export const ListScheduleMatchingTimesRequestSchema: GenMessage<ListScheduleMatchingTimesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 92);

/**
 * @generated from message temporal.api.workflowservice.v1.ListScheduleMatchingTimesResponse
 */
export type ListScheduleMatchingTimesResponse = Message<"temporal.api.workflowservice.v1.ListScheduleMatchingTimesResponse"> & {
  /**
   * @generated from field: repeated google.protobuf.Timestamp start_time = 1;
   */
  startTime: Timestamp[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListScheduleMatchingTimesResponse.
 * Use `create(ListScheduleMatchingTimesResponseSchema)` to create a new message.
 */
export const ListScheduleMatchingTimesResponseSchema: GenMessage<ListScheduleMatchingTimesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 93);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteScheduleRequest
 */
export type DeleteScheduleRequest = Message<"temporal.api.workflowservice.v1.DeleteScheduleRequest"> & {
  /**
   * The namespace of the schedule to delete.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The id of the schedule to delete.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteScheduleRequest.
 * Use `create(DeleteScheduleRequestSchema)` to create a new message.
 */
export const DeleteScheduleRequestSchema: GenMessage<DeleteScheduleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 94);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteScheduleResponse
 */
export type DeleteScheduleResponse = Message<"temporal.api.workflowservice.v1.DeleteScheduleResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteScheduleResponse.
 * Use `create(DeleteScheduleResponseSchema)` to create a new message.
 */
export const DeleteScheduleResponseSchema: GenMessage<DeleteScheduleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 95);

/**
 * @generated from message temporal.api.workflowservice.v1.ListSchedulesRequest
 */
export type ListSchedulesRequest = Message<"temporal.api.workflowservice.v1.ListSchedulesRequest"> & {
  /**
   * The namespace to list schedules in.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * How many to return at once.
   *
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize: number;

  /**
   * Token to get the next page of results.
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * Query to filter schedules.
   *
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListSchedulesRequest.
 * Use `create(ListSchedulesRequestSchema)` to create a new message.
 */
export const ListSchedulesRequestSchema: GenMessage<ListSchedulesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 96);

/**
 * @generated from message temporal.api.workflowservice.v1.ListSchedulesResponse
 */
export type ListSchedulesResponse = Message<"temporal.api.workflowservice.v1.ListSchedulesResponse"> & {
  /**
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleListEntry schedules = 1;
   */
  schedules: ScheduleListEntry[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListSchedulesResponse.
 * Use `create(ListSchedulesResponseSchema)` to create a new message.
 */
export const ListSchedulesResponseSchema: GenMessage<ListSchedulesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 97);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest
 */
export type UpdateWorkerBuildIdCompatibilityRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Must be set, the task queue to apply changes to. Because all workers on a given task queue
   * must have the same set of workflow & activity implementations, there is no reason to specify
   * a task queue type here.
   *
   * @generated from field: string task_queue = 2;
   */
  taskQueue: string;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.operation
   */
  operation: {
    /**
     * A new build id. This operation will create a new set which will be the new overall
     * default version for the queue, with this id as its only member. This new set is
     * incompatible with all previous sets/versions.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: In makes perfect sense here. --)
     *
     * @generated from field: string add_new_build_id_in_new_default_set = 3;
     */
    value: string;
    case: "addNewBuildIdInNewDefaultSet";
  } | {
    /**
     * Adds a new id to an existing compatible set, see sub-message definition for more.
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion add_new_compatible_build_id = 4;
     */
    value: UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion;
    case: "addNewCompatibleBuildId";
  } | {
    /**
     * Promote an existing set to be the current default (if it isn't already) by targeting
     * an existing build id within it. This field's value is the extant build id.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: Names are hard. --)
     *
     * @generated from field: string promote_set_by_build_id = 5;
     */
    value: string;
    case: "promoteSetByBuildId";
  } | {
    /**
     * Promote an existing build id within some set to be the current default for that set.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: Within makes perfect sense here. --)
     *
     * @generated from field: string promote_build_id_within_set = 6;
     */
    value: string;
    case: "promoteBuildIdWithinSet";
  } | {
    /**
     * Merge two existing sets together, thus declaring all build IDs in both sets compatible
     * with one another. The primary set's default will become the default for the merged set.
     * This is useful if you've accidentally declared a new ID as incompatible you meant to
     * declare as compatible. The unusual case of incomplete replication during failover could
     * also result in a split set, which this operation can repair.
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets merge_sets = 7;
     */
    value: UpdateWorkerBuildIdCompatibilityRequest_MergeSets;
    case: "mergeSets";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.
 * Use `create(UpdateWorkerBuildIdCompatibilityRequestSchema)` to create a new message.
 */
export const UpdateWorkerBuildIdCompatibilityRequestSchema: GenMessage<UpdateWorkerBuildIdCompatibilityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 98);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion
 */
export type UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion = Message<"temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion"> & {
  /**
   * A new id to be added to an existing compatible set.
   *
   * @generated from field: string new_build_id = 1;
   */
  newBuildId: string;

  /**
   * A build id which must already exist in the version sets known by the task queue. The new
   * id will be stored in the set containing this id, marking it as compatible with
   * the versions within.
   *
   * @generated from field: string existing_compatible_build_id = 2;
   */
  existingCompatibleBuildId: string;

  /**
   * When set, establishes the compatible set being targeted as the overall default for the
   * queue. If a different set was the current default, the targeted set will replace it as
   * the new default.
   *
   * @generated from field: bool make_set_default = 3;
   */
  makeSetDefault: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion.
 * Use `create(UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersionSchema)` to create a new message.
 */
export const UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersionSchema: GenMessage<UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 98, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets
 */
export type UpdateWorkerBuildIdCompatibilityRequest_MergeSets = Message<"temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets"> & {
  /**
   * A build ID in the set whose default will become the merged set default
   *
   * @generated from field: string primary_set_build_id = 1;
   */
  primarySetBuildId: string;

  /**
   * A build ID in the set which will be merged into the primary set
   *
   * @generated from field: string secondary_set_build_id = 2;
   */
  secondarySetBuildId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets.
 * Use `create(UpdateWorkerBuildIdCompatibilityRequest_MergeSetsSchema)` to create a new message.
 */
export const UpdateWorkerBuildIdCompatibilityRequest_MergeSetsSchema: GenMessage<UpdateWorkerBuildIdCompatibilityRequest_MergeSets> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 98, 1);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityResponse
 */
export type UpdateWorkerBuildIdCompatibilityResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityResponse.
 * Use `create(UpdateWorkerBuildIdCompatibilityResponseSchema)` to create a new message.
 */
export const UpdateWorkerBuildIdCompatibilityResponseSchema: GenMessage<UpdateWorkerBuildIdCompatibilityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 99);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityRequest
 */
export type GetWorkerBuildIdCompatibilityRequest = Message<"temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Must be set, the task queue to interrogate about worker id compatibility.
   *
   * @generated from field: string task_queue = 2;
   */
  taskQueue: string;

  /**
   * Limits how many compatible sets will be returned. Specify 1 to only return the current
   * default major version set. 0 returns all sets.
   *
   * @generated from field: int32 max_sets = 3;
   */
  maxSets: number;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityRequest.
 * Use `create(GetWorkerBuildIdCompatibilityRequestSchema)` to create a new message.
 */
export const GetWorkerBuildIdCompatibilityRequestSchema: GenMessage<GetWorkerBuildIdCompatibilityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 100);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityResponse
 */
export type GetWorkerBuildIdCompatibilityResponse = Message<"temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityResponse"> & {
  /**
   * Major version sets, in order from oldest to newest. The last element of the list will always
   * be the current default major version. IE: New workflows will target the most recent version
   * in that version set.
   *
   * There may be fewer sets returned than exist, if the request chose to limit this response.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.CompatibleVersionSet major_version_sets = 1;
   */
  majorVersionSets: CompatibleVersionSet[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityResponse.
 * Use `create(GetWorkerBuildIdCompatibilityResponseSchema)` to create a new message.
 */
export const GetWorkerBuildIdCompatibilityResponseSchema: GenMessage<GetWorkerBuildIdCompatibilityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 101);

/**
 * (-- api-linter: core::0134::request-mask-required=disabled
 *     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
 * (-- api-linter: core::0134::request-resource-required=disabled
 *     aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest
 */
export type UpdateWorkerVersioningRulesRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string task_queue = 2;
   */
  taskQueue: string;

  /**
   * A valid conflict_token can be taken from the previous
   * ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
   * An invalid token will cause this request to fail, ensuring that if the rules
   * for this Task Queue have been modified between the previous and current
   * operation, the request will fail instead of causing an unpredictable mutation.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken: Uint8Array;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.operation
   */
  operation: {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule insert_assignment_rule = 4;
     */
    value: UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule;
    case: "insertAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule replace_assignment_rule = 5;
     */
    value: UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule;
    case: "replaceAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule delete_assignment_rule = 6;
     */
    value: UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule;
    case: "deleteAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule add_compatible_redirect_rule = 7;
     */
    value: UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule;
    case: "addCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule replace_compatible_redirect_rule = 8;
     */
    value: UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule;
    case: "replaceCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule delete_compatible_redirect_rule = 9;
     */
    value: UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule;
    case: "deleteCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId commit_build_id = 10;
     */
    value: UpdateWorkerVersioningRulesRequest_CommitBuildId;
    case: "commitBuildId";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.
 * Use `create(UpdateWorkerVersioningRulesRequestSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequestSchema: GenMessage<UpdateWorkerVersioningRulesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102);

/**
 * Inserts the rule to the list of assignment rules for this Task Queue.
 * The rules are evaluated in order, starting from index 0. The first
 * applicable rule will be applied and the rest will be ignored.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule
 */
export type UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule"> & {
  /**
   * Use this option to insert the rule in a particular index. By
   * default, the new rule is inserted at the beginning of the list
   * (index 0). If the given index is too larger the rule will be
   * inserted at the end of the list.
   *
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex: number;

  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;
   */
  rule?: BuildIdAssignmentRule;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 0);

/**
 * Replaces the assignment rule at a given index.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule
 */
export type UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule"> & {
  /**
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex: number;

  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;
   */
  rule?: BuildIdAssignmentRule;

  /**
   * By default presence of one unconditional rule is enforced, otherwise
   * the replace operation will be rejected. Set `force` to true to
   * bypass this validation. An unconditional assignment rule:
   *   - Has no hint filter
   *   - Has no ramp
   *
   * @generated from field: bool force = 3;
   */
  force: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 1);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule
 */
export type UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule"> & {
  /**
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex: number;

  /**
   * By default presence of one unconditional rule is enforced, otherwise
   * the delete operation will be rejected. Set `force` to true to
   * bypass this validation. An unconditional assignment rule:
   *   - Has no hint filter
   *   - Has no ramp
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 2);

/**
 * Adds the rule to the list of redirect rules for this Task Queue. There
 * can be at most one redirect rule for each distinct Source Build ID.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule
 */
export type UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 3);

/**
 * Replaces the routing rule with the given source Build ID.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule
 */
export type UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 4);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule
 */
export type UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule"> & {
  /**
   * @generated from field: string source_build_id = 1;
   */
  sourceBuildId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule.
 * Use `create(UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRuleSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRuleSchema: GenMessage<UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 5);

/**
 * This command is intended to be used to complete the rollout of a Build
 * ID and cleanup unnecessary rules possibly created during a gradual
 * rollout. Specifically, this command will make the following changes
 * atomically:
 *  1. Adds an assignment rule (with full ramp) for the target Build ID at
 *     the end of the list.
 *  2. Removes all previously added assignment rules to the given target
 *     Build ID (if any).
 *  3. Removes any fully-ramped assignment rule for other Build IDs.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId
 */
export type UpdateWorkerVersioningRulesRequest_CommitBuildId = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId"> & {
  /**
   * @generated from field: string target_build_id = 1;
   */
  targetBuildId: string;

  /**
   * To prevent committing invalid Build IDs, we reject the request if no
   * pollers has been seen recently for this Build ID. Use the `force`
   * option to disable this validation.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId.
 * Use `create(UpdateWorkerVersioningRulesRequest_CommitBuildIdSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesRequest_CommitBuildIdSchema: GenMessage<UpdateWorkerVersioningRulesRequest_CommitBuildId> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 102, 6);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesResponse
 */
export type UpdateWorkerVersioningRulesResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesResponse"> & {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
   */
  assignmentRules: TimestampedBuildIdAssignmentRule[];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;
   */
  compatibleRedirectRules: TimestampedCompatibleBuildIdRedirectRule[];

  /**
   * This value can be passed back to UpdateWorkerVersioningRulesRequest to
   * ensure that the rules were not modified between the two updates, which
   * could lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesResponse.
 * Use `create(UpdateWorkerVersioningRulesResponseSchema)` to create a new message.
 */
export const UpdateWorkerVersioningRulesResponseSchema: GenMessage<UpdateWorkerVersioningRulesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 103);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerVersioningRulesRequest
 */
export type GetWorkerVersioningRulesRequest = Message<"temporal.api.workflowservice.v1.GetWorkerVersioningRulesRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string task_queue = 2;
   */
  taskQueue: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerVersioningRulesRequest.
 * Use `create(GetWorkerVersioningRulesRequestSchema)` to create a new message.
 */
export const GetWorkerVersioningRulesRequestSchema: GenMessage<GetWorkerVersioningRulesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 104);

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerVersioningRulesResponse
 */
export type GetWorkerVersioningRulesResponse = Message<"temporal.api.workflowservice.v1.GetWorkerVersioningRulesResponse"> & {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
   */
  assignmentRules: TimestampedBuildIdAssignmentRule[];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;
   */
  compatibleRedirectRules: TimestampedCompatibleBuildIdRedirectRule[];

  /**
   * This value can be passed back to UpdateWorkerVersioningRulesRequest to
   * ensure that the rules were not modified between this List and the Update,
   * which could lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerVersioningRulesResponse.
 * Use `create(GetWorkerVersioningRulesResponseSchema)` to create a new message.
 */
export const GetWorkerVersioningRulesResponseSchema: GenMessage<GetWorkerVersioningRulesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 105);

/**
 * [cleanup-wv-pre-release]
 * Deprecated. Use `DescribeTaskQueue`.
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityRequest
 */
export type GetWorkerTaskReachabilityRequest = Message<"temporal.api.workflowservice.v1.GetWorkerTaskReachabilityRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
   * The number of build ids that can be queried in a single API call is limited.
   * Open source users can adjust this limit by setting the server's dynamic config value for
   * `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
   *
   * @generated from field: repeated string build_ids = 2;
   */
  buildIds: string[];

  /**
   * Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
   * build ids in the namespace.
   * Must specify at least one task queue if querying for an unversioned worker.
   * The number of task queues that the server will fetch reachability information for is limited.
   * See the `GetWorkerTaskReachabilityResponse` documentation for more information.
   *
   * @generated from field: repeated string task_queues = 3;
   */
  taskQueues: string[];

  /**
   * Type of reachability to query for.
   * `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
   * Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
   * Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
   * unspecified.
   * See the TaskReachability docstring for information about each enum variant.
   *
   * @generated from field: temporal.api.enums.v1.TaskReachability reachability = 4;
   */
  reachability: TaskReachability;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityRequest.
 * Use `create(GetWorkerTaskReachabilityRequestSchema)` to create a new message.
 */
export const GetWorkerTaskReachabilityRequestSchema: GenMessage<GetWorkerTaskReachabilityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 106);

/**
 * [cleanup-wv-pre-release]
 * Deprecated. Use `DescribeTaskQueue`.
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityResponse
 */
export type GetWorkerTaskReachabilityResponse = Message<"temporal.api.workflowservice.v1.GetWorkerTaskReachabilityResponse"> & {
  /**
   * Task reachability, broken down by build id and then task queue.
   * When requesting a large number of task queues or all task queues associated with the given build ids in a
   * namespace, all task queues will be listed in the response but some of them may not contain reachability
   * information due to a server enforced limit. When reaching the limit, task queues that reachability information
   * could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
   * another call to get the reachability for those task queues.
   *
   * Open source users can adjust this limit by setting the server's dynamic config value for
   * `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.BuildIdReachability build_id_reachability = 1;
   */
  buildIdReachability: BuildIdReachability[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityResponse.
 * Use `create(GetWorkerTaskReachabilityResponseSchema)` to create a new message.
 */
export const GetWorkerTaskReachabilityResponseSchema: GenMessage<GetWorkerTaskReachabilityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 107);

/**
 * (-- api-linter: core::0134=disabled
 *     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest
 */
export type UpdateWorkflowExecutionRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest"> & {
  /**
   * The namespace name of the target Workflow.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The target Workflow Id and (optionally) a specific Run Id thereof.
   * (-- api-linter: core::0203::optional=disabled
   *     aip.dev/not-precedent: false positive triggered by the word "optional" --)
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * If set, this call will error if the most recent (if no Run Id is set on
   * `workflow_execution`), or specified (if it is) Workflow Execution is not
   * part of the same execution chain as this Id.
   *
   * @generated from field: string first_execution_run_id = 3;
   */
  firstExecutionRunId: string;

  /**
   * Specifies client's intent to wait for Update results.
   * NOTE: This field works together with API call timeout which is limited by
   * server timeout (maximum wait time). If server timeout is expired before
   * user specified timeout, API call returns even if specified stage is not reached.
   * Actual reached stage will be included in the response.
   *
   * @generated from field: temporal.api.update.v1.WaitPolicy wait_policy = 4;
   */
  waitPolicy?: WaitPolicy;

  /**
   * The request information that will be delivered all the way down to the
   * Workflow Execution.
   *
   * @generated from field: temporal.api.update.v1.Request request = 5;
   */
  request?: Request;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest.
 * Use `create(UpdateWorkflowExecutionRequestSchema)` to create a new message.
 */
export const UpdateWorkflowExecutionRequestSchema: GenMessage<UpdateWorkflowExecutionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 108);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse
 */
export type UpdateWorkflowExecutionResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse"> & {
  /**
   * Enough information for subsequent poll calls if needed. Never null.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 1;
   */
  updateRef?: UpdateRef;

  /**
   * The outcome of the Update if and only if the Workflow Update
   * has completed. If this response is being returned before the Update has
   * completed then this field will not be set.
   *
   * @generated from field: temporal.api.update.v1.Outcome outcome = 2;
   */
  outcome?: Outcome;

  /**
   * The most advanced lifecycle stage that the Update is known to have
   * reached, where lifecycle stages are ordered
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
   * UNSPECIFIED will be returned if and only if the server's maximum wait
   * time was reached before the Update reached the stage specified in the
   * request WaitPolicy, and before the context deadline expired; clients may
   * may then retry the call as needed.
   *
   * @generated from field: temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 3;
   */
  stage: UpdateWorkflowExecutionLifecycleStage;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse.
 * Use `create(UpdateWorkflowExecutionResponseSchema)` to create a new message.
 */
export const UpdateWorkflowExecutionResponseSchema: GenMessage<UpdateWorkflowExecutionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 109);

/**
 * @generated from message temporal.api.workflowservice.v1.StartBatchOperationRequest
 */
export type StartBatchOperationRequest = Message<"temporal.api.workflowservice.v1.StartBatchOperationRequest"> & {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Visibility query defines the the group of workflow to apply the batch operation
   * This field and `executions` are mutually exclusive
   *
   * @generated from field: string visibility_query = 2;
   */
  visibilityQuery: string;

  /**
   * Job ID defines the unique ID for the batch job
   *
   * @generated from field: string job_id = 3;
   */
  jobId: string;

  /**
   * Reason to perform the batch operation
   *
   * @generated from field: string reason = 4;
   */
  reason: string;

  /**
   * Executions to apply the batch operation
   * This field and `visibility_query` are mutually exclusive
   *
   * @generated from field: repeated temporal.api.common.v1.WorkflowExecution executions = 5;
   */
  executions: WorkflowExecution[];

  /**
   * Limit for the number of operations processed per second within this batch.
   * Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
   * overload and minimize potential delays in executing ongoing tasks for user workers.
   * Note that when no explicit limit is provided, the server will operate according to its limit defined by the
   * dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
   * server's configured limit.
   *
   * @generated from field: float max_operations_per_second = 6;
   */
  maxOperationsPerSecond: number;

  /**
   * Operation input
   *
   * @generated from oneof temporal.api.workflowservice.v1.StartBatchOperationRequest.operation
   */
  operation: {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationTermination termination_operation = 10;
     */
    value: BatchOperationTermination;
    case: "terminationOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationSignal signal_operation = 11;
     */
    value: BatchOperationSignal;
    case: "signalOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationCancellation cancellation_operation = 12;
     */
    value: BatchOperationCancellation;
    case: "cancellationOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationDeletion deletion_operation = 13;
     */
    value: BatchOperationDeletion;
    case: "deletionOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationReset reset_operation = 14;
     */
    value: BatchOperationReset;
    case: "resetOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions update_workflow_options_operation = 15;
     */
    value: BatchOperationUpdateWorkflowExecutionOptions;
    case: "updateWorkflowOptionsOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUnpauseActivities unpause_activities_operation = 16;
     */
    value: BatchOperationUnpauseActivities;
    case: "unpauseActivitiesOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationResetActivities reset_activities_operation = 17;
     */
    value: BatchOperationResetActivities;
    case: "resetActivitiesOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUpdateActivityOptions update_activity_options_operation = 18;
     */
    value: BatchOperationUpdateActivityOptions;
    case: "updateActivityOptionsOperation";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.StartBatchOperationRequest.
 * Use `create(StartBatchOperationRequestSchema)` to create a new message.
 */
export const StartBatchOperationRequestSchema: GenMessage<StartBatchOperationRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 110);

/**
 * @generated from message temporal.api.workflowservice.v1.StartBatchOperationResponse
 */
export type StartBatchOperationResponse = Message<"temporal.api.workflowservice.v1.StartBatchOperationResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.StartBatchOperationResponse.
 * Use `create(StartBatchOperationResponseSchema)` to create a new message.
 */
export const StartBatchOperationResponseSchema: GenMessage<StartBatchOperationResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 111);

/**
 * @generated from message temporal.api.workflowservice.v1.StopBatchOperationRequest
 */
export type StopBatchOperationRequest = Message<"temporal.api.workflowservice.v1.StopBatchOperationRequest"> & {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Batch job id
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;

  /**
   * Reason to stop a batch operation
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * Identity of the operator
   *
   * @generated from field: string identity = 4;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.StopBatchOperationRequest.
 * Use `create(StopBatchOperationRequestSchema)` to create a new message.
 */
export const StopBatchOperationRequestSchema: GenMessage<StopBatchOperationRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 112);

/**
 * @generated from message temporal.api.workflowservice.v1.StopBatchOperationResponse
 */
export type StopBatchOperationResponse = Message<"temporal.api.workflowservice.v1.StopBatchOperationResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.StopBatchOperationResponse.
 * Use `create(StopBatchOperationResponseSchema)` to create a new message.
 */
export const StopBatchOperationResponseSchema: GenMessage<StopBatchOperationResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 113);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeBatchOperationRequest
 */
export type DescribeBatchOperationRequest = Message<"temporal.api.workflowservice.v1.DescribeBatchOperationRequest"> & {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Batch job id
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeBatchOperationRequest.
 * Use `create(DescribeBatchOperationRequestSchema)` to create a new message.
 */
export const DescribeBatchOperationRequestSchema: GenMessage<DescribeBatchOperationRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 114);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeBatchOperationResponse
 */
export type DescribeBatchOperationResponse = Message<"temporal.api.workflowservice.v1.DescribeBatchOperationResponse"> & {
  /**
   * Batch operation type
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationType operation_type = 1;
   */
  operationType: BatchOperationType;

  /**
   * Batch job ID
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;

  /**
   * Batch operation state
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationState state = 3;
   */
  state: BatchOperationState;

  /**
   * Batch operation start time
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * Batch operation close time
   *
   * @generated from field: google.protobuf.Timestamp close_time = 5;
   */
  closeTime?: Timestamp;

  /**
   * Total operation count
   *
   * @generated from field: int64 total_operation_count = 6;
   */
  totalOperationCount: bigint;

  /**
   * Complete operation count
   *
   * @generated from field: int64 complete_operation_count = 7;
   */
  completeOperationCount: bigint;

  /**
   * Failure operation count
   *
   * @generated from field: int64 failure_operation_count = 8;
   */
  failureOperationCount: bigint;

  /**
   * Identity indicates the operator identity
   *
   * @generated from field: string identity = 9;
   */
  identity: string;

  /**
   * Reason indicates the reason to stop a operation
   *
   * @generated from field: string reason = 10;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeBatchOperationResponse.
 * Use `create(DescribeBatchOperationResponseSchema)` to create a new message.
 */
export const DescribeBatchOperationResponseSchema: GenMessage<DescribeBatchOperationResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 115);

/**
 * @generated from message temporal.api.workflowservice.v1.ListBatchOperationsRequest
 */
export type ListBatchOperationsRequest = Message<"temporal.api.workflowservice.v1.ListBatchOperationsRequest"> & {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * List page size
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Next page token
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListBatchOperationsRequest.
 * Use `create(ListBatchOperationsRequestSchema)` to create a new message.
 */
export const ListBatchOperationsRequestSchema: GenMessage<ListBatchOperationsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 116);

/**
 * @generated from message temporal.api.workflowservice.v1.ListBatchOperationsResponse
 */
export type ListBatchOperationsResponse = Message<"temporal.api.workflowservice.v1.ListBatchOperationsResponse"> & {
  /**
   * BatchOperationInfo contains the basic info about batch operation
   *
   * @generated from field: repeated temporal.api.batch.v1.BatchOperationInfo operation_info = 1;
   */
  operationInfo: BatchOperationInfo[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListBatchOperationsResponse.
 * Use `create(ListBatchOperationsResponseSchema)` to create a new message.
 */
export const ListBatchOperationsResponseSchema: GenMessage<ListBatchOperationsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 117);

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest
 */
export type PollWorkflowExecutionUpdateRequest = Message<"temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest"> & {
  /**
   * The namespace of the Workflow Execution to which the Update was
   * originally issued.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The Update reference returned in the initial UpdateWorkflowExecutionResponse.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 2;
   */
  updateRef?: UpdateRef;

  /**
   * The identity of the worker/client who is polling this Update outcome.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Specifies client's intent to wait for Update results.
   * Omit to request a non-blocking poll.
   *
   * @generated from field: temporal.api.update.v1.WaitPolicy wait_policy = 4;
   */
  waitPolicy?: WaitPolicy;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest.
 * Use `create(PollWorkflowExecutionUpdateRequestSchema)` to create a new message.
 */
export const PollWorkflowExecutionUpdateRequestSchema: GenMessage<PollWorkflowExecutionUpdateRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 118);

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse
 */
export type PollWorkflowExecutionUpdateResponse = Message<"temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse"> & {
  /**
   * The outcome of the update if and only if the update has completed. If
   * this response is being returned before the update has completed (e.g. due
   * to the specification of a wait policy that only waits on
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
   * not be set.
   *
   * @generated from field: temporal.api.update.v1.Outcome outcome = 1;
   */
  outcome?: Outcome;

  /**
   * The most advanced lifecycle stage that the Update is known to have
   * reached, where lifecycle stages are ordered
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
   * UNSPECIFIED will be returned if and only if the server's maximum wait
   * time was reached before the Update reached the stage specified in the
   * request WaitPolicy, and before the context deadline expired; clients may
   * may then retry the call as needed.
   *
   * @generated from field: temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 2;
   */
  stage: UpdateWorkflowExecutionLifecycleStage;

  /**
   * Sufficient information to address this Update.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 3;
   */
  updateRef?: UpdateRef;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse.
 * Use `create(PollWorkflowExecutionUpdateResponseSchema)` to create a new message.
 */
export const PollWorkflowExecutionUpdateResponseSchema: GenMessage<PollWorkflowExecutionUpdateResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 119);

/**
 * @generated from message temporal.api.workflowservice.v1.PollNexusTaskQueueRequest
 */
export type PollNexusTaskQueueRequest = Message<"temporal.api.workflowservice.v1.PollNexusTaskQueueRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  /**
   * Worker info to be sent to the server.
   *
   * @generated from field: repeated temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 7;
   */
  workerHeartbeat: WorkerHeartbeat[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollNexusTaskQueueRequest.
 * Use `create(PollNexusTaskQueueRequestSchema)` to create a new message.
 */
export const PollNexusTaskQueueRequestSchema: GenMessage<PollNexusTaskQueueRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 120);

/**
 * @generated from message temporal.api.workflowservice.v1.PollNexusTaskQueueResponse
 */
export type PollNexusTaskQueueResponse = Message<"temporal.api.workflowservice.v1.PollNexusTaskQueueResponse"> & {
  /**
   * An opaque unique identifier for this task for correlating a completion request the embedded request.
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken: Uint8Array;

  /**
   * Embedded request as translated from the incoming frontend request.
   *
   * @generated from field: temporal.api.nexus.v1.Request request = 2;
   */
  request?: Request$1;

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 3;
   */
  pollerScalingDecision?: PollerScalingDecision;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PollNexusTaskQueueResponse.
 * Use `create(PollNexusTaskQueueResponseSchema)` to create a new message.
 */
export const PollNexusTaskQueueResponseSchema: GenMessage<PollNexusTaskQueueResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 121);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskCompletedRequest
 */
export type RespondNexusTaskCompletedRequest = Message<"temporal.api.workflowservice.v1.RespondNexusTaskCompletedRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * A unique identifier for this task as received via a poll response.
   *
   * @generated from field: bytes task_token = 3;
   */
  taskToken: Uint8Array;

  /**
   * Embedded response to be translated into a frontend response.
   *
   * @generated from field: temporal.api.nexus.v1.Response response = 4;
   */
  response?: Response;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondNexusTaskCompletedRequest.
 * Use `create(RespondNexusTaskCompletedRequestSchema)` to create a new message.
 */
export const RespondNexusTaskCompletedRequestSchema: GenMessage<RespondNexusTaskCompletedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 122);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskCompletedResponse
 */
export type RespondNexusTaskCompletedResponse = Message<"temporal.api.workflowservice.v1.RespondNexusTaskCompletedResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondNexusTaskCompletedResponse.
 * Use `create(RespondNexusTaskCompletedResponseSchema)` to create a new message.
 */
export const RespondNexusTaskCompletedResponseSchema: GenMessage<RespondNexusTaskCompletedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 123);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskFailedRequest
 */
export type RespondNexusTaskFailedRequest = Message<"temporal.api.workflowservice.v1.RespondNexusTaskFailedRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * A unique identifier for this task.
   *
   * @generated from field: bytes task_token = 3;
   */
  taskToken: Uint8Array;

  /**
   * The error the handler failed with.
   *
   * @generated from field: temporal.api.nexus.v1.HandlerError error = 4;
   */
  error?: HandlerError;
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondNexusTaskFailedRequest.
 * Use `create(RespondNexusTaskFailedRequestSchema)` to create a new message.
 */
export const RespondNexusTaskFailedRequestSchema: GenMessage<RespondNexusTaskFailedRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 124);

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskFailedResponse
 */
export type RespondNexusTaskFailedResponse = Message<"temporal.api.workflowservice.v1.RespondNexusTaskFailedResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RespondNexusTaskFailedResponse.
 * Use `create(RespondNexusTaskFailedResponseSchema)` to create a new message.
 */
export const RespondNexusTaskFailedResponseSchema: GenMessage<RespondNexusTaskFailedResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 125);

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest
 */
export type ExecuteMultiOperationRequest = Message<"temporal.api.workflowservice.v1.ExecuteMultiOperationRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * List of operations to execute within a single workflow.
   *
   * Preconditions:
   * - The list of operations must not be empty.
   * - The workflow ids must match across operations.
   * - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
   *
   * Note that additional operation-specific restrictions have to be considered.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation operations = 2;
   */
  operations: ExecuteMultiOperationRequest_Operation[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.
 * Use `create(ExecuteMultiOperationRequestSchema)` to create a new message.
 */
export const ExecuteMultiOperationRequestSchema: GenMessage<ExecuteMultiOperationRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 126);

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation
 */
export type ExecuteMultiOperationRequest_Operation = Message<"temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation"> & {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation.operation
   */
  operation: {
    /**
     * Additional restrictions:
     * - setting `cron_schedule` is invalid
     * - setting `request_eager_execution` is invalid
     * - setting `workflow_start_delay` is invalid
     *
     * @generated from field: temporal.api.workflowservice.v1.StartWorkflowExecutionRequest start_workflow = 1;
     */
    value: StartWorkflowExecutionRequest;
    case: "startWorkflow";
  } | {
    /**
     * Additional restrictions:
     * - setting `first_execution_run_id` is invalid
     * - setting `workflow_execution.run_id` is invalid
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest update_workflow = 2;
     */
    value: UpdateWorkflowExecutionRequest;
    case: "updateWorkflow";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation.
 * Use `create(ExecuteMultiOperationRequest_OperationSchema)` to create a new message.
 */
export const ExecuteMultiOperationRequest_OperationSchema: GenMessage<ExecuteMultiOperationRequest_Operation> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 126, 0);

/**
 * IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination ("Update-with-Start") when both
 *   1. the workflow update for the requested update ID has already completed, and
 *   2. the workflow for the requested workflow ID has already been closed,
 * then you'll receive
 *   - an update response containing the update's outcome, and
 *   - a start response with a `status` field that reflects the workflow's current state.
 *
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse
 */
export type ExecuteMultiOperationResponse = Message<"temporal.api.workflowservice.v1.ExecuteMultiOperationResponse"> & {
  /**
   * @generated from field: repeated temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response responses = 1;
   */
  responses: ExecuteMultiOperationResponse_Response[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.
 * Use `create(ExecuteMultiOperationResponseSchema)` to create a new message.
 */
export const ExecuteMultiOperationResponseSchema: GenMessage<ExecuteMultiOperationResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 127);

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response
 */
export type ExecuteMultiOperationResponse_Response = Message<"temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response"> & {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response.response
   */
  response: {
    /**
     * @generated from field: temporal.api.workflowservice.v1.StartWorkflowExecutionResponse start_workflow = 1;
     */
    value: StartWorkflowExecutionResponse;
    case: "startWorkflow";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse update_workflow = 2;
     */
    value: UpdateWorkflowExecutionResponse;
    case: "updateWorkflow";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response.
 * Use `create(ExecuteMultiOperationResponse_ResponseSchema)` to create a new message.
 */
export const ExecuteMultiOperationResponse_ResponseSchema: GenMessage<ExecuteMultiOperationResponse_Response> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 127, 0);

/**
 * NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateActivityOptionsRequest
 */
export type UpdateActivityOptionsRequest = Message<"temporal.api.workflowservice.v1.UpdateActivityOptionsRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Activity options. Partial updates are accepted and controlled by update_mask
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 4;
   */
  activityOptions?: ActivityOptions;

  /**
   * Controls which fields from `activity_options` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;

  /**
   * either activity id, activity type or update_all must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.UpdateActivityOptionsRequest.activity
   */
  activity: {
    /**
     * Only activity with this ID will be updated.
     *
     * @generated from field: string id = 6;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Update all running activities of this type.
     *
     * @generated from field: string type = 7;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Update all running activities.
     *
     * @generated from field: bool match_all = 9;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined };

  /**
   * If set, the activity options will be restored to the default.
   * Default options are then options activity was created with.
   * They are part of the first SCHEDULE event.
   * This flag cannot be combined with any other option; if you supply
   * restore_original together with other options, the request will be rejected.
   *
   * @generated from field: bool restore_original = 8;
   */
  restoreOriginal: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateActivityOptionsRequest.
 * Use `create(UpdateActivityOptionsRequestSchema)` to create a new message.
 */
export const UpdateActivityOptionsRequestSchema: GenMessage<UpdateActivityOptionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 128);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateActivityOptionsResponse
 */
export type UpdateActivityOptionsResponse = Message<"temporal.api.workflowservice.v1.UpdateActivityOptionsResponse"> & {
  /**
   * Activity options after an update
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 1;
   */
  activityOptions?: ActivityOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateActivityOptionsResponse.
 * Use `create(UpdateActivityOptionsResponseSchema)` to create a new message.
 */
export const UpdateActivityOptionsResponseSchema: GenMessage<UpdateActivityOptionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 129);

/**
 * @generated from message temporal.api.workflowservice.v1.PauseActivityRequest
 */
export type PauseActivityRequest = Message<"temporal.api.workflowservice.v1.PauseActivityRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * either activity id or activity type must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.PauseActivityRequest.activity
   */
  activity: {
    /**
     * Only the activity with this ID will be paused.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Pause all running activities of this type.
     * Note: Experimental - the behavior of pause by activity type might change in a future release.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | { case: undefined; value?: undefined };

  /**
   * Reason to pause the activity.
   *
   * @generated from field: string reason = 6;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.PauseActivityRequest.
 * Use `create(PauseActivityRequestSchema)` to create a new message.
 */
export const PauseActivityRequestSchema: GenMessage<PauseActivityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 130);

/**
 * @generated from message temporal.api.workflowservice.v1.PauseActivityResponse
 */
export type PauseActivityResponse = Message<"temporal.api.workflowservice.v1.PauseActivityResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.PauseActivityResponse.
 * Use `create(PauseActivityResponseSchema)` to create a new message.
 */
export const PauseActivityResponseSchema: GenMessage<PauseActivityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 131);

/**
 * @generated from message temporal.api.workflowservice.v1.UnpauseActivityRequest
 */
export type UnpauseActivityRequest = Message<"temporal.api.workflowservice.v1.UnpauseActivityRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * either activity id or activity type must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.UnpauseActivityRequest.activity
   */
  activity: {
    /**
     * Only the activity with this ID will be unpaused.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Unpause all running activities with of this type.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Unpause all running activities.
     *
     * @generated from field: bool unpause_all = 6;
     */
    value: boolean;
    case: "unpauseAll";
  } | { case: undefined; value?: undefined };

  /**
   * Providing this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 7;
   */
  resetAttempts: boolean;

  /**
   * Providing this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 8;
   */
  resetHeartbeat: boolean;

  /**
   * If set, the activity will start at a random time within the specified jitter duration.
   *
   * @generated from field: google.protobuf.Duration jitter = 9;
   */
  jitter?: Duration;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UnpauseActivityRequest.
 * Use `create(UnpauseActivityRequestSchema)` to create a new message.
 */
export const UnpauseActivityRequestSchema: GenMessage<UnpauseActivityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 132);

/**
 * @generated from message temporal.api.workflowservice.v1.UnpauseActivityResponse
 */
export type UnpauseActivityResponse = Message<"temporal.api.workflowservice.v1.UnpauseActivityResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.UnpauseActivityResponse.
 * Use `create(UnpauseActivityResponseSchema)` to create a new message.
 */
export const UnpauseActivityResponseSchema: GenMessage<UnpauseActivityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 133);

/**
 * NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities
 *
 * @generated from message temporal.api.workflowservice.v1.ResetActivityRequest
 */
export type ResetActivityRequest = Message<"temporal.api.workflowservice.v1.ResetActivityRequest"> & {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * either activity id, activity type or update_all must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.ResetActivityRequest.activity
   */
  activity: {
    /**
     * Only activity with this ID will be reset.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Reset all running activities with of this type.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Reset all running activities.
     *
     * @generated from field: bool match_all = 10;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined };

  /**
   * Indicates that activity should reset heartbeat details.
   * This flag will be applied only to the new instance of the activity.
   *
   * @generated from field: bool reset_heartbeat = 6;
   */
  resetHeartbeat: boolean;

  /**
   * If activity is paused, it will remain paused after reset
   *
   * @generated from field: bool keep_paused = 7;
   */
  keepPaused: boolean;

  /**
   * If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
   * (unless it is paused and keep_paused is set)
   *
   * @generated from field: google.protobuf.Duration jitter = 8;
   */
  jitter?: Duration;

  /**
   * If set, the activity options will be restored to the defaults.
   * Default options are then options activity was created with.
   * They are part of the first SCHEDULE event.
   *
   * @generated from field: bool restore_original_options = 9;
   */
  restoreOriginalOptions: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetActivityRequest.
 * Use `create(ResetActivityRequestSchema)` to create a new message.
 */
export const ResetActivityRequestSchema: GenMessage<ResetActivityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 134);

/**
 * @generated from message temporal.api.workflowservice.v1.ResetActivityResponse
 */
export type ResetActivityResponse = Message<"temporal.api.workflowservice.v1.ResetActivityResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.ResetActivityResponse.
 * Use `create(ResetActivityResponseSchema)` to create a new message.
 */
export const ResetActivityResponseSchema: GenMessage<ResetActivityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 135);

/**
 * Keep the parameters in sync with:
 *   - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
 *   - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest
 */
export type UpdateWorkflowExecutionOptionsRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest"> & {
  /**
   * The namespace name of the target Workflow.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The target Workflow Id and (optionally) a specific Run Id thereof.
   * (-- api-linter: core::0203::optional=disabled
   *     aip.dev/not-precedent: false positive triggered by the word "optional" --)
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * Workflow Execution options. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 3;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 4;
   */
  updateMask?: FieldMask;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 * Use `create(UpdateWorkflowExecutionOptionsRequestSchema)` to create a new message.
 */
export const UpdateWorkflowExecutionOptionsRequestSchema: GenMessage<UpdateWorkflowExecutionOptionsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 136);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsResponse
 */
export type UpdateWorkflowExecutionOptionsResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsResponse"> & {
  /**
   * Workflow Execution options after update.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 1;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsResponse.
 * Use `create(UpdateWorkflowExecutionOptionsResponseSchema)` to create a new message.
 */
export const UpdateWorkflowExecutionOptionsResponseSchema: GenMessage<UpdateWorkflowExecutionOptionsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 137);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeDeploymentRequest
 */
export type DescribeDeploymentRequest = Message<"temporal.api.workflowservice.v1.DescribeDeploymentRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeDeploymentRequest.
 * Use `create(DescribeDeploymentRequestSchema)` to create a new message.
 */
export const DescribeDeploymentRequestSchema: GenMessage<DescribeDeploymentRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 138);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeDeploymentResponse
 */
export type DescribeDeploymentResponse = Message<"temporal.api.workflowservice.v1.DescribeDeploymentResponse"> & {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo deployment_info = 1;
   */
  deploymentInfo?: DeploymentInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeDeploymentResponse.
 * Use `create(DescribeDeploymentResponseSchema)` to create a new message.
 */
export const DescribeDeploymentResponseSchema: GenMessage<DescribeDeploymentResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 139);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionRequest
 */
export type DescribeWorkerDeploymentVersionRequest = Message<"temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 3;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Report stats for task queues which have been polled by this version.
   *
   * @generated from field: bool report_task_queue_stats = 4;
   */
  reportTaskQueueStats: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionRequest.
 * Use `create(DescribeWorkerDeploymentVersionRequestSchema)` to create a new message.
 */
export const DescribeWorkerDeploymentVersionRequestSchema: GenMessage<DescribeWorkerDeploymentVersionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 140);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse
 */
export type DescribeWorkerDeploymentVersionResponse = Message<"temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse"> & {
  /**
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersionInfo worker_deployment_version_info = 1;
   */
  workerDeploymentVersionInfo?: WorkerDeploymentVersionInfo;

  /**
   * All the Task Queues that have ever polled from this Deployment version.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue version_task_queues = 2;
   */
  versionTaskQueues: DescribeWorkerDeploymentVersionResponse_VersionTaskQueue[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.
 * Use `create(DescribeWorkerDeploymentVersionResponseSchema)` to create a new message.
 */
export const DescribeWorkerDeploymentVersionResponseSchema: GenMessage<DescribeWorkerDeploymentVersionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 141);

/**
 * (-- api-linter: core::0123::resource-annotation=disabled --)
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue
 */
export type DescribeWorkerDeploymentVersionResponse_VersionTaskQueue = Message<"temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType type = 2;
   */
  type: TaskQueueType;

  /**
   * Only set if `report_task_queue_stats` is set on the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 3;
   */
  stats?: TaskQueueStats;

  /**
   * Task queue stats breakdown by priority key. Only contains actively used priority keys.
   * Only set if `report_task_queue_stats` is set to true in the request.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "by" is used to clarify the key. --)
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueStats> stats_by_priority_key = 4;
   */
  statsByPriorityKey: { [key: number]: TaskQueueStats };
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue.
 * Use `create(DescribeWorkerDeploymentVersionResponse_VersionTaskQueueSchema)` to create a new message.
 */
export const DescribeWorkerDeploymentVersionResponse_VersionTaskQueueSchema: GenMessage<DescribeWorkerDeploymentVersionResponse_VersionTaskQueue> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 141, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentRequest
 */
export type DescribeWorkerDeploymentRequest = Message<"temporal.api.workflowservice.v1.DescribeWorkerDeploymentRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerDeploymentRequest.
 * Use `create(DescribeWorkerDeploymentRequestSchema)` to create a new message.
 */
export const DescribeWorkerDeploymentRequestSchema: GenMessage<DescribeWorkerDeploymentRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 142);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentResponse
 */
export type DescribeWorkerDeploymentResponse = Message<"temporal.api.workflowservice.v1.DescribeWorkerDeploymentResponse"> & {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this read and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken: Uint8Array;

  /**
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo worker_deployment_info = 2;
   */
  workerDeploymentInfo?: WorkerDeploymentInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerDeploymentResponse.
 * Use `create(DescribeWorkerDeploymentResponseSchema)` to create a new message.
 */
export const DescribeWorkerDeploymentResponseSchema: GenMessage<DescribeWorkerDeploymentResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 143);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.ListDeploymentsRequest
 */
export type ListDeploymentsRequest = Message<"temporal.api.workflowservice.v1.ListDeploymentsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * Optional. Use to filter based on exact series name match.
   *
   * @generated from field: string series_name = 4;
   */
  seriesName: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListDeploymentsRequest.
 * Use `create(ListDeploymentsRequestSchema)` to create a new message.
 */
export const ListDeploymentsRequestSchema: GenMessage<ListDeploymentsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 144);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.ListDeploymentsResponse
 */
export type ListDeploymentsResponse = Message<"temporal.api.workflowservice.v1.ListDeploymentsResponse"> & {
  /**
   * @generated from field: bytes next_page_token = 1;
   */
  nextPageToken: Uint8Array;

  /**
   * @generated from field: repeated temporal.api.deployment.v1.DeploymentListInfo deployments = 2;
   */
  deployments: DeploymentListInfo[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListDeploymentsResponse.
 * Use `create(ListDeploymentsResponseSchema)` to create a new message.
 */
export const ListDeploymentsResponseSchema: GenMessage<ListDeploymentsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 145);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.SetCurrentDeploymentRequest
 */
export type SetCurrentDeploymentRequest = Message<"temporal.api.workflowservice.v1.SetCurrentDeploymentRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
   * when describing a deployment. It is a good place for information such as operator name,
   * links to internal deployment pipelines, etc.
   *
   * @generated from field: temporal.api.deployment.v1.UpdateDeploymentMetadata update_metadata = 4;
   */
  updateMetadata?: UpdateDeploymentMetadata;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetCurrentDeploymentRequest.
 * Use `create(SetCurrentDeploymentRequestSchema)` to create a new message.
 */
export const SetCurrentDeploymentRequestSchema: GenMessage<SetCurrentDeploymentRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 146);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.SetCurrentDeploymentResponse
 */
export type SetCurrentDeploymentResponse = Message<"temporal.api.workflowservice.v1.SetCurrentDeploymentResponse"> & {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo current_deployment_info = 1;
   */
  currentDeploymentInfo?: DeploymentInfo;

  /**
   * Info of the deployment that was current before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo previous_deployment_info = 2;
   */
  previousDeploymentInfo?: DeploymentInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetCurrentDeploymentResponse.
 * Use `create(SetCurrentDeploymentResponseSchema)` to create a new message.
 */
export const SetCurrentDeploymentResponseSchema: GenMessage<SetCurrentDeploymentResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 147);

/**
 * Set/unset the Current Version of a Worker Deployment.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionRequest
 */
export type SetWorkerDeploymentCurrentVersionRequest = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName: string;

  /**
   * Deprecated. Use `build_id`.
   *
   * @generated from field: string version = 3 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The build id of the Version that you want to set as Current.
   * Pass an empty value to set the Current Version to nil.
   * A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   *
   * @generated from field: string build_id = 7;
   */
  buildId: string;

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 4;
   */
  conflictToken: Uint8Array;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * Optional. By default this request would be rejected if not all the expected Task Queues are
   * being polled by the new Version, to protect against accidental removal of Task Queues, or
   * worker health issues. Pass `true` here to bypass this protection.
   * The set of expected Task Queues is the set of all the Task Queues that were ever poller by
   * the existing Current Version of the Deployment, with the following exclusions:
   *   - Task Queues that are not used anymore (inferred by having empty backlog and a task
   *     add_rate of 0.)
   *   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
   *     having a different Current Version than the Current Version of this deployment.)
   * WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
   * needed. If the request is unexpectedly rejected due to missing pollers, then that means the
   * pollers have not reached to the server yet. Only set this if you expect those pollers to
   * never arrive.
   *
   * @generated from field: bool ignore_missing_task_queues = 6;
   */
  ignoreMissingTaskQueues: boolean;

  /**
   * Optional. By default this request will be rejected if no pollers have been seen for the proposed
   * Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
   * to possible timeouts. Pass `true` here to bypass this protection.
   *
   * @generated from field: bool allow_no_pollers = 9;
   */
  allowNoPollers: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionRequest.
 * Use `create(SetWorkerDeploymentCurrentVersionRequestSchema)` to create a new message.
 */
export const SetWorkerDeploymentCurrentVersionRequestSchema: GenMessage<SetWorkerDeploymentCurrentVersionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 148);

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionResponse
 */
export type SetWorkerDeploymentCurrentVersionResponse = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionResponse"> & {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken: Uint8Array;

  /**
   * Deprecated. Use `previous_deployment_version`.
   *
   * @generated from field: string previous_version = 2 [deprecated = true];
   * @deprecated
   */
  previousVersion: string;

  /**
   * The version that was current before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion previous_deployment_version = 3;
   */
  previousDeploymentVersion?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionResponse.
 * Use `create(SetWorkerDeploymentCurrentVersionResponseSchema)` to create a new message.
 */
export const SetWorkerDeploymentCurrentVersionResponseSchema: GenMessage<SetWorkerDeploymentCurrentVersionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 149);

/**
 * Set/unset the Ramping Version of a Worker Deployment and its ramp percentage.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionRequest
 */
export type SetWorkerDeploymentRampingVersionRequest = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName: string;

  /**
   * Deprecated. Use `build_id`.
   *
   * @generated from field: string version = 3 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * The build id of the Version that you want to ramp traffic to.
   * Pass an empty value to set the Ramping Version to nil.
   * A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   *
   * @generated from field: string build_id = 8;
   */
  buildId: string;

  /**
   * Ramp percentage to set. Valid range: [0,100].
   *
   * @generated from field: float percentage = 4;
   */
  percentage: number;

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken: Uint8Array;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity: string;

  /**
   * Optional. By default this request would be rejected if not all the expected Task Queues are
   * being polled by the new Version, to protect against accidental removal of Task Queues, or
   * worker health issues. Pass `true` here to bypass this protection.
   * The set of expected Task Queues equals to all the Task Queues ever polled from the existing
   * Current Version of the Deployment, with the following exclusions:
   *   - Task Queues that are not used anymore (inferred by having empty backlog and a task
   *     add_rate of 0.)
   *   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
   *     having a different Current Version than the Current Version of this deployment.)
   * WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
   * needed. If the request is unexpectedly rejected due to missing pollers, then that means the
   * pollers have not reached to the server yet. Only set this if you expect those pollers to
   * never arrive.
   * Note: this check only happens when the ramping version is about to change, not every time
   * that the percentage changes. Also note that the check is against the deployment's Current
   * Version, not the previous Ramping Version.
   *
   * @generated from field: bool ignore_missing_task_queues = 7;
   */
  ignoreMissingTaskQueues: boolean;

  /**
   * Optional. By default this request will be rejected if no pollers have been seen for the proposed
   * Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
   * to possible timeouts. Pass `true` here to bypass this protection.
   *
   * @generated from field: bool allow_no_pollers = 10;
   */
  allowNoPollers: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionRequest.
 * Use `create(SetWorkerDeploymentRampingVersionRequestSchema)` to create a new message.
 */
export const SetWorkerDeploymentRampingVersionRequestSchema: GenMessage<SetWorkerDeploymentRampingVersionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 150);

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionResponse
 */
export type SetWorkerDeploymentRampingVersionResponse = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionResponse"> & {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken: Uint8Array;

  /**
   * Deprecated. Use `previous_deployment_version`.
   *
   * @generated from field: string previous_version = 2 [deprecated = true];
   * @deprecated
   */
  previousVersion: string;

  /**
   * The version that was ramping before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion previous_deployment_version = 4;
   */
  previousDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * The ramping version percentage before executing this operation.
   *
   * @generated from field: float previous_percentage = 3;
   */
  previousPercentage: number;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionResponse.
 * Use `create(SetWorkerDeploymentRampingVersionResponseSchema)` to create a new message.
 */
export const SetWorkerDeploymentRampingVersionResponseSchema: GenMessage<SetWorkerDeploymentRampingVersionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 151);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsRequest
 */
export type ListWorkerDeploymentsRequest = Message<"temporal.api.workflowservice.v1.ListWorkerDeploymentsRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkerDeploymentsRequest.
 * Use `create(ListWorkerDeploymentsRequestSchema)` to create a new message.
 */
export const ListWorkerDeploymentsRequestSchema: GenMessage<ListWorkerDeploymentsRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 152);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse
 */
export type ListWorkerDeploymentsResponse = Message<"temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse"> & {
  /**
   * @generated from field: bytes next_page_token = 1;
   */
  nextPageToken: Uint8Array;

  /**
   * The list of worker deployments.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary worker_deployments = 2;
   */
  workerDeployments: ListWorkerDeploymentsResponse_WorkerDeploymentSummary[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.
 * Use `create(ListWorkerDeploymentsResponseSchema)` to create a new message.
 */
export const ListWorkerDeploymentsResponseSchema: GenMessage<ListWorkerDeploymentsResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 153);

/**
 * (-- api-linter: core::0123::resource-annotation=disabled --)
 * A subset of WorkerDeploymentInfo
 *
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary
 */
export type ListWorkerDeploymentsResponse_WorkerDeploymentSummary = Message<"temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: temporal.api.deployment.v1.RoutingConfig routing_config = 3;
   */
  routingConfig?: RoutingConfig;

  /**
   * Summary of the version that was added most recently in the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary latest_version_summary = 4;
   */
  latestVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;

  /**
   * Summary of the current version of the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary current_version_summary = 5;
   */
  currentVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;

  /**
   * Summary of the ramping version of the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary ramping_version_summary = 6;
   */
  rampingVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary.
 * Use `create(ListWorkerDeploymentsResponse_WorkerDeploymentSummarySchema)` to create a new message.
 */
export const ListWorkerDeploymentsResponse_WorkerDeploymentSummarySchema: GenMessage<ListWorkerDeploymentsResponse_WorkerDeploymentSummary> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 153, 0);

/**
 * Used for manual deletion of Versions. User can delete a Version only when all the
 * following conditions are met:
 *  - It is not the Current or Ramping Version of its Deployment.
 *  - It has no active pollers (none of the task queues in the Version have pollers)
 *  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
 *    can be skipped by passing `skip-drainage=true`.
 *
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionRequest
 */
export type DeleteWorkerDeploymentVersionRequest = Message<"temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 5;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Pass to force deletion even if the Version is draining. In this case the open pinned
   * workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
   *
   * @generated from field: bool skip_drainage = 3;
   */
  skipDrainage: boolean;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 4;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionRequest.
 * Use `create(DeleteWorkerDeploymentVersionRequestSchema)` to create a new message.
 */
export const DeleteWorkerDeploymentVersionRequestSchema: GenMessage<DeleteWorkerDeploymentVersionRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 154);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionResponse
 */
export type DeleteWorkerDeploymentVersionResponse = Message<"temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionResponse.
 * Use `create(DeleteWorkerDeploymentVersionResponseSchema)` to create a new message.
 */
export const DeleteWorkerDeploymentVersionResponseSchema: GenMessage<DeleteWorkerDeploymentVersionResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 155);

/**
 * Deletes records of (an old) Deployment. A deployment can only be deleted if
 * it has no Version in it.
 *
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentRequest
 */
export type DeleteWorkerDeploymentRequest = Message<"temporal.api.workflowservice.v1.DeleteWorkerDeploymentRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName: string;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkerDeploymentRequest.
 * Use `create(DeleteWorkerDeploymentRequestSchema)` to create a new message.
 */
export const DeleteWorkerDeploymentRequestSchema: GenMessage<DeleteWorkerDeploymentRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 156);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentResponse
 */
export type DeleteWorkerDeploymentResponse = Message<"temporal.api.workflowservice.v1.DeleteWorkerDeploymentResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkerDeploymentResponse.
 * Use `create(DeleteWorkerDeploymentResponseSchema)` to create a new message.
 */
export const DeleteWorkerDeploymentResponseSchema: GenMessage<DeleteWorkerDeploymentResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 157);

/**
 * Used to update the user-defined metadata of a Worker Deployment Version.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataRequest
 */
export type UpdateWorkerDeploymentVersionMetadataRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 5;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> upsert_entries = 3;
   */
  upsertEntries: { [key: string]: Payload };

  /**
   * List of keys to remove from the metadata.
   *
   * @generated from field: repeated string remove_entries = 4;
   */
  removeEntries: string[];

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataRequest.
 * Use `create(UpdateWorkerDeploymentVersionMetadataRequestSchema)` to create a new message.
 */
export const UpdateWorkerDeploymentVersionMetadataRequestSchema: GenMessage<UpdateWorkerDeploymentVersionMetadataRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 158);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataResponse
 */
export type UpdateWorkerDeploymentVersionMetadataResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataResponse"> & {
  /**
   * Full metadata after performing the update.
   *
   * @generated from field: temporal.api.deployment.v1.VersionMetadata metadata = 1;
   */
  metadata?: VersionMetadata;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataResponse.
 * Use `create(UpdateWorkerDeploymentVersionMetadataResponseSchema)` to create a new message.
 */
export const UpdateWorkerDeploymentVersionMetadataResponseSchema: GenMessage<UpdateWorkerDeploymentVersionMetadataResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 159);

/**
 * Update the ManagerIdentity of a Worker Deployment.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest
 */
export type SetWorkerDeploymentManagerRequest = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName: string;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest.new_manager_identity
   */
  newManagerIdentity: {
    /**
     * Arbitrary value for `manager_identity`.
     * Empty will unset the field.
     *
     * @generated from field: string manager_identity = 3;
     */
    value: string;
    case: "managerIdentity";
  } | {
    /**
     * True will set `manager_identity` to `identity`.
     *
     * @generated from field: bool self = 4;
     */
    value: boolean;
    case: "self";
  } | { case: undefined; value?: undefined };

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken: Uint8Array;

  /**
   * Required. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest.
 * Use `create(SetWorkerDeploymentManagerRequestSchema)` to create a new message.
 */
export const SetWorkerDeploymentManagerRequestSchema: GenMessage<SetWorkerDeploymentManagerRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 160);

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerResponse
 */
export type SetWorkerDeploymentManagerResponse = Message<"temporal.api.workflowservice.v1.SetWorkerDeploymentManagerResponse"> & {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken: Uint8Array;

  /**
   * What the `manager_identity` field was before this change.
   *
   * @generated from field: string previous_manager_identity = 2;
   */
  previousManagerIdentity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerResponse.
 * Use `create(SetWorkerDeploymentManagerResponseSchema)` to create a new message.
 */
export const SetWorkerDeploymentManagerResponseSchema: GenMessage<SetWorkerDeploymentManagerResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 161);

/**
 * Returns the Current Deployment of a deployment series.
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetCurrentDeploymentRequest
 */
export type GetCurrentDeploymentRequest = Message<"temporal.api.workflowservice.v1.GetCurrentDeploymentRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string series_name = 2;
   */
  seriesName: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetCurrentDeploymentRequest.
 * Use `create(GetCurrentDeploymentRequestSchema)` to create a new message.
 */
export const GetCurrentDeploymentRequestSchema: GenMessage<GetCurrentDeploymentRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 162);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetCurrentDeploymentResponse
 */
export type GetCurrentDeploymentResponse = Message<"temporal.api.workflowservice.v1.GetCurrentDeploymentResponse"> & {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo current_deployment_info = 1;
   */
  currentDeploymentInfo?: DeploymentInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetCurrentDeploymentResponse.
 * Use `create(GetCurrentDeploymentResponseSchema)` to create a new message.
 */
export const GetCurrentDeploymentResponseSchema: GenMessage<GetCurrentDeploymentResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 163);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetDeploymentReachabilityRequest
 */
export type GetDeploymentReachabilityRequest = Message<"temporal.api.workflowservice.v1.GetDeploymentReachabilityRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetDeploymentReachabilityRequest.
 * Use `create(GetDeploymentReachabilityRequestSchema)` to create a new message.
 */
export const GetDeploymentReachabilityRequestSchema: GenMessage<GetDeploymentReachabilityRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 164);

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetDeploymentReachabilityResponse
 */
export type GetDeploymentReachabilityResponse = Message<"temporal.api.workflowservice.v1.GetDeploymentReachabilityResponse"> & {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo deployment_info = 1;
   */
  deploymentInfo?: DeploymentInfo;

  /**
   * @generated from field: temporal.api.enums.v1.DeploymentReachability reachability = 2;
   */
  reachability: DeploymentReachability;

  /**
   * Reachability level might come from server cache. This timestamp specifies when the value
   * was actually calculated.
   *
   * @generated from field: google.protobuf.Timestamp last_update_time = 3;
   */
  lastUpdateTime?: Timestamp;
};

/**
 * Describes the message temporal.api.workflowservice.v1.GetDeploymentReachabilityResponse.
 * Use `create(GetDeploymentReachabilityResponseSchema)` to create a new message.
 */
export const GetDeploymentReachabilityResponseSchema: GenMessage<GetDeploymentReachabilityResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 165);

/**
 * @generated from message temporal.api.workflowservice.v1.CreateWorkflowRuleRequest
 */
export type CreateWorkflowRuleRequest = Message<"temporal.api.workflowservice.v1.CreateWorkflowRuleRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The rule specification .
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 2;
   */
  spec?: WorkflowRuleSpec;

  /**
   * If true, the rule will be applied to the currently running workflows via batch job.
   * If not set , the rule will only be applied when triggering condition is satisfied.
   * visibility_query in the rule will be used to select the workflows to apply the rule to.
   *
   * @generated from field: bool force_scan = 3;
   */
  forceScan: boolean;

  /**
   * Used to de-dupe requests. Typically should be UUID.
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;

  /**
   * Identity of the actor who created the rule. Will be stored with the rule.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * Rule description.Will be stored with the rule.
   *
   * @generated from field: string description = 6;
   */
  description: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CreateWorkflowRuleRequest.
 * Use `create(CreateWorkflowRuleRequestSchema)` to create a new message.
 */
export const CreateWorkflowRuleRequestSchema: GenMessage<CreateWorkflowRuleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 166);

/**
 * @generated from message temporal.api.workflowservice.v1.CreateWorkflowRuleResponse
 */
export type CreateWorkflowRuleResponse = Message<"temporal.api.workflowservice.v1.CreateWorkflowRuleResponse"> & {
  /**
   * Created rule.
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRule rule = 1;
   */
  rule?: WorkflowRule;

  /**
   * Batch Job ID if force-scan flag was provided. Otherwise empty.
   *
   * @generated from field: string job_id = 2;
   */
  jobId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.CreateWorkflowRuleResponse.
 * Use `create(CreateWorkflowRuleResponseSchema)` to create a new message.
 */
export const CreateWorkflowRuleResponseSchema: GenMessage<CreateWorkflowRuleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 167);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowRuleRequest
 */
export type DescribeWorkflowRuleRequest = Message<"temporal.api.workflowservice.v1.DescribeWorkflowRuleRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * User-specified ID of the rule to read. Unique within the namespace.
   *
   * @generated from field: string rule_id = 2;
   */
  ruleId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkflowRuleRequest.
 * Use `create(DescribeWorkflowRuleRequestSchema)` to create a new message.
 */
export const DescribeWorkflowRuleRequestSchema: GenMessage<DescribeWorkflowRuleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 168);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowRuleResponse
 */
export type DescribeWorkflowRuleResponse = Message<"temporal.api.workflowservice.v1.DescribeWorkflowRuleResponse"> & {
  /**
   * The rule that was read.
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRule rule = 1;
   */
  rule?: WorkflowRule;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkflowRuleResponse.
 * Use `create(DescribeWorkflowRuleResponseSchema)` to create a new message.
 */
export const DescribeWorkflowRuleResponseSchema: GenMessage<DescribeWorkflowRuleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 169);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowRuleRequest
 */
export type DeleteWorkflowRuleRequest = Message<"temporal.api.workflowservice.v1.DeleteWorkflowRuleRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * ID of the rule to delete. Unique within the namespace.
   *
   * @generated from field: string rule_id = 2;
   */
  ruleId: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkflowRuleRequest.
 * Use `create(DeleteWorkflowRuleRequestSchema)` to create a new message.
 */
export const DeleteWorkflowRuleRequestSchema: GenMessage<DeleteWorkflowRuleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 170);

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowRuleResponse
 */
export type DeleteWorkflowRuleResponse = Message<"temporal.api.workflowservice.v1.DeleteWorkflowRuleResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.DeleteWorkflowRuleResponse.
 * Use `create(DeleteWorkflowRuleResponseSchema)` to create a new message.
 */
export const DeleteWorkflowRuleResponseSchema: GenMessage<DeleteWorkflowRuleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 171);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowRulesRequest
 */
export type ListWorkflowRulesRequest = Message<"temporal.api.workflowservice.v1.ListWorkflowRulesRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkflowRulesRequest.
 * Use `create(ListWorkflowRulesRequestSchema)` to create a new message.
 */
export const ListWorkflowRulesRequestSchema: GenMessage<ListWorkflowRulesRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 172);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowRulesResponse
 */
export type ListWorkflowRulesResponse = Message<"temporal.api.workflowservice.v1.ListWorkflowRulesResponse"> & {
  /**
   * @generated from field: repeated temporal.api.rules.v1.WorkflowRule rules = 1;
   */
  rules: WorkflowRule[];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkflowRulesResponse.
 * Use `create(ListWorkflowRulesResponseSchema)` to create a new message.
 */
export const ListWorkflowRulesResponseSchema: GenMessage<ListWorkflowRulesResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 173);

/**
 * @generated from message temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest
 */
export type TriggerWorkflowRuleRequest = Message<"temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * Either provide id of existing rule, or rule specification
   *
   * @generated from oneof temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest.rule
   */
  rule: {
    /**
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Note: Rule ID and expiration date are not used in the trigger request.
     *
     * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 5;
     */
    value: WorkflowRuleSpec;
    case: "spec";
  } | { case: undefined; value?: undefined };

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 3;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest.
 * Use `create(TriggerWorkflowRuleRequestSchema)` to create a new message.
 */
export const TriggerWorkflowRuleRequestSchema: GenMessage<TriggerWorkflowRuleRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 174);

/**
 * @generated from message temporal.api.workflowservice.v1.TriggerWorkflowRuleResponse
 */
export type TriggerWorkflowRuleResponse = Message<"temporal.api.workflowservice.v1.TriggerWorkflowRuleResponse"> & {
  /**
   * True is the rule was applied, based on the rule conditions (predicate/visibility_query).
   *
   * @generated from field: bool applied = 1;
   */
  applied: boolean;
};

/**
 * Describes the message temporal.api.workflowservice.v1.TriggerWorkflowRuleResponse.
 * Use `create(TriggerWorkflowRuleResponseSchema)` to create a new message.
 */
export const TriggerWorkflowRuleResponseSchema: GenMessage<TriggerWorkflowRuleResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 175);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordWorkerHeartbeatRequest
 */
export type RecordWorkerHeartbeatRequest = Message<"temporal.api.workflowservice.v1.RecordWorkerHeartbeatRequest"> & {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * @generated from field: repeated temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 3;
   */
  workerHeartbeat: WorkerHeartbeat[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordWorkerHeartbeatRequest.
 * Use `create(RecordWorkerHeartbeatRequestSchema)` to create a new message.
 */
export const RecordWorkerHeartbeatRequestSchema: GenMessage<RecordWorkerHeartbeatRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 176);

/**
 * @generated from message temporal.api.workflowservice.v1.RecordWorkerHeartbeatResponse
 */
export type RecordWorkerHeartbeatResponse = Message<"temporal.api.workflowservice.v1.RecordWorkerHeartbeatResponse"> & {
};

/**
 * Describes the message temporal.api.workflowservice.v1.RecordWorkerHeartbeatResponse.
 * Use `create(RecordWorkerHeartbeatResponseSchema)` to create a new message.
 */
export const RecordWorkerHeartbeatResponseSchema: GenMessage<RecordWorkerHeartbeatResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 177);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkersRequest
 */
export type ListWorkersRequest = Message<"temporal.api.workflowservice.v1.ListWorkersRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken: Uint8Array;

  /**
   * `query` in ListWorkers is used to filter workers based on worker status info.
   * The following worker status attributes are expected are supported as part of the query:
   * * WorkerInstanceKey
   * * WorkerIdentity
   * * HostName
   * * TaskQueue
   * * DeploymentName
   * * BuildId
   * * SdkName
   * * SdkVersion
   * * StartTime
   * * LastHeartbeatTime
   * * Status
   * Currently metrics are not supported as a part of ListWorkers query.
   *
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkersRequest.
 * Use `create(ListWorkersRequestSchema)` to create a new message.
 */
export const ListWorkersRequestSchema: GenMessage<ListWorkersRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 178);

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkersResponse
 */
export type ListWorkersResponse = Message<"temporal.api.workflowservice.v1.ListWorkersResponse"> & {
  /**
   * @generated from field: repeated temporal.api.worker.v1.WorkerInfo workers_info = 1;
   */
  workersInfo: WorkerInfo[];

  /**
   * Next page token
   *
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken: Uint8Array;
};

/**
 * Describes the message temporal.api.workflowservice.v1.ListWorkersResponse.
 * Use `create(ListWorkersResponseSchema)` to create a new message.
 */
export const ListWorkersResponseSchema: GenMessage<ListWorkersResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 179);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest
 */
export type UpdateTaskQueueConfigRequest = Message<"temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest"> & {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * Selects the task queue to update.
   *
   * @generated from field: string task_queue = 3;
   */
  taskQueue: string;

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType task_queue_type = 4;
   */
  taskQueueType: TaskQueueType;

  /**
   * Update to queue-wide rate limit.
   * If not set, this configuration is unchanged.
   * NOTE: A limit set by the worker is overriden; and restored again when reset.
   * If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
   *
   * @generated from field: temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate update_queue_rate_limit = 5;
   */
  updateQueueRateLimit?: UpdateTaskQueueConfigRequest_RateLimitUpdate;

  /**
   * Update to the default fairness key rate limit.
   * If not set, this configuration is unchanged.
   * If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
   *
   * @generated from field: temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate update_fairness_key_rate_limit_default = 6;
   */
  updateFairnessKeyRateLimitDefault?: UpdateTaskQueueConfigRequest_RateLimitUpdate;

  /**
   * If set, overrides the fairness weight for each specified fairness key.
   * Fairness keys not listed in this map will keep their existing overrides (if any).
   *
   * @generated from field: map<string, float> set_fairness_weight_overrides = 7;
   */
  setFairnessWeightOverrides: { [key: string]: number };

  /**
   * If set, removes any existing fairness weight overrides for each specified fairness key.
   * Fairness weights for corresponding keys fall back to the values set during task creation (if any),
   * or to the default weight of 1.0.
   *
   * @generated from field: repeated string unset_fairness_weight_overrides = 8;
   */
  unsetFairnessWeightOverrides: string[];
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.
 * Use `create(UpdateTaskQueueConfigRequestSchema)` to create a new message.
 */
export const UpdateTaskQueueConfigRequestSchema: GenMessage<UpdateTaskQueueConfigRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 180);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate
 */
export type UpdateTaskQueueConfigRequest_RateLimitUpdate = Message<"temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate"> & {
  /**
   * Rate Limit to be updated
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimit rate_limit = 1;
   */
  rateLimit?: RateLimit;

  /**
   * Reason for why the rate limit was set.
   *
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate.
 * Use `create(UpdateTaskQueueConfigRequest_RateLimitUpdateSchema)` to create a new message.
 */
export const UpdateTaskQueueConfigRequest_RateLimitUpdateSchema: GenMessage<UpdateTaskQueueConfigRequest_RateLimitUpdate> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 180, 0);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigResponse
 */
export type UpdateTaskQueueConfigResponse = Message<"temporal.api.workflowservice.v1.UpdateTaskQueueConfigResponse"> & {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueConfig config = 1;
   */
  config?: TaskQueueConfig;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateTaskQueueConfigResponse.
 * Use `create(UpdateTaskQueueConfigResponseSchema)` to create a new message.
 */
export const UpdateTaskQueueConfigResponseSchema: GenMessage<UpdateTaskQueueConfigResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 181);

/**
 * @generated from message temporal.api.workflowservice.v1.FetchWorkerConfigRequest
 */
export type FetchWorkerConfigRequest = Message<"temporal.api.workflowservice.v1.FetchWorkerConfigRequest"> & {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * Reason for sending worker command, can be used for audit purpose.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * Defines which workers should receive this command.
   * only single worker is supported at this time.
   *
   * @generated from field: temporal.api.common.v1.WorkerSelector selector = 6;
   */
  selector?: WorkerSelector;
};

/**
 * Describes the message temporal.api.workflowservice.v1.FetchWorkerConfigRequest.
 * Use `create(FetchWorkerConfigRequestSchema)` to create a new message.
 */
export const FetchWorkerConfigRequestSchema: GenMessage<FetchWorkerConfigRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 182);

/**
 * @generated from message temporal.api.workflowservice.v1.FetchWorkerConfigResponse
 */
export type FetchWorkerConfigResponse = Message<"temporal.api.workflowservice.v1.FetchWorkerConfigResponse"> & {
  /**
   * The worker configuration.
   *
   * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 1;
   */
  workerConfig?: WorkerConfig;
};

/**
 * Describes the message temporal.api.workflowservice.v1.FetchWorkerConfigResponse.
 * Use `create(FetchWorkerConfigResponseSchema)` to create a new message.
 */
export const FetchWorkerConfigResponseSchema: GenMessage<FetchWorkerConfigResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 183);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerConfigRequest
 */
export type UpdateWorkerConfigRequest = Message<"temporal.api.workflowservice.v1.UpdateWorkerConfigRequest"> & {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * Reason for sending worker command, can be used for audit purpose.
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * Partial updates are accepted and controlled by update_mask.
   * The worker configuration to set.
   *
   * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 4;
   */
  workerConfig?: WorkerConfig;

  /**
   * Controls which fields from `worker_config` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;

  /**
   * Defines which workers should receive this command.
   *
   * @generated from field: temporal.api.common.v1.WorkerSelector selector = 6;
   */
  selector?: WorkerSelector;
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerConfigRequest.
 * Use `create(UpdateWorkerConfigRequestSchema)` to create a new message.
 */
export const UpdateWorkerConfigRequestSchema: GenMessage<UpdateWorkerConfigRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 184);

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerConfigResponse
 */
export type UpdateWorkerConfigResponse = Message<"temporal.api.workflowservice.v1.UpdateWorkerConfigResponse"> & {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerConfigResponse.response
   */
  response: {
    /**
     * The worker configuration. Will be returned if the command was sent to a single worker.
     *
     * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 1;
     */
    value: WorkerConfig;
    case: "workerConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.workflowservice.v1.UpdateWorkerConfigResponse.
 * Use `create(UpdateWorkerConfigResponseSchema)` to create a new message.
 */
export const UpdateWorkerConfigResponseSchema: GenMessage<UpdateWorkerConfigResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 185);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerRequest
 */
export type DescribeWorkerRequest = Message<"temporal.api.workflowservice.v1.DescribeWorkerRequest"> & {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Worker instance key to describe.
   *
   * @generated from field: string worker_instance_key = 2;
   */
  workerInstanceKey: string;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerRequest.
 * Use `create(DescribeWorkerRequestSchema)` to create a new message.
 */
export const DescribeWorkerRequestSchema: GenMessage<DescribeWorkerRequest> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 186);

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerResponse
 */
export type DescribeWorkerResponse = Message<"temporal.api.workflowservice.v1.DescribeWorkerResponse"> & {
  /**
   * @generated from field: temporal.api.worker.v1.WorkerInfo worker_info = 1;
   */
  workerInfo?: WorkerInfo;
};

/**
 * Describes the message temporal.api.workflowservice.v1.DescribeWorkerResponse.
 * Use `create(DescribeWorkerResponseSchema)` to create a new message.
 */
export const DescribeWorkerResponseSchema: GenMessage<DescribeWorkerResponse> = /*@__PURE__*/
  messageDesc(file_temporal_api_workflowservice_v1_request_response, 187);

