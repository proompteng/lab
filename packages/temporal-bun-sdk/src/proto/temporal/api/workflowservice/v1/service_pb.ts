// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/workflowservice/v1/service.proto (package temporal.api.workflowservice.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { CountWorkflowExecutionsRequestSchema, CountWorkflowExecutionsResponseSchema, CreateScheduleRequestSchema, CreateScheduleResponseSchema, CreateWorkflowRuleRequestSchema, CreateWorkflowRuleResponseSchema, DeleteScheduleRequestSchema, DeleteScheduleResponseSchema, DeleteWorkerDeploymentRequestSchema, DeleteWorkerDeploymentResponseSchema, DeleteWorkerDeploymentVersionRequestSchema, DeleteWorkerDeploymentVersionResponseSchema, DeleteWorkflowExecutionRequestSchema, DeleteWorkflowExecutionResponseSchema, DeleteWorkflowRuleRequestSchema, DeleteWorkflowRuleResponseSchema, DeprecateNamespaceRequestSchema, DeprecateNamespaceResponseSchema, DescribeBatchOperationRequestSchema, DescribeBatchOperationResponseSchema, DescribeDeploymentRequestSchema, DescribeDeploymentResponseSchema, DescribeNamespaceRequestSchema, DescribeNamespaceResponseSchema, DescribeScheduleRequestSchema, DescribeScheduleResponseSchema, DescribeTaskQueueRequestSchema, DescribeTaskQueueResponseSchema, DescribeWorkerDeploymentRequestSchema, DescribeWorkerDeploymentResponseSchema, DescribeWorkerDeploymentVersionRequestSchema, DescribeWorkerDeploymentVersionResponseSchema, DescribeWorkerRequestSchema, DescribeWorkerResponseSchema, DescribeWorkflowExecutionRequestSchema, DescribeWorkflowExecutionResponseSchema, DescribeWorkflowRuleRequestSchema, DescribeWorkflowRuleResponseSchema, ExecuteMultiOperationRequestSchema, ExecuteMultiOperationResponseSchema, FetchWorkerConfigRequestSchema, FetchWorkerConfigResponseSchema, GetClusterInfoRequestSchema, GetClusterInfoResponseSchema, GetCurrentDeploymentRequestSchema, GetCurrentDeploymentResponseSchema, GetDeploymentReachabilityRequestSchema, GetDeploymentReachabilityResponseSchema, GetSearchAttributesRequestSchema, GetSearchAttributesResponseSchema, GetSystemInfoRequestSchema, GetSystemInfoResponseSchema, GetWorkerBuildIdCompatibilityRequestSchema, GetWorkerBuildIdCompatibilityResponseSchema, GetWorkerTaskReachabilityRequestSchema, GetWorkerTaskReachabilityResponseSchema, GetWorkerVersioningRulesRequestSchema, GetWorkerVersioningRulesResponseSchema, GetWorkflowExecutionHistoryRequestSchema, GetWorkflowExecutionHistoryResponseSchema, GetWorkflowExecutionHistoryReverseRequestSchema, GetWorkflowExecutionHistoryReverseResponseSchema, ListArchivedWorkflowExecutionsRequestSchema, ListArchivedWorkflowExecutionsResponseSchema, ListBatchOperationsRequestSchema, ListBatchOperationsResponseSchema, ListClosedWorkflowExecutionsRequestSchema, ListClosedWorkflowExecutionsResponseSchema, ListDeploymentsRequestSchema, ListDeploymentsResponseSchema, ListNamespacesRequestSchema, ListNamespacesResponseSchema, ListOpenWorkflowExecutionsRequestSchema, ListOpenWorkflowExecutionsResponseSchema, ListScheduleMatchingTimesRequestSchema, ListScheduleMatchingTimesResponseSchema, ListSchedulesRequestSchema, ListSchedulesResponseSchema, ListTaskQueuePartitionsRequestSchema, ListTaskQueuePartitionsResponseSchema, ListWorkerDeploymentsRequestSchema, ListWorkerDeploymentsResponseSchema, ListWorkersRequestSchema, ListWorkersResponseSchema, ListWorkflowExecutionsRequestSchema, ListWorkflowExecutionsResponseSchema, ListWorkflowRulesRequestSchema, ListWorkflowRulesResponseSchema, PatchScheduleRequestSchema, PatchScheduleResponseSchema, PauseActivityRequestSchema, PauseActivityResponseSchema, PollActivityTaskQueueRequestSchema, PollActivityTaskQueueResponseSchema, PollNexusTaskQueueRequestSchema, PollNexusTaskQueueResponseSchema, PollWorkflowExecutionUpdateRequestSchema, PollWorkflowExecutionUpdateResponseSchema, PollWorkflowTaskQueueRequestSchema, PollWorkflowTaskQueueResponseSchema, QueryWorkflowRequestSchema, QueryWorkflowResponseSchema, RecordActivityTaskHeartbeatByIdRequestSchema, RecordActivityTaskHeartbeatByIdResponseSchema, RecordActivityTaskHeartbeatRequestSchema, RecordActivityTaskHeartbeatResponseSchema, RecordWorkerHeartbeatRequestSchema, RecordWorkerHeartbeatResponseSchema, RegisterNamespaceRequestSchema, RegisterNamespaceResponseSchema, RequestCancelWorkflowExecutionRequestSchema, RequestCancelWorkflowExecutionResponseSchema, ResetActivityRequestSchema, ResetActivityResponseSchema, ResetStickyTaskQueueRequestSchema, ResetStickyTaskQueueResponseSchema, ResetWorkflowExecutionRequestSchema, ResetWorkflowExecutionResponseSchema, RespondActivityTaskCanceledByIdRequestSchema, RespondActivityTaskCanceledByIdResponseSchema, RespondActivityTaskCanceledRequestSchema, RespondActivityTaskCanceledResponseSchema, RespondActivityTaskCompletedByIdRequestSchema, RespondActivityTaskCompletedByIdResponseSchema, RespondActivityTaskCompletedRequestSchema, RespondActivityTaskCompletedResponseSchema, RespondActivityTaskFailedByIdRequestSchema, RespondActivityTaskFailedByIdResponseSchema, RespondActivityTaskFailedRequestSchema, RespondActivityTaskFailedResponseSchema, RespondNexusTaskCompletedRequestSchema, RespondNexusTaskCompletedResponseSchema, RespondNexusTaskFailedRequestSchema, RespondNexusTaskFailedResponseSchema, RespondQueryTaskCompletedRequestSchema, RespondQueryTaskCompletedResponseSchema, RespondWorkflowTaskCompletedRequestSchema, RespondWorkflowTaskCompletedResponseSchema, RespondWorkflowTaskFailedRequestSchema, RespondWorkflowTaskFailedResponseSchema, ScanWorkflowExecutionsRequestSchema, ScanWorkflowExecutionsResponseSchema, SetCurrentDeploymentRequestSchema, SetCurrentDeploymentResponseSchema, SetWorkerDeploymentCurrentVersionRequestSchema, SetWorkerDeploymentCurrentVersionResponseSchema, SetWorkerDeploymentManagerRequestSchema, SetWorkerDeploymentManagerResponseSchema, SetWorkerDeploymentRampingVersionRequestSchema, SetWorkerDeploymentRampingVersionResponseSchema, ShutdownWorkerRequestSchema, ShutdownWorkerResponseSchema, SignalWithStartWorkflowExecutionRequestSchema, SignalWithStartWorkflowExecutionResponseSchema, SignalWorkflowExecutionRequestSchema, SignalWorkflowExecutionResponseSchema, StartBatchOperationRequestSchema, StartBatchOperationResponseSchema, StartWorkflowExecutionRequestSchema, StartWorkflowExecutionResponseSchema, StopBatchOperationRequestSchema, StopBatchOperationResponseSchema, TerminateWorkflowExecutionRequestSchema, TerminateWorkflowExecutionResponseSchema, TriggerWorkflowRuleRequestSchema, TriggerWorkflowRuleResponseSchema, UnpauseActivityRequestSchema, UnpauseActivityResponseSchema, UpdateActivityOptionsRequestSchema, UpdateActivityOptionsResponseSchema, UpdateNamespaceRequestSchema, UpdateNamespaceResponseSchema, UpdateScheduleRequestSchema, UpdateScheduleResponseSchema, UpdateTaskQueueConfigRequestSchema, UpdateTaskQueueConfigResponseSchema, UpdateWorkerBuildIdCompatibilityRequestSchema, UpdateWorkerBuildIdCompatibilityResponseSchema, UpdateWorkerConfigRequestSchema, UpdateWorkerConfigResponseSchema, UpdateWorkerDeploymentVersionMetadataRequestSchema, UpdateWorkerDeploymentVersionMetadataResponseSchema, UpdateWorkerVersioningRulesRequestSchema, UpdateWorkerVersioningRulesResponseSchema, UpdateWorkflowExecutionOptionsRequestSchema, UpdateWorkflowExecutionOptionsResponseSchema, UpdateWorkflowExecutionRequestSchema, UpdateWorkflowExecutionResponseSchema } from "./request_response_pb.js";
import { file_temporal_api_workflowservice_v1_request_response } from "./request_response_pb.js";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb.js";

/**
 * Describes the file temporal/api/workflowservice/v1/service.proto.
 */
export const file_temporal_api_workflowservice_v1_service: GenFile = /*@__PURE__*/
  fileDesc("Ci10ZW1wb3JhbC9hcGkvd29ya2Zsb3dzZXJ2aWNlL3YxL3NlcnZpY2UucHJvdG8SH3RlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEy+8EBCg9Xb3JrZmxvd1NlcnZpY2USwwEKEVJlZ2lzdGVyTmFtZXNwYWNlEjkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZWdpc3Rlck5hbWVzcGFjZVJlcXVlc3QaOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlZ2lzdGVyTmFtZXNwYWNlUmVzcG9uc2UiN4LT5JMCMToBKloXOgEqIhIvYXBpL3YxL25hbWVzcGFjZXMiEy9jbHVzdGVyL25hbWVzcGFjZXMS1QEKEURlc2NyaWJlTmFtZXNwYWNlEjkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZU5hbWVzcGFjZVJlcXVlc3QaOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlTmFtZXNwYWNlUmVzcG9uc2UiSYLT5JMCQ1ogEh4vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0SHy9jbHVzdGVyL25hbWVzcGFjZXMve25hbWVzcGFjZX0StAEKDkxpc3ROYW1lc3BhY2VzEjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0TmFtZXNwYWNlc1JlcXVlc3QaNy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3ROYW1lc3BhY2VzUmVzcG9uc2UiMYLT5JMCK1oUEhIvYXBpL3YxL25hbWVzcGFjZXMSEy9jbHVzdGVyL25hbWVzcGFjZXMS4wEKD1VwZGF0ZU5hbWVzcGFjZRI3LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlTmFtZXNwYWNlUmVxdWVzdBo4LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlTmFtZXNwYWNlUmVzcG9uc2UiXYLT5JMCVzoBKloqOgEqIiUvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vdXBkYXRlIiYvY2x1c3Rlci9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3VwZGF0ZRKPAQoSRGVwcmVjYXRlTmFtZXNwYWNlEjoudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXByZWNhdGVOYW1lc3BhY2VSZXF1ZXN0GjsudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXByZWNhdGVOYW1lc3BhY2VSZXNwb25zZSIAEpICChZTdGFydFdvcmtmbG93RXhlY3V0aW9uEj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TdGFydFdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU3RhcnRXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIneC0+STAnE6ASpaOzoBKiI2L2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97d29ya2Zsb3dfaWR9Ii8vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2lkfRKlAgoVRXhlY3V0ZU11bHRpT3BlcmF0aW9uEj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5FeGVjdXRlTXVsdGlPcGVyYXRpb25SZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5FeGVjdXRlTXVsdGlPcGVyYXRpb25SZXNwb25zZSKMAYLT5JMChQE6ASpaRToBKiJAL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy9leGVjdXRlLW11bHRpLW9wZXJhdGlvbiI5L25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL2V4ZWN1dGUtbXVsdGktb3BlcmF0aW9uEsECChtHZXRXb3JrZmxvd0V4ZWN1dGlvbkhpc3RvcnkSQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldFdvcmtmbG93RXhlY3V0aW9uSGlzdG9yeVJlcXVlc3QaRC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldFdvcmtmbG93RXhlY3V0aW9uSGlzdG9yeVJlc3BvbnNlIpYBgtPkkwKPAVpKEkgvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3tleGVjdXRpb24ud29ya2Zsb3dfaWR9L2hpc3RvcnkSQS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97ZXhlY3V0aW9uLndvcmtmbG93X2lkfS9oaXN0b3J5EuYCCiJHZXRXb3JrZmxvd0V4ZWN1dGlvbkhpc3RvcnlSZXZlcnNlEkoudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRXb3JrZmxvd0V4ZWN1dGlvbkhpc3RvcnlSZXZlcnNlUmVxdWVzdBpLLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0V29ya2Zsb3dFeGVjdXRpb25IaXN0b3J5UmV2ZXJzZVJlc3BvbnNlIqYBgtPkkwKfAVpSElAvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3tleGVjdXRpb24ud29ya2Zsb3dfaWR9L2hpc3RvcnktcmV2ZXJzZRJJL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3tleGVjdXRpb24ud29ya2Zsb3dfaWR9L2hpc3RvcnktcmV2ZXJzZRKYAQoVUG9sbFdvcmtmbG93VGFza1F1ZXVlEj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsV29ya2Zsb3dUYXNrUXVldWVSZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsV29ya2Zsb3dUYXNrUXVldWVSZXNwb25zZSIAEq0BChxSZXNwb25kV29ya2Zsb3dUYXNrQ29tcGxldGVkEkQudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kV29ya2Zsb3dUYXNrQ29tcGxldGVkUmVxdWVzdBpFLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZFdvcmtmbG93VGFza0NvbXBsZXRlZFJlc3BvbnNlIgASpAEKGVJlc3BvbmRXb3JrZmxvd1Rhc2tGYWlsZWQSQS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRXb3JrZmxvd1Rhc2tGYWlsZWRSZXF1ZXN0GkIudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kV29ya2Zsb3dUYXNrRmFpbGVkUmVzcG9uc2UiABKYAQoVUG9sbEFjdGl2aXR5VGFza1F1ZXVlEj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsQWN0aXZpdHlUYXNrUXVldWVSZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Qb2xsQWN0aXZpdHlUYXNrUXVldWVSZXNwb25zZSIAEpsCChtSZWNvcmRBY3Rpdml0eVRhc2tIZWFydGJlYXQSQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlY29yZEFjdGl2aXR5VGFza0hlYXJ0YmVhdFJlcXVlc3QaRC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlY29yZEFjdGl2aXR5VGFza0hlYXJ0YmVhdFJlc3BvbnNlInGC0+STAms6ASpaODoBKiIzL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvaGVhcnRiZWF0IiwvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2hlYXJ0YmVhdBKzAgofUmVjb3JkQWN0aXZpdHlUYXNrSGVhcnRiZWF0QnlJZBJHLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVjb3JkQWN0aXZpdHlUYXNrSGVhcnRiZWF0QnlJZFJlcXVlc3QaSC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlY29yZEFjdGl2aXR5VGFza0hlYXJ0YmVhdEJ5SWRSZXNwb25zZSJ9gtPkkwJ3OgEqWj46ASoiOS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2hlYXJ0YmVhdC1ieS1pZCIyL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9oZWFydGJlYXQtYnktaWQSnAIKHFJlc3BvbmRBY3Rpdml0eVRhc2tDb21wbGV0ZWQSRC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRBY3Rpdml0eVRhc2tDb21wbGV0ZWRSZXF1ZXN0GkUudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kQWN0aXZpdHlUYXNrQ29tcGxldGVkUmVzcG9uc2Uib4LT5JMCaToBKlo3OgEqIjIvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9jb21wbGV0ZSIrL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9jb21wbGV0ZRK0AgogUmVzcG9uZEFjdGl2aXR5VGFza0NvbXBsZXRlZEJ5SWQSSC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRBY3Rpdml0eVRhc2tDb21wbGV0ZWRCeUlkUmVxdWVzdBpJLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZEFjdGl2aXR5VGFza0NvbXBsZXRlZEJ5SWRSZXNwb25zZSJ7gtPkkwJ1OgEqWj06ASoiOC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2NvbXBsZXRlLWJ5LWlkIjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2NvbXBsZXRlLWJ5LWlkEosCChlSZXNwb25kQWN0aXZpdHlUYXNrRmFpbGVkEkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kQWN0aXZpdHlUYXNrRmFpbGVkUmVxdWVzdBpCLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZEFjdGl2aXR5VGFza0ZhaWxlZFJlc3BvbnNlImeC0+STAmE6ASpaMzoBKiIuL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvZmFpbCInL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9mYWlsEqMCCh1SZXNwb25kQWN0aXZpdHlUYXNrRmFpbGVkQnlJZBJFLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZEFjdGl2aXR5VGFza0ZhaWxlZEJ5SWRSZXF1ZXN0GkYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kQWN0aXZpdHlUYXNrRmFpbGVkQnlJZFJlc3BvbnNlInOC0+STAm06ASpaOToBKiI0L2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvZmFpbC1ieS1pZCItL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9mYWlsLWJ5LWlkEpUCChtSZXNwb25kQWN0aXZpdHlUYXNrQ2FuY2VsZWQSQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZFJlcXVlc3QaRC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZFJlc3BvbnNlImuC0+STAmU6ASpaNToBKiIwL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvY2FuY2VsIikvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2NhbmNlbBKtAgofUmVzcG9uZEFjdGl2aXR5VGFza0NhbmNlbGVkQnlJZBJHLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZEFjdGl2aXR5VGFza0NhbmNlbGVkQnlJZFJlcXVlc3QaSC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRBY3Rpdml0eVRhc2tDYW5jZWxlZEJ5SWRSZXNwb25zZSJ3gtPkkwJxOgEqWjs6ASoiNi9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL2NhbmNlbC1ieS1pZCIvL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9jYW5jZWwtYnktaWQS4AIKHlJlcXVlc3RDYW5jZWxXb3JrZmxvd0V4ZWN1dGlvbhJGLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVxdWVzdENhbmNlbFdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBpHLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVxdWVzdENhbmNlbFdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2UirAGC0+STAqUBOgEqWlU6ASoiUC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vY2FuY2VsIkkvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vY2FuY2VsEucCChdTaWduYWxXb3JrZmxvd0V4ZWN1dGlvbhI/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU2lnbmFsV29ya2Zsb3dFeGVjdXRpb25SZXF1ZXN0GkAudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TaWduYWxXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIsgBgtPkkwLBAToBKlpjOgEqIl4vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3t3b3JrZmxvd19leGVjdXRpb24ud29ya2Zsb3dfaWR9L3NpZ25hbC97c2lnbmFsX25hbWV9IlcvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vc2lnbmFsL3tzaWduYWxfbmFtZX0S8gIKIFNpZ25hbFdpdGhTdGFydFdvcmtmbG93RXhlY3V0aW9uEkgudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TaWduYWxXaXRoU3RhcnRXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3QaSS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlNpZ25hbFdpdGhTdGFydFdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2UiuAGC0+STArEBOgEqWls6ASoiVi9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9zaWduYWwtd2l0aC1zdGFydC97c2lnbmFsX25hbWV9Ik8vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2lkfS9zaWduYWwtd2l0aC1zdGFydC97c2lnbmFsX25hbWV9EsYCChZSZXNldFdvcmtmbG93RXhlY3V0aW9uEj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNldFdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzZXRXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIqoBgtPkkwKjAToBKlpUOgEqIk8vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3t3b3JrZmxvd19leGVjdXRpb24ud29ya2Zsb3dfaWR9L3Jlc2V0IkgvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vcmVzZXQS2gIKGlRlcm1pbmF0ZVdvcmtmbG93RXhlY3V0aW9uEkIudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5UZXJtaW5hdGVXb3JrZmxvd0V4ZWN1dGlvblJlcXVlc3QaQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlRlcm1pbmF0ZVdvcmtmbG93RXhlY3V0aW9uUmVzcG9uc2UisgGC0+STAqsBOgEqWlg6ASoiUy9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vdGVybWluYXRlIkwvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve3dvcmtmbG93X2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vdGVybWluYXRlEp4BChdEZWxldGVXb3JrZmxvd0V4ZWN1dGlvbhI/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVsZXRlV29ya2Zsb3dFeGVjdXRpb25SZXF1ZXN0GkAudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZWxldGVXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIgASpwEKGkxpc3RPcGVuV29ya2Zsb3dFeGVjdXRpb25zEkIudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0T3BlbldvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QaQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RPcGVuV29ya2Zsb3dFeGVjdXRpb25zUmVzcG9uc2UiABKtAQocTGlzdENsb3NlZFdvcmtmbG93RXhlY3V0aW9ucxJELnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuTGlzdENsb3NlZFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QaRS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RDbG9zZWRXb3JrZmxvd0V4ZWN1dGlvbnNSZXNwb25zZSIAEvABChZMaXN0V29ya2Zsb3dFeGVjdXRpb25zEj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0V29ya2Zsb3dFeGVjdXRpb25zUmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuTGlzdFdvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlIlWC0+STAk9aKhIoL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cxIhL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzEpoCCh5MaXN0QXJjaGl2ZWRXb3JrZmxvd0V4ZWN1dGlvbnMSRi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RBcmNoaXZlZFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QaRy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RBcmNoaXZlZFdvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlImeC0+STAmFaMxIxL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FyY2hpdmVkLXdvcmtmbG93cxIqL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYXJjaGl2ZWQtd29ya2Zsb3dzEpsBChZTY2FuV29ya2Zsb3dFeGVjdXRpb25zEj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TY2FuV29ya2Zsb3dFeGVjdXRpb25zUmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU2NhbldvcmtmbG93RXhlY3V0aW9uc1Jlc3BvbnNlIgAS/QEKF0NvdW50V29ya2Zsb3dFeGVjdXRpb25zEj8udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5Db3VudFdvcmtmbG93RXhlY3V0aW9uc1JlcXVlc3QaQC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkNvdW50V29ya2Zsb3dFeGVjdXRpb25zUmVzcG9uc2UiX4LT5JMCWVovEi0vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3ctY291bnQSJi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93LWNvdW50EpIBChNHZXRTZWFyY2hBdHRyaWJ1dGVzEjsudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRTZWFyY2hBdHRyaWJ1dGVzUmVxdWVzdBo8LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0U2VhcmNoQXR0cmlidXRlc1Jlc3BvbnNlIgASpAEKGVJlc3BvbmRRdWVyeVRhc2tDb21wbGV0ZWQSQS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmRRdWVyeVRhc2tDb21wbGV0ZWRSZXF1ZXN0GkIudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kUXVlcnlUYXNrQ29tcGxldGVkUmVzcG9uc2UiABKVAQoUUmVzZXRTdGlja3lUYXNrUXVldWUSPC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc2V0U3RpY2t5VGFza1F1ZXVlUmVxdWVzdBo9LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzZXRTdGlja3lUYXNrUXVldWVSZXNwb25zZSIAEoMBCg5TaHV0ZG93bldvcmtlchI2LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU2h1dGRvd25Xb3JrZXJSZXF1ZXN0GjcudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TaHV0ZG93bldvcmtlclJlc3BvbnNlIgASvwIKDVF1ZXJ5V29ya2Zsb3cSNS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlF1ZXJ5V29ya2Zsb3dSZXF1ZXN0GjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5RdWVyeVdvcmtmbG93UmVzcG9uc2UivgGC0+STArcBOgEqWl46ASoiWS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vcXVlcnkve3F1ZXJ5LnF1ZXJ5X3R5cGV9IlIvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve2V4ZWN1dGlvbi53b3JrZmxvd19pZH0vcXVlcnkve3F1ZXJ5LnF1ZXJ5X3R5cGV9EqoCChlEZXNjcmliZVdvcmtmbG93RXhlY3V0aW9uEkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBpCLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVzY3JpYmVXb3JrZmxvd0V4ZWN1dGlvblJlc3BvbnNlIoUBgtPkkwJ/WkISQC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvd3Mve2V4ZWN1dGlvbi53b3JrZmxvd19pZH0SOS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97ZXhlY3V0aW9uLndvcmtmbG93X2lkfRKJAgoRRGVzY3JpYmVUYXNrUXVldWUSOS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlVGFza1F1ZXVlUmVxdWVzdBo6LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVzY3JpYmVUYXNrUXVldWVSZXNwb25zZSJ9gtPkkwJ3Wj4SPC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS90YXNrLXF1ZXVlcy97dGFza19xdWV1ZS5uYW1lfRI1L25hbWVzcGFjZXMve25hbWVzcGFjZX0vdGFzay1xdWV1ZXMve3Rhc2tfcXVldWUubmFtZX0SqwEKDkdldENsdXN0ZXJJbmZvEjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRDbHVzdGVySW5mb1JlcXVlc3QaNy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldENsdXN0ZXJJbmZvUmVzcG9uc2UiKILT5JMCIloWEhQvYXBpL3YxL2NsdXN0ZXItaW5mbxIIL2NsdXN0ZXISqwEKDUdldFN5c3RlbUluZm8SNS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldFN5c3RlbUluZm9SZXF1ZXN0GjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRTeXN0ZW1JbmZvUmVzcG9uc2UiK4LT5JMCJVoVEhMvYXBpL3YxL3N5c3RlbS1pbmZvEgwvc3lzdGVtLWluZm8SngEKF0xpc3RUYXNrUXVldWVQYXJ0aXRpb25zEj8udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0VGFza1F1ZXVlUGFydGl0aW9uc1JlcXVlc3QaQC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RUYXNrUXVldWVQYXJ0aXRpb25zUmVzcG9uc2UiABL6AQoOQ3JlYXRlU2NoZWR1bGUSNi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkNyZWF0ZVNjaGVkdWxlUmVxdWVzdBo3LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuQ3JlYXRlU2NoZWR1bGVSZXNwb25zZSJ3gtPkkwJxOgEqWjs6ASoiNi9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9zY2hlZHVsZXMve3NjaGVkdWxlX2lkfSIvL25hbWVzcGFjZXMve25hbWVzcGFjZX0vc2NoZWR1bGVzL3tzY2hlZHVsZV9pZH0S+gEKEERlc2NyaWJlU2NoZWR1bGUSOC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlU2NoZWR1bGVSZXF1ZXN0GjkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVNjaGVkdWxlUmVzcG9uc2UicYLT5JMCa1o4EjYvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vc2NoZWR1bGVzL3tzY2hlZHVsZV9pZH0SLy9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcy97c2NoZWR1bGVfaWR9EokCCg5VcGRhdGVTY2hlZHVsZRI2LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlU2NoZWR1bGVSZXF1ZXN0GjcudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVTY2hlZHVsZVJlc3BvbnNlIoUBgtPkkwJ/OgEqWkI6ASoiPS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9zY2hlZHVsZXMve3NjaGVkdWxlX2lkfS91cGRhdGUiNi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcy97c2NoZWR1bGVfaWR9L3VwZGF0ZRKEAgoNUGF0Y2hTY2hlZHVsZRI1LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUGF0Y2hTY2hlZHVsZVJlcXVlc3QaNi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlBhdGNoU2NoZWR1bGVSZXNwb25zZSKDAYLT5JMCfToBKlpBOgEqIjwvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vc2NoZWR1bGVzL3tzY2hlZHVsZV9pZH0vcGF0Y2giNS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcy97c2NoZWR1bGVfaWR9L3BhdGNoErUCChlMaXN0U2NoZWR1bGVNYXRjaGluZ1RpbWVzEkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0U2NoZWR1bGVNYXRjaGluZ1RpbWVzUmVxdWVzdBpCLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuTGlzdFNjaGVkdWxlTWF0Y2hpbmdUaW1lc1Jlc3BvbnNlIpABgtPkkwKJAVpHEkUvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vc2NoZWR1bGVzL3tzY2hlZHVsZV9pZH0vbWF0Y2hpbmctdGltZXMSPi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcy97c2NoZWR1bGVfaWR9L21hdGNoaW5nLXRpbWVzEvQBCg5EZWxldGVTY2hlZHVsZRI2LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVsZXRlU2NoZWR1bGVSZXF1ZXN0GjcudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZWxldGVTY2hlZHVsZVJlc3BvbnNlInGC0+STAmtaOCo2L2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcy97c2NoZWR1bGVfaWR9Ki8vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9zY2hlZHVsZXMve3NjaGVkdWxlX2lkfRLVAQoNTGlzdFNjaGVkdWxlcxI1LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuTGlzdFNjaGVkdWxlc1JlcXVlc3QaNi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RTY2hlZHVsZXNSZXNwb25zZSJVgtPkkwJPWioSKC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9zY2hlZHVsZXMSIS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3NjaGVkdWxlcxK5AQogVXBkYXRlV29ya2VyQnVpbGRJZENvbXBhdGliaWxpdHkSSC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlckJ1aWxkSWRDb21wYXRpYmlsaXR5UmVxdWVzdBpJLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyQnVpbGRJZENvbXBhdGliaWxpdHlSZXNwb25zZSIAEuECCh1HZXRXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eRJFLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0V29ya2VyQnVpbGRJZENvbXBhdGliaWxpdHlSZXF1ZXN0GkYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRXb3JrZXJCdWlsZElkQ29tcGF0aWJpbGl0eVJlc3BvbnNlIrABgtPkkwKpAVpXElUvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vdGFzay1xdWV1ZXMve3Rhc2tfcXVldWV9L3dvcmtlci1idWlsZC1pZC1jb21wYXRpYmlsaXR5Ek4vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS90YXNrLXF1ZXVlcy97dGFza19xdWV1ZX0vd29ya2VyLWJ1aWxkLWlkLWNvbXBhdGliaWxpdHkSqgEKG1VwZGF0ZVdvcmtlclZlcnNpb25pbmdSdWxlcxJDLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyVmVyc2lvbmluZ1J1bGVzUmVxdWVzdBpELnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyVmVyc2lvbmluZ1J1bGVzUmVzcG9uc2UiABLGAgoYR2V0V29ya2VyVmVyc2lvbmluZ1J1bGVzEkAudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXF1ZXN0GkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRXb3JrZXJWZXJzaW9uaW5nUnVsZXNSZXNwb25zZSKkAYLT5JMCnQFaURJPL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3Rhc2stcXVldWVzL3t0YXNrX3F1ZXVlfS93b3JrZXItdmVyc2lvbmluZy1ydWxlcxJIL25hbWVzcGFjZXMve25hbWVzcGFjZX0vdGFzay1xdWV1ZXMve3Rhc2tfcXVldWV9L3dvcmtlci12ZXJzaW9uaW5nLXJ1bGVzEpcCChlHZXRXb3JrZXJUYXNrUmVhY2hhYmlsaXR5EkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5HZXRXb3JrZXJUYXNrUmVhY2hhYmlsaXR5UmVxdWVzdBpCLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0V29ya2VyVGFza1JlYWNoYWJpbGl0eVJlc3BvbnNlInOC0+STAm1aORI3L2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci10YXNrLXJlYWNoYWJpbGl0eRIwL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VyLXRhc2stcmVhY2hhYmlsaXR5EsgCChJEZXNjcmliZURlcGxveW1lbnQSOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlRGVwbG95bWVudFJlcXVlc3QaOy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlRGVwbG95bWVudFJlc3BvbnNlIrgBgtPkkwKxAVpbElkvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vZGVwbG95bWVudHMve2RlcGxveW1lbnQuc2VyaWVzX25hbWV9L3tkZXBsb3ltZW50LmJ1aWxkX2lkfRJSL25hbWVzcGFjZXMve25hbWVzcGFjZX0vZGVwbG95bWVudHMve2RlcGxveW1lbnQuc2VyaWVzX25hbWV9L3tkZXBsb3ltZW50LmJ1aWxkX2lkfRK1AwofRGVzY3JpYmVXb3JrZXJEZXBsb3ltZW50VmVyc2lvbhJHLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVzY3JpYmVXb3JrZXJEZXBsb3ltZW50VmVyc2lvblJlcXVlc3QaSC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlV29ya2VyRGVwbG95bWVudFZlcnNpb25SZXNwb25zZSL+AYLT5JMC9wFafhJ8L2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50LXZlcnNpb25zL3tkZXBsb3ltZW50X3ZlcnNpb24uZGVwbG95bWVudF9uYW1lfS97ZGVwbG95bWVudF92ZXJzaW9uLmJ1aWxkX2lkfRJ1L25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VyLWRlcGxveW1lbnQtdmVyc2lvbnMve2RlcGxveW1lbnRfdmVyc2lvbi5kZXBsb3ltZW50X25hbWV9L3tkZXBsb3ltZW50X3ZlcnNpb24uYnVpbGRfaWR9Et8BCg9MaXN0RGVwbG95bWVudHMSNy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3REZXBsb3ltZW50c1JlcXVlc3QaOC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3REZXBsb3ltZW50c1Jlc3BvbnNlIlmC0+STAlNaLBIqL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2RlcGxveW1lbnRzEiMvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9kZXBsb3ltZW50cxL3AgoZR2V0RGVwbG95bWVudFJlYWNoYWJpbGl0eRJBLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0RGVwbG95bWVudFJlYWNoYWJpbGl0eVJlcXVlc3QaQi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldERlcGxveW1lbnRSZWFjaGFiaWxpdHlSZXNwb25zZSLSAYLT5JMCywFaaBJmL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2RlcGxveW1lbnRzL3tkZXBsb3ltZW50LnNlcmllc19uYW1lfS97ZGVwbG95bWVudC5idWlsZF9pZH0vcmVhY2hhYmlsaXR5El8vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9kZXBsb3ltZW50cy97ZGVwbG95bWVudC5zZXJpZXNfbmFtZX0ve2RlcGxveW1lbnQuYnVpbGRfaWR9L3JlYWNoYWJpbGl0eRKZAgoUR2V0Q3VycmVudERlcGxveW1lbnQSPC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkdldEN1cnJlbnREZXBsb3ltZW50UmVxdWVzdBo9LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuR2V0Q3VycmVudERlcGxveW1lbnRSZXNwb25zZSKDAYLT5JMCfVpBEj8vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vY3VycmVudC1kZXBsb3ltZW50L3tzZXJpZXNfbmFtZX0SOC9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2N1cnJlbnQtZGVwbG95bWVudC97c2VyaWVzX25hbWV9ErYCChRTZXRDdXJyZW50RGVwbG95bWVudBI8LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU2V0Q3VycmVudERlcGxveW1lbnRSZXF1ZXN0Gj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRDdXJyZW50RGVwbG95bWVudFJlc3BvbnNlIqABgtPkkwKZAToBKlpPOgEqIkovYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vY3VycmVudC1kZXBsb3ltZW50L3tkZXBsb3ltZW50LnNlcmllc19uYW1lfSJDL25hbWVzcGFjZXMve25hbWVzcGFjZX0vY3VycmVudC1kZXBsb3ltZW50L3tkZXBsb3ltZW50LnNlcmllc19uYW1lfRL3AgohU2V0V29ya2VyRGVwbG95bWVudEN1cnJlbnRWZXJzaW9uEkkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRXb3JrZXJEZXBsb3ltZW50Q3VycmVudFZlcnNpb25SZXF1ZXN0GkoudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRXb3JrZXJEZXBsb3ltZW50Q3VycmVudFZlcnNpb25SZXNwb25zZSK6AYLT5JMCswE6ASpaXDoBKiJXL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50cy97ZGVwbG95bWVudF9uYW1lfS9zZXQtY3VycmVudC12ZXJzaW9uIlAvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudHMve2RlcGxveW1lbnRfbmFtZX0vc2V0LWN1cnJlbnQtdmVyc2lvbhKuAgoYRGVzY3JpYmVXb3JrZXJEZXBsb3ltZW50EkAudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtlckRlcGxveW1lbnRSZXF1ZXN0GkEudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtlckRlcGxveW1lbnRSZXNwb25zZSKMAYLT5JMChQFaRRJDL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50cy97ZGVwbG95bWVudF9uYW1lfRI8L25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VyLWRlcGxveW1lbnRzL3tkZXBsb3ltZW50X25hbWV9EqgCChZEZWxldGVXb3JrZXJEZXBsb3ltZW50Ej4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZWxldGVXb3JrZXJEZXBsb3ltZW50UmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVsZXRlV29ya2VyRGVwbG95bWVudFJlc3BvbnNlIowBgtPkkwKFAVpFKkMvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VyLWRlcGxveW1lbnRzL3tkZXBsb3ltZW50X25hbWV9KjwvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudHMve2RlcGxveW1lbnRfbmFtZX0SrwMKHURlbGV0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uEkUudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZWxldGVXb3JrZXJEZXBsb3ltZW50VmVyc2lvblJlcXVlc3QaRi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlbGV0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uUmVzcG9uc2Ui/gGC0+STAvcBWn4qfC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudC12ZXJzaW9ucy97ZGVwbG95bWVudF92ZXJzaW9uLmRlcGxveW1lbnRfbmFtZX0ve2RlcGxveW1lbnRfdmVyc2lvbi5idWlsZF9pZH0qdS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50LXZlcnNpb25zL3tkZXBsb3ltZW50X3ZlcnNpb24uZGVwbG95bWVudF9uYW1lfS97ZGVwbG95bWVudF92ZXJzaW9uLmJ1aWxkX2lkfRL3AgohU2V0V29ya2VyRGVwbG95bWVudFJhbXBpbmdWZXJzaW9uEkkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRXb3JrZXJEZXBsb3ltZW50UmFtcGluZ1ZlcnNpb25SZXF1ZXN0GkoudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRXb3JrZXJEZXBsb3ltZW50UmFtcGluZ1ZlcnNpb25SZXNwb25zZSK6AYLT5JMCswE6ASpaXDoBKiJXL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50cy97ZGVwbG95bWVudF9uYW1lfS9zZXQtcmFtcGluZy12ZXJzaW9uIlAvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudHMve2RlcGxveW1lbnRfbmFtZX0vc2V0LXJhbXBpbmctdmVyc2lvbhL/AQoVTGlzdFdvcmtlckRlcGxveW1lbnRzEj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0V29ya2VyRGVwbG95bWVudHNSZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0V29ya2VyRGVwbG95bWVudHNSZXNwb25zZSJngtPkkwJhWjMSMS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudHMSKi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50cxLwAwolVXBkYXRlV29ya2VyRGVwbG95bWVudFZlcnNpb25NZXRhZGF0YRJNLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyRGVwbG95bWVudFZlcnNpb25NZXRhZGF0YVJlcXVlc3QaTi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtlckRlcGxveW1lbnRWZXJzaW9uTWV0YWRhdGFSZXNwb25zZSKnAoLT5JMCoAI6ASpakgE6ASoijAEvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VyLWRlcGxveW1lbnQtdmVyc2lvbnMve2RlcGxveW1lbnRfdmVyc2lvbi5kZXBsb3ltZW50X25hbWV9L3tkZXBsb3ltZW50X3ZlcnNpb24uYnVpbGRfaWR9L3VwZGF0ZS1tZXRhZGF0YSKFAS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50LXZlcnNpb25zL3tkZXBsb3ltZW50X3ZlcnNpb24uZGVwbG95bWVudF9uYW1lfS97ZGVwbG95bWVudF92ZXJzaW9uLmJ1aWxkX2lkfS91cGRhdGUtbWV0YWRhdGES0gIKGlNldFdvcmtlckRlcGxveW1lbnRNYW5hZ2VyEkIudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5TZXRXb3JrZXJEZXBsb3ltZW50TWFuYWdlclJlcXVlc3QaQy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlNldFdvcmtlckRlcGxveW1lbnRNYW5hZ2VyUmVzcG9uc2UiqgGC0+STAqMBOgEqWlQ6ASoiTy9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXItZGVwbG95bWVudHMve2RlcGxveW1lbnRfbmFtZX0vc2V0LW1hbmFnZXIiSC9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtlci1kZXBsb3ltZW50cy97ZGVwbG95bWVudF9uYW1lfS9zZXQtbWFuYWdlchL1AgoXVXBkYXRlV29ya2Zsb3dFeGVjdXRpb24SPy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlVwZGF0ZVdvcmtmbG93RXhlY3V0aW9uUmVxdWVzdBpALnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25SZXNwb25zZSLWAYLT5JMCzwE6ASpaajoBKiJlL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97d29ya2Zsb3dfZXhlY3V0aW9uLndvcmtmbG93X2lkfS91cGRhdGUve3JlcXVlc3QuaW5wdXQubmFtZX0iXi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97d29ya2Zsb3dfZXhlY3V0aW9uLndvcmtmbG93X2lkfS91cGRhdGUve3JlcXVlc3QuaW5wdXQubmFtZX0SqgEKG1BvbGxXb3JrZmxvd0V4ZWN1dGlvblVwZGF0ZRJDLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUG9sbFdvcmtmbG93RXhlY3V0aW9uVXBkYXRlUmVxdWVzdBpELnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUG9sbFdvcmtmbG93RXhlY3V0aW9uVXBkYXRlUmVzcG9uc2UiABKNAgoTU3RhcnRCYXRjaE9wZXJhdGlvbhI7LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuU3RhcnRCYXRjaE9wZXJhdGlvblJlcXVlc3QaPC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlN0YXJ0QmF0Y2hPcGVyYXRpb25SZXNwb25zZSJ7gtPkkwJ1OgEqWj06ASoiOC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9iYXRjaC1vcGVyYXRpb25zL3tqb2JfaWR9IjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9iYXRjaC1vcGVyYXRpb25zL3tqb2JfaWR9EpUCChJTdG9wQmF0Y2hPcGVyYXRpb24SOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlN0b3BCYXRjaE9wZXJhdGlvblJlcXVlc3QaOy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlN0b3BCYXRjaE9wZXJhdGlvblJlc3BvbnNlIoUBgtPkkwJ/OgEqWkI6ASoiPS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9iYXRjaC1vcGVyYXRpb25zL3tqb2JfaWR9L3N0b3AiNi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2JhdGNoLW9wZXJhdGlvbnMve2pvYl9pZH0vc3RvcBKQAgoWRGVzY3JpYmVCYXRjaE9wZXJhdGlvbhI+LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVzY3JpYmVCYXRjaE9wZXJhdGlvblJlcXVlc3QaPy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlQmF0Y2hPcGVyYXRpb25SZXNwb25zZSJ1gtPkkwJvWjoSOC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9iYXRjaC1vcGVyYXRpb25zL3tqb2JfaWR9EjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9iYXRjaC1vcGVyYXRpb25zL3tqb2JfaWR9EvUBChNMaXN0QmF0Y2hPcGVyYXRpb25zEjsudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0QmF0Y2hPcGVyYXRpb25zUmVxdWVzdBo8LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuTGlzdEJhdGNoT3BlcmF0aW9uc1Jlc3BvbnNlImOC0+STAl1aMRIvL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2JhdGNoLW9wZXJhdGlvbnMSKC9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2JhdGNoLW9wZXJhdGlvbnMSjwEKElBvbGxOZXh1c1Rhc2tRdWV1ZRI6LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUG9sbE5leHVzVGFza1F1ZXVlUmVxdWVzdBo7LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUG9sbE5leHVzVGFza1F1ZXVlUmVzcG9uc2UiABKkAQoZUmVzcG9uZE5leHVzVGFza0NvbXBsZXRlZBJBLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZE5leHVzVGFza0NvbXBsZXRlZFJlcXVlc3QaQi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc3BvbmROZXh1c1Rhc2tDb21wbGV0ZWRSZXNwb25zZSIAEpsBChZSZXNwb25kTmV4dXNUYXNrRmFpbGVkEj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNwb25kTmV4dXNUYXNrRmFpbGVkUmVxdWVzdBo/LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUmVzcG9uZE5leHVzVGFza0ZhaWxlZFJlc3BvbnNlIgASkwIKFVVwZGF0ZUFjdGl2aXR5T3B0aW9ucxI9LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlQWN0aXZpdHlPcHRpb25zUmVxdWVzdBo+LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlQWN0aXZpdHlPcHRpb25zUmVzcG9uc2Uie4LT5JMCdToBKlo9OgEqIjgvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy91cGRhdGUtb3B0aW9ucyIxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy91cGRhdGUtb3B0aW9ucxLwAgoeVXBkYXRlV29ya2Zsb3dFeGVjdXRpb25PcHRpb25zEkYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVXb3JrZmxvd0V4ZWN1dGlvbk9wdGlvbnNSZXF1ZXN0GkcudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVXb3JrZmxvd0V4ZWN1dGlvbk9wdGlvbnNSZXNwb25zZSK8AYLT5JMCtQE6ASpaXToBKiJYL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93cy97d29ya2Zsb3dfZXhlY3V0aW9uLndvcmtmbG93X2lkfS91cGRhdGUtb3B0aW9ucyJRL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3t3b3JrZmxvd19leGVjdXRpb24ud29ya2Zsb3dfaWR9L3VwZGF0ZS1vcHRpb25zEukBCg1QYXVzZUFjdGl2aXR5EjUudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5QYXVzZUFjdGl2aXR5UmVxdWVzdBo2LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuUGF1c2VBY3Rpdml0eVJlc3BvbnNlImmC0+STAmM6ASpaNDoBKiIvL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvcGF1c2UiKC9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L2FjdGl2aXRpZXMvcGF1c2US8wEKD1VucGF1c2VBY3Rpdml0eRI3LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVW5wYXVzZUFjdGl2aXR5UmVxdWVzdBo4LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVW5wYXVzZUFjdGl2aXR5UmVzcG9uc2UibYLT5JMCZzoBKlo2OgEqIjEvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy91bnBhdXNlIiovbmFtZXNwYWNlcy97bmFtZXNwYWNlfS9hY3Rpdml0aWVzL3VucGF1c2US6QEKDVJlc2V0QWN0aXZpdHkSNS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLlJlc2V0QWN0aXZpdHlSZXF1ZXN0GjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZXNldEFjdGl2aXR5UmVzcG9uc2UiaYLT5JMCYzoBKlo0OgEqIi8vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9yZXNldCIoL25hbWVzcGFjZXMve25hbWVzcGFjZX0vYWN0aXZpdGllcy9yZXNldBL0AQoSQ3JlYXRlV29ya2Zsb3dSdWxlEjoudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5DcmVhdGVXb3JrZmxvd1J1bGVSZXF1ZXN0GjsudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5DcmVhdGVXb3JrZmxvd1J1bGVSZXNwb25zZSJlgtPkkwJfOgEqWjI6ASoiLS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvdy1ydWxlcyImL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3ctcnVsZXMSiAIKFERlc2NyaWJlV29ya2Zsb3dSdWxlEjwudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtmbG93UnVsZVJlcXVlc3QaPS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlV29ya2Zsb3dSdWxlUmVzcG9uc2Uic4LT5JMCbVo5EjcvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3ctcnVsZXMve3J1bGVfaWR9EjAvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvdy1ydWxlcy97cnVsZV9pZH0SggIKEkRlbGV0ZVdvcmtmbG93UnVsZRI6LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVsZXRlV29ya2Zsb3dSdWxlUmVxdWVzdBo7LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRGVsZXRlV29ya2Zsb3dSdWxlUmVzcG9uc2Uic4LT5JMCbVo5KjcvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3ctcnVsZXMve3J1bGVfaWR9KjAvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZmxvdy1ydWxlcy97cnVsZV9pZH0S6wEKEUxpc3RXb3JrZmxvd1J1bGVzEjkudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0V29ya2Zsb3dSdWxlc1JlcXVlc3QaOi50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RXb3JrZmxvd1J1bGVzUmVzcG9uc2UiX4LT5JMCWVovEi0vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3ctcnVsZXMSJi9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3dvcmtmbG93LXJ1bGVzErkCChNUcmlnZ2VyV29ya2Zsb3dSdWxlEjsudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5UcmlnZ2VyV29ya2Zsb3dSdWxlUmVxdWVzdBo8LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVHJpZ2dlcldvcmtmbG93UnVsZVJlc3BvbnNlIqYBgtPkkwKfAToBKlpSOgEqIk0vYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3tleGVjdXRpb24ud29ya2Zsb3dfaWR9L3RyaWdnZXItcnVsZSJGL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Zsb3dzL3tleGVjdXRpb24ud29ya2Zsb3dfaWR9L3RyaWdnZXItcnVsZRKDAgoVUmVjb3JkV29ya2VySGVhcnRiZWF0Ej0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZWNvcmRXb3JrZXJIZWFydGJlYXRSZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5SZWNvcmRXb3JrZXJIZWFydGJlYXRSZXNwb25zZSJrgtPkkwJlOgEqWjU6ASoiMC9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXJzL2hlYXJ0YmVhdCIpL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Vycy9oZWFydGJlYXQSywEKC0xpc3RXb3JrZXJzEjMudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5MaXN0V29ya2Vyc1JlcXVlc3QaNC50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkxpc3RXb3JrZXJzUmVzcG9uc2UiUYLT5JMCS1ooEiYvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VycxIfL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2VycxKvAgoVVXBkYXRlVGFza1F1ZXVlQ29uZmlnEj0udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVUYXNrUXVldWVDb25maWdSZXF1ZXN0Gj4udGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5VcGRhdGVUYXNrUXVldWVDb25maWdSZXNwb25zZSKWAYLT5JMCjwE6ASpaSjoBKiJFL2FwaS92MS9uYW1lc3BhY2VzL3tuYW1lc3BhY2V9L3Rhc2stcXVldWVzL3t0YXNrX3F1ZXVlfS91cGRhdGUtY29uZmlnIj4vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS90YXNrLXF1ZXVlcy97dGFza19xdWV1ZX0vdXBkYXRlLWNvbmZpZxL9AQoRRmV0Y2hXb3JrZXJDb25maWcSOS50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkZldGNoV29ya2VyQ29uZmlnUmVxdWVzdBo6LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuRmV0Y2hXb3JrZXJDb25maWdSZXNwb25zZSJxgtPkkwJrOgEqWjg6ASoiMy9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXJzL2ZldGNoLWNvbmZpZyIsL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Vycy9mZXRjaC1jb25maWcSggIKElVwZGF0ZVdvcmtlckNvbmZpZxI6LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyQ29uZmlnUmVxdWVzdBo7LnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjEuVXBkYXRlV29ya2VyQ29uZmlnUmVzcG9uc2Uic4LT5JMCbToBKlo5OgEqIjQvYXBpL3YxL25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Vycy91cGRhdGUtY29uZmlnIi0vbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXJzL3VwZGF0ZS1jb25maWcSlAIKDkRlc2NyaWJlV29ya2VyEjYudGVtcG9yYWwuYXBpLndvcmtmbG93c2VydmljZS52MS5EZXNjcmliZVdvcmtlclJlcXVlc3QaNy50ZW1wb3JhbC5hcGkud29ya2Zsb3dzZXJ2aWNlLnYxLkRlc2NyaWJlV29ya2VyUmVzcG9uc2UikAGC0+STAokBWkcSRS9hcGkvdjEvbmFtZXNwYWNlcy97bmFtZXNwYWNlfS93b3JrZXJzL2Rlc2NyaWJlL3t3b3JrZXJfaW5zdGFuY2Vfa2V5fRI+L25hbWVzcGFjZXMve25hbWVzcGFjZX0vd29ya2Vycy9kZXNjcmliZS97d29ya2VyX2luc3RhbmNlX2tleX1CtgEKImlvLnRlbXBvcmFsLmFwaS53b3JrZmxvd3NlcnZpY2UudjFCDFNlcnZpY2VQcm90b1ABWjVnby50ZW1wb3JhbC5pby9hcGkvd29ya2Zsb3dzZXJ2aWNlL3YxO3dvcmtmbG93c2VydmljZaoCIVRlbXBvcmFsaW8uQXBpLldvcmtmbG93U2VydmljZS5WMeoCJFRlbXBvcmFsaW86OkFwaTo6V29ya2Zsb3dTZXJ2aWNlOjpWMWIGcHJvdG8z", [file_temporal_api_workflowservice_v1_request_response, file_google_api_annotations]);

/**
 * WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
 * to create and interact with workflows and activities.
 *
 * Users are expected to call `StartWorkflowExecution` to create a new workflow execution.
 *
 * To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
 * and activity tasks from the service. For each workflow task, the sdk must process the
 * (incremental or complete) event history and respond back with any newly generated commands.
 *
 * For each activity task, the worker is expected to execute the user's code which implements that
 * activity, responding with completion or failure.
 *
 * @generated from service temporal.api.workflowservice.v1.WorkflowService
 */
export const WorkflowService: GenService<{
  /**
   * RegisterNamespace creates a new namespace which can be used as a container for all resources.
   *
   * A Namespace is a top level entity within Temporal, and is used as a container for resources
   * like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
   * isolation for all resources within the namespace. All resources belongs to exactly one
   * namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RegisterNamespace
   */
  registerNamespace: {
    methodKind: "unary";
    input: typeof RegisterNamespaceRequestSchema;
    output: typeof RegisterNamespaceResponseSchema;
  },
  /**
   * DescribeNamespace returns the information and configuration for a registered namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeNamespace
   */
  describeNamespace: {
    methodKind: "unary";
    input: typeof DescribeNamespaceRequestSchema;
    output: typeof DescribeNamespaceResponseSchema;
  },
  /**
   * ListNamespaces returns the information and configuration for all namespaces.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListNamespaces
   */
  listNamespaces: {
    methodKind: "unary";
    input: typeof ListNamespacesRequestSchema;
    output: typeof ListNamespacesResponseSchema;
  },
  /**
   * UpdateNamespace is used to update the information and configuration of a registered
   * namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateNamespace
   */
  updateNamespace: {
    methodKind: "unary";
    input: typeof UpdateNamespaceRequestSchema;
    output: typeof UpdateNamespaceResponseSchema;
  },
  /**
   * DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
   *
   * Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
   * workflow executions will continue to run on deprecated namespaces.
   * Deprecated.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: Deprecated --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeprecateNamespace
   */
  deprecateNamespace: {
    methodKind: "unary";
    input: typeof DeprecateNamespaceRequestSchema;
    output: typeof DeprecateNamespaceResponseSchema;
  },
  /**
   * StartWorkflowExecution starts a new workflow execution.
   *
   * It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
   * also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
   * instance already exists with same workflow id.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.StartWorkflowExecution
   */
  startWorkflowExecution: {
    methodKind: "unary";
    input: typeof StartWorkflowExecutionRequestSchema;
    output: typeof StartWorkflowExecutionResponseSchema;
  },
  /**
   * ExecuteMultiOperation executes multiple operations within a single workflow.
   *
   * Operations are started atomically, meaning if *any* operation fails to be started, none are,
   * and the request fails. Upon start, the API returns only when *all* operations have a response.
   *
   * Upon failure, it returns `MultiOperationExecutionFailure` where the status code
   * equals the status code of the *first* operation that failed to be started.
   *
   * NOTE: Experimental API.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ExecuteMultiOperation
   */
  executeMultiOperation: {
    methodKind: "unary";
    input: typeof ExecuteMultiOperationRequestSchema;
    output: typeof ExecuteMultiOperationResponseSchema;
  },
  /**
   * GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
   * `NotFound` if the specified workflow execution is unknown to the service.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetWorkflowExecutionHistory
   */
  getWorkflowExecutionHistory: {
    methodKind: "unary";
    input: typeof GetWorkflowExecutionHistoryRequestSchema;
    output: typeof GetWorkflowExecutionHistoryResponseSchema;
  },
  /**
   * GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
   * order (starting from last event). Fails with`NotFound` if the specified workflow execution is
   * unknown to the service.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetWorkflowExecutionHistoryReverse
   */
  getWorkflowExecutionHistoryReverse: {
    methodKind: "unary";
    input: typeof GetWorkflowExecutionHistoryReverseRequestSchema;
    output: typeof GetWorkflowExecutionHistoryReverseResponseSchema;
  },
  /**
   * PollWorkflowTaskQueue is called by workers to make progress on workflows.
   *
   * A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
   * tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
   * processing the task. The service will create a `WorkflowTaskStarted` event in the history for
   * this task before handing it to the worker.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PollWorkflowTaskQueue
   */
  pollWorkflowTaskQueue: {
    methodKind: "unary";
    input: typeof PollWorkflowTaskQueueRequestSchema;
    output: typeof PollWorkflowTaskQueueResponseSchema;
  },
  /**
   * RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
   * they received from `PollWorkflowTaskQueue`.
   *
   * Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
   * history, along with events corresponding to whatever commands the SDK generated while
   * executing the task (ex timer started, activity task scheduled, etc).
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondWorkflowTaskCompleted
   */
  respondWorkflowTaskCompleted: {
    methodKind: "unary";
    input: typeof RespondWorkflowTaskCompletedRequestSchema;
    output: typeof RespondWorkflowTaskCompletedResponseSchema;
  },
  /**
   * RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
   * failed.
   *
   * This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
   * task will be scheduled. This API can be used to report unhandled failures resulting from
   * applying the workflow task.
   *
   * Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
   * for consecutive failures.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondWorkflowTaskFailed
   */
  respondWorkflowTaskFailed: {
    methodKind: "unary";
    input: typeof RespondWorkflowTaskFailedRequestSchema;
    output: typeof RespondWorkflowTaskFailedResponseSchema;
  },
  /**
   * PollActivityTaskQueue is called by workers to process activity tasks from a specific task
   * queue.
   *
   * The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
   * processing the task.
   *
   * An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
   * workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
   * before the task is dispatched to the worker. The started event, and the final event
   * (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
   * written permanently to Workflow execution history when Activity is finished. This is done to
   * avoid writing many events in the case of a failure/retry loop.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PollActivityTaskQueue
   */
  pollActivityTaskQueue: {
    methodKind: "unary";
    input: typeof PollActivityTaskQueueRequestSchema;
    output: typeof PollActivityTaskQueueResponseSchema;
  },
  /**
   * RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
   *
   * If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
   * then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
   * the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
   * such situations, in that event, the SDK should request cancellation of the activity.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RecordActivityTaskHeartbeat
   */
  recordActivityTaskHeartbeat: {
    methodKind: "unary";
    input: typeof RecordActivityTaskHeartbeatRequestSchema;
    output: typeof RecordActivityTaskHeartbeatResponseSchema;
  },
  /**
   * See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
   * namespace/workflow id/activity id instead of task token.
   *
   * (-- api-linter: core::0136::prepositions=disabled
   *     aip.dev/not-precedent: "By" is used to indicate request type. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RecordActivityTaskHeartbeatById
   */
  recordActivityTaskHeartbeatById: {
    methodKind: "unary";
    input: typeof RecordActivityTaskHeartbeatByIdRequestSchema;
    output: typeof RecordActivityTaskHeartbeatByIdResponseSchema;
  },
  /**
   * RespondActivityTaskCompleted is called by workers when they successfully complete an activity
   * task.
   *
   * This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
   * and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   * no longer valid due to activity timeout, already being completed, or never having existed.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskCompleted
   */
  respondActivityTaskCompleted: {
    methodKind: "unary";
    input: typeof RespondActivityTaskCompletedRequestSchema;
    output: typeof RespondActivityTaskCompletedResponseSchema;
  },
  /**
   * See `RecordActivityTaskCompleted`. This version allows clients to record completions by
   * namespace/workflow id/activity id instead of task token.
   *
   * (-- api-linter: core::0136::prepositions=disabled
   *     aip.dev/not-precedent: "By" is used to indicate request type. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskCompletedById
   */
  respondActivityTaskCompletedById: {
    methodKind: "unary";
    input: typeof RespondActivityTaskCompletedByIdRequestSchema;
    output: typeof RespondActivityTaskCompletedByIdResponseSchema;
  },
  /**
   * RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   * This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
   * a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
   * longer valid due to activity timeout, already being completed, or never having existed.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskFailed
   */
  respondActivityTaskFailed: {
    methodKind: "unary";
    input: typeof RespondActivityTaskFailedRequestSchema;
    output: typeof RespondActivityTaskFailedResponseSchema;
  },
  /**
   * See `RecordActivityTaskFailed`. This version allows clients to record failures by
   * namespace/workflow id/activity id instead of task token.
   *
   * (-- api-linter: core::0136::prepositions=disabled
   *     aip.dev/not-precedent: "By" is used to indicate request type. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskFailedById
   */
  respondActivityTaskFailedById: {
    methodKind: "unary";
    input: typeof RespondActivityTaskFailedByIdRequestSchema;
    output: typeof RespondActivityTaskFailedByIdResponseSchema;
  },
  /**
   * RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   * This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
   * and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   * no longer valid due to activity timeout, already being completed, or never having existed.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskCanceled
   */
  respondActivityTaskCanceled: {
    methodKind: "unary";
    input: typeof RespondActivityTaskCanceledRequestSchema;
    output: typeof RespondActivityTaskCanceledResponseSchema;
  },
  /**
   * See `RecordActivityTaskCanceled`. This version allows clients to record failures by
   * namespace/workflow id/activity id instead of task token.
   *
   * (-- api-linter: core::0136::prepositions=disabled
   *     aip.dev/not-precedent: "By" is used to indicate request type. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondActivityTaskCanceledById
   */
  respondActivityTaskCanceledById: {
    methodKind: "unary";
    input: typeof RespondActivityTaskCanceledByIdRequestSchema;
    output: typeof RespondActivityTaskCanceledByIdResponseSchema;
  },
  /**
   * RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
   * a workflow execution.
   *
   * This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
   * workflow history and a new workflow task created for the workflow. It returns success if the requested
   * workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RequestCancelWorkflowExecution
   */
  requestCancelWorkflowExecution: {
    methodKind: "unary";
    input: typeof RequestCancelWorkflowExecutionRequestSchema;
    output: typeof RequestCancelWorkflowExecutionResponseSchema;
  },
  /**
   * SignalWorkflowExecution is used to send a signal to a running workflow execution.
   *
   * This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
   * task being created for the execution.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SignalWorkflowExecution
   */
  signalWorkflowExecution: {
    methodKind: "unary";
    input: typeof SignalWorkflowExecutionRequestSchema;
    output: typeof SignalWorkflowExecutionResponseSchema;
  },
  /**
   * SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
   * it isn't yet started.
   *
   * If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
   * and a workflow task is generated.
   *
   * If the workflow is not running or not found, then the workflow is created with
   * `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
   * workflow task is generated.
   *
   * (-- api-linter: core::0136::prepositions=disabled
   *     aip.dev/not-precedent: "With" is used to indicate combined operation. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SignalWithStartWorkflowExecution
   */
  signalWithStartWorkflowExecution: {
    methodKind: "unary";
    input: typeof SignalWithStartWorkflowExecutionRequestSchema;
    output: typeof SignalWithStartWorkflowExecutionResponseSchema;
  },
  /**
   * ResetWorkflowExecution will reset an existing workflow execution to a specified
   * `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
   * execution instance. "Exclusive" means the identified completed event itself is not replayed
   * in the reset history; the preceding `WORKFLOW_TASK_STARTED` event remains and will be marked as failed
   * immediately, and a new workflow task will be scheduled to retry it.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ResetWorkflowExecution
   */
  resetWorkflowExecution: {
    methodKind: "unary";
    input: typeof ResetWorkflowExecutionRequestSchema;
    output: typeof ResetWorkflowExecutionResponseSchema;
  },
  /**
   * TerminateWorkflowExecution terminates an existing workflow execution by recording a
   * `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
   * execution instance.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.TerminateWorkflowExecution
   */
  terminateWorkflowExecution: {
    methodKind: "unary";
    input: typeof TerminateWorkflowExecutionRequestSchema;
    output: typeof TerminateWorkflowExecutionResponseSchema;
  },
  /**
   * DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
   * WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
   * WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
   * terminated before deletion.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeleteWorkflowExecution
   */
  deleteWorkflowExecution: {
    methodKind: "unary";
    input: typeof DeleteWorkflowExecutionRequestSchema;
    output: typeof DeleteWorkflowExecutionResponseSchema;
  },
  /**
   * ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListOpenWorkflowExecutions
   */
  listOpenWorkflowExecutions: {
    methodKind: "unary";
    input: typeof ListOpenWorkflowExecutionsRequestSchema;
    output: typeof ListOpenWorkflowExecutionsResponseSchema;
  },
  /**
   * ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListClosedWorkflowExecutions
   */
  listClosedWorkflowExecutions: {
    methodKind: "unary";
    input: typeof ListClosedWorkflowExecutionsRequestSchema;
    output: typeof ListClosedWorkflowExecutionsResponseSchema;
  },
  /**
   * ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListWorkflowExecutions
   */
  listWorkflowExecutions: {
    methodKind: "unary";
    input: typeof ListWorkflowExecutionsRequestSchema;
    output: typeof ListWorkflowExecutionsResponseSchema;
  },
  /**
   * ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListArchivedWorkflowExecutions
   */
  listArchivedWorkflowExecutions: {
    methodKind: "unary";
    input: typeof ListArchivedWorkflowExecutionsRequestSchema;
    output: typeof ListArchivedWorkflowExecutionsResponseSchema;
  },
  /**
   * ScanWorkflowExecutions _was_ a visibility API to list large amount of workflow executions in a specific namespace without order.
   * It has since been deprecated in favor of `ListWorkflowExecutions` and rewritten to use `ListWorkflowExecutions` internally.
   *
   * Deprecated: Replaced with `ListWorkflowExecutions`.
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ScanWorkflowExecutions
   */
  scanWorkflowExecutions: {
    methodKind: "unary";
    input: typeof ScanWorkflowExecutionsRequestSchema;
    output: typeof ScanWorkflowExecutionsResponseSchema;
  },
  /**
   * CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.CountWorkflowExecutions
   */
  countWorkflowExecutions: {
    methodKind: "unary";
    input: typeof CountWorkflowExecutionsRequestSchema;
    output: typeof CountWorkflowExecutionsResponseSchema;
  },
  /**
   * GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetSearchAttributes
   */
  getSearchAttributes: {
    methodKind: "unary";
    input: typeof GetSearchAttributesRequestSchema;
    output: typeof GetSearchAttributesResponseSchema;
  },
  /**
   * RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
   * the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
   *
   * Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
   * the query result a response.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondQueryTaskCompleted
   */
  respondQueryTaskCompleted: {
    methodKind: "unary";
    input: typeof RespondQueryTaskCompletedRequestSchema;
    output: typeof RespondQueryTaskCompletedResponseSchema;
  },
  /**
   * ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
   * a given workflow. This is prudent for workers to perform if a workflow has been paged out of
   * their cache.
   *
   * Things cleared are:
   * 1. StickyTaskQueue
   * 2. StickyScheduleToStartTimeout
   *
   * When possible, ShutdownWorker should be preferred over
   * ResetStickyTaskQueue (particularly when a worker is shutting down or
   * cycling).
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ResetStickyTaskQueue
   */
  resetStickyTaskQueue: {
    methodKind: "unary";
    input: typeof ResetStickyTaskQueueRequestSchema;
    output: typeof ResetStickyTaskQueueResponseSchema;
  },
  /**
   * ShutdownWorker is used to indicate that the given sticky task
   * queue is no longer being polled by its worker. Following the completion of
   * ShutdownWorker, newly-added workflow tasks will instead be placed
   * in the normal task queue, eligible for any worker to pick up.
   *
   * ShutdownWorker should be called by workers while shutting down,
   * after they've shut down their pollers. If another sticky poll
   * request is issued, the sticky task queue will be revived.
   *
   * As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ShutdownWorker
   */
  shutdownWorker: {
    methodKind: "unary";
    input: typeof ShutdownWorkerRequestSchema;
    output: typeof ShutdownWorkerResponseSchema;
  },
  /**
   * QueryWorkflow requests a query be executed for a specified workflow execution.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.QueryWorkflow
   */
  queryWorkflow: {
    methodKind: "unary";
    input: typeof QueryWorkflowRequestSchema;
    output: typeof QueryWorkflowResponseSchema;
  },
  /**
   * DescribeWorkflowExecution returns information about the specified workflow execution.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeWorkflowExecution
   */
  describeWorkflowExecution: {
    methodKind: "unary";
    input: typeof DescribeWorkflowExecutionRequestSchema;
    output: typeof DescribeWorkflowExecutionResponseSchema;
  },
  /**
   * DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
   *   - List of pollers
   *   - Workflow Reachability status
   *   - Backlog info for Workflow and/or Activity tasks
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeTaskQueue
   */
  describeTaskQueue: {
    methodKind: "unary";
    input: typeof DescribeTaskQueueRequestSchema;
    output: typeof DescribeTaskQueueResponseSchema;
  },
  /**
   * GetClusterInfo returns information about temporal cluster
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetClusterInfo
   */
  getClusterInfo: {
    methodKind: "unary";
    input: typeof GetClusterInfoRequestSchema;
    output: typeof GetClusterInfoResponseSchema;
  },
  /**
   * GetSystemInfo returns information about the system.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetSystemInfo
   */
  getSystemInfo: {
    methodKind: "unary";
    input: typeof GetSystemInfoRequestSchema;
    output: typeof GetSystemInfoResponseSchema;
  },
  /**
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListTaskQueuePartitions
   */
  listTaskQueuePartitions: {
    methodKind: "unary";
    input: typeof ListTaskQueuePartitionsRequestSchema;
    output: typeof ListTaskQueuePartitionsResponseSchema;
  },
  /**
   * Creates a new schedule.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.CreateSchedule
   */
  createSchedule: {
    methodKind: "unary";
    input: typeof CreateScheduleRequestSchema;
    output: typeof CreateScheduleResponseSchema;
  },
  /**
   * Returns the schedule description and current state of an existing schedule.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeSchedule
   */
  describeSchedule: {
    methodKind: "unary";
    input: typeof DescribeScheduleRequestSchema;
    output: typeof DescribeScheduleResponseSchema;
  },
  /**
   * Changes the configuration or state of an existing schedule.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateSchedule
   */
  updateSchedule: {
    methodKind: "unary";
    input: typeof UpdateScheduleRequestSchema;
    output: typeof UpdateScheduleResponseSchema;
  },
  /**
   * Makes a specific change to a schedule or triggers an immediate action.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PatchSchedule
   */
  patchSchedule: {
    methodKind: "unary";
    input: typeof PatchScheduleRequestSchema;
    output: typeof PatchScheduleResponseSchema;
  },
  /**
   * Lists matching times within a range.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListScheduleMatchingTimes
   */
  listScheduleMatchingTimes: {
    methodKind: "unary";
    input: typeof ListScheduleMatchingTimesRequestSchema;
    output: typeof ListScheduleMatchingTimesResponseSchema;
  },
  /**
   * Deletes a schedule, removing it from the system.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeleteSchedule
   */
  deleteSchedule: {
    methodKind: "unary";
    input: typeof DeleteScheduleRequestSchema;
    output: typeof DeleteScheduleResponseSchema;
  },
  /**
   * List all schedules in a namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListSchedules
   */
  listSchedules: {
    methodKind: "unary";
    input: typeof ListSchedulesRequestSchema;
    output: typeof ListSchedulesResponseSchema;
  },
  /**
   * Deprecated. Use `UpdateWorkerVersioningRules`.
   *
   * Allows users to specify sets of worker build id versions on a per task queue basis. Versions
   * are ordered, and may be either compatible with some extant version, or a new incompatible
   * version, forming sets of ids which are incompatible with each other, but whose contained
   * members are compatible with one another.
   *
   * A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
   * multiple workers.
   *
   * To query which workers can be retired, use the `GetWorkerTaskReachability` API.
   *
   * NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
   * (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkerBuildIdCompatibility
   */
  updateWorkerBuildIdCompatibility: {
    methodKind: "unary";
    input: typeof UpdateWorkerBuildIdCompatibilityRequestSchema;
    output: typeof UpdateWorkerBuildIdCompatibilityResponseSchema;
  },
  /**
   * Deprecated. Use `GetWorkerVersioningRules`.
   * Fetches the worker build id versioning sets for a task queue.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetWorkerBuildIdCompatibility
   */
  getWorkerBuildIdCompatibility: {
    methodKind: "unary";
    input: typeof GetWorkerBuildIdCompatibilityRequestSchema;
    output: typeof GetWorkerBuildIdCompatibilityResponseSchema;
  },
  /**
   * Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
   * rules: Build ID Assignment rules and Compatible Build ID Redirect rules.
   *
   * Assignment rules determine how to assign new executions to a Build IDs. Their primary
   * use case is to specify the latest Build ID but they have powerful features for gradual rollout
   * of a new Build ID.
   *
   * Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
   * the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
   * eliminates the need for compatibility between versions when you only care about using the new
   * version for new workflows and let existing workflows finish in their own version.
   *
   * Activities, Child Workflows and Continue-as-New executions have the option to inherit the
   * Build ID of their parent/previous workflow or use the latest assignment rules to independently
   * select a Build ID.
   *
   * Redirect rules should only be used when you want to move workflows and activities assigned to
   * one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
   * the target Build ID of a redirect rule is able to process event histories made by the source
   * Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.
   *
   * WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkerVersioningRules
   */
  updateWorkerVersioningRules: {
    methodKind: "unary";
    input: typeof UpdateWorkerVersioningRulesRequestSchema;
    output: typeof UpdateWorkerVersioningRulesResponseSchema;
  },
  /**
   * Fetches the Build ID assignment and redirect rules for a Task Queue.
   * WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetWorkerVersioningRules
   */
  getWorkerVersioningRules: {
    methodKind: "unary";
    input: typeof GetWorkerVersioningRulesRequestSchema;
    output: typeof GetWorkerVersioningRulesResponseSchema;
  },
  /**
   * Deprecated. Use `DescribeTaskQueue`.
   *
   * Fetches task reachability to determine whether a worker may be retired.
   * The request may specify task queues to query for or let the server fetch all task queues mapped to the given
   * build IDs.
   *
   * When requesting a large number of task queues or all task queues associated with the given build ids in a
   * namespace, all task queues will be listed in the response but some of them may not contain reachability
   * information due to a server enforced limit. When reaching the limit, task queues that reachability information
   * could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
   * another call to get the reachability for those task queues.
   *
   * Open source users can adjust this limit by setting the server's dynamic config value for
   * `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetWorkerTaskReachability
   */
  getWorkerTaskReachability: {
    methodKind: "unary";
    input: typeof GetWorkerTaskReachabilityRequestSchema;
    output: typeof GetWorkerTaskReachabilityResponseSchema;
  },
  /**
   * Describes a worker deployment.
   * Experimental. This API might significantly change or be removed in a future release.
   * Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeDeployment
   */
  describeDeployment: {
    methodKind: "unary";
    input: typeof DescribeDeploymentRequestSchema;
    output: typeof DescribeDeploymentResponseSchema;
  },
  /**
   * Describes a worker deployment version.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeWorkerDeploymentVersion
   */
  describeWorkerDeploymentVersion: {
    methodKind: "unary";
    input: typeof DescribeWorkerDeploymentVersionRequestSchema;
    output: typeof DescribeWorkerDeploymentVersionResponseSchema;
  },
  /**
   * Lists worker deployments in the namespace. Optionally can filter based on deployment series
   * name.
   * Experimental. This API might significantly change or be removed in a future release.
   * Deprecated. Replaced with `ListWorkerDeployments`.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListDeployments
   */
  listDeployments: {
    methodKind: "unary";
    input: typeof ListDeploymentsRequestSchema;
    output: typeof ListDeploymentsResponseSchema;
  },
  /**
   * Returns the reachability level of a worker deployment to help users decide when it is time
   * to decommission a deployment. Reachability level is calculated based on the deployment's
   * `status` and existing workflows that depend on the given deployment for their execution.
   * Calculating reachability is relatively expensive. Therefore, server might return a recently
   * cached value. In such a case, the `last_update_time` will inform you about the actual
   * reachability calculation time.
   * Experimental. This API might significantly change or be removed in a future release.
   * Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetDeploymentReachability
   */
  getDeploymentReachability: {
    methodKind: "unary";
    input: typeof GetDeploymentReachabilityRequestSchema;
    output: typeof GetDeploymentReachabilityResponseSchema;
  },
  /**
   * Returns the current deployment (and its info) for a given deployment series.
   * Experimental. This API might significantly change or be removed in a future release.
   * Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.GetCurrentDeployment
   */
  getCurrentDeployment: {
    methodKind: "unary";
    input: typeof GetCurrentDeploymentRequestSchema;
    output: typeof GetCurrentDeploymentResponseSchema;
  },
  /**
   * Sets a deployment as the current deployment for its deployment series. Can optionally update
   * the metadata of the deployment as well.
   * Experimental. This API might significantly change or be removed in a future release.
   * Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SetCurrentDeployment
   */
  setCurrentDeployment: {
    methodKind: "unary";
    input: typeof SetCurrentDeploymentRequestSchema;
    output: typeof SetCurrentDeploymentResponseSchema;
  },
  /**
   * Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
   * Version if it is the Version being set as Current.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SetWorkerDeploymentCurrentVersion
   */
  setWorkerDeploymentCurrentVersion: {
    methodKind: "unary";
    input: typeof SetWorkerDeploymentCurrentVersionRequestSchema;
    output: typeof SetWorkerDeploymentCurrentVersionResponseSchema;
  },
  /**
   * Describes a Worker Deployment.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeWorkerDeployment
   */
  describeWorkerDeployment: {
    methodKind: "unary";
    input: typeof DescribeWorkerDeploymentRequestSchema;
    output: typeof DescribeWorkerDeploymentResponseSchema;
  },
  /**
   * Deletes records of (an old) Deployment. A deployment can only be deleted if
   * it has no Version in it.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeleteWorkerDeployment
   */
  deleteWorkerDeployment: {
    methodKind: "unary";
    input: typeof DeleteWorkerDeploymentRequestSchema;
    output: typeof DeleteWorkerDeploymentResponseSchema;
  },
  /**
   * Used for manual deletion of Versions. User can delete a Version only when all the
   * following conditions are met:
   *  - It is not the Current or Ramping Version of its Deployment.
   *  - It has no active pollers (none of the task queues in the Version have pollers)
   *  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
   *    can be skipped by passing `skip-drainage=true`.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeleteWorkerDeploymentVersion
   */
  deleteWorkerDeploymentVersion: {
    methodKind: "unary";
    input: typeof DeleteWorkerDeploymentVersionRequestSchema;
    output: typeof DeleteWorkerDeploymentVersionResponseSchema;
  },
  /**
   * Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
   * gradual ramp to unversioned workers too.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SetWorkerDeploymentRampingVersion
   */
  setWorkerDeploymentRampingVersion: {
    methodKind: "unary";
    input: typeof SetWorkerDeploymentRampingVersionRequestSchema;
    output: typeof SetWorkerDeploymentRampingVersionResponseSchema;
  },
  /**
   * Lists all Worker Deployments that are tracked in the Namespace.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListWorkerDeployments
   */
  listWorkerDeployments: {
    methodKind: "unary";
    input: typeof ListWorkerDeploymentsRequestSchema;
    output: typeof ListWorkerDeploymentsResponseSchema;
  },
  /**
   * Updates the user-given metadata attached to a Worker Deployment Version.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkerDeploymentVersionMetadata
   */
  updateWorkerDeploymentVersionMetadata: {
    methodKind: "unary";
    input: typeof UpdateWorkerDeploymentVersionMetadataRequestSchema;
    output: typeof UpdateWorkerDeploymentVersionMetadataResponseSchema;
  },
  /**
   * Set/unset the ManagerIdentity of a Worker Deployment.
   * Experimental. This API might significantly change or be removed in a future release.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.SetWorkerDeploymentManager
   */
  setWorkerDeploymentManager: {
    methodKind: "unary";
    input: typeof SetWorkerDeploymentManagerRequestSchema;
    output: typeof SetWorkerDeploymentManagerResponseSchema;
  },
  /**
   * Invokes the specified Update function on user Workflow code.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkflowExecution
   */
  updateWorkflowExecution: {
    methodKind: "unary";
    input: typeof UpdateWorkflowExecutionRequestSchema;
    output: typeof UpdateWorkflowExecutionResponseSchema;
  },
  /**
   * Polls a Workflow Execution for the outcome of a Workflow Update
   * previously issued through the UpdateWorkflowExecution RPC. The effective
   * timeout on this call will be shorter of the the caller-supplied gRPC
   * timeout and the server's configured long-poll timeout.
   *
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PollWorkflowExecutionUpdate
   */
  pollWorkflowExecutionUpdate: {
    methodKind: "unary";
    input: typeof PollWorkflowExecutionUpdateRequestSchema;
    output: typeof PollWorkflowExecutionUpdateResponseSchema;
  },
  /**
   * StartBatchOperation starts a new batch operation
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.StartBatchOperation
   */
  startBatchOperation: {
    methodKind: "unary";
    input: typeof StartBatchOperationRequestSchema;
    output: typeof StartBatchOperationResponseSchema;
  },
  /**
   * StopBatchOperation stops a batch operation
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.StopBatchOperation
   */
  stopBatchOperation: {
    methodKind: "unary";
    input: typeof StopBatchOperationRequestSchema;
    output: typeof StopBatchOperationResponseSchema;
  },
  /**
   * DescribeBatchOperation returns the information about a batch operation
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeBatchOperation
   */
  describeBatchOperation: {
    methodKind: "unary";
    input: typeof DescribeBatchOperationRequestSchema;
    output: typeof DescribeBatchOperationResponseSchema;
  },
  /**
   * ListBatchOperations returns a list of batch operations
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListBatchOperations
   */
  listBatchOperations: {
    methodKind: "unary";
    input: typeof ListBatchOperationsRequestSchema;
    output: typeof ListBatchOperationsResponseSchema;
  },
  /**
   * PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PollNexusTaskQueue
   */
  pollNexusTaskQueue: {
    methodKind: "unary";
    input: typeof PollNexusTaskQueueRequestSchema;
    output: typeof PollNexusTaskQueueResponseSchema;
  },
  /**
   * RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondNexusTaskCompleted
   */
  respondNexusTaskCompleted: {
    methodKind: "unary";
    input: typeof RespondNexusTaskCompletedRequestSchema;
    output: typeof RespondNexusTaskCompletedResponseSchema;
  },
  /**
   * RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
   * (-- api-linter: core::0127::http-annotation=disabled
   *     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RespondNexusTaskFailed
   */
  respondNexusTaskFailed: {
    methodKind: "unary";
    input: typeof RespondNexusTaskFailedRequestSchema;
    output: typeof RespondNexusTaskFailedResponseSchema;
  },
  /**
   * UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
   * If there are multiple pending activities of the provided type - all of them will be updated.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateActivityOptions
   */
  updateActivityOptions: {
    methodKind: "unary";
    input: typeof UpdateActivityOptionsRequestSchema;
    output: typeof UpdateActivityOptionsResponseSchema;
  },
  /**
   * UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkflowExecutionOptions
   */
  updateWorkflowExecutionOptions: {
    methodKind: "unary";
    input: typeof UpdateWorkflowExecutionOptionsRequestSchema;
    output: typeof UpdateWorkflowExecutionOptionsResponseSchema;
  },
  /**
   * PauseActivity pauses the execution of an activity specified by its ID or type.
   * If there are multiple pending activities of the provided type - all of them will be paused
   *
   * Pausing an activity means:
   * - If the activity is currently waiting for a retry or is running and subsequently fails,
   *   it will not be rescheduled until it is unpaused.
   * - If the activity is already paused, calling this method will have no effect.
   * - If the activity is running and finishes successfully, the activity will be completed.
   * - If the activity is running and finishes with failure:
   *   * if there is no retry left - the activity will be completed.
   *   * if there are more retries left - the activity will be paused.
   * For long-running activities:
   * - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
   * - The activity should respond to the cancellation accordingly.
   *
   * Returns a `NotFound` error if there is no pending activity with the provided ID or type
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.PauseActivity
   */
  pauseActivity: {
    methodKind: "unary";
    input: typeof PauseActivityRequestSchema;
    output: typeof PauseActivityResponseSchema;
  },
  /**
   * UnpauseActivity unpauses the execution of an activity specified by its ID or type.
   * If there are multiple pending activities of the provided type - all of them will be unpaused.
   *
   * If activity is not paused, this call will have no effect.
   * If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
   * Once the activity is unpaused, all timeout timers will be regenerated.
   *
   * Flags:
   * 'jitter': the activity will be scheduled at a random time within the jitter duration.
   * 'reset_attempts': the number of attempts will be reset.
   * 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
   *
   * Returns a `NotFound` error if there is no pending activity with the provided ID or type
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UnpauseActivity
   */
  unpauseActivity: {
    methodKind: "unary";
    input: typeof UnpauseActivityRequestSchema;
    output: typeof UnpauseActivityResponseSchema;
  },
  /**
   * ResetActivity resets the execution of an activity specified by its ID or type.
   * If there are multiple pending activities of the provided type - all of them will be reset.
   *
   * Resetting an activity means:
   * * number of attempts will be reset to 0.
   * * activity timeouts will be reset.
   * * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
   *    it will be scheduled immediately (* see 'jitter' flag),
   *
   * Flags:
   *
   * 'jitter': the activity will be scheduled at a random time within the jitter duration.
   * If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
   * 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
   * 'keep_paused': if the activity is paused, it will remain paused.
   *
   * Returns a `NotFound` error if there is no pending activity with the provided ID or type.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ResetActivity
   */
  resetActivity: {
    methodKind: "unary";
    input: typeof ResetActivityRequestSchema;
    output: typeof ResetActivityResponseSchema;
  },
  /**
   * Create a new workflow rule. The rules are used to control the workflow execution.
   * The rule will be applied to all running and new workflows in the namespace.
   * If the rule with such ID already exist this call will fail
   * Note: the rules are part of namespace configuration and will be stored in the namespace config.
   * Namespace config is eventually consistent.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.CreateWorkflowRule
   */
  createWorkflowRule: {
    methodKind: "unary";
    input: typeof CreateWorkflowRuleRequestSchema;
    output: typeof CreateWorkflowRuleResponseSchema;
  },
  /**
   * DescribeWorkflowRule return the rule specification for existing rule id.
   * If there is no rule with such id - NOT FOUND error will be returned.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeWorkflowRule
   */
  describeWorkflowRule: {
    methodKind: "unary";
    input: typeof DescribeWorkflowRuleRequestSchema;
    output: typeof DescribeWorkflowRuleResponseSchema;
  },
  /**
   * Delete rule by rule id
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DeleteWorkflowRule
   */
  deleteWorkflowRule: {
    methodKind: "unary";
    input: typeof DeleteWorkflowRuleRequestSchema;
    output: typeof DeleteWorkflowRuleResponseSchema;
  },
  /**
   * Return all namespace workflow rules
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListWorkflowRules
   */
  listWorkflowRules: {
    methodKind: "unary";
    input: typeof ListWorkflowRulesRequestSchema;
    output: typeof ListWorkflowRulesResponseSchema;
  },
  /**
   * TriggerWorkflowRule allows to:
   *  * trigger existing rule for a specific workflow execution;
   *  * trigger rule for a specific workflow execution without creating a rule;
   * This is useful for one-off operations.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.TriggerWorkflowRule
   */
  triggerWorkflowRule: {
    methodKind: "unary";
    input: typeof TriggerWorkflowRuleRequestSchema;
    output: typeof TriggerWorkflowRuleResponseSchema;
  },
  /**
   * WorkerHeartbeat receive heartbeat request from the worker.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.RecordWorkerHeartbeat
   */
  recordWorkerHeartbeat: {
    methodKind: "unary";
    input: typeof RecordWorkerHeartbeatRequestSchema;
    output: typeof RecordWorkerHeartbeatResponseSchema;
  },
  /**
   * ListWorkers is a visibility API to list worker status information in a specific namespace.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.ListWorkers
   */
  listWorkers: {
    methodKind: "unary";
    input: typeof ListWorkersRequestSchema;
    output: typeof ListWorkersResponseSchema;
  },
  /**
   * Updates task queue configuration.
   * For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
   * which uncouples the rate limit from the worker lifecycle.
   * If the overall queue rate limit is unset, the worker-set rate limit takes effect.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateTaskQueueConfig
   */
  updateTaskQueueConfig: {
    methodKind: "unary";
    input: typeof UpdateTaskQueueConfigRequestSchema;
    output: typeof UpdateTaskQueueConfigResponseSchema;
  },
  /**
   * FetchWorkerConfig returns the worker configuration for a specific worker.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.FetchWorkerConfig
   */
  fetchWorkerConfig: {
    methodKind: "unary";
    input: typeof FetchWorkerConfigRequestSchema;
    output: typeof FetchWorkerConfigResponseSchema;
  },
  /**
   * UpdateWorkerConfig updates the worker configuration of one or more workers.
   * Can be used to partially update the worker configuration.
   * Can be used to update the configuration of multiple workers.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.UpdateWorkerConfig
   */
  updateWorkerConfig: {
    methodKind: "unary";
    input: typeof UpdateWorkerConfigRequestSchema;
    output: typeof UpdateWorkerConfigResponseSchema;
  },
  /**
   * DescribeWorker returns information about the specified worker.
   *
   * @generated from rpc temporal.api.workflowservice.v1.WorkflowService.DescribeWorker
   */
  describeWorker: {
    methodKind: "unary";
    input: typeof DescribeWorkerRequestSchema;
    output: typeof DescribeWorkerResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_temporal_api_workflowservice_v1_service, 0);

