// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/sdk/v1/enhanced_stack_trace.proto (package temporal.api.sdk.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf'
import { Message, proto3 } from '@bufbuild/protobuf'

/**
 * Internal structure used to create worker stack traces with references to code.
 *
 * @generated from message temporal.api.sdk.v1.EnhancedStackTrace
 */
export class EnhancedStackTrace extends Message<EnhancedStackTrace> {
  /**
   * Information pertaining to the SDK that the trace has been captured from.
   *
   * @generated from field: temporal.api.sdk.v1.StackTraceSDKInfo sdk = 1;
   */
  sdk?: StackTraceSDKInfo

  /**
   * Mapping of file path to file contents.
   *
   * @generated from field: map<string, temporal.api.sdk.v1.StackTraceFileSlice> sources = 2;
   */
  sources: { [key: string]: StackTraceFileSlice } = {}

  /**
   * Collection of stacks captured.
   *
   * @generated from field: repeated temporal.api.sdk.v1.StackTrace stacks = 3;
   */
  stacks: StackTrace[] = []

  constructor(data?: PartialMessage<EnhancedStackTrace>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.sdk.v1.EnhancedStackTrace'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'sdk', kind: 'message', T: StackTraceSDKInfo },
    {
      no: 2,
      name: 'sources',
      kind: 'map',
      K: 9 /* ScalarType.STRING */,
      V: { kind: 'message', T: StackTraceFileSlice },
    },
    { no: 3, name: 'stacks', kind: 'message', T: StackTrace, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnhancedStackTrace {
    return new EnhancedStackTrace().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnhancedStackTrace {
    return new EnhancedStackTrace().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnhancedStackTrace {
    return new EnhancedStackTrace().fromJsonString(jsonString, options)
  }

  static equals(
    a: EnhancedStackTrace | PlainMessage<EnhancedStackTrace> | undefined,
    b: EnhancedStackTrace | PlainMessage<EnhancedStackTrace> | undefined,
  ): boolean {
    return proto3.util.equals(EnhancedStackTrace, a, b)
  }
}

/**
 * Information pertaining to the SDK that the trace has been captured from.
 * (-- api-linter: core::0123::resource-annotation=disabled
 *     aip.dev/not-precedent: Naming SDK version is optional. --)
 *
 * @generated from message temporal.api.sdk.v1.StackTraceSDKInfo
 */
export class StackTraceSDKInfo extends Message<StackTraceSDKInfo> {
  /**
   * Name of the SDK
   *
   * @generated from field: string name = 1;
   */
  name = ''

  /**
   * Version string of the SDK
   *
   * @generated from field: string version = 2;
   */
  version = ''

  constructor(data?: PartialMessage<StackTraceSDKInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.sdk.v1.StackTraceSDKInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'version', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTraceSDKInfo {
    return new StackTraceSDKInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTraceSDKInfo {
    return new StackTraceSDKInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTraceSDKInfo {
    return new StackTraceSDKInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: StackTraceSDKInfo | PlainMessage<StackTraceSDKInfo> | undefined,
    b: StackTraceSDKInfo | PlainMessage<StackTraceSDKInfo> | undefined,
  ): boolean {
    return proto3.util.equals(StackTraceSDKInfo, a, b)
  }
}

/**
 * "Slice" of a file starting at line_offset -- a line offset and code fragment corresponding to the worker's stack.
 *
 * @generated from message temporal.api.sdk.v1.StackTraceFileSlice
 */
export class StackTraceFileSlice extends Message<StackTraceFileSlice> {
  /**
   * Only used (possibly) to trim the file without breaking syntax highlighting. This is not optional, unlike
   * the `line` property of a `StackTraceFileLocation`.
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: These really shouldn't have negative values. --)
   *
   * @generated from field: uint32 line_offset = 1;
   */
  lineOffset = 0

  /**
   * Slice of a file with the respective OS-specific line terminator.
   *
   * @generated from field: string content = 2;
   */
  content = ''

  constructor(data?: PartialMessage<StackTraceFileSlice>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.sdk.v1.StackTraceFileSlice'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'line_offset', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: 'content', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTraceFileSlice {
    return new StackTraceFileSlice().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTraceFileSlice {
    return new StackTraceFileSlice().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTraceFileSlice {
    return new StackTraceFileSlice().fromJsonString(jsonString, options)
  }

  static equals(
    a: StackTraceFileSlice | PlainMessage<StackTraceFileSlice> | undefined,
    b: StackTraceFileSlice | PlainMessage<StackTraceFileSlice> | undefined,
  ): boolean {
    return proto3.util.equals(StackTraceFileSlice, a, b)
  }
}

/**
 * More specific location details of a file: its path, precise line and column numbers if applicable, and function name if available.
 * In essence, a pointer to a location in a file
 *
 * @generated from message temporal.api.sdk.v1.StackTraceFileLocation
 */
export class StackTraceFileLocation extends Message<StackTraceFileLocation> {
  /**
   * Path to source file (absolute or relative).
   * If the paths are relative, ensure that they are all relative to the same root.
   *
   * @generated from field: string file_path = 1;
   */
  filePath = ''

  /**
   * Optional; If possible, SDK should send this -- this is required for displaying the code location.
   * If not provided, set to -1.
   *
   * @generated from field: int32 line = 2;
   */
  line = 0

  /**
   * Optional; if possible, SDK should send this.
   * If not provided, set to -1.
   *
   * @generated from field: int32 column = 3;
   */
  column = 0

  /**
   * Function name this line belongs to, if applicable.
   * Used for falling back to stack trace view.
   *
   * @generated from field: string function_name = 4;
   */
  functionName = ''

  /**
   * Flag to communicate whether a location should be hidden by default in the stack view.
   *
   * @generated from field: bool internal_code = 5;
   */
  internalCode = false

  constructor(data?: PartialMessage<StackTraceFileLocation>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.sdk.v1.StackTraceFileLocation'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'file_path', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'line', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: 'column', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: 'function_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 5, name: 'internal_code', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTraceFileLocation {
    return new StackTraceFileLocation().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTraceFileLocation {
    return new StackTraceFileLocation().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTraceFileLocation {
    return new StackTraceFileLocation().fromJsonString(jsonString, options)
  }

  static equals(
    a: StackTraceFileLocation | PlainMessage<StackTraceFileLocation> | undefined,
    b: StackTraceFileLocation | PlainMessage<StackTraceFileLocation> | undefined,
  ): boolean {
    return proto3.util.equals(StackTraceFileLocation, a, b)
  }
}

/**
 * Collection of FileLocation messages from a single stack.
 *
 * @generated from message temporal.api.sdk.v1.StackTrace
 */
export class StackTrace extends Message<StackTrace> {
  /**
   * Collection of `FileLocation`s, each for a stack frame that comprise a stack trace.
   *
   * @generated from field: repeated temporal.api.sdk.v1.StackTraceFileLocation locations = 1;
   */
  locations: StackTraceFileLocation[] = []

  constructor(data?: PartialMessage<StackTrace>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'temporal.api.sdk.v1.StackTrace'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'locations', kind: 'message', T: StackTraceFileLocation, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTrace {
    return new StackTrace().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTrace {
    return new StackTrace().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTrace {
    return new StackTrace().fromJsonString(jsonString, options)
  }

  static equals(
    a: StackTrace | PlainMessage<StackTrace> | undefined,
    b: StackTrace | PlainMessage<StackTrace> | undefined,
  ): boolean {
    return proto3.util.equals(StackTrace, a, b)
  }
}
