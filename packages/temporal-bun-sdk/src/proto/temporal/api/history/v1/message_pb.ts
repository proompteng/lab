// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/history/v1/message.proto (package temporal.api.history.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { EventType } from "../../enums/v1/event_type_pb.js";
import { file_temporal_api_enums_v1_event_type } from "../../enums/v1/event_type_pb.js";
import type { CancelExternalWorkflowExecutionFailedCause, SignalExternalWorkflowExecutionFailedCause, StartChildWorkflowExecutionFailedCause, WorkflowTaskFailedCause } from "../../enums/v1/failed_cause_pb.js";
import { file_temporal_api_enums_v1_failed_cause } from "../../enums/v1/failed_cause_pb.js";
import type { UpdateAdmittedEventOrigin } from "../../enums/v1/update_pb.js";
import { file_temporal_api_enums_v1_update } from "../../enums/v1/update_pb.js";
import type { ContinueAsNewInitiator, ParentClosePolicy, RetryState, TimeoutType, VersioningBehavior, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pb.js";
import { file_temporal_api_enums_v1_workflow } from "../../enums/v1/workflow_pb.js";
import type { ActivityType, Callback, Header, Link, Memo, MeteringMetadata, Payload, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pb.js";
import { file_temporal_api_common_v1_message } from "../../common/v1/message_pb.js";
import type { Deployment, WorkerDeploymentVersion } from "../../deployment/v1/message_pb.js";
import { file_temporal_api_deployment_v1_message } from "../../deployment/v1/message_pb.js";
import type { Failure } from "../../failure/v1/message_pb.js";
import { file_temporal_api_failure_v1_message } from "../../failure/v1/message_pb.js";
import type { TaskQueue } from "../../taskqueue/v1/message_pb.js";
import { file_temporal_api_taskqueue_v1_message } from "../../taskqueue/v1/message_pb.js";
import type { Meta, Outcome, Request } from "../../update/v1/message_pb.js";
import { file_temporal_api_update_v1_message } from "../../update/v1/message_pb.js";
import type { ResetPoints, VersioningOverride } from "../../workflow/v1/message_pb.js";
import { file_temporal_api_workflow_v1_message } from "../../workflow/v1/message_pb.js";
import type { WorkflowTaskCompletedMetadata } from "../../sdk/v1/task_complete_metadata_pb.js";
import { file_temporal_api_sdk_v1_task_complete_metadata } from "../../sdk/v1/task_complete_metadata_pb.js";
import type { UserMetadata } from "../../sdk/v1/user_metadata_pb.js";
import { file_temporal_api_sdk_v1_user_metadata } from "../../sdk/v1/user_metadata_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file temporal/api/history/v1/message.proto.
 */
export const file_temporal_api_history_v1_message: GenFile = /*@__PURE__*/
  fileDesc("CiV0ZW1wb3JhbC9hcGkvaGlzdG9yeS92MS9tZXNzYWdlLnByb3RvEhd0ZW1wb3JhbC5hcGkuaGlzdG9yeS52MSLWDwonV29ya2Zsb3dFeGVjdXRpb25TdGFydGVkRXZlbnRBdHRyaWJ1dGVzEjsKDXdvcmtmbG93X3R5cGUYASABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93VHlwZRIhChlwYXJlbnRfd29ya2Zsb3dfbmFtZXNwYWNlGAIgASgJEiQKHHBhcmVudF93b3JrZmxvd19uYW1lc3BhY2VfaWQYGyABKAkSTAoZcGFyZW50X3dvcmtmbG93X2V4ZWN1dGlvbhgDIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SIQoZcGFyZW50X2luaXRpYXRlZF9ldmVudF9pZBgEIAEoAxI4Cgp0YXNrX3F1ZXVlGAUgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUSLwoFaW5wdXQYBiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEj0KGndvcmtmbG93X2V4ZWN1dGlvbl90aW1lb3V0GAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjcKFHdvcmtmbG93X3J1bl90aW1lb3V0GAggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjgKFXdvcmtmbG93X3Rhc2tfdGltZW91dBgJIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIiChpjb250aW51ZWRfZXhlY3V0aW9uX3J1bl9pZBgKIAEoCRJACglpbml0aWF0b3IYCyABKA4yLS50ZW1wb3JhbC5hcGkuZW51bXMudjEuQ29udGludWVBc05ld0luaXRpYXRvchI7ChFjb250aW51ZWRfZmFpbHVyZRgMIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSQAoWbGFzdF9jb21wbGV0aW9uX3Jlc3VsdBgNIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSIQoZb3JpZ2luYWxfZXhlY3V0aW9uX3J1bl9pZBgOIAEoCRIQCghpZGVudGl0eRgPIAEoCRIeChZmaXJzdF9leGVjdXRpb25fcnVuX2lkGBAgASgJEjkKDHJldHJ5X3BvbGljeRgRIAEoCzIjLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUmV0cnlQb2xpY3kSDwoHYXR0ZW1wdBgSIAEoBRJGCiJ3b3JrZmxvd19leGVjdXRpb25fZXhwaXJhdGlvbl90aW1lGBMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIVCg1jcm9uX3NjaGVkdWxlGBQgASgJEj4KG2ZpcnN0X3dvcmtmbG93X3Rhc2tfYmFja29mZhgVIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIqCgRtZW1vGBYgASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGBcgASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzEkUKFnByZXZfYXV0b19yZXNldF9wb2ludHMYGCABKAsyJS50ZW1wb3JhbC5hcGkud29ya2Zsb3cudjEuUmVzZXRQb2ludHMSLgoGaGVhZGVyGBkgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISJgoecGFyZW50X2luaXRpYXRlZF9ldmVudF92ZXJzaW9uGBogASgDEhMKC3dvcmtmbG93X2lkGBwgASgJEkwKFHNvdXJjZV92ZXJzaW9uX3N0YW1wGB0gASgLMioudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJWZXJzaW9uU3RhbXBCAhgBEj4KFGNvbXBsZXRpb25fY2FsbGJhY2tzGB4gAygLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5DYWxsYmFjaxJKChdyb290X3dvcmtmbG93X2V4ZWN1dGlvbhgfIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SHgoSaW5oZXJpdGVkX2J1aWxkX2lkGCAgASgJQgIYARJJChN2ZXJzaW9uaW5nX292ZXJyaWRlGCEgASgLMiwudGVtcG9yYWwuYXBpLndvcmtmbG93LnYxLlZlcnNpb25pbmdPdmVycmlkZRIzCidwYXJlbnRfcGlubmVkX3dvcmtlcl9kZXBsb3ltZW50X3ZlcnNpb24YIiABKAlCAhgBEjIKCHByaW9yaXR5GCMgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eRJVChhpbmhlcml0ZWRfcGlubmVkX3ZlcnNpb24YJSABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbhIgChhlYWdlcl9leGVjdXRpb25fYWNjZXB0ZWQYJiABKAhKBAgkECVSIHBhcmVudF9waW5uZWRfZGVwbG95bWVudF92ZXJzaW9uIqUBCilXb3JrZmxvd0V4ZWN1dGlvbkNvbXBsZXRlZEV2ZW50QXR0cmlidXRlcxIwCgZyZXN1bHQYASABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAIgASgDEhwKFG5ld19leGVjdXRpb25fcnVuX2lkGAMgASgJItsBCiZXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZEV2ZW50QXR0cmlidXRlcxIxCgdmYWlsdXJlGAEgASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZRI2CgtyZXRyeV9zdGF0ZRgCIAEoDjIhLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5SZXRyeVN0YXRlEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAMgASgDEhwKFG5ld19leGVjdXRpb25fcnVuX2lkGAQgASgJIoABCihXb3JrZmxvd0V4ZWN1dGlvblRpbWVkT3V0RXZlbnRBdHRyaWJ1dGVzEjYKC3JldHJ5X3N0YXRlGAEgASgOMiEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUSHAoUbmV3X2V4ZWN1dGlvbl9ydW5faWQYAiABKAkiyAYKLldvcmtmbG93RXhlY3V0aW9uQ29udGludWVkQXNOZXdFdmVudEF0dHJpYnV0ZXMSHAoUbmV3X2V4ZWN1dGlvbl9ydW5faWQYASABKAkSOwoNd29ya2Zsb3dfdHlwZRgCIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEjgKCnRhc2tfcXVldWUYAyABKAsyJC50ZW1wb3JhbC5hcGkudGFza3F1ZXVlLnYxLlRhc2tRdWV1ZRIvCgVpbnB1dBgEIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSNwoUd29ya2Zsb3dfcnVuX3RpbWVvdXQYBSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOAoVd29ya2Zsb3dfdGFza190aW1lb3V0GAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAcgASgDEjkKFmJhY2tvZmZfc3RhcnRfaW50ZXJ2YWwYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SQAoJaW5pdGlhdG9yGAkgASgOMi0udGVtcG9yYWwuYXBpLmVudW1zLnYxLkNvbnRpbnVlQXNOZXdJbml0aWF0b3ISNQoHZmFpbHVyZRgKIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmVCAhgBEkAKFmxhc3RfY29tcGxldGlvbl9yZXN1bHQYCyABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEi4KBmhlYWRlchgMIAEoCzIeLnRlbXBvcmFsLmFwaS5jb21tb24udjEuSGVhZGVyEioKBG1lbW8YDSABKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLk1lbW8SQwoRc2VhcmNoX2F0dHJpYnV0ZXMYDiABKAsyKC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlNlYXJjaEF0dHJpYnV0ZXMSHAoQaW5oZXJpdF9idWlsZF9pZBgPIAEoCEICGAEirAEKJFdvcmtmbG93VGFza1NjaGVkdWxlZEV2ZW50QXR0cmlidXRlcxI4Cgp0YXNrX3F1ZXVlGAEgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUSOQoWc3RhcnRfdG9fY2xvc2VfdGltZW91dBgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIPCgdhdHRlbXB0GAMgASgFIpICCiJXb3JrZmxvd1Rhc2tTdGFydGVkRXZlbnRBdHRyaWJ1dGVzEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgBIAEoAxIQCghpZGVudGl0eRgCIAEoCRISCgpyZXF1ZXN0X2lkGAMgASgJEh8KF3N1Z2dlc3RfY29udGludWVfYXNfbmV3GAQgASgIEhoKEmhpc3Rvcnlfc2l6ZV9ieXRlcxgFIAEoAxJGCg53b3JrZXJfdmVyc2lvbhgGIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYARIlChlidWlsZF9pZF9yZWRpcmVjdF9jb3VudGVyGAcgASgDQgIYASKCBQokV29ya2Zsb3dUYXNrQ29tcGxldGVkRXZlbnRBdHRyaWJ1dGVzEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgBIAEoAxIYChBzdGFydGVkX2V2ZW50X2lkGAIgASgDEhAKCGlkZW50aXR5GAMgASgJEhsKD2JpbmFyeV9jaGVja3N1bRgEIAEoCUICGAESRgoOd29ya2VyX3ZlcnNpb24YBSABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAESSAoMc2RrX21ldGFkYXRhGAYgASgLMjIudGVtcG9yYWwuYXBpLnNkay52MS5Xb3JrZmxvd1Rhc2tDb21wbGV0ZWRNZXRhZGF0YRJDChFtZXRlcmluZ19tZXRhZGF0YRgNIAEoCzIoLnRlbXBvcmFsLmFwaS5jb21tb24udjEuTWV0ZXJpbmdNZXRhZGF0YRI+CgpkZXBsb3ltZW50GAcgASgLMiYudGVtcG9yYWwuYXBpLmRlcGxveW1lbnQudjEuRGVwbG95bWVudEICGAESRgoTdmVyc2lvbmluZ19iZWhhdmlvchgIIAEoDjIpLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5WZXJzaW9uaW5nQmVoYXZpb3ISJQoZd29ya2VyX2RlcGxveW1lbnRfdmVyc2lvbhgJIAEoCUICGAESHgoWd29ya2VyX2RlcGxveW1lbnRfbmFtZRgKIAEoCRJPChJkZXBsb3ltZW50X3ZlcnNpb24YCyABKAsyMy50ZW1wb3JhbC5hcGkuZGVwbG95bWVudC52MS5Xb3JrZXJEZXBsb3ltZW50VmVyc2lvbiKVAQojV29ya2Zsb3dUYXNrVGltZWRPdXRFdmVudEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYAiABKAMSOAoMdGltZW91dF90eXBlGAMgASgOMiIudGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlIocDCiFXb3JrZmxvd1Rhc2tGYWlsZWRFdmVudEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYAiABKAMSPQoFY2F1c2UYAyABKA4yLi50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dUYXNrRmFpbGVkQ2F1c2USMQoHZmFpbHVyZRgEIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSEAoIaWRlbnRpdHkYBSABKAkSEwoLYmFzZV9ydW5faWQYBiABKAkSEgoKbmV3X3J1bl9pZBgHIAEoCRIaChJmb3JrX2V2ZW50X3ZlcnNpb24YCCABKAMSGwoPYmluYXJ5X2NoZWNrc3VtGAkgASgJQgIYARJGCg53b3JrZXJfdmVyc2lvbhgKIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYASLCBQokQWN0aXZpdHlUYXNrU2NoZWR1bGVkRXZlbnRBdHRyaWJ1dGVzEhMKC2FjdGl2aXR5X2lkGAEgASgJEjsKDWFjdGl2aXR5X3R5cGUYAiABKAsyJC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkFjdGl2aXR5VHlwZRI4Cgp0YXNrX3F1ZXVlGAQgASgLMiQudGVtcG9yYWwuYXBpLnRhc2txdWV1ZS52MS5UYXNrUXVldWUSLgoGaGVhZGVyGAUgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISLwoFaW5wdXQYBiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEjwKGXNjaGVkdWxlX3RvX2Nsb3NlX3RpbWVvdXQYByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SPAoZc2NoZWR1bGVfdG9fc3RhcnRfdGltZW91dBgIIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI5ChZzdGFydF90b19jbG9zZV90aW1lb3V0GAkgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjQKEWhlYXJ0YmVhdF90aW1lb3V0GAogASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAsgASgDEjkKDHJldHJ5X3BvbGljeRgMIAEoCzIjLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUmV0cnlQb2xpY3kSIQoVdXNlX3dvcmtmbG93X2J1aWxkX2lkGA0gASgIQgIYARIyCghwcmlvcml0eRgOIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUHJpb3JpdHlKBAgDEAQingIKIkFjdGl2aXR5VGFza1N0YXJ0ZWRFdmVudEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDEhAKCGlkZW50aXR5GAIgASgJEhIKCnJlcXVlc3RfaWQYAyABKAkSDwoHYXR0ZW1wdBgEIAEoBRI2CgxsYXN0X2ZhaWx1cmUYBSABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEkYKDndvcmtlcl92ZXJzaW9uGAYgASgLMioudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZXJWZXJzaW9uU3RhbXBCAhgBEiUKGWJ1aWxkX2lkX3JlZGlyZWN0X2NvdW50ZXIYByABKANCAhgBIugBCiRBY3Rpdml0eVRhc2tDb21wbGV0ZWRFdmVudEF0dHJpYnV0ZXMSMAoGcmVzdWx0GAEgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYAiABKAMSGAoQc3RhcnRlZF9ldmVudF9pZBgDIAEoAxIQCghpZGVudGl0eRgEIAEoCRJGCg53b3JrZXJfdmVyc2lvbhgFIAEoCzIqLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2VyVmVyc2lvblN0YW1wQgIYASKeAgohQWN0aXZpdHlUYXNrRmFpbGVkRXZlbnRBdHRyaWJ1dGVzEjEKB2ZhaWx1cmUYASABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgCIAEoAxIYChBzdGFydGVkX2V2ZW50X2lkGAMgASgDEhAKCGlkZW50aXR5GAQgASgJEjYKC3JldHJ5X3N0YXRlGAUgASgOMiEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUSRgoOd29ya2VyX3ZlcnNpb24YBiABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAEixgEKI0FjdGl2aXR5VGFza1RpbWVkT3V0RXZlbnRBdHRyaWJ1dGVzEjEKB2ZhaWx1cmUYASABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgCIAEoAxIYChBzdGFydGVkX2V2ZW50X2lkGAMgASgDEjYKC3JldHJ5X3N0YXRlGAQgASgOMiEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUicgoqQWN0aXZpdHlUYXNrQ2FuY2VsUmVxdWVzdGVkRXZlbnRBdHRyaWJ1dGVzEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgBIAEoAxIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgCIAEoAyKSAgojQWN0aXZpdHlUYXNrQ2FuY2VsZWRFdmVudEF0dHJpYnV0ZXMSMQoHZGV0YWlscxgBIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSKAogbGF0ZXN0X2NhbmNlbF9yZXF1ZXN0ZWRfZXZlbnRfaWQYAiABKAMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAMgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYBCABKAMSEAoIaWRlbnRpdHkYBSABKAkSRgoOd29ya2VyX3ZlcnNpb24YBiABKAsyKi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtlclZlcnNpb25TdGFtcEICGAEikwEKG1RpbWVyU3RhcnRlZEV2ZW50QXR0cmlidXRlcxIQCgh0aW1lcl9pZBgBIAEoCRI4ChVzdGFydF90b19maXJlX3RpbWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYAyABKAMiRwoZVGltZXJGaXJlZEV2ZW50QXR0cmlidXRlcxIQCgh0aW1lcl9pZBgBIAEoCRIYChBzdGFydGVkX2V2ZW50X2lkGAIgASgDIoYBChxUaW1lckNhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzEhAKCHRpbWVyX2lkGAEgASgJEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYAiABKAMSKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYAyABKAMSEAoIaWRlbnRpdHkYBCABKAkixwEKL1dvcmtmbG93RXhlY3V0aW9uQ2FuY2VsUmVxdWVzdGVkRXZlbnRBdHRyaWJ1dGVzEg0KBWNhdXNlGAEgASgJEiMKG2V4dGVybmFsX2luaXRpYXRlZF9ldmVudF9pZBgCIAEoAxJOChtleHRlcm5hbF93b3JrZmxvd19leGVjdXRpb24YAyABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEhAKCGlkZW50aXR5GAQgASgJIocBCihXb3JrZmxvd0V4ZWN1dGlvbkNhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAEgASgDEjEKB2RldGFpbHMYAiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzIukCCh1NYXJrZXJSZWNvcmRlZEV2ZW50QXR0cmlidXRlcxITCgttYXJrZXJfbmFtZRgBIAEoCRJUCgdkZXRhaWxzGAIgAygLMkMudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuTWFya2VyUmVjb3JkZWRFdmVudEF0dHJpYnV0ZXMuRGV0YWlsc0VudHJ5EigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAMgASgDEi4KBmhlYWRlchgEIAEoCzIeLnRlbXBvcmFsLmFwaS5jb21tb24udjEuSGVhZGVyEjEKB2ZhaWx1cmUYBSABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlGlAKDERldGFpbHNFbnRyeRILCgNrZXkYASABKAkSLwoFdmFsdWUYAiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzOgI4ASKrAgooV29ya2Zsb3dFeGVjdXRpb25TaWduYWxlZEV2ZW50QXR0cmlidXRlcxITCgtzaWduYWxfbmFtZRgBIAEoCRIvCgVpbnB1dBgCIAEoCzIgLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZHMSEAoIaWRlbnRpdHkYAyABKAkSLgoGaGVhZGVyGAQgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXISJwobc2tpcF9nZW5lcmF0ZV93b3JrZmxvd190YXNrGAUgASgIQgIYARJOChtleHRlcm5hbF93b3JrZmxvd19leGVjdXRpb24YBiABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uIoEBCipXb3JrZmxvd0V4ZWN1dGlvblRlcm1pbmF0ZWRFdmVudEF0dHJpYnV0ZXMSDgoGcmVhc29uGAEgASgJEjEKB2RldGFpbHMYAiABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhAKCGlkZW50aXR5GAMgASgJIpwCCj5SZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvd0V4ZWN1dGlvbkluaXRpYXRlZEV2ZW50QXR0cmlidXRlcxIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgBIAEoAxIRCgluYW1lc3BhY2UYAiABKAkSFAoMbmFtZXNwYWNlX2lkGAcgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgDIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SEwoHY29udHJvbBgEIAEoCUICGAESGwoTY2hpbGRfd29ya2Zsb3dfb25seRgFIAEoCBIOCgZyZWFzb24YBiABKAki2gIKO1JlcXVlc3RDYW5jZWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzElAKBWNhdXNlGAEgASgOMkEudGVtcG9yYWwuYXBpLmVudW1zLnYxLkNhbmNlbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZRIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgCIAEoAxIRCgluYW1lc3BhY2UYAyABKAkSFAoMbmFtZXNwYWNlX2lkGAcgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgEIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAUgASgDEhMKB2NvbnRyb2wYBiABKAlCAhgBIsUBCjdFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uQ2FuY2VsUmVxdWVzdGVkRXZlbnRBdHRyaWJ1dGVzEhoKEmluaXRpYXRlZF9ldmVudF9pZBgBIAEoAxIRCgluYW1lc3BhY2UYAiABKAkSFAoMbmFtZXNwYWNlX2lkGAQgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgDIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24i+wIKN1NpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25Jbml0aWF0ZWRFdmVudEF0dHJpYnV0ZXMSKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYASABKAMSEQoJbmFtZXNwYWNlGAIgASgJEhQKDG5hbWVzcGFjZV9pZBgJIAEoCRJFChJ3b3JrZmxvd19leGVjdXRpb24YAyABKAsyKS50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLldvcmtmbG93RXhlY3V0aW9uEhMKC3NpZ25hbF9uYW1lGAQgASgJEi8KBWlucHV0GAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxITCgdjb250cm9sGAYgASgJQgIYARIbChNjaGlsZF93b3JrZmxvd19vbmx5GAcgASgIEi4KBmhlYWRlchgIIAEoCzIeLnRlbXBvcmFsLmFwaS5jb21tb24udjEuSGVhZGVyItMCCjRTaWduYWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzElAKBWNhdXNlGAEgASgOMkEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlNpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZRIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgCIAEoAxIRCgluYW1lc3BhY2UYAyABKAkSFAoMbmFtZXNwYWNlX2lkGAcgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgEIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAUgASgDEhMKB2NvbnRyb2wYBiABKAlCAhgBItMBCjBFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uU2lnbmFsZWRFdmVudEF0dHJpYnV0ZXMSGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAEgASgDEhEKCW5hbWVzcGFjZRgCIAEoCRIUCgxuYW1lc3BhY2VfaWQYBSABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAMgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhITCgdjb250cm9sGAQgASgJQgIYASKeAQotVXBzZXJ0V29ya2Zsb3dTZWFyY2hBdHRyaWJ1dGVzRXZlbnRBdHRyaWJ1dGVzEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAEgASgDEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGAIgASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzIooBCilXb3JrZmxvd1Byb3BlcnRpZXNNb2RpZmllZEV2ZW50QXR0cmlidXRlcxIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgBIAEoAxIzCg11cHNlcnRlZF9tZW1vGAIgASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vIugHCjNTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25Jbml0aWF0ZWRFdmVudEF0dHJpYnV0ZXMSEQoJbmFtZXNwYWNlGAEgASgJEhQKDG5hbWVzcGFjZV9pZBgSIAEoCRITCgt3b3JrZmxvd19pZBgCIAEoCRI7Cg13b3JrZmxvd190eXBlGAMgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSOAoKdGFza19xdWV1ZRgEIAEoCzIkLnRlbXBvcmFsLmFwaS50YXNrcXVldWUudjEuVGFza1F1ZXVlEi8KBWlucHV0GAUgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxI9Chp3b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI3ChR3b3JrZmxvd19ydW5fdGltZW91dBgHIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4ChV3b3JrZmxvd190YXNrX3RpbWVvdXQYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRQoTcGFyZW50X2Nsb3NlX3BvbGljeRgJIAEoDjIoLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5QYXJlbnRDbG9zZVBvbGljeRITCgdjb250cm9sGAogASgJQgIYARIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgLIAEoAxJOChh3b3JrZmxvd19pZF9yZXVzZV9wb2xpY3kYDCABKA4yLC50ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5EjkKDHJldHJ5X3BvbGljeRgNIAEoCzIjLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUmV0cnlQb2xpY3kSFQoNY3Jvbl9zY2hlZHVsZRgOIAEoCRIuCgZoZWFkZXIYDyABKAsyHi50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkhlYWRlchIqCgRtZW1vGBAgASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vEkMKEXNlYXJjaF9hdHRyaWJ1dGVzGBEgASgLMigudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5TZWFyY2hBdHRyaWJ1dGVzEhwKEGluaGVyaXRfYnVpbGRfaWQYEyABKAhCAhgBEjIKCHByaW9yaXR5GBQgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Qcmlvcml0eSLWAgowU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzEhEKCW5hbWVzcGFjZRgBIAEoCRIUCgxuYW1lc3BhY2VfaWQYCCABKAkSEwoLd29ya2Zsb3dfaWQYAiABKAkSOwoNd29ya2Zsb3dfdHlwZRgDIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEkwKBWNhdXNlGAQgASgOMj0udGVtcG9yYWwuYXBpLmVudW1zLnYxLlN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlEhMKB2NvbnRyb2wYBSABKAlCAhgBEhoKEmluaXRpYXRlZF9ldmVudF9pZBgGIAEoAxIoCiB3b3JrZmxvd190YXNrX2NvbXBsZXRlZF9ldmVudF9pZBgHIAEoAyKnAgosQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblN0YXJ0ZWRFdmVudEF0dHJpYnV0ZXMSEQoJbmFtZXNwYWNlGAEgASgJEhQKDG5hbWVzcGFjZV9pZBgGIAEoCRIaChJpbml0aWF0ZWRfZXZlbnRfaWQYAiABKAMSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAMgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhI7Cg13b3JrZmxvd190eXBlGAQgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSLgoGaGVhZGVyGAUgASgLMh4udGVtcG9yYWwuYXBpLmNvbW1vbi52MS5IZWFkZXIixQIKLkNoaWxkV29ya2Zsb3dFeGVjdXRpb25Db21wbGV0ZWRFdmVudEF0dHJpYnV0ZXMSMAoGcmVzdWx0GAEgASgLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5QYXlsb2FkcxIRCgluYW1lc3BhY2UYAiABKAkSFAoMbmFtZXNwYWNlX2lkGAcgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgDIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SOwoNd29ya2Zsb3dfdHlwZRgEIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEhoKEmluaXRpYXRlZF9ldmVudF9pZBgFIAEoAxIYChBzdGFydGVkX2V2ZW50X2lkGAYgASgDIvsCCitDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzEjEKB2ZhaWx1cmUYASABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhEKCW5hbWVzcGFjZRgCIAEoCRIUCgxuYW1lc3BhY2VfaWQYCCABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAMgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhI7Cg13b3JrZmxvd190eXBlGAQgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAUgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYBiABKAMSNgoLcmV0cnlfc3RhdGUYByABKA4yIS50ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZSLFAgotQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkNhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzEjEKB2RldGFpbHMYASABKAsyIC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlBheWxvYWRzEhEKCW5hbWVzcGFjZRgCIAEoCRIUCgxuYW1lc3BhY2VfaWQYByABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAMgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhI7Cg13b3JrZmxvd190eXBlGAQgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAUgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYBiABKAMiygIKLUNoaWxkV29ya2Zsb3dFeGVjdXRpb25UaW1lZE91dEV2ZW50QXR0cmlidXRlcxIRCgluYW1lc3BhY2UYASABKAkSFAoMbmFtZXNwYWNlX2lkGAcgASgJEkUKEndvcmtmbG93X2V4ZWN1dGlvbhgCIAEoCzIpLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dFeGVjdXRpb24SOwoNd29ya2Zsb3dfdHlwZRgDIAEoCzIkLnRlbXBvcmFsLmFwaS5jb21tb24udjEuV29ya2Zsb3dUeXBlEhoKEmluaXRpYXRlZF9ldmVudF9pZBgEIAEoAxIYChBzdGFydGVkX2V2ZW50X2lkGAUgASgDEjYKC3JldHJ5X3N0YXRlGAYgASgOMiEudGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUilAIKL0NoaWxkV29ya2Zsb3dFeGVjdXRpb25UZXJtaW5hdGVkRXZlbnRBdHRyaWJ1dGVzEhEKCW5hbWVzcGFjZRgBIAEoCRIUCgxuYW1lc3BhY2VfaWQYBiABKAkSRQoSd29ya2Zsb3dfZXhlY3V0aW9uGAIgASgLMikudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd0V4ZWN1dGlvbhI7Cg13b3JrZmxvd190eXBlGAMgASgLMiQudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5Xb3JrZmxvd1R5cGUSGgoSaW5pdGlhdGVkX2V2ZW50X2lkGAQgASgDEhgKEHN0YXJ0ZWRfZXZlbnRfaWQYBSABKAMilgIKLldvcmtmbG93RXhlY3V0aW9uT3B0aW9uc1VwZGF0ZWRFdmVudEF0dHJpYnV0ZXMSSQoTdmVyc2lvbmluZ19vdmVycmlkZRgBIAEoCzIsLnRlbXBvcmFsLmFwaS53b3JrZmxvdy52MS5WZXJzaW9uaW5nT3ZlcnJpZGUSIQoZdW5zZXRfdmVyc2lvbmluZ19vdmVycmlkZRgCIAEoCBIbChNhdHRhY2hlZF9yZXF1ZXN0X2lkGAMgASgJEkcKHWF0dGFjaGVkX2NvbXBsZXRpb25fY2FsbGJhY2tzGAQgAygLMiAudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5DYWxsYmFjaxIQCghpZGVudGl0eRgFIAEoCSLAAgozV29ya2Zsb3dQcm9wZXJ0aWVzTW9kaWZpZWRFeHRlcm5hbGx5RXZlbnRBdHRyaWJ1dGVzEhYKDm5ld190YXNrX3F1ZXVlGAEgASgJEjwKGW5ld193b3JrZmxvd190YXNrX3RpbWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOwoYbmV3X3dvcmtmbG93X3J1bl90aW1lb3V0GAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkEKHm5ld193b3JrZmxvd19leGVjdXRpb25fdGltZW91dBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIzCg11cHNlcnRlZF9tZW1vGAUgASgLMhwudGVtcG9yYWwuYXBpLmNvbW1vbi52MS5NZW1vIpABCjNBY3Rpdml0eVByb3BlcnRpZXNNb2RpZmllZEV4dGVybmFsbHlFdmVudEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDEj0KEG5ld19yZXRyeV9wb2xpY3kYAiABKAsyIy50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLlJldHJ5UG9saWN5ItwBCi5Xb3JrZmxvd0V4ZWN1dGlvblVwZGF0ZUFjY2VwdGVkRXZlbnRBdHRyaWJ1dGVzEhwKFHByb3RvY29sX2luc3RhbmNlX2lkGAEgASgJEiMKG2FjY2VwdGVkX3JlcXVlc3RfbWVzc2FnZV9pZBgCIAEoCRIsCiRhY2NlcHRlZF9yZXF1ZXN0X3NlcXVlbmNpbmdfZXZlbnRfaWQYAyABKAMSOQoQYWNjZXB0ZWRfcmVxdWVzdBgEIAEoCzIfLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuUmVxdWVzdCKqAQovV29ya2Zsb3dFeGVjdXRpb25VcGRhdGVDb21wbGV0ZWRFdmVudEF0dHJpYnV0ZXMSKgoEbWV0YRgBIAEoCzIcLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuTWV0YRIZChFhY2NlcHRlZF9ldmVudF9pZBgDIAEoAxIwCgdvdXRjb21lGAIgASgLMh8udGVtcG9yYWwuYXBpLnVwZGF0ZS52MS5PdXRjb21lIo8CCi5Xb3JrZmxvd0V4ZWN1dGlvblVwZGF0ZVJlamVjdGVkRXZlbnRBdHRyaWJ1dGVzEhwKFHByb3RvY29sX2luc3RhbmNlX2lkGAEgASgJEiMKG3JlamVjdGVkX3JlcXVlc3RfbWVzc2FnZV9pZBgCIAEoCRIsCiRyZWplY3RlZF9yZXF1ZXN0X3NlcXVlbmNpbmdfZXZlbnRfaWQYAyABKAMSOQoQcmVqZWN0ZWRfcmVxdWVzdBgEIAEoCzIfLnRlbXBvcmFsLmFwaS51cGRhdGUudjEuUmVxdWVzdBIxCgdmYWlsdXJlGAUgASgLMiAudGVtcG9yYWwuYXBpLmZhaWx1cmUudjEuRmFpbHVyZSKkAQouV29ya2Zsb3dFeGVjdXRpb25VcGRhdGVBZG1pdHRlZEV2ZW50QXR0cmlidXRlcxIwCgdyZXF1ZXN0GAEgASgLMh8udGVtcG9yYWwuYXBpLnVwZGF0ZS52MS5SZXF1ZXN0EkAKBm9yaWdpbhgCIAEoDjIwLnRlbXBvcmFsLmFwaS5lbnVtcy52MS5VcGRhdGVBZG1pdHRlZEV2ZW50T3JpZ2luIrsDCiZOZXh1c09wZXJhdGlvblNjaGVkdWxlZEV2ZW50QXR0cmlidXRlcxIQCghlbmRwb2ludBgBIAEoCRIPCgdzZXJ2aWNlGAIgASgJEhEKCW9wZXJhdGlvbhgDIAEoCRIuCgVpbnB1dBgEIAEoCzIfLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZBI8ChlzY2hlZHVsZV90b19jbG9zZV90aW1lb3V0GAUgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEmYKDG5leHVzX2hlYWRlchgGIAMoCzJQLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLk5leHVzT3BlcmF0aW9uU2NoZWR1bGVkRXZlbnRBdHRyaWJ1dGVzLk5leHVzSGVhZGVyRW50cnkSKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYByABKAMSEgoKcmVxdWVzdF9pZBgIIAEoCRITCgtlbmRwb2ludF9pZBgJIAEoCRoyChBOZXh1c0hlYWRlckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiiQEKJE5leHVzT3BlcmF0aW9uU3RhcnRlZEV2ZW50QXR0cmlidXRlcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYASABKAMSGAoMb3BlcmF0aW9uX2lkGAMgASgJQgIYARISCgpyZXF1ZXN0X2lkGAQgASgJEhcKD29wZXJhdGlvbl90b2tlbhgFIAEoCSKJAQomTmV4dXNPcGVyYXRpb25Db21wbGV0ZWRFdmVudEF0dHJpYnV0ZXMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAEgASgDEi8KBnJlc3VsdBgCIAEoCzIfLnRlbXBvcmFsLmFwaS5jb21tb24udjEuUGF5bG9hZBISCgpyZXF1ZXN0X2lkGAMgASgJIogBCiNOZXh1c09wZXJhdGlvbkZhaWxlZEV2ZW50QXR0cmlidXRlcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYASABKAMSMQoHZmFpbHVyZRgCIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSEgoKcmVxdWVzdF9pZBgDIAEoCSKKAQolTmV4dXNPcGVyYXRpb25UaW1lZE91dEV2ZW50QXR0cmlidXRlcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYASABKAMSMQoHZmFpbHVyZRgCIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSEgoKcmVxdWVzdF9pZBgDIAEoCSKKAQolTmV4dXNPcGVyYXRpb25DYW5jZWxlZEV2ZW50QXR0cmlidXRlcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYASABKAMSMQoHZmFpbHVyZRgCIAEoCzIgLnRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLkZhaWx1cmUSEgoKcmVxdWVzdF9pZBgDIAEoCSJ0CixOZXh1c09wZXJhdGlvbkNhbmNlbFJlcXVlc3RlZEV2ZW50QXR0cmlidXRlcxIaChJzY2hlZHVsZWRfZXZlbnRfaWQYASABKAMSKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYAiABKAMilwEKM05leHVzT3BlcmF0aW9uQ2FuY2VsUmVxdWVzdENvbXBsZXRlZEV2ZW50QXR0cmlidXRlcxIaChJyZXF1ZXN0ZWRfZXZlbnRfaWQYASABKAMSKAogd29ya2Zsb3dfdGFza19jb21wbGV0ZWRfZXZlbnRfaWQYAiABKAMSGgoSc2NoZWR1bGVkX2V2ZW50X2lkGAMgASgDIscBCjBOZXh1c09wZXJhdGlvbkNhbmNlbFJlcXVlc3RGYWlsZWRFdmVudEF0dHJpYnV0ZXMSGgoScmVxdWVzdGVkX2V2ZW50X2lkGAEgASgDEigKIHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2lkGAIgASgDEjEKB2ZhaWx1cmUYAyABKAsyIC50ZW1wb3JhbC5hcGkuZmFpbHVyZS52MS5GYWlsdXJlEhoKEnNjaGVkdWxlZF9ldmVudF9pZBgEIAEoAyK+OwoMSGlzdG9yeUV2ZW50EhAKCGV2ZW50X2lkGAEgASgDEi4KCmV2ZW50X3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjQKCmV2ZW50X3R5cGUYAyABKA4yIC50ZW1wb3JhbC5hcGkuZW51bXMudjEuRXZlbnRUeXBlEg8KB3ZlcnNpb24YBCABKAMSDwoHdGFza19pZBgFIAEoAxIaChF3b3JrZXJfbWF5X2lnbm9yZRisAiABKAgSOQoNdXNlcl9tZXRhZGF0YRitAiABKAsyIS50ZW1wb3JhbC5hcGkuc2RrLnYxLlVzZXJNZXRhZGF0YRIsCgVsaW5rcxiuAiADKAsyHC50ZW1wb3JhbC5hcGkuY29tbW9uLnYxLkxpbmsSdword29ya2Zsb3dfZXhlY3V0aW9uX3N0YXJ0ZWRfZXZlbnRfYXR0cmlidXRlcxgGIAEoCzJALnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uU3RhcnRlZEV2ZW50QXR0cmlidXRlc0gAEnsKLXdvcmtmbG93X2V4ZWN1dGlvbl9jb21wbGV0ZWRfZXZlbnRfYXR0cmlidXRlcxgHIAEoCzJCLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uQ29tcGxldGVkRXZlbnRBdHRyaWJ1dGVzSAASdQoqd29ya2Zsb3dfZXhlY3V0aW9uX2ZhaWxlZF9ldmVudF9hdHRyaWJ1dGVzGAggASgLMj8udGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRFdmVudEF0dHJpYnV0ZXNIABJ6Ci13b3JrZmxvd19leGVjdXRpb25fdGltZWRfb3V0X2V2ZW50X2F0dHJpYnV0ZXMYCSABKAsyQS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5Xb3JrZmxvd0V4ZWN1dGlvblRpbWVkT3V0RXZlbnRBdHRyaWJ1dGVzSAAScQood29ya2Zsb3dfdGFza19zY2hlZHVsZWRfZXZlbnRfYXR0cmlidXRlcxgKIAEoCzI9LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93VGFza1NjaGVkdWxlZEV2ZW50QXR0cmlidXRlc0gAEm0KJndvcmtmbG93X3Rhc2tfc3RhcnRlZF9ldmVudF9hdHRyaWJ1dGVzGAsgASgLMjsudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dUYXNrU3RhcnRlZEV2ZW50QXR0cmlidXRlc0gAEnEKKHdvcmtmbG93X3Rhc2tfY29tcGxldGVkX2V2ZW50X2F0dHJpYnV0ZXMYDCABKAsyPS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5Xb3JrZmxvd1Rhc2tDb21wbGV0ZWRFdmVudEF0dHJpYnV0ZXNIABJwCih3b3JrZmxvd190YXNrX3RpbWVkX291dF9ldmVudF9hdHRyaWJ1dGVzGA0gASgLMjwudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dUYXNrVGltZWRPdXRFdmVudEF0dHJpYnV0ZXNIABJrCiV3b3JrZmxvd190YXNrX2ZhaWxlZF9ldmVudF9hdHRyaWJ1dGVzGA4gASgLMjoudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dUYXNrRmFpbGVkRXZlbnRBdHRyaWJ1dGVzSAAScQooYWN0aXZpdHlfdGFza19zY2hlZHVsZWRfZXZlbnRfYXR0cmlidXRlcxgPIAEoCzI9LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkFjdGl2aXR5VGFza1NjaGVkdWxlZEV2ZW50QXR0cmlidXRlc0gAEm0KJmFjdGl2aXR5X3Rhc2tfc3RhcnRlZF9ldmVudF9hdHRyaWJ1dGVzGBAgASgLMjsudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQWN0aXZpdHlUYXNrU3RhcnRlZEV2ZW50QXR0cmlidXRlc0gAEnEKKGFjdGl2aXR5X3Rhc2tfY29tcGxldGVkX2V2ZW50X2F0dHJpYnV0ZXMYESABKAsyPS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5BY3Rpdml0eVRhc2tDb21wbGV0ZWRFdmVudEF0dHJpYnV0ZXNIABJrCiVhY3Rpdml0eV90YXNrX2ZhaWxlZF9ldmVudF9hdHRyaWJ1dGVzGBIgASgLMjoudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQWN0aXZpdHlUYXNrRmFpbGVkRXZlbnRBdHRyaWJ1dGVzSAAScAooYWN0aXZpdHlfdGFza190aW1lZF9vdXRfZXZlbnRfYXR0cmlidXRlcxgTIAEoCzI8LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkFjdGl2aXR5VGFza1RpbWVkT3V0RXZlbnRBdHRyaWJ1dGVzSAASXgoedGltZXJfc3RhcnRlZF9ldmVudF9hdHRyaWJ1dGVzGBQgASgLMjQudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuVGltZXJTdGFydGVkRXZlbnRBdHRyaWJ1dGVzSAASWgocdGltZXJfZmlyZWRfZXZlbnRfYXR0cmlidXRlcxgVIAEoCzIyLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLlRpbWVyRmlyZWRFdmVudEF0dHJpYnV0ZXNIABJ+Ci9hY3Rpdml0eV90YXNrX2NhbmNlbF9yZXF1ZXN0ZWRfZXZlbnRfYXR0cmlidXRlcxgWIAEoCzJDLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkFjdGl2aXR5VGFza0NhbmNlbFJlcXVlc3RlZEV2ZW50QXR0cmlidXRlc0gAEm8KJ2FjdGl2aXR5X3Rhc2tfY2FuY2VsZWRfZXZlbnRfYXR0cmlidXRlcxgXIAEoCzI8LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkFjdGl2aXR5VGFza0NhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzSAASYAofdGltZXJfY2FuY2VsZWRfZXZlbnRfYXR0cmlidXRlcxgYIAEoCzI1LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLlRpbWVyQ2FuY2VsZWRFdmVudEF0dHJpYnV0ZXNIABJiCiBtYXJrZXJfcmVjb3JkZWRfZXZlbnRfYXR0cmlidXRlcxgZIAEoCzI2LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLk1hcmtlclJlY29yZGVkRXZlbnRBdHRyaWJ1dGVzSAASeQosd29ya2Zsb3dfZXhlY3V0aW9uX3NpZ25hbGVkX2V2ZW50X2F0dHJpYnV0ZXMYGiABKAsyQS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5Xb3JrZmxvd0V4ZWN1dGlvblNpZ25hbGVkRXZlbnRBdHRyaWJ1dGVzSAASfQoud29ya2Zsb3dfZXhlY3V0aW9uX3Rlcm1pbmF0ZWRfZXZlbnRfYXR0cmlidXRlcxgbIAEoCzJDLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uVGVybWluYXRlZEV2ZW50QXR0cmlidXRlc0gAEogBCjR3b3JrZmxvd19leGVjdXRpb25fY2FuY2VsX3JlcXVlc3RlZF9ldmVudF9hdHRyaWJ1dGVzGBwgASgLMkgudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dFeGVjdXRpb25DYW5jZWxSZXF1ZXN0ZWRFdmVudEF0dHJpYnV0ZXNIABJ5Cix3b3JrZmxvd19leGVjdXRpb25fY2FuY2VsZWRfZXZlbnRfYXR0cmlidXRlcxgdIAEoCzJBLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uQ2FuY2VsZWRFdmVudEF0dHJpYnV0ZXNIABKoAQpFcmVxdWVzdF9jYW5jZWxfZXh0ZXJuYWxfd29ya2Zsb3dfZXhlY3V0aW9uX2luaXRpYXRlZF9ldmVudF9hdHRyaWJ1dGVzGB4gASgLMlcudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25Jbml0aWF0ZWRFdmVudEF0dHJpYnV0ZXNIABKiAQpCcmVxdWVzdF9jYW5jZWxfZXh0ZXJuYWxfd29ya2Zsb3dfZXhlY3V0aW9uX2ZhaWxlZF9ldmVudF9hdHRyaWJ1dGVzGB8gASgLMlQudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRFdmVudEF0dHJpYnV0ZXNIABKZAQo9ZXh0ZXJuYWxfd29ya2Zsb3dfZXhlY3V0aW9uX2NhbmNlbF9yZXF1ZXN0ZWRfZXZlbnRfYXR0cmlidXRlcxggIAEoCzJQLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25DYW5jZWxSZXF1ZXN0ZWRFdmVudEF0dHJpYnV0ZXNIABKHAQo0d29ya2Zsb3dfZXhlY3V0aW9uX2NvbnRpbnVlZF9hc19uZXdfZXZlbnRfYXR0cmlidXRlcxghIAEoCzJHLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uQ29udGludWVkQXNOZXdFdmVudEF0dHJpYnV0ZXNIABKRAQo5c3RhcnRfY2hpbGRfd29ya2Zsb3dfZXhlY3V0aW9uX2luaXRpYXRlZF9ldmVudF9hdHRyaWJ1dGVzGCIgASgLMkwudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5pdGlhdGVkRXZlbnRBdHRyaWJ1dGVzSAASiwEKNnN0YXJ0X2NoaWxkX3dvcmtmbG93X2V4ZWN1dGlvbl9mYWlsZWRfZXZlbnRfYXR0cmlidXRlcxgjIAEoCzJJLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLlN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZEV2ZW50QXR0cmlidXRlc0gAEoIBCjFjaGlsZF93b3JrZmxvd19leGVjdXRpb25fc3RhcnRlZF9ldmVudF9hdHRyaWJ1dGVzGCQgASgLMkUudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblN0YXJ0ZWRFdmVudEF0dHJpYnV0ZXNIABKGAQozY2hpbGRfd29ya2Zsb3dfZXhlY3V0aW9uX2NvbXBsZXRlZF9ldmVudF9hdHRyaWJ1dGVzGCUgASgLMkcudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkNvbXBsZXRlZEV2ZW50QXR0cmlidXRlc0gAEoABCjBjaGlsZF93b3JrZmxvd19leGVjdXRpb25fZmFpbGVkX2V2ZW50X2F0dHJpYnV0ZXMYJiABKAsyRC50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5DaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzSAAShAEKMmNoaWxkX3dvcmtmbG93X2V4ZWN1dGlvbl9jYW5jZWxlZF9ldmVudF9hdHRyaWJ1dGVzGCcgASgLMkYudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkNhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzSAAShQEKM2NoaWxkX3dvcmtmbG93X2V4ZWN1dGlvbl90aW1lZF9vdXRfZXZlbnRfYXR0cmlidXRlcxgoIAEoCzJGLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkNoaWxkV29ya2Zsb3dFeGVjdXRpb25UaW1lZE91dEV2ZW50QXR0cmlidXRlc0gAEogBCjRjaGlsZF93b3JrZmxvd19leGVjdXRpb25fdGVybWluYXRlZF9ldmVudF9hdHRyaWJ1dGVzGCkgASgLMkgudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblRlcm1pbmF0ZWRFdmVudEF0dHJpYnV0ZXNIABKZAQo9c2lnbmFsX2V4dGVybmFsX3dvcmtmbG93X2V4ZWN1dGlvbl9pbml0aWF0ZWRfZXZlbnRfYXR0cmlidXRlcxgqIAEoCzJQLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLlNpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25Jbml0aWF0ZWRFdmVudEF0dHJpYnV0ZXNIABKTAQo6c2lnbmFsX2V4dGVybmFsX3dvcmtmbG93X2V4ZWN1dGlvbl9mYWlsZWRfZXZlbnRfYXR0cmlidXRlcxgrIAEoCzJNLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLlNpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRFdmVudEF0dHJpYnV0ZXNIABKKAQo1ZXh0ZXJuYWxfd29ya2Zsb3dfZXhlY3V0aW9uX3NpZ25hbGVkX2V2ZW50X2F0dHJpYnV0ZXMYLCABKAsySS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5FeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uU2lnbmFsZWRFdmVudEF0dHJpYnV0ZXNIABKEAQoydXBzZXJ0X3dvcmtmbG93X3NlYXJjaF9hdHRyaWJ1dGVzX2V2ZW50X2F0dHJpYnV0ZXMYLSABKAsyRi50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5VcHNlcnRXb3JrZmxvd1NlYXJjaEF0dHJpYnV0ZXNFdmVudEF0dHJpYnV0ZXNIABKGAQozd29ya2Zsb3dfZXhlY3V0aW9uX3VwZGF0ZV9hY2NlcHRlZF9ldmVudF9hdHRyaWJ1dGVzGC4gASgLMkcudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dFeGVjdXRpb25VcGRhdGVBY2NlcHRlZEV2ZW50QXR0cmlidXRlc0gAEoYBCjN3b3JrZmxvd19leGVjdXRpb25fdXBkYXRlX3JlamVjdGVkX2V2ZW50X2F0dHJpYnV0ZXMYLyABKAsyRy50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5Xb3JrZmxvd0V4ZWN1dGlvblVwZGF0ZVJlamVjdGVkRXZlbnRBdHRyaWJ1dGVzSAASiAEKNHdvcmtmbG93X2V4ZWN1dGlvbl91cGRhdGVfY29tcGxldGVkX2V2ZW50X2F0dHJpYnV0ZXMYMCABKAsySC50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5Xb3JrZmxvd0V4ZWN1dGlvblVwZGF0ZUNvbXBsZXRlZEV2ZW50QXR0cmlidXRlc0gAEpABCjh3b3JrZmxvd19wcm9wZXJ0aWVzX21vZGlmaWVkX2V4dGVybmFsbHlfZXZlbnRfYXR0cmlidXRlcxgxIAEoCzJMLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93UHJvcGVydGllc01vZGlmaWVkRXh0ZXJuYWxseUV2ZW50QXR0cmlidXRlc0gAEpABCjhhY3Rpdml0eV9wcm9wZXJ0aWVzX21vZGlmaWVkX2V4dGVybmFsbHlfZXZlbnRfYXR0cmlidXRlcxgyIAEoCzJMLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkFjdGl2aXR5UHJvcGVydGllc01vZGlmaWVkRXh0ZXJuYWxseUV2ZW50QXR0cmlidXRlc0gAEnsKLXdvcmtmbG93X3Byb3BlcnRpZXNfbW9kaWZpZWRfZXZlbnRfYXR0cmlidXRlcxgzIAEoCzJCLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93UHJvcGVydGllc01vZGlmaWVkRXZlbnRBdHRyaWJ1dGVzSAAShgEKM3dvcmtmbG93X2V4ZWN1dGlvbl91cGRhdGVfYWRtaXR0ZWRfZXZlbnRfYXR0cmlidXRlcxg0IAEoCzJHLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLldvcmtmbG93RXhlY3V0aW9uVXBkYXRlQWRtaXR0ZWRFdmVudEF0dHJpYnV0ZXNIABJ1CipuZXh1c19vcGVyYXRpb25fc2NoZWR1bGVkX2V2ZW50X2F0dHJpYnV0ZXMYNSABKAsyPy50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5OZXh1c09wZXJhdGlvblNjaGVkdWxlZEV2ZW50QXR0cmlidXRlc0gAEnEKKG5leHVzX29wZXJhdGlvbl9zdGFydGVkX2V2ZW50X2F0dHJpYnV0ZXMYNiABKAsyPS50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5OZXh1c09wZXJhdGlvblN0YXJ0ZWRFdmVudEF0dHJpYnV0ZXNIABJ1CipuZXh1c19vcGVyYXRpb25fY29tcGxldGVkX2V2ZW50X2F0dHJpYnV0ZXMYNyABKAsyPy50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5OZXh1c09wZXJhdGlvbkNvbXBsZXRlZEV2ZW50QXR0cmlidXRlc0gAEm8KJ25leHVzX29wZXJhdGlvbl9mYWlsZWRfZXZlbnRfYXR0cmlidXRlcxg4IAEoCzI8LnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLk5leHVzT3BlcmF0aW9uRmFpbGVkRXZlbnRBdHRyaWJ1dGVzSAAScwopbmV4dXNfb3BlcmF0aW9uX2NhbmNlbGVkX2V2ZW50X2F0dHJpYnV0ZXMYOSABKAsyPi50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5OZXh1c09wZXJhdGlvbkNhbmNlbGVkRXZlbnRBdHRyaWJ1dGVzSAASdAoqbmV4dXNfb3BlcmF0aW9uX3RpbWVkX291dF9ldmVudF9hdHRyaWJ1dGVzGDogASgLMj4udGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuTmV4dXNPcGVyYXRpb25UaW1lZE91dEV2ZW50QXR0cmlidXRlc0gAEoIBCjFuZXh1c19vcGVyYXRpb25fY2FuY2VsX3JlcXVlc3RlZF9ldmVudF9hdHRyaWJ1dGVzGDsgASgLMkUudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuTmV4dXNPcGVyYXRpb25DYW5jZWxSZXF1ZXN0ZWRFdmVudEF0dHJpYnV0ZXNIABKGAQozd29ya2Zsb3dfZXhlY3V0aW9uX29wdGlvbnNfdXBkYXRlZF9ldmVudF9hdHRyaWJ1dGVzGDwgASgLMkcudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuV29ya2Zsb3dFeGVjdXRpb25PcHRpb25zVXBkYXRlZEV2ZW50QXR0cmlidXRlc0gAEpEBCjluZXh1c19vcGVyYXRpb25fY2FuY2VsX3JlcXVlc3RfY29tcGxldGVkX2V2ZW50X2F0dHJpYnV0ZXMYPSABKAsyTC50ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5OZXh1c09wZXJhdGlvbkNhbmNlbFJlcXVlc3RDb21wbGV0ZWRFdmVudEF0dHJpYnV0ZXNIABKLAQo2bmV4dXNfb3BlcmF0aW9uX2NhbmNlbF9yZXF1ZXN0X2ZhaWxlZF9ldmVudF9hdHRyaWJ1dGVzGD4gASgLMkkudGVtcG9yYWwuYXBpLmhpc3RvcnkudjEuTmV4dXNPcGVyYXRpb25DYW5jZWxSZXF1ZXN0RmFpbGVkRXZlbnRBdHRyaWJ1dGVzSABCDAoKYXR0cmlidXRlcyJACgdIaXN0b3J5EjUKBmV2ZW50cxgBIAMoCzIlLnRlbXBvcmFsLmFwaS5oaXN0b3J5LnYxLkhpc3RvcnlFdmVudEKOAQoaaW8udGVtcG9yYWwuYXBpLmhpc3RvcnkudjFCDE1lc3NhZ2VQcm90b1ABWiVnby50ZW1wb3JhbC5pby9hcGkvaGlzdG9yeS92MTtoaXN0b3J5qgIZVGVtcG9yYWxpby5BcGkuSGlzdG9yeS5WMeoCHFRlbXBvcmFsaW86OkFwaTo6SGlzdG9yeTo6VjFiBnByb3RvMw", [file_google_protobuf_duration, file_google_protobuf_timestamp, file_temporal_api_enums_v1_event_type, file_temporal_api_enums_v1_failed_cause, file_temporal_api_enums_v1_update, file_temporal_api_enums_v1_workflow, file_temporal_api_common_v1_message, file_temporal_api_deployment_v1_message, file_temporal_api_failure_v1_message, file_temporal_api_taskqueue_v1_message, file_temporal_api_update_v1_message, file_temporal_api_workflow_v1_message, file_temporal_api_sdk_v1_task_complete_metadata, file_temporal_api_sdk_v1_user_metadata]);

/**
 * Always the first event in workflow history
 *
 * @generated from message temporal.api.history.v1.WorkflowExecutionStartedEventAttributes
 */
export type WorkflowExecutionStartedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionStartedEventAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 1;
   */
  workflowType?: WorkflowType;

  /**
   * If this workflow is a child, the namespace our parent lives in.
   * SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only.
   *
   * @generated from field: string parent_workflow_namespace = 2;
   */
  parentWorkflowNamespace: string;

  /**
   * @generated from field: string parent_workflow_namespace_id = 27;
   */
  parentWorkflowNamespaceId: string;

  /**
   * Contains information about parent workflow execution that initiated the child workflow these attributes belong to.
   * If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution parent_workflow_execution = 3;
   */
  parentWorkflowExecution?: WorkflowExecution;

  /**
   * EventID of the child execution initiated event in parent workflow
   *
   * @generated from field: int64 parent_initiated_event_id = 4;
   */
  parentInitiatedEventId: bigint;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 5;
   */
  taskQueue?: TaskQueue;

  /**
   * SDK will deserialize this and provide it as arguments to the workflow function
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 6;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 7;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 8;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 9;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Run id of the previous workflow which continued-as-new or retried or cron executed into this
   * workflow.
   *
   * @generated from field: string continued_execution_run_id = 10;
   */
  continuedExecutionRunId: string;

  /**
   * @generated from field: temporal.api.enums.v1.ContinueAsNewInitiator initiator = 11;
   */
  initiator: ContinueAsNewInitiator;

  /**
   * @generated from field: temporal.api.failure.v1.Failure continued_failure = 12;
   */
  continuedFailure?: Failure;

  /**
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 13;
   */
  lastCompletionResult?: Payloads;

  /**
   * This is the run id when the WorkflowExecutionStarted event was written.
   * A workflow reset changes the execution run_id, but preserves this field.
   *
   * @generated from field: string original_execution_run_id = 14;
   */
  originalExecutionRunId: string;

  /**
   * Identity of the client who requested this execution
   *
   * @generated from field: string identity = 15;
   */
  identity: string;

  /**
   * This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
   * Used to identify a chain.
   *
   * @generated from field: string first_execution_run_id = 16;
   */
  firstExecutionRunId: string;

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 17;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Starting at 1, the number of times we have tried to execute this workflow
   *
   * @generated from field: int32 attempt = 18;
   */
  attempt: number;

  /**
   * The absolute time at which the workflow will be timed out.
   * This is passed without change to the next run/retry of a workflow.
   *
   * @generated from field: google.protobuf.Timestamp workflow_execution_expiration_time = 19;
   */
  workflowExecutionExpirationTime?: Timestamp;

  /**
   * If this workflow runs on a cron schedule, it will appear here
   *
   * @generated from field: string cron_schedule = 20;
   */
  cronSchedule: string;

  /**
   * For a cron workflow, this contains the amount of time between when this iteration of
   * the cron workflow was scheduled and when it should run next per its cron_schedule.
   *
   * @generated from field: google.protobuf.Duration first_workflow_task_backoff = 21;
   */
  firstWorkflowTaskBackoff?: Duration;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 22;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 23;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.workflow.v1.ResetPoints prev_auto_reset_points = 24;
   */
  prevAutoResetPoints?: ResetPoints;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 25;
   */
  header?: Header;

  /**
   * Version of the child execution initiated event in parent workflow
   * It should be used together with parent_initiated_event_id to identify
   * a child initiated event for global namespace
   *
   * @generated from field: int64 parent_initiated_event_version = 26;
   */
  parentInitiatedEventVersion: bigint;

  /**
   * This field is new in 1.21.
   *
   * @generated from field: string workflow_id = 28;
   */
  workflowId: string;

  /**
   * If this workflow intends to use anything other than the current overall default version for
   * the queue, then we include it here.
   * Deprecated. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp source_version_stamp = 29 [deprecated = true];
   * @deprecated
   */
  sourceVersionStamp?: WorkerVersionStamp;

  /**
   * Completion callbacks attached when this workflow was started.
   *
   * @generated from field: repeated temporal.api.common.v1.Callback completion_callbacks = 30;
   */
  completionCallbacks: Callback[];

  /**
   * Contains information about the root workflow execution.
   * The root workflow execution is defined as follows:
   *   1. A workflow without parent workflow is its own root workflow.
   *   2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
   * When the workflow is its own root workflow, then root_workflow_execution is nil.
   * Note: workflows continued as new or reseted may or may not have parents, check examples below.
   *
   * Examples:
   *   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
   *     - The root workflow of all three workflows is W1.
   *     - W1 has root_workflow_execution set to nil.
   *     - W2 and W3 have root_workflow_execution set to W1.
   *   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
   *     - The root workflow of all three workflows is W1.
   *     - W1 has root_workflow_execution set to nil.
   *     - W2 and W3 have root_workflow_execution set to W1.
   *   Scenario 3: Workflow W1 continued as new W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *     - W1 and W2 have root_workflow_execution set to nil.
   *   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
   *     - The root workflow of all three workflows is W1.
   *     - W1 has root_workflow_execution set to nil.
   *     - W2 and W3 have root_workflow_execution set to W1.
   *   Scenario 5: Workflow W1 is reseted, creating W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *     - W1 and W2 have root_workflow_execution set to nil.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution root_workflow_execution = 31;
   */
  rootWorkflowExecution?: WorkflowExecution;

  /**
   * When present, this execution is assigned to the build ID of its parent or previous execution.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string inherited_build_id = 32 [deprecated = true];
   * @deprecated
   */
  inheritedBuildId: string;

  /**
   * Versioning override applied to this workflow when it was started.
   * Children, crons, retries, and continue-as-new will inherit source run's override if pinned
   * and if the new workflow's Task Queue belongs to the override version.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 33;
   */
  versioningOverride?: VersioningOverride;

  /**
   * When present, it means this is a child workflow of a parent that is Pinned to this Worker
   * Deployment Version. In this case, child workflow will start as Pinned to this Version instead
   * of starting on the Current Version of its Task Queue.
   * This is set only if the child workflow is starting on a Task Queue belonging to the same
   * Worker Deployment Version.
   * Deprecated. Use `parent_versioning_info`.
   *
   * @generated from field: string parent_pinned_worker_deployment_version = 34 [deprecated = true];
   * @deprecated
   */
  parentPinnedWorkerDeploymentVersion: string;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 35;
   */
  priority?: Priority;

  /**
   * If present, the new workflow should start on this version with pinned base behavior.
   * Child of pinned parent will inherit the parent's version if the Child's Task Queue belongs to that version.
   *
   * New run initiated by workflow ContinueAsNew of pinned run, will inherit the previous run's version if the
   * new run's Task Queue belongs to that version.
   *
   * New run initiated by workflow Cron will never inherit.
   *
   * New run initiated by workflow Retry will only inherit if the retried run is effectively pinned at the time
   * of retry, and the retried run inherited a pinned version when it started (ie. it is a child of a pinned
   * parent, or a CaN of a pinned run, and is running on a Task Queue in the inherited version).
   *
   * Pinned override is inherited if Task Queue of new run is compatible with the override version.
   * Override is inherited separately and takes precedence over inherited base version.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion inherited_pinned_version = 37;
   */
  inheritedPinnedVersion?: WorkerDeploymentVersion;

  /**
   * A boolean indicating whether the SDK has asked to eagerly execute the first workflow task for this workflow and
   * eager execution was accepted by the server.
   * Only populated by server with version >= 1.29.0.
   *
   * @generated from field: bool eager_execution_accepted = 38;
   */
  eagerExecutionAccepted: boolean;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionStartedEventAttributes.
 * Use `create(WorkflowExecutionStartedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionStartedEventAttributesSchema: GenMessage<WorkflowExecutionStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 0);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionCompletedEventAttributes
 */
export type WorkflowExecutionCompletedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionCompletedEventAttributes"> & {
  /**
   * Serialized result of workflow completion (ie: The return value of the workflow function)
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 1;
   */
  result?: Payloads;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * If another run is started by cron, this contains the new run id.
   *
   * @generated from field: string new_execution_run_id = 3;
   */
  newExecutionRunId: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionCompletedEventAttributes.
 * Use `create(WorkflowExecutionCompletedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionCompletedEventAttributesSchema: GenMessage<WorkflowExecutionCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 1);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionFailedEventAttributes
 */
export type WorkflowExecutionFailedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionFailedEventAttributes"> & {
  /**
   * Serialized result of workflow failure (ex: An exception thrown, or error returned)
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 2;
   */
  retryState: RetryState;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 3;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * If another run is started by cron or retry, this contains the new run id.
   *
   * @generated from field: string new_execution_run_id = 4;
   */
  newExecutionRunId: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionFailedEventAttributes.
 * Use `create(WorkflowExecutionFailedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionFailedEventAttributesSchema: GenMessage<WorkflowExecutionFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 2);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionTimedOutEventAttributes
 */
export type WorkflowExecutionTimedOutEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionTimedOutEventAttributes"> & {
  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 1;
   */
  retryState: RetryState;

  /**
   * If another run is started by cron or retry, this contains the new run id.
   *
   * @generated from field: string new_execution_run_id = 2;
   */
  newExecutionRunId: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionTimedOutEventAttributes.
 * Use `create(WorkflowExecutionTimedOutEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionTimedOutEventAttributesSchema: GenMessage<WorkflowExecutionTimedOutEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 3);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionContinuedAsNewEventAttributes
 */
export type WorkflowExecutionContinuedAsNewEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionContinuedAsNewEventAttributes"> & {
  /**
   * The run ID of the new workflow started by this continue-as-new
   *
   * @generated from field: string new_execution_run_id = 1;
   */
  newExecutionRunId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 5;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 6;
   */
  workflowTaskTimeout?: Duration;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 7;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * How long the server will wait before scheduling the first workflow task for the new run.
   * Used for cron, retry, and other continue-as-new cases that server may enforce some minimal
   * delay between new runs for system protection purpose.
   *
   * @generated from field: google.protobuf.Duration backoff_start_interval = 8;
   */
  backoffStartInterval?: Duration;

  /**
   * @generated from field: temporal.api.enums.v1.ContinueAsNewInitiator initiator = 9;
   */
  initiator: ContinueAsNewInitiator;

  /**
   * Deprecated. If a workflow's retry policy would cause a new run to start when the current one
   * has failed, this field would be populated with that failure. Now (when supported by server
   * and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 10 [deprecated = true];
   * @deprecated
   */
  failure?: Failure;

  /**
   * The result from the most recent completed run of this workflow. The SDK surfaces this to the
   * new run via APIs such as `GetLastCompletionResult`.
   *
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 11;
   */
  lastCompletionResult?: Payloads;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 12;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 13;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 14;
   */
  searchAttributes?: SearchAttributes;

  /**
   * If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
   * the assignment rules will be used to independently assign a Build ID to the new execution.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 15 [deprecated = true];
   * @deprecated
   */
  inheritBuildId: boolean;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionContinuedAsNewEventAttributes.
 * Use `create(WorkflowExecutionContinuedAsNewEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionContinuedAsNewEventAttributesSchema: GenMessage<WorkflowExecutionContinuedAsNewEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 4);

/**
 * @generated from message temporal.api.history.v1.WorkflowTaskScheduledEventAttributes
 */
export type WorkflowTaskScheduledEventAttributes = Message<"temporal.api.history.v1.WorkflowTaskScheduledEventAttributes"> & {
  /**
   * The task queue this workflow task was enqueued in, which could be a normal or sticky queue
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
   */
  taskQueue?: TaskQueue;

  /**
   * How long the worker has to process this task once receiving it before it times out
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 2;
   */
  startToCloseTimeout?: Duration;

  /**
   * Starting at 1, how many attempts there have been to complete this task
   *
   * @generated from field: int32 attempt = 3;
   */
  attempt: number;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowTaskScheduledEventAttributes.
 * Use `create(WorkflowTaskScheduledEventAttributesSchema)` to create a new message.
 */
export const WorkflowTaskScheduledEventAttributesSchema: GenMessage<WorkflowTaskScheduledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 5);

/**
 * @generated from message temporal.api.history.v1.WorkflowTaskStartedEventAttributes
 */
export type WorkflowTaskStartedEventAttributes = Message<"temporal.api.history.v1.WorkflowTaskStartedEventAttributes"> & {
  /**
   * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * Identity of the worker who picked up this task
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * This field is populated from the RecordWorkflowTaskStartedRequest. Matching service would
   * set the request_id on the RecordWorkflowTaskStartedRequest to a new UUID. This is useful
   * in case a RecordWorkflowTaskStarted call succeed but matching doesn't get that response,
   * so matching could retry and history service would return success if the request_id matches.
   * In that case, matching will continue to deliver the task to worker. Without this field, history
   * service would return AlreadyStarted error, and matching would drop the task.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;

  /**
   * True if this workflow should continue-as-new soon because its history size (in
   * either event count or bytes) is getting large.
   *
   * @generated from field: bool suggest_continue_as_new = 4;
   */
  suggestContinueAsNew: boolean;

  /**
   * Total history size in bytes, which the workflow might use to decide when to
   * continue-as-new regardless of the suggestion. Note that history event count is
   * just the event id of this event, so we don't include it explicitly here.
   *
   * @generated from field: int64 history_size_bytes = 5;
   */
  historySizeBytes: bigint;

  /**
   * Version info of the worker to whom this task was dispatched.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Used by server internally to properly reapply build ID redirects to an execution
   * when rebuilding it from events.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: int64 build_id_redirect_counter = 7 [deprecated = true];
   * @deprecated
   */
  buildIdRedirectCounter: bigint;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowTaskStartedEventAttributes.
 * Use `create(WorkflowTaskStartedEventAttributesSchema)` to create a new message.
 */
export const WorkflowTaskStartedEventAttributesSchema: GenMessage<WorkflowTaskStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 6);

/**
 * @generated from message temporal.api.history.v1.WorkflowTaskCompletedEventAttributes
 */
export type WorkflowTaskCompletedEventAttributes = Message<"temporal.api.history.v1.WorkflowTaskCompletedEventAttributes"> & {
  /**
   * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
   *
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId: bigint;

  /**
   * Identity of the worker who completed this task
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Binary ID of the worker who completed this task
   * Deprecated. Replaced with `deployment_version`.
   *
   * @generated from field: string binary_checksum = 4 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * Version info of the worker who processed this workflow task. If present, the `build_id` field
   * within is also used as `binary_checksum`, which may be omitted in that case (it may also be
   * populated to preserve compatibility).
   * Deprecated. Use `deployment_version` and `versioning_behavior` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Data the SDK wishes to record for itself, but server need not interpret, and does not
   * directly impact workflow state.
   *
   * @generated from field: temporal.api.sdk.v1.WorkflowTaskCompletedMetadata sdk_metadata = 6;
   */
  sdkMetadata?: WorkflowTaskCompletedMetadata;

  /**
   * Local usage data sent during workflow task completion and recorded here for posterity
   *
   * @generated from field: temporal.api.common.v1.MeteringMetadata metering_metadata = 13;
   */
  meteringMetadata?: MeteringMetadata;

  /**
   * The deployment that completed this task. May or may not be set for unversioned workers,
   * depending on whether a value is sent by the SDK. This value updates workflow execution's
   * `versioning_info.deployment`.
   * Deprecated. Replaced with `deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 7 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Versioning behavior sent by the worker that completed this task for this particular workflow
   * execution. UNSPECIFIED means the task was completed by an unversioned worker. This value
   * updates workflow execution's `versioning_info.behavior`.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior versioning_behavior = 8;
   */
  versioningBehavior: VersioningBehavior;

  /**
   * The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
   * is set. This value updates workflow execution's `versioning_info.version`.
   * Experimental. Worker Deployments are experimental and might significantly change in the future.
   * Deprecated. Replaced with `deployment_version`.
   *
   * @generated from field: string worker_deployment_version = 9 [deprecated = true];
   * @deprecated
   */
  workerDeploymentVersion: string;

  /**
   * The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`
   * is set. This value updates workflow execution's `worker_deployment_name`.
   * Experimental. Worker Deployments are experimental and might significantly change in the future.
   *
   * @generated from field: string worker_deployment_name = 10;
   */
  workerDeploymentName: string;

  /**
   * The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
   * is set. This value updates workflow execution's `versioning_info.deployment_version`.
   * Experimental. Worker Deployments are experimental and might significantly change in the future.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 11;
   */
  deploymentVersion?: WorkerDeploymentVersion;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowTaskCompletedEventAttributes.
 * Use `create(WorkflowTaskCompletedEventAttributesSchema)` to create a new message.
 */
export const WorkflowTaskCompletedEventAttributesSchema: GenMessage<WorkflowTaskCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 7);

/**
 * @generated from message temporal.api.history.v1.WorkflowTaskTimedOutEventAttributes
 */
export type WorkflowTaskTimedOutEventAttributes = Message<"temporal.api.history.v1.WorkflowTaskTimedOutEventAttributes"> & {
  /**
   * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
   *
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.TimeoutType timeout_type = 3;
   */
  timeoutType: TimeoutType;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowTaskTimedOutEventAttributes.
 * Use `create(WorkflowTaskTimedOutEventAttributesSchema)` to create a new message.
 */
export const WorkflowTaskTimedOutEventAttributesSchema: GenMessage<WorkflowTaskTimedOutEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 8);

/**
 * @generated from message temporal.api.history.v1.WorkflowTaskFailedEventAttributes
 */
export type WorkflowTaskFailedEventAttributes = Message<"temporal.api.history.v1.WorkflowTaskFailedEventAttributes"> & {
  /**
   * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
   *
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.WorkflowTaskFailedCause cause = 3;
   */
  cause: WorkflowTaskFailedCause;

  /**
   * The failure details
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 4;
   */
  failure?: Failure;

  /**
   * If a worker explicitly failed this task, this field contains the worker's identity. 
   * When the server generates the failure internally this field is set as 'history-service'.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * The original run id of the workflow. For reset workflow.
   *
   * @generated from field: string base_run_id = 6;
   */
  baseRunId: string;

  /**
   * If the workflow is being reset, the new run id.
   *
   * @generated from field: string new_run_id = 7;
   */
  newRunId: string;

  /**
   * Version of the event where the history branch was forked. Used by multi-cluster replication
   * during resets to identify the correct history branch.
   *
   * @generated from field: int64 fork_event_version = 8;
   */
  forkEventVersion: bigint;

  /**
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   * If a worker explicitly failed this task, its binary id
   *
   * @generated from field: string binary_checksum = 9 [deprecated = true];
   * @deprecated
   */
  binaryChecksum: string;

  /**
   * Version info of the worker who processed this workflow task. If present, the `build_id` field
   * within is also used as `binary_checksum`, which may be omitted in that case (it may also be
   * populated to preserve compatibility).
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 10 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowTaskFailedEventAttributes.
 * Use `create(WorkflowTaskFailedEventAttributesSchema)` to create a new message.
 */
export const WorkflowTaskFailedEventAttributesSchema: GenMessage<WorkflowTaskFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 9);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskScheduledEventAttributes
 */
export type ActivityTaskScheduledEventAttributes = Message<"temporal.api.history.v1.ActivityTaskScheduledEventAttributes"> & {
  /**
   * The worker/user assigned identifier for the activity
   *
   * @generated from field: string activity_id = 1;
   */
  activityId: string;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 5;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 6;
   */
  input?: Payloads;

  /**
   * Indicates how long the caller is willing to wait for an activity completion. Limits how long
   * retries will be attempted. Either this or `start_to_close_timeout` must be specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 7;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Limits time an activity task can stay in a task queue before a worker picks it up. This
   * timeout is always non retryable, as all a retry would achieve is to put it back into the same
   * queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
   * specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 8;
   */
  scheduleToStartTimeout?: Duration;

  /**
   * Maximum time an activity is allowed to execute after being picked up by a worker. This
   * timeout is always retryable. Either this or `schedule_to_close_timeout` must be
   * specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 9;
   */
  startToCloseTimeout?: Duration;

  /**
   * Maximum permitted time between successful worker heartbeats.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 10;
   */
  heartbeatTimeout?: Duration;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 11;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Activities are assigned a default retry policy controlled by the service's dynamic
   * configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set
   * retry_policy.maximum_attempts to 1.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 12;
   */
  retryPolicy?: RetryPolicy;

  /**
   * If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
   * Assignment rules of the activity's Task Queue will be used to determine the Build ID.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: bool use_workflow_build_id = 13 [deprecated = true];
   * @deprecated
   */
  useWorkflowBuildId: boolean;

  /**
   * Priority metadata. If this message is not present, or any fields are not
   * present, they inherit the values from the workflow.
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 14;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskScheduledEventAttributes.
 * Use `create(ActivityTaskScheduledEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskScheduledEventAttributesSchema: GenMessage<ActivityTaskScheduledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 10);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskStartedEventAttributes
 */
export type ActivityTaskStartedEventAttributes = Message<"temporal.api.history.v1.ActivityTaskStartedEventAttributes"> & {
  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * id of the worker that picked up this task
   *
   * @generated from field: string identity = 2;
   */
  identity: string;

  /**
   * This field is populated from the RecordActivityTaskStartedRequest. Matching service would
   * set the request_id on the RecordActivityTaskStartedRequest to a new UUID. This is useful
   * in case a RecordActivityTaskStarted call succeed but matching doesn't get that response,
   * so matching could retry and history service would return success if the request_id matches.
   * In that case, matching will continue to deliver the task to worker. Without this field, history
   * service would return AlreadyStarted error, and matching would drop the task.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;

  /**
   * Starting at 1, the number of times this task has been attempted
   *
   * @generated from field: int32 attempt = 4;
   */
  attempt: number;

  /**
   * Will be set to the most recent failure details, if this task has previously failed and then
   * been retried.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_failure = 5;
   */
  lastFailure?: Failure;

  /**
   * Version info of the worker to whom this task was dispatched.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Used by server internally to properly reapply build ID redirects to an execution
   * when rebuilding it from events.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: int64 build_id_redirect_counter = 7 [deprecated = true];
   * @deprecated
   */
  buildIdRedirectCounter: bigint;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskStartedEventAttributes.
 * Use `create(ActivityTaskStartedEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskStartedEventAttributesSchema: GenMessage<ActivityTaskStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 11);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskCompletedEventAttributes
 */
export type ActivityTaskCompletedEventAttributes = Message<"temporal.api.history.v1.ActivityTaskCompletedEventAttributes"> & {
  /**
   * Serialized results of the activity. IE: The return value of the activity function
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 1;
   */
  result?: Payloads;

  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 2;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to
   *
   * @generated from field: int64 started_event_id = 3;
   */
  startedEventId: bigint;

  /**
   * id of the worker that completed this task
   *
   * @generated from field: string identity = 4;
   */
  identity: string;

  /**
   * Version info of the worker who processed this workflow task.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskCompletedEventAttributes.
 * Use `create(ActivityTaskCompletedEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskCompletedEventAttributesSchema: GenMessage<ActivityTaskCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 12);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskFailedEventAttributes
 */
export type ActivityTaskFailedEventAttributes = Message<"temporal.api.history.v1.ActivityTaskFailedEventAttributes"> & {
  /**
   * Failure details
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure;

  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 2;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to
   *
   * @generated from field: int64 started_event_id = 3;
   */
  startedEventId: bigint;

  /**
   * id of the worker that failed this task
   *
   * @generated from field: string identity = 4;
   */
  identity: string;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 5;
   */
  retryState: RetryState;

  /**
   * Version info of the worker who processed this workflow task.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskFailedEventAttributes.
 * Use `create(ActivityTaskFailedEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskFailedEventAttributesSchema: GenMessage<ActivityTaskFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 13);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskTimedOutEventAttributes
 */
export type ActivityTaskTimedOutEventAttributes = Message<"temporal.api.history.v1.ActivityTaskTimedOutEventAttributes"> & {
  /**
   * If this activity had failed, was retried, and then timed out, that failure is stored as the
   * `cause` in here.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure;

  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 2;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to
   *
   * @generated from field: int64 started_event_id = 3;
   */
  startedEventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 4;
   */
  retryState: RetryState;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskTimedOutEventAttributes.
 * Use `create(ActivityTaskTimedOutEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskTimedOutEventAttributesSchema: GenMessage<ActivityTaskTimedOutEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 14);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskCancelRequestedEventAttributes
 */
export type ActivityTaskCancelRequestedEventAttributes = Message<"temporal.api.history.v1.ActivityTaskCancelRequestedEventAttributes"> & {
  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskCancelRequestedEventAttributes.
 * Use `create(ActivityTaskCancelRequestedEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskCancelRequestedEventAttributesSchema: GenMessage<ActivityTaskCancelRequestedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 15);

/**
 * @generated from message temporal.api.history.v1.ActivityTaskCanceledEventAttributes
 */
export type ActivityTaskCanceledEventAttributes = Message<"temporal.api.history.v1.ActivityTaskCanceledEventAttributes"> & {
  /**
   * Additional information that the activity reported upon confirming cancellation
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads;

  /**
   * id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
   * activity
   *
   * @generated from field: int64 latest_cancel_requested_event_id = 2;
   */
  latestCancelRequestedEventId: bigint;

  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to
   *
   * @generated from field: int64 scheduled_event_id = 3;
   */
  scheduledEventId: bigint;

  /**
   * The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to
   *
   * @generated from field: int64 started_event_id = 4;
   */
  startedEventId: bigint;

  /**
   * id of the worker who canceled this activity
   *
   * @generated from field: string identity = 5;
   */
  identity: string;

  /**
   * Version info of the worker who processed this workflow task.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;
};

/**
 * Describes the message temporal.api.history.v1.ActivityTaskCanceledEventAttributes.
 * Use `create(ActivityTaskCanceledEventAttributesSchema)` to create a new message.
 */
export const ActivityTaskCanceledEventAttributesSchema: GenMessage<ActivityTaskCanceledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 16);

/**
 * @generated from message temporal.api.history.v1.TimerStartedEventAttributes
 */
export type TimerStartedEventAttributes = Message<"temporal.api.history.v1.TimerStartedEventAttributes"> & {
  /**
   * The worker/user assigned id for this timer
   *
   * @generated from field: string timer_id = 1;
   */
  timerId: string;

  /**
   * How long until this timer fires
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_fire_timeout = 2;
   */
  startToFireTimeout?: Duration;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 3;
   */
  workflowTaskCompletedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.TimerStartedEventAttributes.
 * Use `create(TimerStartedEventAttributesSchema)` to create a new message.
 */
export const TimerStartedEventAttributesSchema: GenMessage<TimerStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 17);

/**
 * @generated from message temporal.api.history.v1.TimerFiredEventAttributes
 */
export type TimerFiredEventAttributes = Message<"temporal.api.history.v1.TimerFiredEventAttributes"> & {
  /**
   * Will match the `timer_id` from `TIMER_STARTED` event for this timer
   *
   * @generated from field: string timer_id = 1;
   */
  timerId: string;

  /**
   * The id of the `TIMER_STARTED` event itself
   *
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.TimerFiredEventAttributes.
 * Use `create(TimerFiredEventAttributesSchema)` to create a new message.
 */
export const TimerFiredEventAttributesSchema: GenMessage<TimerFiredEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 18);

/**
 * @generated from message temporal.api.history.v1.TimerCanceledEventAttributes
 */
export type TimerCanceledEventAttributes = Message<"temporal.api.history.v1.TimerCanceledEventAttributes"> & {
  /**
   * Will match the `timer_id` from `TIMER_STARTED` event for this timer
   *
   * @generated from field: string timer_id = 1;
   */
  timerId: string;

  /**
   * The id of the `TIMER_STARTED` event itself
   *
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 3;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * The id of the worker who requested this cancel
   *
   * @generated from field: string identity = 4;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.history.v1.TimerCanceledEventAttributes.
 * Use `create(TimerCanceledEventAttributesSchema)` to create a new message.
 */
export const TimerCanceledEventAttributesSchema: GenMessage<TimerCanceledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 19);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionCancelRequestedEventAttributes
 */
export type WorkflowExecutionCancelRequestedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionCancelRequestedEventAttributes"> & {
  /**
   * User provided reason for requesting cancellation
   *
   * @generated from field: string cause = 1;
   */
  cause: string;

  /**
   * The ID of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event in the external
   * workflow history when the cancellation was requested by another workflow.
   *
   * @generated from field: int64 external_initiated_event_id = 2;
   */
  externalInitiatedEventId: bigint;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution external_workflow_execution = 3;
   */
  externalWorkflowExecution?: WorkflowExecution;

  /**
   * id of the worker or client who requested this cancel
   *
   * @generated from field: string identity = 4;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionCancelRequestedEventAttributes.
 * Use `create(WorkflowExecutionCancelRequestedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionCancelRequestedEventAttributesSchema: GenMessage<WorkflowExecutionCancelRequestedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 20);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionCanceledEventAttributes
 */
export type WorkflowExecutionCanceledEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionCanceledEventAttributes"> & {
  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 1;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionCanceledEventAttributes.
 * Use `create(WorkflowExecutionCanceledEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionCanceledEventAttributesSchema: GenMessage<WorkflowExecutionCanceledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 21);

/**
 * @generated from message temporal.api.history.v1.MarkerRecordedEventAttributes
 */
export type MarkerRecordedEventAttributes = Message<"temporal.api.history.v1.MarkerRecordedEventAttributes"> & {
  /**
   * Workers use this to identify the "types" of various markers. Ex: Local activity, side effect.
   *
   * @generated from field: string marker_name = 1;
   */
  markerName: string;

  /**
   * Serialized information recorded in the marker
   *
   * @generated from field: map<string, temporal.api.common.v1.Payloads> details = 2;
   */
  details: { [key: string]: Payloads };

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 3;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 4;
   */
  header?: Header;

  /**
   * Some uses of markers, like a local activity, could "fail". If they did that is recorded here.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 5;
   */
  failure?: Failure;
};

/**
 * Describes the message temporal.api.history.v1.MarkerRecordedEventAttributes.
 * Use `create(MarkerRecordedEventAttributesSchema)` to create a new message.
 */
export const MarkerRecordedEventAttributesSchema: GenMessage<MarkerRecordedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 22);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionSignaledEventAttributes
 */
export type WorkflowExecutionSignaledEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionSignaledEventAttributes"> & {
  /**
   * The name/type of the signal to fire
   *
   * @generated from field: string signal_name = 1;
   */
  signalName: string;

  /**
   * Will be deserialized and provided as argument(s) to the signal handler
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads;

  /**
   * id of the worker/client who sent this signal
   *
   * @generated from field: string identity = 3;
   */
  identity: string;

  /**
   * Headers that were passed by the sender of the signal and copied by temporal
   * server into the workflow task.
   *
   * @generated from field: temporal.api.common.v1.Header header = 4;
   */
  header?: Header;

  /**
   * Deprecated. This field is never respected and should always be set to false.
   *
   * @generated from field: bool skip_generate_workflow_task = 5 [deprecated = true];
   * @deprecated
   */
  skipGenerateWorkflowTask: boolean;

  /**
   * When signal origin is a workflow execution, this field is set.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution external_workflow_execution = 6;
   */
  externalWorkflowExecution?: WorkflowExecution;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionSignaledEventAttributes.
 * Use `create(WorkflowExecutionSignaledEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionSignaledEventAttributesSchema: GenMessage<WorkflowExecutionSignaledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 23);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionTerminatedEventAttributes
 */
export type WorkflowExecutionTerminatedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionTerminatedEventAttributes"> & {
  /**
   * User/client provided reason for termination
   *
   * @generated from field: string reason = 1;
   */
  reason: string;

  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;

  /**
   * id of the client who requested termination
   *
   * @generated from field: string identity = 3;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionTerminatedEventAttributes.
 * Use `create(WorkflowExecutionTerminatedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionTerminatedEventAttributesSchema: GenMessage<WorkflowExecutionTerminatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 24);

/**
 * @generated from message temporal.api.history.v1.RequestCancelExternalWorkflowExecutionInitiatedEventAttributes
 */
export type RequestCancelExternalWorkflowExecutionInitiatedEventAttributes = Message<"temporal.api.history.v1.RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"> & {
  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 1;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * The namespace the workflow to be cancelled lives in.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 4 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Workers are expected to set this to true if the workflow they are requesting to cancel is
   * a child of the workflow which issued the request
   *
   * @generated from field: bool child_workflow_only = 5;
   */
  childWorkflowOnly: boolean;

  /**
   * Reason for requesting the cancellation
   *
   * @generated from field: string reason = 6;
   */
  reason: string;
};

/**
 * Describes the message temporal.api.history.v1.RequestCancelExternalWorkflowExecutionInitiatedEventAttributes.
 * Use `create(RequestCancelExternalWorkflowExecutionInitiatedEventAttributesSchema)` to create a new message.
 */
export const RequestCancelExternalWorkflowExecutionInitiatedEventAttributesSchema: GenMessage<RequestCancelExternalWorkflowExecutionInitiatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 25);

/**
 * @generated from message temporal.api.history.v1.RequestCancelExternalWorkflowExecutionFailedEventAttributes
 */
export type RequestCancelExternalWorkflowExecutionFailedEventAttributes = Message<"temporal.api.history.v1.RequestCancelExternalWorkflowExecutionFailedEventAttributes"> & {
  /**
   * @generated from field: temporal.api.enums.v1.CancelExternalWorkflowExecutionFailedCause cause = 1;
   */
  cause: CancelExternalWorkflowExecutionFailedCause;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Namespace of the workflow which failed to cancel.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
   * corresponds to
   *
   * @generated from field: int64 initiated_event_id = 5;
   */
  initiatedEventId: bigint;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 6 [deprecated = true];
   * @deprecated
   */
  control: string;
};

/**
 * Describes the message temporal.api.history.v1.RequestCancelExternalWorkflowExecutionFailedEventAttributes.
 * Use `create(RequestCancelExternalWorkflowExecutionFailedEventAttributesSchema)` to create a new message.
 */
export const RequestCancelExternalWorkflowExecutionFailedEventAttributesSchema: GenMessage<RequestCancelExternalWorkflowExecutionFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 26);

/**
 * @generated from message temporal.api.history.v1.ExternalWorkflowExecutionCancelRequestedEventAttributes
 */
export type ExternalWorkflowExecutionCancelRequestedEventAttributes = Message<"temporal.api.history.v1.ExternalWorkflowExecutionCancelRequestedEventAttributes"> & {
  /**
   * id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
   * to
   *
   * @generated from field: int64 initiated_event_id = 1;
   */
  initiatedEventId: bigint;

  /**
   * Namespace of the to-be-cancelled workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 4;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;
};

/**
 * Describes the message temporal.api.history.v1.ExternalWorkflowExecutionCancelRequestedEventAttributes.
 * Use `create(ExternalWorkflowExecutionCancelRequestedEventAttributesSchema)` to create a new message.
 */
export const ExternalWorkflowExecutionCancelRequestedEventAttributesSchema: GenMessage<ExternalWorkflowExecutionCancelRequestedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 27);

/**
 * @generated from message temporal.api.history.v1.SignalExternalWorkflowExecutionInitiatedEventAttributes
 */
export type SignalExternalWorkflowExecutionInitiatedEventAttributes = Message<"temporal.api.history.v1.SignalExternalWorkflowExecutionInitiatedEventAttributes"> & {
  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 1;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Namespace of the to-be-signalled workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 9;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * name/type of the signal to fire in the external workflow
   *
   * @generated from field: string signal_name = 4;
   */
  signalName: string;

  /**
   * Serialized arguments to provide to the signal handler
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 6 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Workers are expected to set this to true if the workflow they are requesting to cancel is
   * a child of the workflow which issued the request
   *
   * @generated from field: bool child_workflow_only = 7;
   */
  childWorkflowOnly: boolean;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 8;
   */
  header?: Header;
};

/**
 * Describes the message temporal.api.history.v1.SignalExternalWorkflowExecutionInitiatedEventAttributes.
 * Use `create(SignalExternalWorkflowExecutionInitiatedEventAttributesSchema)` to create a new message.
 */
export const SignalExternalWorkflowExecutionInitiatedEventAttributesSchema: GenMessage<SignalExternalWorkflowExecutionInitiatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 28);

/**
 * @generated from message temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes
 */
export type SignalExternalWorkflowExecutionFailedEventAttributes = Message<"temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes"> & {
  /**
   * @generated from field: temporal.api.enums.v1.SignalExternalWorkflowExecutionFailedCause cause = 1;
   */
  cause: SignalExternalWorkflowExecutionFailedCause;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Namespace of the workflow which failed the signal.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: int64 initiated_event_id = 5;
   */
  initiatedEventId: bigint;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 6 [deprecated = true];
   * @deprecated
   */
  control: string;
};

/**
 * Describes the message temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes.
 * Use `create(SignalExternalWorkflowExecutionFailedEventAttributesSchema)` to create a new message.
 */
export const SignalExternalWorkflowExecutionFailedEventAttributesSchema: GenMessage<SignalExternalWorkflowExecutionFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 29);

/**
 * @generated from message temporal.api.history.v1.ExternalWorkflowExecutionSignaledEventAttributes
 */
export type ExternalWorkflowExecutionSignaledEventAttributes = Message<"temporal.api.history.v1.ExternalWorkflowExecutionSignaledEventAttributes"> & {
  /**
   * id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 1;
   */
  initiatedEventId: bigint;

  /**
   * Namespace of the workflow which was signaled.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 5;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 4 [deprecated = true];
   * @deprecated
   */
  control: string;
};

/**
 * Describes the message temporal.api.history.v1.ExternalWorkflowExecutionSignaledEventAttributes.
 * Use `create(ExternalWorkflowExecutionSignaledEventAttributesSchema)` to create a new message.
 */
export const ExternalWorkflowExecutionSignaledEventAttributesSchema: GenMessage<ExternalWorkflowExecutionSignaledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 30);

/**
 * @generated from message temporal.api.history.v1.UpsertWorkflowSearchAttributesEventAttributes
 */
export type UpsertWorkflowSearchAttributesEventAttributes = Message<"temporal.api.history.v1.UpsertWorkflowSearchAttributesEventAttributes"> & {
  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 1;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 2;
   */
  searchAttributes?: SearchAttributes;
};

/**
 * Describes the message temporal.api.history.v1.UpsertWorkflowSearchAttributesEventAttributes.
 * Use `create(UpsertWorkflowSearchAttributesEventAttributesSchema)` to create a new message.
 */
export const UpsertWorkflowSearchAttributesEventAttributesSchema: GenMessage<UpsertWorkflowSearchAttributesEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 31);

/**
 * @generated from message temporal.api.history.v1.WorkflowPropertiesModifiedEventAttributes
 */
export type WorkflowPropertiesModifiedEventAttributes = Message<"temporal.api.history.v1.WorkflowPropertiesModifiedEventAttributes"> & {
  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 1;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * If set, update the workflow memo with the provided values. The values will be merged with
   * the existing memo. If the user wants to delete values, a default/empty Payload should be
   * used as the value for the key being deleted.
   *
   * @generated from field: temporal.api.common.v1.Memo upserted_memo = 2;
   */
  upsertedMemo?: Memo;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowPropertiesModifiedEventAttributes.
 * Use `create(WorkflowPropertiesModifiedEventAttributesSchema)` to create a new message.
 */
export const WorkflowPropertiesModifiedEventAttributesSchema: GenMessage<WorkflowPropertiesModifiedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 32);

/**
 * @generated from message temporal.api.history.v1.StartChildWorkflowExecutionInitiatedEventAttributes
 */
export type StartChildWorkflowExecutionInitiatedEventAttributes = Message<"temporal.api.history.v1.StartChildWorkflowExecutionInitiatedEventAttributes"> & {
  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 18;
   */
  namespaceId: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 9;
   */
  parentClosePolicy: ParentClosePolicy;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 10 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 11;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 12;
   */
  workflowIdReusePolicy: WorkflowIdReusePolicy;

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 13;
   */
  retryPolicy?: RetryPolicy;

  /**
   * If this child runs on a cron schedule, it will appear here
   *
   * @generated from field: string cron_schedule = 14;
   */
  cronSchedule: string;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 15;
   */
  header?: Header;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 16;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 17;
   */
  searchAttributes?: SearchAttributes;

  /**
   * If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
   * rules of the child's Task Queue will be used to independently assign a Build ID to it.
   * Deprecated. Only considered for versioning v0.2.
   *
   * @generated from field: bool inherit_build_id = 19 [deprecated = true];
   * @deprecated
   */
  inheritBuildId: boolean;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 20;
   */
  priority?: Priority;
};

/**
 * Describes the message temporal.api.history.v1.StartChildWorkflowExecutionInitiatedEventAttributes.
 * Use `create(StartChildWorkflowExecutionInitiatedEventAttributesSchema)` to create a new message.
 */
export const StartChildWorkflowExecutionInitiatedEventAttributesSchema: GenMessage<StartChildWorkflowExecutionInitiatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 33);

/**
 * @generated from message temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes
 */
export type StartChildWorkflowExecutionFailedEventAttributes = Message<"temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes"> & {
  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 8;
   */
  namespaceId: string;

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.enums.v1.StartChildWorkflowExecutionFailedCause cause = 4;
   */
  cause: StartChildWorkflowExecutionFailedCause;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 5 [deprecated = true];
   * @deprecated
   */
  control: string;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 6;
   */
  initiatedEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
   *
   * @generated from field: int64 workflow_task_completed_event_id = 7;
   */
  workflowTaskCompletedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes.
 * Use `create(StartChildWorkflowExecutionFailedEventAttributesSchema)` to create a new message.
 */
export const StartChildWorkflowExecutionFailedEventAttributesSchema: GenMessage<StartChildWorkflowExecutionFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 34);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionStartedEventAttributes
 */
export type ChildWorkflowExecutionStartedEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionStartedEventAttributes"> & {
  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 6;
   */
  namespaceId: string;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 2;
   */
  initiatedEventId: bigint;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 4;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 5;
   */
  header?: Header;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionStartedEventAttributes.
 * Use `create(ChildWorkflowExecutionStartedEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionStartedEventAttributesSchema: GenMessage<ChildWorkflowExecutionStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 35);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes
 */
export type ChildWorkflowExecutionCompletedEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.Payloads result = 1;
   */
  result?: Payloads;

  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 4;
   */
  workflowType?: WorkflowType;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 5;
   */
  initiatedEventId: bigint;

  /**
   * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
   *
   * @generated from field: int64 started_event_id = 6;
   */
  startedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes.
 * Use `create(ChildWorkflowExecutionCompletedEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionCompletedEventAttributesSchema: GenMessage<ChildWorkflowExecutionCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 36);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes
 */
export type ChildWorkflowExecutionFailedEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes"> & {
  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 1;
   */
  failure?: Failure;

  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 8;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 4;
   */
  workflowType?: WorkflowType;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 5;
   */
  initiatedEventId: bigint;

  /**
   * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
   *
   * @generated from field: int64 started_event_id = 6;
   */
  startedEventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 7;
   */
  retryState: RetryState;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes.
 * Use `create(ChildWorkflowExecutionFailedEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionFailedEventAttributesSchema: GenMessage<ChildWorkflowExecutionFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 37);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes
 */
export type ChildWorkflowExecutionCanceledEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes"> & {
  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads;

  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 4;
   */
  workflowType?: WorkflowType;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 5;
   */
  initiatedEventId: bigint;

  /**
   * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
   *
   * @generated from field: int64 started_event_id = 6;
   */
  startedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes.
 * Use `create(ChildWorkflowExecutionCanceledEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionCanceledEventAttributesSchema: GenMessage<ChildWorkflowExecutionCanceledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 38);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes
 */
export type ChildWorkflowExecutionTimedOutEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes"> & {
  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 7;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 4;
   */
  initiatedEventId: bigint;

  /**
   * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
   *
   * @generated from field: int64 started_event_id = 5;
   */
  startedEventId: bigint;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 6;
   */
  retryState: RetryState;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes.
 * Use `create(ChildWorkflowExecutionTimedOutEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionTimedOutEventAttributesSchema: GenMessage<ChildWorkflowExecutionTimedOutEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 39);

/**
 * @generated from message temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes
 */
export type ChildWorkflowExecutionTerminatedEventAttributes = Message<"temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes"> & {
  /**
   * Namespace of the child workflow.
   * SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string namespace_id = 6;
   */
  namespaceId: string;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
   *
   * @generated from field: int64 initiated_event_id = 4;
   */
  initiatedEventId: bigint;

  /**
   * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
   *
   * @generated from field: int64 started_event_id = 5;
   */
  startedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes.
 * Use `create(ChildWorkflowExecutionTerminatedEventAttributesSchema)` to create a new message.
 */
export const ChildWorkflowExecutionTerminatedEventAttributesSchema: GenMessage<ChildWorkflowExecutionTerminatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 40);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionOptionsUpdatedEventAttributes
 */
export type WorkflowExecutionOptionsUpdatedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionOptionsUpdatedEventAttributes"> & {
  /**
   * Versioning override upserted in this event.
   * Ignored if nil or if unset_versioning_override is true.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 1;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Versioning override removed in this event.
   *
   * @generated from field: bool unset_versioning_override = 2;
   */
  unsetVersioningOverride: boolean;

  /**
   * Request ID attachedto the running workflow execution so that subsequent requests with same
   * request ID will be deduped.
   *
   * @generated from field: string attached_request_id = 3;
   */
  attachedRequestId: string;

  /**
   * Completion callbacks attached to the running workflow execution.
   *
   * @generated from field: repeated temporal.api.common.v1.Callback attached_completion_callbacks = 4;
   */
  attachedCompletionCallbacks: Callback[];

  /**
   * Optional. The identity of the client who initiated the request that created this event.
   *
   * @generated from field: string identity = 5;
   */
  identity: string;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionOptionsUpdatedEventAttributes.
 * Use `create(WorkflowExecutionOptionsUpdatedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionOptionsUpdatedEventAttributesSchema: GenMessage<WorkflowExecutionOptionsUpdatedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 41);

/**
 * Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes
 *
 * @generated from message temporal.api.history.v1.WorkflowPropertiesModifiedExternallyEventAttributes
 */
export type WorkflowPropertiesModifiedExternallyEventAttributes = Message<"temporal.api.history.v1.WorkflowPropertiesModifiedExternallyEventAttributes"> & {
  /**
   * Not used.
   *
   * @generated from field: string new_task_queue = 1;
   */
  newTaskQueue: string;

  /**
   * Not used.
   *
   * @generated from field: google.protobuf.Duration new_workflow_task_timeout = 2;
   */
  newWorkflowTaskTimeout?: Duration;

  /**
   * Not used.
   *
   * @generated from field: google.protobuf.Duration new_workflow_run_timeout = 3;
   */
  newWorkflowRunTimeout?: Duration;

  /**
   * Not used.
   *
   * @generated from field: google.protobuf.Duration new_workflow_execution_timeout = 4;
   */
  newWorkflowExecutionTimeout?: Duration;

  /**
   * Not used.
   *
   * @generated from field: temporal.api.common.v1.Memo upserted_memo = 5;
   */
  upsertedMemo?: Memo;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowPropertiesModifiedExternallyEventAttributes.
 * Use `create(WorkflowPropertiesModifiedExternallyEventAttributesSchema)` to create a new message.
 */
export const WorkflowPropertiesModifiedExternallyEventAttributesSchema: GenMessage<WorkflowPropertiesModifiedExternallyEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 42);

/**
 * @generated from message temporal.api.history.v1.ActivityPropertiesModifiedExternallyEventAttributes
 */
export type ActivityPropertiesModifiedExternallyEventAttributes = Message<"temporal.api.history.v1.ActivityPropertiesModifiedExternallyEventAttributes"> & {
  /**
   * The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * If set, update the retry policy of the activity, replacing it with the specified one.
   * The number of attempts at the activity is preserved.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy new_retry_policy = 2;
   */
  newRetryPolicy?: RetryPolicy;
};

/**
 * Describes the message temporal.api.history.v1.ActivityPropertiesModifiedExternallyEventAttributes.
 * Use `create(ActivityPropertiesModifiedExternallyEventAttributesSchema)` to create a new message.
 */
export const ActivityPropertiesModifiedExternallyEventAttributesSchema: GenMessage<ActivityPropertiesModifiedExternallyEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 43);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionUpdateAcceptedEventAttributes
 */
export type WorkflowExecutionUpdateAcceptedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionUpdateAcceptedEventAttributes"> & {
  /**
   * The instance ID of the update protocol that generated this event.
   *
   * @generated from field: string protocol_instance_id = 1;
   */
  protocolInstanceId: string;

  /**
   * The message ID of the original request message that initiated this
   * update. Needed so that the worker can recreate and deliver that same
   * message as part of replay.
   *
   * @generated from field: string accepted_request_message_id = 2;
   */
  acceptedRequestMessageId: string;

  /**
   * The event ID used to sequence the original request message.
   *
   * @generated from field: int64 accepted_request_sequencing_event_id = 3;
   */
  acceptedRequestSequencingEventId: bigint;

  /**
   * The message payload of the original request message that initiated this
   * update.
   *
   * @generated from field: temporal.api.update.v1.Request accepted_request = 4;
   */
  acceptedRequest?: Request;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionUpdateAcceptedEventAttributes.
 * Use `create(WorkflowExecutionUpdateAcceptedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionUpdateAcceptedEventAttributesSchema: GenMessage<WorkflowExecutionUpdateAcceptedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 44);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionUpdateCompletedEventAttributes
 */
export type WorkflowExecutionUpdateCompletedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionUpdateCompletedEventAttributes"> & {
  /**
   * The metadata about this update.
   *
   * @generated from field: temporal.api.update.v1.Meta meta = 1;
   */
  meta?: Meta;

  /**
   * The event ID indicating the acceptance of this update.
   *
   * @generated from field: int64 accepted_event_id = 3;
   */
  acceptedEventId: bigint;

  /**
   * The outcome of executing the workflow update function.
   *
   * @generated from field: temporal.api.update.v1.Outcome outcome = 2;
   */
  outcome?: Outcome;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionUpdateCompletedEventAttributes.
 * Use `create(WorkflowExecutionUpdateCompletedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionUpdateCompletedEventAttributesSchema: GenMessage<WorkflowExecutionUpdateCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 45);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionUpdateRejectedEventAttributes
 */
export type WorkflowExecutionUpdateRejectedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionUpdateRejectedEventAttributes"> & {
  /**
   * The instance ID of the update protocol that generated this event.
   *
   * @generated from field: string protocol_instance_id = 1;
   */
  protocolInstanceId: string;

  /**
   * The message ID of the original request message that initiated this
   * update. Needed so that the worker can recreate and deliver that same
   * message as part of replay.
   *
   * @generated from field: string rejected_request_message_id = 2;
   */
  rejectedRequestMessageId: string;

  /**
   * The event ID used to sequence the original request message.
   *
   * @generated from field: int64 rejected_request_sequencing_event_id = 3;
   */
  rejectedRequestSequencingEventId: bigint;

  /**
   * The message payload of the original request message that initiated this
   * update.
   *
   * @generated from field: temporal.api.update.v1.Request rejected_request = 4;
   */
  rejectedRequest?: Request;

  /**
   * The cause of rejection.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 5;
   */
  failure?: Failure;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionUpdateRejectedEventAttributes.
 * Use `create(WorkflowExecutionUpdateRejectedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionUpdateRejectedEventAttributesSchema: GenMessage<WorkflowExecutionUpdateRejectedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 46);

/**
 * @generated from message temporal.api.history.v1.WorkflowExecutionUpdateAdmittedEventAttributes
 */
export type WorkflowExecutionUpdateAdmittedEventAttributes = Message<"temporal.api.history.v1.WorkflowExecutionUpdateAdmittedEventAttributes"> & {
  /**
   * The update request associated with this event.
   *
   * @generated from field: temporal.api.update.v1.Request request = 1;
   */
  request?: Request;

  /**
   * An explanation of why this event was written to history.
   *
   * @generated from field: temporal.api.enums.v1.UpdateAdmittedEventOrigin origin = 2;
   */
  origin: UpdateAdmittedEventOrigin;
};

/**
 * Describes the message temporal.api.history.v1.WorkflowExecutionUpdateAdmittedEventAttributes.
 * Use `create(WorkflowExecutionUpdateAdmittedEventAttributesSchema)` to create a new message.
 */
export const WorkflowExecutionUpdateAdmittedEventAttributesSchema: GenMessage<WorkflowExecutionUpdateAdmittedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 47);

/**
 * Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command.
 *
 * @generated from message temporal.api.history.v1.NexusOperationScheduledEventAttributes
 */
export type NexusOperationScheduledEventAttributes = Message<"temporal.api.history.v1.NexusOperationScheduledEventAttributes"> & {
  /**
   * Endpoint name, must exist in the endpoint registry.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint: string;

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service: string;

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation: string;

  /**
   * Input for the operation. The server converts this into Nexus request content and the appropriate content headers
   * internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
   * content is transformed back to the original Payload stored in this event.
   *
   * @generated from field: temporal.api.common.v1.Payload input = 4;
   */
  input?: Payload;

  /**
   * Schedule-to-close timeout for this operation.
   * Indicates how long the caller is willing to wait for operation completion.
   * Calls are retried internally by the server.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
   * activities and child workflows, these are transmitted to Nexus operations that may be external and are not
   * traditional payloads.
   *
   * @generated from field: map<string, string> nexus_header = 6;
   */
  nexusHeader: { [key: string]: string };

  /**
   * The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with.
   *
   * @generated from field: int64 workflow_task_completed_event_id = 7;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * A unique ID generated by the history service upon creation of this event.
   * The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key.
   *
   * @generated from field: string request_id = 8;
   */
  requestId: string;

  /**
   * Endpoint ID as resolved in the endpoint registry at the time this event was generated.
   * This is stored on the event and used internally by the server in case the endpoint is renamed from the time the
   * event was originally scheduled.
   *
   * @generated from field: string endpoint_id = 9;
   */
  endpointId: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationScheduledEventAttributes.
 * Use `create(NexusOperationScheduledEventAttributesSchema)` to create a new message.
 */
export const NexusOperationScheduledEventAttributesSchema: GenMessage<NexusOperationScheduledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 48);

/**
 * Event marking an asynchronous operation was started by the responding Nexus handler.
 * If the operation completes synchronously, this event is not generated.
 * In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
 * this event upon receiving the operation completion via callback.
 *
 * @generated from message temporal.api.history.v1.NexusOperationStartedEventAttributes
 */
export type NexusOperationStartedEventAttributes = Message<"temporal.api.history.v1.NexusOperationStartedEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The operation ID returned by the Nexus handler in the response to the StartOperation request.
   * This ID is used when canceling the operation.
   *
   * Deprecated: Renamed to operation_token.
   *
   * @generated from field: string operation_id = 3 [deprecated = true];
   * @deprecated
   */
  operationId: string;

  /**
   * The request ID allocated at schedule time.
   *
   * @generated from field: string request_id = 4;
   */
  requestId: string;

  /**
   * The operation token returned by the Nexus handler in the response to the StartOperation request.
   * This token is used when canceling the operation.
   *
   * @generated from field: string operation_token = 5;
   */
  operationToken: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationStartedEventAttributes.
 * Use `create(NexusOperationStartedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationStartedEventAttributesSchema: GenMessage<NexusOperationStartedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 49);

/**
 * Nexus operation completed successfully.
 *
 * @generated from message temporal.api.history.v1.NexusOperationCompletedEventAttributes
 */
export type NexusOperationCompletedEventAttributes = Message<"temporal.api.history.v1.NexusOperationCompletedEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * Serialized result of the Nexus operation. The response of the Nexus handler.
   * Delivered either via a completion callback or as a response to a synchronous operation.
   *
   * @generated from field: temporal.api.common.v1.Payload result = 2;
   */
  result?: Payload;

  /**
   * The request ID allocated at schedule time.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationCompletedEventAttributes.
 * Use `create(NexusOperationCompletedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationCompletedEventAttributesSchema: GenMessage<NexusOperationCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 50);

/**
 * Nexus operation failed.
 *
 * @generated from message temporal.api.history.v1.NexusOperationFailedEventAttributes
 */
export type NexusOperationFailedEventAttributes = Message<"temporal.api.history.v1.NexusOperationFailedEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 2;
   */
  failure?: Failure;

  /**
   * The request ID allocated at schedule time.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationFailedEventAttributes.
 * Use `create(NexusOperationFailedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationFailedEventAttributesSchema: GenMessage<NexusOperationFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 51);

/**
 * Nexus operation timed out.
 *
 * @generated from message temporal.api.history.v1.NexusOperationTimedOutEventAttributes
 */
export type NexusOperationTimedOutEventAttributes = Message<"temporal.api.history.v1.NexusOperationTimedOutEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 2;
   */
  failure?: Failure;

  /**
   * The request ID allocated at schedule time.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationTimedOutEventAttributes.
 * Use `create(NexusOperationTimedOutEventAttributesSchema)` to create a new message.
 */
export const NexusOperationTimedOutEventAttributesSchema: GenMessage<NexusOperationTimedOutEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 52);

/**
 * Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow.
 *
 * @generated from message temporal.api.history.v1.NexusOperationCanceledEventAttributes
 */
export type NexusOperationCanceledEventAttributes = Message<"temporal.api.history.v1.NexusOperationCanceledEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * Cancellation details.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 2;
   */
  failure?: Failure;

  /**
   * The request ID allocated at schedule time.
   *
   * @generated from field: string request_id = 3;
   */
  requestId: string;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationCanceledEventAttributes.
 * Use `create(NexusOperationCanceledEventAttributesSchema)` to create a new message.
 */
export const NexusOperationCanceledEventAttributesSchema: GenMessage<NexusOperationCanceledEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 53);

/**
 * @generated from message temporal.api.history.v1.NexusOperationCancelRequestedEventAttributes
 */
export type NexusOperationCancelRequestedEventAttributes = Message<"temporal.api.history.v1.NexusOperationCancelRequestedEventAttributes"> & {
  /**
   * The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
   * with.
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationCancelRequestedEventAttributes.
 * Use `create(NexusOperationCancelRequestedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationCancelRequestedEventAttributesSchema: GenMessage<NexusOperationCancelRequestedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 54);

/**
 * @generated from message temporal.api.history.v1.NexusOperationCancelRequestCompletedEventAttributes
 */
export type NexusOperationCancelRequestCompletedEventAttributes = Message<"temporal.api.history.v1.NexusOperationCancelRequestCompletedEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
   *
   * @generated from field: int64 requested_event_id = 1;
   */
  requestedEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
   * with.
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
   *
   * @generated from field: int64 scheduled_event_id = 3;
   */
  scheduledEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationCancelRequestCompletedEventAttributes.
 * Use `create(NexusOperationCancelRequestCompletedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationCancelRequestCompletedEventAttributesSchema: GenMessage<NexusOperationCancelRequestCompletedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 55);

/**
 * @generated from message temporal.api.history.v1.NexusOperationCancelRequestFailedEventAttributes
 */
export type NexusOperationCancelRequestFailedEventAttributes = Message<"temporal.api.history.v1.NexusOperationCancelRequestFailedEventAttributes"> & {
  /**
   * The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
   *
   * @generated from field: int64 requested_event_id = 1;
   */
  requestedEventId: bigint;

  /**
   * The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
   * with.
   *
   * @generated from field: int64 workflow_task_completed_event_id = 2;
   */
  workflowTaskCompletedEventId: bigint;

  /**
   * Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 3;
   */
  failure?: Failure;

  /**
   * The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
   *
   * @generated from field: int64 scheduled_event_id = 4;
   */
  scheduledEventId: bigint;
};

/**
 * Describes the message temporal.api.history.v1.NexusOperationCancelRequestFailedEventAttributes.
 * Use `create(NexusOperationCancelRequestFailedEventAttributesSchema)` to create a new message.
 */
export const NexusOperationCancelRequestFailedEventAttributesSchema: GenMessage<NexusOperationCancelRequestFailedEventAttributes> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 56);

/**
 * History events are the method by which Temporal SDKs advance (or recreate) workflow state.
 * See the `EventType` enum for more info about what each event is for.
 *
 * @generated from message temporal.api.history.v1.HistoryEvent
 */
export type HistoryEvent = Message<"temporal.api.history.v1.HistoryEvent"> & {
  /**
   * Monotonically increasing event number, starts at 1.
   *
   * @generated from field: int64 event_id = 1;
   */
  eventId: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp event_time = 2;
   */
  eventTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.EventType event_type = 3;
   */
  eventType: EventType;

  /**
   * Failover version of the event, used by the server for multi-cluster replication and history
   * versioning. SDKs generally ignore this field.
   *
   * @generated from field: int64 version = 4;
   */
  version: bigint;

  /**
   * Identifier used by the service to order replication and transfer tasks associated with this
   * event. SDKs generally ignore this field.
   *
   * @generated from field: int64 task_id = 5;
   */
  taskId: bigint;

  /**
   * Set to true when the SDK may ignore the event as it does not impact workflow state or
   * information in any way that the SDK need be concerned with. If an SDK encounters an event
   * type which it does not understand, it must error unless this is true. If it is true, it's
   * acceptable for the event type and/or attributes to be uninterpretable.
   *
   * @generated from field: bool worker_may_ignore = 300;
   */
  workerMayIgnore: boolean;

  /**
   * Metadata on the event. This is often carried over from commands and client calls. Most events
   * won't have this information, and how this information is used is dependent upon the interface
   * that reads it.
   *
   * Current well-known uses:
   *  * workflow_execution_started_event_attributes - summary and details from start workflow.
   *  * timer_started_event_attributes - summary represents an identifier for the timer for use by
   *    user interfaces.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 301;
   */
  userMetadata?: UserMetadata;

  /**
   * Links associated with the event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 302;
   */
  links: Link[];

  /**
   * The event details. The type must match that in `event_type`.
   *
   * @generated from oneof temporal.api.history.v1.HistoryEvent.attributes
   */
  attributes: {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionStartedEventAttributes workflow_execution_started_event_attributes = 6;
     */
    value: WorkflowExecutionStartedEventAttributes;
    case: "workflowExecutionStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionCompletedEventAttributes workflow_execution_completed_event_attributes = 7;
     */
    value: WorkflowExecutionCompletedEventAttributes;
    case: "workflowExecutionCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionFailedEventAttributes workflow_execution_failed_event_attributes = 8;
     */
    value: WorkflowExecutionFailedEventAttributes;
    case: "workflowExecutionFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionTimedOutEventAttributes workflow_execution_timed_out_event_attributes = 9;
     */
    value: WorkflowExecutionTimedOutEventAttributes;
    case: "workflowExecutionTimedOutEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowTaskScheduledEventAttributes workflow_task_scheduled_event_attributes = 10;
     */
    value: WorkflowTaskScheduledEventAttributes;
    case: "workflowTaskScheduledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowTaskStartedEventAttributes workflow_task_started_event_attributes = 11;
     */
    value: WorkflowTaskStartedEventAttributes;
    case: "workflowTaskStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowTaskCompletedEventAttributes workflow_task_completed_event_attributes = 12;
     */
    value: WorkflowTaskCompletedEventAttributes;
    case: "workflowTaskCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowTaskTimedOutEventAttributes workflow_task_timed_out_event_attributes = 13;
     */
    value: WorkflowTaskTimedOutEventAttributes;
    case: "workflowTaskTimedOutEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowTaskFailedEventAttributes workflow_task_failed_event_attributes = 14;
     */
    value: WorkflowTaskFailedEventAttributes;
    case: "workflowTaskFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskScheduledEventAttributes activity_task_scheduled_event_attributes = 15;
     */
    value: ActivityTaskScheduledEventAttributes;
    case: "activityTaskScheduledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskStartedEventAttributes activity_task_started_event_attributes = 16;
     */
    value: ActivityTaskStartedEventAttributes;
    case: "activityTaskStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskCompletedEventAttributes activity_task_completed_event_attributes = 17;
     */
    value: ActivityTaskCompletedEventAttributes;
    case: "activityTaskCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskFailedEventAttributes activity_task_failed_event_attributes = 18;
     */
    value: ActivityTaskFailedEventAttributes;
    case: "activityTaskFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskTimedOutEventAttributes activity_task_timed_out_event_attributes = 19;
     */
    value: ActivityTaskTimedOutEventAttributes;
    case: "activityTaskTimedOutEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.TimerStartedEventAttributes timer_started_event_attributes = 20;
     */
    value: TimerStartedEventAttributes;
    case: "timerStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.TimerFiredEventAttributes timer_fired_event_attributes = 21;
     */
    value: TimerFiredEventAttributes;
    case: "timerFiredEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskCancelRequestedEventAttributes activity_task_cancel_requested_event_attributes = 22;
     */
    value: ActivityTaskCancelRequestedEventAttributes;
    case: "activityTaskCancelRequestedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityTaskCanceledEventAttributes activity_task_canceled_event_attributes = 23;
     */
    value: ActivityTaskCanceledEventAttributes;
    case: "activityTaskCanceledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.TimerCanceledEventAttributes timer_canceled_event_attributes = 24;
     */
    value: TimerCanceledEventAttributes;
    case: "timerCanceledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.MarkerRecordedEventAttributes marker_recorded_event_attributes = 25;
     */
    value: MarkerRecordedEventAttributes;
    case: "markerRecordedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionSignaledEventAttributes workflow_execution_signaled_event_attributes = 26;
     */
    value: WorkflowExecutionSignaledEventAttributes;
    case: "workflowExecutionSignaledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionTerminatedEventAttributes workflow_execution_terminated_event_attributes = 27;
     */
    value: WorkflowExecutionTerminatedEventAttributes;
    case: "workflowExecutionTerminatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionCancelRequestedEventAttributes workflow_execution_cancel_requested_event_attributes = 28;
     */
    value: WorkflowExecutionCancelRequestedEventAttributes;
    case: "workflowExecutionCancelRequestedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionCanceledEventAttributes workflow_execution_canceled_event_attributes = 29;
     */
    value: WorkflowExecutionCanceledEventAttributes;
    case: "workflowExecutionCanceledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.RequestCancelExternalWorkflowExecutionInitiatedEventAttributes request_cancel_external_workflow_execution_initiated_event_attributes = 30;
     */
    value: RequestCancelExternalWorkflowExecutionInitiatedEventAttributes;
    case: "requestCancelExternalWorkflowExecutionInitiatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.RequestCancelExternalWorkflowExecutionFailedEventAttributes request_cancel_external_workflow_execution_failed_event_attributes = 31;
     */
    value: RequestCancelExternalWorkflowExecutionFailedEventAttributes;
    case: "requestCancelExternalWorkflowExecutionFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ExternalWorkflowExecutionCancelRequestedEventAttributes external_workflow_execution_cancel_requested_event_attributes = 32;
     */
    value: ExternalWorkflowExecutionCancelRequestedEventAttributes;
    case: "externalWorkflowExecutionCancelRequestedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionContinuedAsNewEventAttributes workflow_execution_continued_as_new_event_attributes = 33;
     */
    value: WorkflowExecutionContinuedAsNewEventAttributes;
    case: "workflowExecutionContinuedAsNewEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.StartChildWorkflowExecutionInitiatedEventAttributes start_child_workflow_execution_initiated_event_attributes = 34;
     */
    value: StartChildWorkflowExecutionInitiatedEventAttributes;
    case: "startChildWorkflowExecutionInitiatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes start_child_workflow_execution_failed_event_attributes = 35;
     */
    value: StartChildWorkflowExecutionFailedEventAttributes;
    case: "startChildWorkflowExecutionFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionStartedEventAttributes child_workflow_execution_started_event_attributes = 36;
     */
    value: ChildWorkflowExecutionStartedEventAttributes;
    case: "childWorkflowExecutionStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes child_workflow_execution_completed_event_attributes = 37;
     */
    value: ChildWorkflowExecutionCompletedEventAttributes;
    case: "childWorkflowExecutionCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes child_workflow_execution_failed_event_attributes = 38;
     */
    value: ChildWorkflowExecutionFailedEventAttributes;
    case: "childWorkflowExecutionFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes child_workflow_execution_canceled_event_attributes = 39;
     */
    value: ChildWorkflowExecutionCanceledEventAttributes;
    case: "childWorkflowExecutionCanceledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes child_workflow_execution_timed_out_event_attributes = 40;
     */
    value: ChildWorkflowExecutionTimedOutEventAttributes;
    case: "childWorkflowExecutionTimedOutEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes child_workflow_execution_terminated_event_attributes = 41;
     */
    value: ChildWorkflowExecutionTerminatedEventAttributes;
    case: "childWorkflowExecutionTerminatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.SignalExternalWorkflowExecutionInitiatedEventAttributes signal_external_workflow_execution_initiated_event_attributes = 42;
     */
    value: SignalExternalWorkflowExecutionInitiatedEventAttributes;
    case: "signalExternalWorkflowExecutionInitiatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes signal_external_workflow_execution_failed_event_attributes = 43;
     */
    value: SignalExternalWorkflowExecutionFailedEventAttributes;
    case: "signalExternalWorkflowExecutionFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ExternalWorkflowExecutionSignaledEventAttributes external_workflow_execution_signaled_event_attributes = 44;
     */
    value: ExternalWorkflowExecutionSignaledEventAttributes;
    case: "externalWorkflowExecutionSignaledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.UpsertWorkflowSearchAttributesEventAttributes upsert_workflow_search_attributes_event_attributes = 45;
     */
    value: UpsertWorkflowSearchAttributesEventAttributes;
    case: "upsertWorkflowSearchAttributesEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionUpdateAcceptedEventAttributes workflow_execution_update_accepted_event_attributes = 46;
     */
    value: WorkflowExecutionUpdateAcceptedEventAttributes;
    case: "workflowExecutionUpdateAcceptedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionUpdateRejectedEventAttributes workflow_execution_update_rejected_event_attributes = 47;
     */
    value: WorkflowExecutionUpdateRejectedEventAttributes;
    case: "workflowExecutionUpdateRejectedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionUpdateCompletedEventAttributes workflow_execution_update_completed_event_attributes = 48;
     */
    value: WorkflowExecutionUpdateCompletedEventAttributes;
    case: "workflowExecutionUpdateCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowPropertiesModifiedExternallyEventAttributes workflow_properties_modified_externally_event_attributes = 49;
     */
    value: WorkflowPropertiesModifiedExternallyEventAttributes;
    case: "workflowPropertiesModifiedExternallyEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.ActivityPropertiesModifiedExternallyEventAttributes activity_properties_modified_externally_event_attributes = 50;
     */
    value: ActivityPropertiesModifiedExternallyEventAttributes;
    case: "activityPropertiesModifiedExternallyEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowPropertiesModifiedEventAttributes workflow_properties_modified_event_attributes = 51;
     */
    value: WorkflowPropertiesModifiedEventAttributes;
    case: "workflowPropertiesModifiedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionUpdateAdmittedEventAttributes workflow_execution_update_admitted_event_attributes = 52;
     */
    value: WorkflowExecutionUpdateAdmittedEventAttributes;
    case: "workflowExecutionUpdateAdmittedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationScheduledEventAttributes nexus_operation_scheduled_event_attributes = 53;
     */
    value: NexusOperationScheduledEventAttributes;
    case: "nexusOperationScheduledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationStartedEventAttributes nexus_operation_started_event_attributes = 54;
     */
    value: NexusOperationStartedEventAttributes;
    case: "nexusOperationStartedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationCompletedEventAttributes nexus_operation_completed_event_attributes = 55;
     */
    value: NexusOperationCompletedEventAttributes;
    case: "nexusOperationCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationFailedEventAttributes nexus_operation_failed_event_attributes = 56;
     */
    value: NexusOperationFailedEventAttributes;
    case: "nexusOperationFailedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationCanceledEventAttributes nexus_operation_canceled_event_attributes = 57;
     */
    value: NexusOperationCanceledEventAttributes;
    case: "nexusOperationCanceledEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationTimedOutEventAttributes nexus_operation_timed_out_event_attributes = 58;
     */
    value: NexusOperationTimedOutEventAttributes;
    case: "nexusOperationTimedOutEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationCancelRequestedEventAttributes nexus_operation_cancel_requested_event_attributes = 59;
     */
    value: NexusOperationCancelRequestedEventAttributes;
    case: "nexusOperationCancelRequestedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.WorkflowExecutionOptionsUpdatedEventAttributes workflow_execution_options_updated_event_attributes = 60;
     */
    value: WorkflowExecutionOptionsUpdatedEventAttributes;
    case: "workflowExecutionOptionsUpdatedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationCancelRequestCompletedEventAttributes nexus_operation_cancel_request_completed_event_attributes = 61;
     */
    value: NexusOperationCancelRequestCompletedEventAttributes;
    case: "nexusOperationCancelRequestCompletedEventAttributes";
  } | {
    /**
     * @generated from field: temporal.api.history.v1.NexusOperationCancelRequestFailedEventAttributes nexus_operation_cancel_request_failed_event_attributes = 62;
     */
    value: NexusOperationCancelRequestFailedEventAttributes;
    case: "nexusOperationCancelRequestFailedEventAttributes";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message temporal.api.history.v1.HistoryEvent.
 * Use `create(HistoryEventSchema)` to create a new message.
 */
export const HistoryEventSchema: GenMessage<HistoryEvent> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 57);

/**
 * @generated from message temporal.api.history.v1.History
 */
export type History = Message<"temporal.api.history.v1.History"> & {
  /**
   * @generated from field: repeated temporal.api.history.v1.HistoryEvent events = 1;
   */
  events: HistoryEvent[];
};

/**
 * Describes the message temporal.api.history.v1.History.
 * Use `create(HistorySchema)` to create a new message.
 */
export const HistorySchema: GenMessage<History> = /*@__PURE__*/
  messageDesc(file_temporal_api_history_v1_message, 58);

