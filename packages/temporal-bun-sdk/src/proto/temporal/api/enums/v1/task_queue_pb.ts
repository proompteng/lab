// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/enums/v1/task_queue.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc } from "@bufbuild/protobuf/codegenv2";

/**
 * Describes the file temporal/api/enums/v1/task_queue.proto.
 */
export const file_temporal_api_enums_v1_task_queue: GenFile = /*@__PURE__*/
  fileDesc("CiZ0ZW1wb3JhbC9hcGkvZW51bXMvdjEvdGFza19xdWV1ZS5wcm90bxIVdGVtcG9yYWwuYXBpLmVudW1zLnYxKmgKDVRhc2tRdWV1ZUtpbmQSHwobVEFTS19RVUVVRV9LSU5EX1VOU1BFQ0lGSUVEEAASGgoWVEFTS19RVUVVRV9LSU5EX05PUk1BTBABEhoKFlRBU0tfUVVFVUVfS0lORF9TVElDS1kQAiqHAQoNVGFza1F1ZXVlVHlwZRIfChtUQVNLX1FVRVVFX1RZUEVfVU5TUEVDSUZJRUQQABIcChhUQVNLX1FVRVVFX1RZUEVfV09SS0ZMT1cQARIcChhUQVNLX1FVRVVFX1RZUEVfQUNUSVZJVFkQAhIZChVUQVNLX1FVRVVFX1RZUEVfTkVYVVMQAyrSAQoQVGFza1JlYWNoYWJpbGl0eRIhCh1UQVNLX1JFQUNIQUJJTElUWV9VTlNQRUNJRklFRBAAEiMKH1RBU0tfUkVBQ0hBQklMSVRZX05FV19XT1JLRkxPV1MQARIoCiRUQVNLX1JFQUNIQUJJTElUWV9FWElTVElOR19XT1JLRkxPV1MQAhIkCiBUQVNLX1JFQUNIQUJJTElUWV9PUEVOX1dPUktGTE9XUxADEiYKIlRBU0tfUkVBQ0hBQklMSVRZX0NMT1NFRF9XT1JLRkxPV1MQBCrRAQoXQnVpbGRJZFRhc2tSZWFjaGFiaWxpdHkSKgomQlVJTERfSURfVEFTS19SRUFDSEFCSUxJVFlfVU5TUEVDSUZJRUQQABIoCiRCVUlMRF9JRF9UQVNLX1JFQUNIQUJJTElUWV9SRUFDSEFCTEUQARI0CjBCVUlMRF9JRF9UQVNLX1JFQUNIQUJJTElUWV9DTE9TRURfV09SS0ZMT1dTX09OTFkQAhIqCiZCVUlMRF9JRF9UQVNLX1JFQUNIQUJJTElUWV9VTlJFQUNIQUJMRRADKmgKFURlc2NyaWJlVGFza1F1ZXVlTW9kZRIoCiRERVNDUklCRV9UQVNLX1FVRVVFX01PREVfVU5TUEVDSUZJRUQQABIlCiFERVNDUklCRV9UQVNLX1FVRVVFX01PREVfRU5IQU5DRUQQASqLAQoPUmF0ZUxpbWl0U291cmNlEiEKHVJBVEVfTElNSVRfU09VUkNFX1VOU1BFQ0lGSUVEEAASGQoVUkFURV9MSU1JVF9TT1VSQ0VfQVBJEAESHAoYUkFURV9MSU1JVF9TT1VSQ0VfV09SS0VSEAISHAoYUkFURV9MSU1JVF9TT1VSQ0VfU1lTVEVNEAMqnwEKGFJvdXRpbmdDb25maWdVcGRhdGVTdGF0ZRIrCidST1VUSU5HX0NPTkZJR19VUERBVEVfU1RBVEVfVU5TUEVDSUZJRUQQABIrCidST1VUSU5HX0NPTkZJR19VUERBVEVfU1RBVEVfSU5fUFJPR1JFU1MQARIpCiVST1VUSU5HX0NPTkZJR19VUERBVEVfU1RBVEVfQ09NUExFVEVEEAJChgEKGGlvLnRlbXBvcmFsLmFwaS5lbnVtcy52MUIOVGFza1F1ZXVlUHJvdG9QAVohZ28udGVtcG9yYWwuaW8vYXBpL2VudW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMuVjHqAhpUZW1wb3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z");

/**
 * @generated from enum temporal.api.enums.v1.TaskQueueKind
 */
export enum TaskQueueKind {
  /**
   * Tasks from any non workflow task may be unspecified.
   *
   * Task queue kind is used to differentiate whether a workflow task queue is sticky or 
   * normal. If a task is not a workflow task, Task queue kind will sometimes be 
   * unspecified.
   *
   * @generated from enum value: TASK_QUEUE_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Tasks from a normal workflow task queue always include complete workflow history
   *
   * The task queue specified by the user is always a normal task queue. There can be as many
   * workers as desired for a single normal task queue. All those workers may pick up tasks from
   * that queue.
   *
   * @generated from enum value: TASK_QUEUE_KIND_NORMAL = 1;
   */
  NORMAL = 1,

  /**
   * A sticky queue only includes new history since the last workflow task, and they are
   * per-worker.
   *
   * Sticky queues are created dynamically by each worker during their start up. They only exist
   * for the lifetime of the worker process. Tasks in a sticky task queue are only available to
   * the worker that created the sticky queue.
   *
   * Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
   *
   * @generated from enum value: TASK_QUEUE_KIND_STICKY = 2;
   */
  STICKY = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.TaskQueueKind.
 */
export const TaskQueueKindSchema: GenEnum<TaskQueueKind> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 0);

/**
 * @generated from enum temporal.api.enums.v1.TaskQueueType
 */
export enum TaskQueueType {
  /**
   * @generated from enum value: TASK_QUEUE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow type of task queue.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_WORKFLOW = 1;
   */
  WORKFLOW = 1,

  /**
   * Activity type of task queue.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_ACTIVITY = 2;
   */
  ACTIVITY = 2,

  /**
   * Task queue type for dispatching Nexus requests.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_NEXUS = 3;
   */
  NEXUS = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.TaskQueueType.
 */
export const TaskQueueTypeSchema: GenEnum<TaskQueueType> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 1);

/**
 * Specifies which category of tasks may reach a worker on a versioned task queue.
 * Used both in a reachability query and its response.
 * Deprecated.
 *
 * @generated from enum temporal.api.enums.v1.TaskReachability
 */
export enum TaskReachability {
  /**
   * @generated from enum value: TASK_REACHABILITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
   *
   * @generated from enum value: TASK_REACHABILITY_NEW_WORKFLOWS = 1;
   */
  NEW_WORKFLOWS = 1,

  /**
   * There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
   * should *not* be retired.
   * This enum value does not distinguish between open and closed workflows.
   *
   * @generated from enum value: TASK_REACHABILITY_EXISTING_WORKFLOWS = 2;
   */
  EXISTING_WORKFLOWS = 2,

  /**
   * There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
   * should *not* be retired.
   *
   * @generated from enum value: TASK_REACHABILITY_OPEN_WORKFLOWS = 3;
   */
  OPEN_WORKFLOWS = 3,

  /**
   * There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
   * retired dependending on application requirements. For example, if there's no need to query closed workflows.
   *
   * @generated from enum value: TASK_REACHABILITY_CLOSED_WORKFLOWS = 4;
   */
  CLOSED_WORKFLOWS = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.TaskReachability.
 */
export const TaskReachabilitySchema: GenEnum<TaskReachability> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 2);

/**
 * Specifies which category of tasks may reach a versioned worker of a certain Build ID.
 *
 * Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
 * converges to the most accurate value but it is designed in a way to take the more conservative
 * side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
 *
 * Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
 * accounted for reachability as server cannot know if they'll happen as they do not use
 * assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
 * who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
 * sure to query reachability for the parent/previous workflow's Task Queue as well.
 *
 * @generated from enum temporal.api.enums.v1.BuildIdTaskReachability
 */
export enum BuildIdTaskReachability {
  /**
   * Task reachability is not reported
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
   * be open workflows or backlogged activities assigned to it.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_REACHABLE = 1;
   */
  REACHABLE = 1,

  /**
   * Build ID does not have open workflows and is not reachable by new workflows,
   * but MAY have closed workflows within the namespace retention period.
   * Not applicable to activity-only task queues.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY = 2;
   */
  CLOSED_WORKFLOWS_ONLY = 2,

  /**
   * Build ID is not used for new executions, nor it has been used by any existing execution
   * within the retention period.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_UNREACHABLE = 3;
   */
  UNREACHABLE = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.BuildIdTaskReachability.
 */
export const BuildIdTaskReachabilitySchema: GenEnum<BuildIdTaskReachability> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 3);

/**
 * @generated from enum temporal.api.enums.v1.DescribeTaskQueueMode
 */
export enum DescribeTaskQueueMode {
  /**
   * Unspecified means legacy behavior.
   *
   * @generated from enum value: DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
   *
   * @generated from enum value: DESCRIBE_TASK_QUEUE_MODE_ENHANCED = 1;
   */
  ENHANCED = 1,
}

/**
 * Describes the enum temporal.api.enums.v1.DescribeTaskQueueMode.
 */
export const DescribeTaskQueueModeSchema: GenEnum<DescribeTaskQueueMode> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 4);

/**
 * Source for the effective rate limit.
 *
 * @generated from enum temporal.api.enums.v1.RateLimitSource
 */
export enum RateLimitSource {
  /**
   * @generated from enum value: RATE_LIMIT_SOURCE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The value was set by the API.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_API = 1;
   */
  API = 1,

  /**
   * The value was set by a worker.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_WORKER = 2;
   */
  WORKER = 2,

  /**
   * The value was set as the system default.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_SYSTEM = 3;
   */
  SYSTEM = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.RateLimitSource.
 */
export const RateLimitSourceSchema: GenEnum<RateLimitSource> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 5);

/**
 * Indicates whether a change to the Routing Config has been
 * propagated to all relevant Task Queues and their partitions.
 *
 * @generated from enum temporal.api.enums.v1.RoutingConfigUpdateState
 */
export enum RoutingConfigUpdateState {
  /**
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Update to the RoutingConfig is currently in progress.
   *
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * Update to the RoutingConfig has completed successfully.
   *
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_COMPLETED = 2;
   */
  COMPLETED = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.RoutingConfigUpdateState.
 */
export const RoutingConfigUpdateStateSchema: GenEnum<RoutingConfigUpdateState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_task_queue, 6);

