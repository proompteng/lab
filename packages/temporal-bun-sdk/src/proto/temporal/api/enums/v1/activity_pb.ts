// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/enums/v1/activity.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc } from "@bufbuild/protobuf/codegenv2";

/**
 * Describes the file temporal/api/enums/v1/activity.proto.
 */
export const file_temporal_api_enums_v1_activity: GenFile = /*@__PURE__*/
  fileDesc("CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvYWN0aXZpdHkucHJvdG8SFXRlbXBvcmFsLmFwaS5lbnVtcy52MSq1AgoXQWN0aXZpdHlFeGVjdXRpb25TdGF0dXMSKQolQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRVU19VTlNQRUNJRklFRBAAEiUKIUFDVElWSVRZX0VYRUNVVElPTl9TVEFUVVNfUlVOTklORxABEicKI0FDVElWSVRZX0VYRUNVVElPTl9TVEFUVVNfQ09NUExFVEVEEAISJAogQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRVU19GQUlMRUQQAxImCiJBQ1RJVklUWV9FWEVDVVRJT05fU1RBVFVTX0NBTkNFTEVEEAQSKAokQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRVU19URVJNSU5BVEVEEAUSJwojQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRVU19USU1FRF9PVVQQBirYAQoVQWN0aXZpdHlJZFJldXNlUG9saWN5EigKJEFDVElWSVRZX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRBAAEiwKKEFDVElWSVRZX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEUQARI4CjRBQ1RJVklUWV9JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZEAISLQopQUNUSVZJVFlfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEUQAyqbAQoYQWN0aXZpdHlJZENvbmZsaWN0UG9saWN5EisKJ0FDVElWSVRZX0lEX0NPTkZMSUNUX1BPTElDWV9VTlNQRUNJRklFRBAAEiQKIEFDVElWSVRZX0lEX0NPTkZMSUNUX1BPTElDWV9GQUlMEAESLAooQUNUSVZJVFlfSURfQ09ORkxJQ1RfUE9MSUNZX1VTRV9FWElTVElORxACQoUBChhpby50ZW1wb3JhbC5hcGkuZW51bXMudjFCDUFjdGl2aXR5UHJvdG9QAVohZ28udGVtcG9yYWwuaW8vYXBpL2VudW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMuVjHqAhpUZW1wb3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z");

/**
 * Status of a standalone activity.
 * The status is updated once, when the activity is originally scheduled, and again when the activity reaches a terminal
 * status.
 * (-- api-linter: core::0216::synonyms=disabled
 *     aip.dev/not-precedent: Named consistently with WorkflowExecutionStatus. --)
 *
 * @generated from enum temporal.api.enums.v1.ActivityExecutionStatus
 */
export enum ActivityExecutionStatus {
  /**
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The activity has not reached a terminal status. See PendingActivityState for the run state
   * (SCHEDULED, STARTED, or CANCEL_REQUESTED).
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * The activity completed successfully. An activity can complete even after cancellation is
   * requested if the worker calls RespondActivityTaskCompleted before acknowledging cancellation.
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_COMPLETED = 2;
   */
  COMPLETED = 2,

  /**
   * The activity failed. Causes:
   * - Worker returned a non-retryable failure
   * - RetryPolicy.maximum_attempts exhausted
   * - Attempt failed after cancellation was requested (retries blocked)
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_FAILED = 3;
   */
  FAILED = 3,

  /**
   * The activity was canceled. Reached when:
   * - Cancellation requested while SCHEDULED (immediate), or
   * - Cancellation requested while STARTED and worker called RespondActivityTaskCanceled.
   *
   * Workers discover cancellation requests via heartbeat responses (cancel_requested=true).
   * Activities that do not heartbeat will not learn of cancellation and may complete, fail, or
   * time out normally. CANCELED requires explicit worker acknowledgment or immediate cancellation
   * of a SCHEDULED activity.
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_CANCELED = 4;
   */
  CANCELED = 4,

  /**
   * The activity was terminated. Immediate; does not wait for worker acknowledgment.
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_TERMINATED = 5;
   */
  TERMINATED = 5,

  /**
   * The activity timed out. See TimeoutType for the specific timeout.
   * - SCHEDULE_TO_START and SCHEDULE_TO_CLOSE timeouts always result in TIMED_OUT.
   * - START_TO_CLOSE and HEARTBEAT may retry if RetryPolicy permits; TIMED_OUT is
   *   reached when retry is blocked (RetryPolicy.maximum_attempts exhausted,
   *   SCHEDULE_TO_CLOSE would be exceeded, or cancellation has been requested).
   *
   * @generated from enum value: ACTIVITY_EXECUTION_STATUS_TIMED_OUT = 6;
   */
  TIMED_OUT = 6,
}

/**
 * Describes the enum temporal.api.enums.v1.ActivityExecutionStatus.
 */
export const ActivityExecutionStatusSchema: GenEnum<ActivityExecutionStatus> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_activity, 0);

/**
 * Defines whether to allow re-using an activity ID from a previously *closed* activity.
 * If the request is denied, the server returns an `ActivityExecutionAlreadyStarted` error.
 *
 * See `ActivityIdConflictPolicy` for handling ID duplication with a *running* activity.
 *
 * @generated from enum temporal.api.enums.v1.ActivityIdReusePolicy
 */
export enum ActivityIdReusePolicy {
  /**
   * @generated from enum value: ACTIVITY_ID_REUSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Always allow starting an activity using the same activity ID.
   *
   * @generated from enum value: ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE = 1;
   */
  ALLOW_DUPLICATE = 1,

  /**
   * Allow starting an activity using the same ID only when the last activity's final state is one
   * of {failed, canceled, terminated, timed out}.
   *
   * @generated from enum value: ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY = 2;
   */
  ALLOW_DUPLICATE_FAILED_ONLY = 2,

  /**
   * Do not permit re-use of the ID for this activity. Future start requests could potentially change the policy,
   * allowing re-use of the ID.
   *
   * @generated from enum value: ACTIVITY_ID_REUSE_POLICY_REJECT_DUPLICATE = 3;
   */
  REJECT_DUPLICATE = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.ActivityIdReusePolicy.
 */
export const ActivityIdReusePolicySchema: GenEnum<ActivityIdReusePolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_activity, 1);

/**
 * Defines what to do when trying to start an activity with the same ID as a *running* activity.
 * Note that it is *never* valid to have two running instances of the same activity ID.
 *
 * See `ActivityIdReusePolicy` for handling activity ID duplication with a *closed* activity.
 *
 * @generated from enum temporal.api.enums.v1.ActivityIdConflictPolicy
 */
export enum ActivityIdConflictPolicy {
  /**
   * @generated from enum value: ACTIVITY_ID_CONFLICT_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Don't start a new activity; instead return `ActivityExecutionAlreadyStarted` error.
   *
   * @generated from enum value: ACTIVITY_ID_CONFLICT_POLICY_FAIL = 1;
   */
  FAIL = 1,

  /**
   * Don't start a new activity; instead return a handle for the running activity.
   *
   * @generated from enum value: ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING = 2;
   */
  USE_EXISTING = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.ActivityIdConflictPolicy.
 */
export const ActivityIdConflictPolicySchema: GenEnum<ActivityIdConflictPolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_activity, 2);

