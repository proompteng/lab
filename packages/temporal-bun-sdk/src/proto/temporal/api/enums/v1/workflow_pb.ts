// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/enums/v1/workflow.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from '@bufbuild/protobuf'

/**
 * Defines whether to allow re-using a workflow id from a previously *closed* workflow.
 * If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
 *
 * See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdReusePolicy
 */
export enum WorkflowIdReusePolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Allow starting a workflow execution using the same workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE = 1;
   */
  ALLOW_DUPLICATE = 1,

  /**
   * Allow starting a workflow execution using the same workflow id, only when the last
   * execution's final state is one of [terminated, cancelled, timed out, failed].
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY = 2;
   */
  ALLOW_DUPLICATE_FAILED_ONLY = 2,

  /**
   * Do not permit re-use of the workflow id for this workflow. Future start workflow requests
   * could potentially change the policy, allowing re-use of the workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE = 3;
   */
  REJECT_DUPLICATE = 3,

  /**
   * This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.
   * If specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on
   * the request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.
   * If no running workflow, then the behavior is the same as ALLOW_DUPLICATE.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING = 4;
   */
  TERMINATE_IF_RUNNING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(WorkflowIdReusePolicy)
proto3.util.setEnumType(WorkflowIdReusePolicy, 'temporal.api.enums.v1.WorkflowIdReusePolicy', [
  { no: 0, name: 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED' },
  { no: 1, name: 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE' },
  { no: 2, name: 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY' },
  { no: 3, name: 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE' },
  { no: 4, name: 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING' },
])

/**
 * Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
 * Note that it is *never* valid to have two actively running instances of the same workflow id.
 *
 * See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdConflictPolicy
 */
export enum WorkflowIdConflictPolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_FAIL = 1;
   */
  FAIL = 1,

  /**
   * Don't start a new workflow; instead return a workflow handle for the running workflow.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING = 2;
   */
  USE_EXISTING = 2,

  /**
   * Terminate the running workflow before starting a new one.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING = 3;
   */
  TERMINATE_EXISTING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(WorkflowIdConflictPolicy)
proto3.util.setEnumType(WorkflowIdConflictPolicy, 'temporal.api.enums.v1.WorkflowIdConflictPolicy', [
  { no: 0, name: 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED' },
  { no: 1, name: 'WORKFLOW_ID_CONFLICT_POLICY_FAIL' },
  { no: 2, name: 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING' },
  { no: 3, name: 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING' },
])

/**
 * Defines how child workflows will react to their parent completing
 *
 * @generated from enum temporal.api.enums.v1.ParentClosePolicy
 */
export enum ParentClosePolicy {
  /**
   * @generated from enum value: PARENT_CLOSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The child workflow will also terminate
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_TERMINATE = 1;
   */
  TERMINATE = 1,

  /**
   * The child workflow will do nothing
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_ABANDON = 2;
   */
  ABANDON = 2,

  /**
   * Cancellation will be requested of the child workflow
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_REQUEST_CANCEL = 3;
   */
  REQUEST_CANCEL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ParentClosePolicy)
proto3.util.setEnumType(ParentClosePolicy, 'temporal.api.enums.v1.ParentClosePolicy', [
  { no: 0, name: 'PARENT_CLOSE_POLICY_UNSPECIFIED' },
  { no: 1, name: 'PARENT_CLOSE_POLICY_TERMINATE' },
  { no: 2, name: 'PARENT_CLOSE_POLICY_ABANDON' },
  { no: 3, name: 'PARENT_CLOSE_POLICY_REQUEST_CANCEL' },
])

/**
 * @generated from enum temporal.api.enums.v1.ContinueAsNewInitiator
 */
export enum ContinueAsNewInitiator {
  /**
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The workflow itself requested to continue as new
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_WORKFLOW = 1;
   */
  WORKFLOW = 1,

  /**
   * The workflow continued as new because it is retrying
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_RETRY = 2;
   */
  RETRY = 2,

  /**
   * The workflow continued as new because cron has triggered a new execution
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE = 3;
   */
  CRON_SCHEDULE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ContinueAsNewInitiator)
proto3.util.setEnumType(ContinueAsNewInitiator, 'temporal.api.enums.v1.ContinueAsNewInitiator', [
  { no: 0, name: 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED' },
  { no: 1, name: 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW' },
  { no: 2, name: 'CONTINUE_AS_NEW_INITIATOR_RETRY' },
  { no: 3, name: 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE' },
])

/**
 * (-- api-linter: core::0216::synonyms=disabled
 *     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
 *
 * @generated from enum temporal.api.enums.v1.WorkflowExecutionStatus
 */
export enum WorkflowExecutionStatus {
  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Value 1 is hardcoded in SQL persistence.
   *
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_COMPLETED = 2;
   */
  COMPLETED = 2,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CANCELED = 4;
   */
  CANCELED = 4,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TERMINATED = 5;
   */
  TERMINATED = 5,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW = 6;
   */
  CONTINUED_AS_NEW = 6,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TIMED_OUT = 7;
   */
  TIMED_OUT = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(WorkflowExecutionStatus)
proto3.util.setEnumType(WorkflowExecutionStatus, 'temporal.api.enums.v1.WorkflowExecutionStatus', [
  { no: 0, name: 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED' },
  { no: 1, name: 'WORKFLOW_EXECUTION_STATUS_RUNNING' },
  { no: 2, name: 'WORKFLOW_EXECUTION_STATUS_COMPLETED' },
  { no: 3, name: 'WORKFLOW_EXECUTION_STATUS_FAILED' },
  { no: 4, name: 'WORKFLOW_EXECUTION_STATUS_CANCELED' },
  { no: 5, name: 'WORKFLOW_EXECUTION_STATUS_TERMINATED' },
  { no: 6, name: 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW' },
  { no: 7, name: 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT' },
])

/**
 * @generated from enum temporal.api.enums.v1.PendingActivityState
 */
export enum PendingActivityState {
  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_STARTED = 2;
   */
  STARTED = 2,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_CANCEL_REQUESTED = 3;
   */
  CANCEL_REQUESTED = 3,

  /**
   * PAUSED means activity is paused on the server, and is not running in the worker
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSED = 4;
   */
  PAUSED = 4,

  /**
   * PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSE_REQUESTED = 5;
   */
  PAUSE_REQUESTED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(PendingActivityState)
proto3.util.setEnumType(PendingActivityState, 'temporal.api.enums.v1.PendingActivityState', [
  { no: 0, name: 'PENDING_ACTIVITY_STATE_UNSPECIFIED' },
  { no: 1, name: 'PENDING_ACTIVITY_STATE_SCHEDULED' },
  { no: 2, name: 'PENDING_ACTIVITY_STATE_STARTED' },
  { no: 3, name: 'PENDING_ACTIVITY_STATE_CANCEL_REQUESTED' },
  { no: 4, name: 'PENDING_ACTIVITY_STATE_PAUSED' },
  { no: 5, name: 'PENDING_ACTIVITY_STATE_PAUSE_REQUESTED' },
])

/**
 * @generated from enum temporal.api.enums.v1.PendingWorkflowTaskState
 */
export enum PendingWorkflowTaskState {
  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_STARTED = 2;
   */
  STARTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PendingWorkflowTaskState)
proto3.util.setEnumType(PendingWorkflowTaskState, 'temporal.api.enums.v1.PendingWorkflowTaskState', [
  { no: 0, name: 'PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED' },
  { no: 1, name: 'PENDING_WORKFLOW_TASK_STATE_SCHEDULED' },
  { no: 2, name: 'PENDING_WORKFLOW_TASK_STATE_STARTED' },
])

/**
 * @generated from enum temporal.api.enums.v1.HistoryEventFilterType
 */
export enum HistoryEventFilterType {
  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT = 1;
   */
  ALL_EVENT = 1,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT = 2;
   */
  CLOSE_EVENT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(HistoryEventFilterType)
proto3.util.setEnumType(HistoryEventFilterType, 'temporal.api.enums.v1.HistoryEventFilterType', [
  { no: 0, name: 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED' },
  { no: 1, name: 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT' },
  { no: 2, name: 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT' },
])

/**
 * @generated from enum temporal.api.enums.v1.RetryState
 */
export enum RetryState {
  /**
   * @generated from enum value: RETRY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RETRY_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * @generated from enum value: RETRY_STATE_NON_RETRYABLE_FAILURE = 2;
   */
  NON_RETRYABLE_FAILURE = 2,

  /**
   * @generated from enum value: RETRY_STATE_TIMEOUT = 3;
   */
  TIMEOUT = 3,

  /**
   * @generated from enum value: RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED = 4;
   */
  MAXIMUM_ATTEMPTS_REACHED = 4,

  /**
   * @generated from enum value: RETRY_STATE_RETRY_POLICY_NOT_SET = 5;
   */
  RETRY_POLICY_NOT_SET = 5,

  /**
   * @generated from enum value: RETRY_STATE_INTERNAL_SERVER_ERROR = 6;
   */
  INTERNAL_SERVER_ERROR = 6,

  /**
   * @generated from enum value: RETRY_STATE_CANCEL_REQUESTED = 7;
   */
  CANCEL_REQUESTED = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(RetryState)
proto3.util.setEnumType(RetryState, 'temporal.api.enums.v1.RetryState', [
  { no: 0, name: 'RETRY_STATE_UNSPECIFIED' },
  { no: 1, name: 'RETRY_STATE_IN_PROGRESS' },
  { no: 2, name: 'RETRY_STATE_NON_RETRYABLE_FAILURE' },
  { no: 3, name: 'RETRY_STATE_TIMEOUT' },
  { no: 4, name: 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED' },
  { no: 5, name: 'RETRY_STATE_RETRY_POLICY_NOT_SET' },
  { no: 6, name: 'RETRY_STATE_INTERNAL_SERVER_ERROR' },
  { no: 7, name: 'RETRY_STATE_CANCEL_REQUESTED' },
])

/**
 * @generated from enum temporal.api.enums.v1.TimeoutType
 */
export enum TimeoutType {
  /**
   * @generated from enum value: TIMEOUT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TIMEOUT_TYPE_START_TO_CLOSE = 1;
   */
  START_TO_CLOSE = 1,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_START = 2;
   */
  SCHEDULE_TO_START = 2,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_CLOSE = 3;
   */
  SCHEDULE_TO_CLOSE = 3,

  /**
   * @generated from enum value: TIMEOUT_TYPE_HEARTBEAT = 4;
   */
  HEARTBEAT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeoutType)
proto3.util.setEnumType(TimeoutType, 'temporal.api.enums.v1.TimeoutType', [
  { no: 0, name: 'TIMEOUT_TYPE_UNSPECIFIED' },
  { no: 1, name: 'TIMEOUT_TYPE_START_TO_CLOSE' },
  { no: 2, name: 'TIMEOUT_TYPE_SCHEDULE_TO_START' },
  { no: 3, name: 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE' },
  { no: 4, name: 'TIMEOUT_TYPE_HEARTBEAT' },
])

/**
 * Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
 * Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
 * who completes the first task of the execution, but is also overridable manually for new and
 * existing workflows (see VersioningOverride).
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from enum temporal.api.enums.v1.VersioningBehavior
 */
export enum VersioningBehavior {
  /**
   * Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
   * legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
   * `WorkerVersioningMode`.)
   * User needs to use Patching to keep the new code compatible with prior versions when dealing
   * with Unversioned workflows.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow will start on the Current Deployment Version of its Task Queue, and then
   * will be pinned to that same Deployment Version until completion (the Version that
   * this Workflow is pinned to is specified in `versioning_info.version`).
   * This behavior eliminates most of compatibility concerns users face when changing their code.
   * Patching is not needed when pinned workflows code change.
   * Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
   * execution to another Deployment Version.
   * Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
   * would be when the activity Task Queue workers are not present in the workflow's Deployment
   * Version, in which case the activity will be sent to the Current Deployment Version of its own
   * task queue.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,

  /**
   * Workflow will automatically move to the Current Deployment Version of its Task Queue when the
   * next workflow task is dispatched.
   * AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
   * latest Deployment Version, but the user still needs to use Patching to keep the new code
   * compatible with prior versions for changed workflow types.
   * Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
   * execution (as specified in versioning_info.version based on the last completed
   * workflow task). Exception to this would be when the activity Task Queue workers are not
   * present in the workflow's Deployment Version, in which case, the activity will be sent to a
   * different Deployment Version according to the Current Deployment Version of its own task
   * queue.
   * Workflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment
   * Version of their Task Queue changes, without having to wait for the backlogged activity to
   * complete on the old Version.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_AUTO_UPGRADE = 2;
   */
  AUTO_UPGRADE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(VersioningBehavior)
proto3.util.setEnumType(VersioningBehavior, 'temporal.api.enums.v1.VersioningBehavior', [
  { no: 0, name: 'VERSIONING_BEHAVIOR_UNSPECIFIED' },
  { no: 1, name: 'VERSIONING_BEHAVIOR_PINNED' },
  { no: 2, name: 'VERSIONING_BEHAVIOR_AUTO_UPGRADE' },
])
