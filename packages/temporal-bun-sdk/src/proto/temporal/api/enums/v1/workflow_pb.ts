// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/enums/v1/workflow.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc } from "@bufbuild/protobuf/codegenv2";

/**
 * Describes the file temporal/api/enums/v1/workflow.proto.
 */
export const file_temporal_api_enums_v1_workflow: GenFile = /*@__PURE__*/
  fileDesc("CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvd29ya2Zsb3cucHJvdG8SFXRlbXBvcmFsLmFwaS5lbnVtcy52MSqLAgoVV29ya2Zsb3dJZFJldXNlUG9saWN5EigKJFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRBAAEiwKKFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEUQARI4CjRXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZEAISLQopV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEUQAxIxCi1XT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlOQVRFX0lGX1JVTk5JTkcQBCrPAQoYV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5EisKJ1dPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9VTlNQRUNJRklFRBAAEiQKIFdPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9GQUlMEAESLAooV09SS0ZMT1dfSURfQ09ORkxJQ1RfUE9MSUNZX1VTRV9FWElTVElORxACEjIKLldPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9URVJNSU5BVEVfRVhJU1RJTkcQAyqkAQoRUGFyZW50Q2xvc2VQb2xpY3kSIwofUEFSRU5UX0NMT1NFX1BPTElDWV9VTlNQRUNJRklFRBAAEiEKHVBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFEAESHwobUEFSRU5UX0NMT1NFX1BPTElDWV9BQkFORE9OEAISJgoiUEFSRU5UX0NMT1NFX1BPTElDWV9SRVFVRVNUX0NBTkNFTBADKr0BChZDb250aW51ZUFzTmV3SW5pdGlhdG9yEikKJUNPTlRJTlVFX0FTX05FV19JTklUSUFUT1JfVU5TUEVDSUZJRUQQABImCiJDT05USU5VRV9BU19ORVdfSU5JVElBVE9SX1dPUktGTE9XEAESIwofQ09OVElOVUVfQVNfTkVXX0lOSVRJQVRPUl9SRVRSWRACEisKJ0NPTlRJTlVFX0FTX05FV19JTklUSUFUT1JfQ1JPTl9TQ0hFRFVMRRADKuUCChdXb3JrZmxvd0V4ZWN1dGlvblN0YXR1cxIpCiVXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX1VOU1BFQ0lGSUVEEAASJQohV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19SVU5OSU5HEAESJwojV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19DT01QTEVURUQQAhIkCiBXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX0ZBSUxFRBADEiYKIldPUktGTE9XX0VYRUNVVElPTl9TVEFUVVNfQ0FOQ0VMRUQQBBIoCiRXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX1RFUk1JTkFURUQQBRIuCipXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX0NPTlRJTlVFRF9BU19ORVcQBhInCiNXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX1RJTUVEX09VVBAHKoQCChRQZW5kaW5nQWN0aXZpdHlTdGF0ZRImCiJQRU5ESU5HX0FDVElWSVRZX1NUQVRFX1VOU1BFQ0lGSUVEEAASJAogUEVORElOR19BQ1RJVklUWV9TVEFURV9TQ0hFRFVMRUQQARIiCh5QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1NUQVJURUQQAhIrCidQRU5ESU5HX0FDVElWSVRZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQQAxIhCh1QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1BBVVNFRBAEEioKJlBFTkRJTkdfQUNUSVZJVFlfU1RBVEVfUEFVU0VfUkVRVUVTVEVEEAUqmwEKGFBlbmRpbmdXb3JrZmxvd1Rhc2tTdGF0ZRIrCidQRU5ESU5HX1dPUktGTE9XX1RBU0tfU1RBVEVfVU5TUEVDSUZJRUQQABIpCiVQRU5ESU5HX1dPUktGTE9XX1RBU0tfU1RBVEVfU0NIRURVTEVEEAESJwojUEVORElOR19XT1JLRkxPV19UQVNLX1NUQVRFX1NUQVJURUQQAiqXAQoWSGlzdG9yeUV2ZW50RmlsdGVyVHlwZRIpCiVISVNUT1JZX0VWRU5UX0ZJTFRFUl9UWVBFX1VOU1BFQ0lGSUVEEAASJwojSElTVE9SWV9FVkVOVF9GSUxURVJfVFlQRV9BTExfRVZFTlQQARIpCiVISVNUT1JZX0VWRU5UX0ZJTFRFUl9UWVBFX0NMT1NFX0VWRU5UEAIqnwIKClJldHJ5U3RhdGUSGwoXUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQQABIbChdSRVRSWV9TVEFURV9JTl9QUk9HUkVTUxABEiUKIVJFVFJZX1NUQVRFX05PTl9SRVRSWUFCTEVfRkFJTFVSRRACEhcKE1JFVFJZX1NUQVRFX1RJTUVPVVQQAxIoCiRSRVRSWV9TVEFURV9NQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQQBBIkCiBSRVRSWV9TVEFURV9SRVRSWV9QT0xJQ1lfTk9UX1NFVBAFEiUKIVJFVFJZX1NUQVRFX0lOVEVSTkFMX1NFUlZFUl9FUlJPUhAGEiAKHFJFVFJZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQQByqwAQoLVGltZW91dFR5cGUSHAoYVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEEAASHwobVElNRU9VVF9UWVBFX1NUQVJUX1RPX0NMT1NFEAESIgoeVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX1NUQVJUEAISIgoeVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX0NMT1NFEAMSGgoWVElNRU9VVF9UWVBFX0hFQVJUQkVBVBAEKn8KElZlcnNpb25pbmdCZWhhdmlvchIjCh9WRVJTSU9OSU5HX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAASHgoaVkVSU0lPTklOR19CRUhBVklPUl9QSU5ORUQQARIkCiBWRVJTSU9OSU5HX0JFSEFWSU9SX0FVVE9fVVBHUkFERRACQoUBChhpby50ZW1wb3JhbC5hcGkuZW51bXMudjFCDVdvcmtmbG93UHJvdG9QAVohZ28udGVtcG9yYWwuaW8vYXBpL2VudW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMuVjHqAhpUZW1wb3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z");

/**
 * Defines whether to allow re-using a workflow id from a previously *closed* workflow.
 * If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
 *
 * See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdReusePolicy
 */
export enum WorkflowIdReusePolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Allow starting a workflow execution using the same workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE = 1;
   */
  ALLOW_DUPLICATE = 1,

  /**
   * Allow starting a workflow execution using the same workflow id, only when the last
   * execution's final state is one of [terminated, cancelled, timed out, failed].
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY = 2;
   */
  ALLOW_DUPLICATE_FAILED_ONLY = 2,

  /**
   * Do not permit re-use of the workflow id for this workflow. Future start workflow requests
   * could potentially change the policy, allowing re-use of the workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE = 3;
   */
  REJECT_DUPLICATE = 3,

  /**
   * This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.
   * If specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on
   * the request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.
   * If no running workflow, then the behavior is the same as ALLOW_DUPLICATE.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING = 4;
   */
  TERMINATE_IF_RUNNING = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowIdReusePolicy.
 */
export const WorkflowIdReusePolicySchema: GenEnum<WorkflowIdReusePolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 0);

/**
 * Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
 * Note that it is *never* valid to have two actively running instances of the same workflow id.
 *
 * See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdConflictPolicy
 */
export enum WorkflowIdConflictPolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_FAIL = 1;
   */
  FAIL = 1,

  /**
   * Don't start a new workflow; instead return a workflow handle for the running workflow.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING = 2;
   */
  USE_EXISTING = 2,

  /**
   * Terminate the running workflow before starting a new one.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING = 3;
   */
  TERMINATE_EXISTING = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowIdConflictPolicy.
 */
export const WorkflowIdConflictPolicySchema: GenEnum<WorkflowIdConflictPolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 1);

/**
 * Defines how child workflows will react to their parent completing
 *
 * @generated from enum temporal.api.enums.v1.ParentClosePolicy
 */
export enum ParentClosePolicy {
  /**
   * @generated from enum value: PARENT_CLOSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The child workflow will also terminate
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_TERMINATE = 1;
   */
  TERMINATE = 1,

  /**
   * The child workflow will do nothing
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_ABANDON = 2;
   */
  ABANDON = 2,

  /**
   * Cancellation will be requested of the child workflow
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_REQUEST_CANCEL = 3;
   */
  REQUEST_CANCEL = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.ParentClosePolicy.
 */
export const ParentClosePolicySchema: GenEnum<ParentClosePolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 2);

/**
 * @generated from enum temporal.api.enums.v1.ContinueAsNewInitiator
 */
export enum ContinueAsNewInitiator {
  /**
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The workflow itself requested to continue as new
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_WORKFLOW = 1;
   */
  WORKFLOW = 1,

  /**
   * The workflow continued as new because it is retrying
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_RETRY = 2;
   */
  RETRY = 2,

  /**
   * The workflow continued as new because cron has triggered a new execution
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE = 3;
   */
  CRON_SCHEDULE = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.ContinueAsNewInitiator.
 */
export const ContinueAsNewInitiatorSchema: GenEnum<ContinueAsNewInitiator> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 3);

/**
 * (-- api-linter: core::0216::synonyms=disabled
 *     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
 *
 * @generated from enum temporal.api.enums.v1.WorkflowExecutionStatus
 */
export enum WorkflowExecutionStatus {
  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Value 1 is hardcoded in SQL persistence.
   *
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_COMPLETED = 2;
   */
  COMPLETED = 2,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CANCELED = 4;
   */
  CANCELED = 4,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TERMINATED = 5;
   */
  TERMINATED = 5,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW = 6;
   */
  CONTINUED_AS_NEW = 6,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TIMED_OUT = 7;
   */
  TIMED_OUT = 7,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowExecutionStatus.
 */
export const WorkflowExecutionStatusSchema: GenEnum<WorkflowExecutionStatus> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 4);

/**
 * @generated from enum temporal.api.enums.v1.PendingActivityState
 */
export enum PendingActivityState {
  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_STARTED = 2;
   */
  STARTED = 2,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_CANCEL_REQUESTED = 3;
   */
  CANCEL_REQUESTED = 3,

  /**
   * PAUSED means activity is paused on the server, and is not running in the worker
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSED = 4;
   */
  PAUSED = 4,

  /**
   * PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSE_REQUESTED = 5;
   */
  PAUSE_REQUESTED = 5,
}

/**
 * Describes the enum temporal.api.enums.v1.PendingActivityState.
 */
export const PendingActivityStateSchema: GenEnum<PendingActivityState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 5);

/**
 * @generated from enum temporal.api.enums.v1.PendingWorkflowTaskState
 */
export enum PendingWorkflowTaskState {
  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_STARTED = 2;
   */
  STARTED = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.PendingWorkflowTaskState.
 */
export const PendingWorkflowTaskStateSchema: GenEnum<PendingWorkflowTaskState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 6);

/**
 * @generated from enum temporal.api.enums.v1.HistoryEventFilterType
 */
export enum HistoryEventFilterType {
  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT = 1;
   */
  ALL_EVENT = 1,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT = 2;
   */
  CLOSE_EVENT = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.HistoryEventFilterType.
 */
export const HistoryEventFilterTypeSchema: GenEnum<HistoryEventFilterType> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 7);

/**
 * @generated from enum temporal.api.enums.v1.RetryState
 */
export enum RetryState {
  /**
   * @generated from enum value: RETRY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RETRY_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * @generated from enum value: RETRY_STATE_NON_RETRYABLE_FAILURE = 2;
   */
  NON_RETRYABLE_FAILURE = 2,

  /**
   * @generated from enum value: RETRY_STATE_TIMEOUT = 3;
   */
  TIMEOUT = 3,

  /**
   * @generated from enum value: RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED = 4;
   */
  MAXIMUM_ATTEMPTS_REACHED = 4,

  /**
   * @generated from enum value: RETRY_STATE_RETRY_POLICY_NOT_SET = 5;
   */
  RETRY_POLICY_NOT_SET = 5,

  /**
   * @generated from enum value: RETRY_STATE_INTERNAL_SERVER_ERROR = 6;
   */
  INTERNAL_SERVER_ERROR = 6,

  /**
   * @generated from enum value: RETRY_STATE_CANCEL_REQUESTED = 7;
   */
  CANCEL_REQUESTED = 7,
}

/**
 * Describes the enum temporal.api.enums.v1.RetryState.
 */
export const RetryStateSchema: GenEnum<RetryState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 8);

/**
 * @generated from enum temporal.api.enums.v1.TimeoutType
 */
export enum TimeoutType {
  /**
   * @generated from enum value: TIMEOUT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TIMEOUT_TYPE_START_TO_CLOSE = 1;
   */
  START_TO_CLOSE = 1,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_START = 2;
   */
  SCHEDULE_TO_START = 2,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_CLOSE = 3;
   */
  SCHEDULE_TO_CLOSE = 3,

  /**
   * @generated from enum value: TIMEOUT_TYPE_HEARTBEAT = 4;
   */
  HEARTBEAT = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.TimeoutType.
 */
export const TimeoutTypeSchema: GenEnum<TimeoutType> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 9);

/**
 * Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
 * Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
 * who completes the first task of the execution, but is also overridable manually for new and
 * existing workflows (see VersioningOverride).
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from enum temporal.api.enums.v1.VersioningBehavior
 */
export enum VersioningBehavior {
  /**
   * Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
   * legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
   * `WorkerVersioningMode`.)
   * User needs to use Patching to keep the new code compatible with prior versions when dealing
   * with Unversioned workflows.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow will start on the Current Deployment Version of its Task Queue, and then
   * will be pinned to that same Deployment Version until completion (the Version that
   * this Workflow is pinned to is specified in `versioning_info.version`).
   * This behavior eliminates most of compatibility concerns users face when changing their code.
   * Patching is not needed when pinned workflows code change.
   * Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
   * execution to another Deployment Version.
   * Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
   * would be when the activity Task Queue workers are not present in the workflow's Deployment
   * Version, in which case the activity will be sent to the Current Deployment Version of its own
   * task queue.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,

  /**
   * Workflow will automatically move to the Current Deployment Version of its Task Queue when the
   * next workflow task is dispatched.
   * AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
   * latest Deployment Version, but the user still needs to use Patching to keep the new code
   * compatible with prior versions for changed workflow types.
   * Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
   * execution (as specified in versioning_info.version based on the last completed
   * workflow task). Exception to this would be when the activity Task Queue workers are not
   * present in the workflow's Deployment Version, in which case, the activity will be sent to a
   * different Deployment Version according to the Current Deployment Version of its own task
   * queue.
   * Workflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment
   * Version of their Task Queue changes, without having to wait for the backlogged activity to
   * complete on the old Version.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_AUTO_UPGRADE = 2;
   */
  AUTO_UPGRADE = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.VersioningBehavior.
 */
export const VersioningBehaviorSchema: GenEnum<VersioningBehavior> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 10);

