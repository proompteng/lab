// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=js"
// @generated from file temporal/api/enums/v1/workflow.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc } from "@bufbuild/protobuf/codegenv2";

/**
 * Describes the file temporal/api/enums/v1/workflow.proto.
 */
export const file_temporal_api_enums_v1_workflow: GenFile = /*@__PURE__*/
  fileDesc("CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvd29ya2Zsb3cucHJvdG8SFXRlbXBvcmFsLmFwaS5lbnVtcy52MSqPAgoVV29ya2Zsb3dJZFJldXNlUG9saWN5EigKJFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRBAAEiwKKFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEUQARI4CjRXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZEAISLQopV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEUQAxI1Ci1XT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlOQVRFX0lGX1JVTk5JTkcQBBoCCAEqzwEKGFdvcmtmbG93SWRDb25mbGljdFBvbGljeRIrCidXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVU5TUEVDSUZJRUQQABIkCiBXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfRkFJTBABEiwKKFdPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9VU0VfRVhJU1RJTkcQAhIyCi5XT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVEVSTUlOQVRFX0VYSVNUSU5HEAMqpAEKEVBhcmVudENsb3NlUG9saWN5EiMKH1BBUkVOVF9DTE9TRV9QT0xJQ1lfVU5TUEVDSUZJRUQQABIhCh1QQVJFTlRfQ0xPU0VfUE9MSUNZX1RFUk1JTkFURRABEh8KG1BBUkVOVF9DTE9TRV9QT0xJQ1lfQUJBTkRPThACEiYKIlBBUkVOVF9DTE9TRV9QT0xJQ1lfUkVRVUVTVF9DQU5DRUwQAyq9AQoWQ29udGludWVBc05ld0luaXRpYXRvchIpCiVDT05USU5VRV9BU19ORVdfSU5JVElBVE9SX1VOU1BFQ0lGSUVEEAASJgoiQ09OVElOVUVfQVNfTkVXX0lOSVRJQVRPUl9XT1JLRkxPVxABEiMKH0NPTlRJTlVFX0FTX05FV19JTklUSUFUT1JfUkVUUlkQAhIrCidDT05USU5VRV9BU19ORVdfSU5JVElBVE9SX0NST05fU0NIRURVTEUQAyqLAwoXV29ya2Zsb3dFeGVjdXRpb25TdGF0dXMSKQolV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19VTlNQRUNJRklFRBAAEiUKIVdPUktGTE9XX0VYRUNVVElPTl9TVEFUVVNfUlVOTklORxABEicKI1dPUktGTE9XX0VYRUNVVElPTl9TVEFUVVNfQ09NUExFVEVEEAISJAogV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19GQUlMRUQQAxImCiJXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX0NBTkNFTEVEEAQSKAokV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19URVJNSU5BVEVEEAUSLgoqV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19DT05USU5VRURfQVNfTkVXEAYSJwojV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19USU1FRF9PVVQQBxIkCiBXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX1BBVVNFRBAIKoQCChRQZW5kaW5nQWN0aXZpdHlTdGF0ZRImCiJQRU5ESU5HX0FDVElWSVRZX1NUQVRFX1VOU1BFQ0lGSUVEEAASJAogUEVORElOR19BQ1RJVklUWV9TVEFURV9TQ0hFRFVMRUQQARIiCh5QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1NUQVJURUQQAhIrCidQRU5ESU5HX0FDVElWSVRZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQQAxIhCh1QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1BBVVNFRBAEEioKJlBFTkRJTkdfQUNUSVZJVFlfU1RBVEVfUEFVU0VfUkVRVUVTVEVEEAUqmwEKGFBlbmRpbmdXb3JrZmxvd1Rhc2tTdGF0ZRIrCidQRU5ESU5HX1dPUktGTE9XX1RBU0tfU1RBVEVfVU5TUEVDSUZJRUQQABIpCiVQRU5ESU5HX1dPUktGTE9XX1RBU0tfU1RBVEVfU0NIRURVTEVEEAESJwojUEVORElOR19XT1JLRkxPV19UQVNLX1NUQVRFX1NUQVJURUQQAiqXAQoWSGlzdG9yeUV2ZW50RmlsdGVyVHlwZRIpCiVISVNUT1JZX0VWRU5UX0ZJTFRFUl9UWVBFX1VOU1BFQ0lGSUVEEAASJwojSElTVE9SWV9FVkVOVF9GSUxURVJfVFlQRV9BTExfRVZFTlQQARIpCiVISVNUT1JZX0VWRU5UX0ZJTFRFUl9UWVBFX0NMT1NFX0VWRU5UEAIqnwIKClJldHJ5U3RhdGUSGwoXUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQQABIbChdSRVRSWV9TVEFURV9JTl9QUk9HUkVTUxABEiUKIVJFVFJZX1NUQVRFX05PTl9SRVRSWUFCTEVfRkFJTFVSRRACEhcKE1JFVFJZX1NUQVRFX1RJTUVPVVQQAxIoCiRSRVRSWV9TVEFURV9NQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQQBBIkCiBSRVRSWV9TVEFURV9SRVRSWV9QT0xJQ1lfTk9UX1NFVBAFEiUKIVJFVFJZX1NUQVRFX0lOVEVSTkFMX1NFUlZFUl9FUlJPUhAGEiAKHFJFVFJZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQQByqwAQoLVGltZW91dFR5cGUSHAoYVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEEAASHwobVElNRU9VVF9UWVBFX1NUQVJUX1RPX0NMT1NFEAESIgoeVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX1NUQVJUEAISIgoeVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX0NMT1NFEAMSGgoWVElNRU9VVF9UWVBFX0hFQVJUQkVBVBAEKn8KElZlcnNpb25pbmdCZWhhdmlvchIjCh9WRVJTSU9OSU5HX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAASHgoaVkVSU0lPTklOR19CRUhBVklPUl9QSU5ORUQQARIkCiBWRVJTSU9OSU5HX0JFSEFWSU9SX0FVVE9fVVBHUkFERRACKowBCh9Db250aW51ZUFzTmV3VmVyc2lvbmluZ0JlaGF2aW9yEjMKL0NPTlRJTlVFX0FTX05FV19WRVJTSU9OSU5HX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAASNAowQ09OVElOVUVfQVNfTkVXX1ZFUlNJT05JTkdfQkVIQVZJT1JfQVVUT19VUEdSQURFEAEqxQIKGlN1Z2dlc3RDb250aW51ZUFzTmV3UmVhc29uEi4KKlNVR0dFU1RfQ09OVElOVUVfQVNfTkVXX1JFQVNPTl9VTlNQRUNJRklFRBAAEjkKNVNVR0dFU1RfQ09OVElOVUVfQVNfTkVXX1JFQVNPTl9ISVNUT1JZX1NJWkVfVE9PX0xBUkdFEAESOgo2U1VHR0VTVF9DT05USU5VRV9BU19ORVdfUkVBU09OX1RPT19NQU5ZX0hJU1RPUllfRVZFTlRTEAISMwovU1VHR0VTVF9DT05USU5VRV9BU19ORVdfUkVBU09OX1RPT19NQU5ZX1VQREFURVMQAxJLCkdTVUdHRVNUX0NPTlRJTlVFX0FTX05FV19SRUFTT05fVEFSR0VUX1dPUktFUl9ERVBMT1lNRU5UX1ZFUlNJT05fQ0hBTkdFRBAEQoUBChhpby50ZW1wb3JhbC5hcGkuZW51bXMudjFCDVdvcmtmbG93UHJvdG9QAVohZ28udGVtcG9yYWwuaW8vYXBpL2VudW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMuVjHqAhpUZW1wb3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z");

/**
 * Defines whether to allow re-using a workflow id from a previously *closed* workflow.
 * If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
 *
 * See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdReusePolicy
 */
export enum WorkflowIdReusePolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Allow starting a workflow execution using the same workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE = 1;
   */
  ALLOW_DUPLICATE = 1,

  /**
   * Allow starting a workflow execution using the same workflow id, only when the last
   * execution's final state is one of [terminated, cancelled, timed out, failed].
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY = 2;
   */
  ALLOW_DUPLICATE_FAILED_ONLY = 2,

  /**
   * Do not permit re-use of the workflow id for this workflow. Future start workflow requests
   * could potentially change the policy, allowing re-use of the workflow id.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE = 3;
   */
  REJECT_DUPLICATE = 3,

  /**
   * Terminate the current Workflow if one is already running; otherwise allow reusing the
   * Workflow ID. When using this option, `WorkflowIdConflictPolicy` must be left unspecified.
   *
   * Deprecated. Instead, set `WorkflowIdReusePolicy` to `ALLOW_DUPLICATE` and
   * `WorkflowIdConflictPolicy` to `TERMINATE_EXISTING`. Note that `WorkflowIdConflictPolicy`
   * requires Temporal Server v1.24.0 or later.
   *
   * @generated from enum value: WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING = 4 [deprecated = true];
   * @deprecated
   */
  TERMINATE_IF_RUNNING = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowIdReusePolicy.
 */
export const WorkflowIdReusePolicySchema: GenEnum<WorkflowIdReusePolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 0);

/**
 * Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
 * Note that it is *never* valid to have two actively running instances of the same workflow id.
 *
 * See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
 *
 * @generated from enum temporal.api.enums.v1.WorkflowIdConflictPolicy
 */
export enum WorkflowIdConflictPolicy {
  /**
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_FAIL = 1;
   */
  FAIL = 1,

  /**
   * Don't start a new workflow; instead return a workflow handle for the running workflow.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING = 2;
   */
  USE_EXISTING = 2,

  /**
   * Terminate the running workflow before starting a new one.
   *
   * @generated from enum value: WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING = 3;
   */
  TERMINATE_EXISTING = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowIdConflictPolicy.
 */
export const WorkflowIdConflictPolicySchema: GenEnum<WorkflowIdConflictPolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 1);

/**
 * Defines how child workflows will react to their parent completing
 *
 * @generated from enum temporal.api.enums.v1.ParentClosePolicy
 */
export enum ParentClosePolicy {
  /**
   * @generated from enum value: PARENT_CLOSE_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The child workflow will also terminate
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_TERMINATE = 1;
   */
  TERMINATE = 1,

  /**
   * The child workflow will do nothing
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_ABANDON = 2;
   */
  ABANDON = 2,

  /**
   * Cancellation will be requested of the child workflow
   *
   * @generated from enum value: PARENT_CLOSE_POLICY_REQUEST_CANCEL = 3;
   */
  REQUEST_CANCEL = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.ParentClosePolicy.
 */
export const ParentClosePolicySchema: GenEnum<ParentClosePolicy> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 2);

/**
 * @generated from enum temporal.api.enums.v1.ContinueAsNewInitiator
 */
export enum ContinueAsNewInitiator {
  /**
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The workflow itself requested to continue as new
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_WORKFLOW = 1;
   */
  WORKFLOW = 1,

  /**
   * The workflow continued as new because it is retrying
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_RETRY = 2;
   */
  RETRY = 2,

  /**
   * The workflow continued as new because cron has triggered a new execution
   *
   * @generated from enum value: CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE = 3;
   */
  CRON_SCHEDULE = 3,
}

/**
 * Describes the enum temporal.api.enums.v1.ContinueAsNewInitiator.
 */
export const ContinueAsNewInitiatorSchema: GenEnum<ContinueAsNewInitiator> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 3);

/**
 * (-- api-linter: core::0216::synonyms=disabled
 *     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
 *
 * @generated from enum temporal.api.enums.v1.WorkflowExecutionStatus
 */
export enum WorkflowExecutionStatus {
  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Value 1 is hardcoded in SQL persistence.
   *
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_COMPLETED = 2;
   */
  COMPLETED = 2,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CANCELED = 4;
   */
  CANCELED = 4,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TERMINATED = 5;
   */
  TERMINATED = 5,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW = 6;
   */
  CONTINUED_AS_NEW = 6,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_TIMED_OUT = 7;
   */
  TIMED_OUT = 7,

  /**
   * @generated from enum value: WORKFLOW_EXECUTION_STATUS_PAUSED = 8;
   */
  PAUSED = 8,
}

/**
 * Describes the enum temporal.api.enums.v1.WorkflowExecutionStatus.
 */
export const WorkflowExecutionStatusSchema: GenEnum<WorkflowExecutionStatus> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 4);

/**
 * @generated from enum temporal.api.enums.v1.PendingActivityState
 */
export enum PendingActivityState {
  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_STARTED = 2;
   */
  STARTED = 2,

  /**
   * @generated from enum value: PENDING_ACTIVITY_STATE_CANCEL_REQUESTED = 3;
   */
  CANCEL_REQUESTED = 3,

  /**
   * PAUSED means activity is paused on the server, and is not running in the worker
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSED = 4;
   */
  PAUSED = 4,

  /**
   * PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
   *
   * @generated from enum value: PENDING_ACTIVITY_STATE_PAUSE_REQUESTED = 5;
   */
  PAUSE_REQUESTED = 5,
}

/**
 * Describes the enum temporal.api.enums.v1.PendingActivityState.
 */
export const PendingActivityStateSchema: GenEnum<PendingActivityState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 5);

/**
 * @generated from enum temporal.api.enums.v1.PendingWorkflowTaskState
 */
export enum PendingWorkflowTaskState {
  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: PENDING_WORKFLOW_TASK_STATE_STARTED = 2;
   */
  STARTED = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.PendingWorkflowTaskState.
 */
export const PendingWorkflowTaskStateSchema: GenEnum<PendingWorkflowTaskState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 6);

/**
 * @generated from enum temporal.api.enums.v1.HistoryEventFilterType
 */
export enum HistoryEventFilterType {
  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT = 1;
   */
  ALL_EVENT = 1,

  /**
   * @generated from enum value: HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT = 2;
   */
  CLOSE_EVENT = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.HistoryEventFilterType.
 */
export const HistoryEventFilterTypeSchema: GenEnum<HistoryEventFilterType> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 7);

/**
 * @generated from enum temporal.api.enums.v1.RetryState
 */
export enum RetryState {
  /**
   * @generated from enum value: RETRY_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RETRY_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * @generated from enum value: RETRY_STATE_NON_RETRYABLE_FAILURE = 2;
   */
  NON_RETRYABLE_FAILURE = 2,

  /**
   * @generated from enum value: RETRY_STATE_TIMEOUT = 3;
   */
  TIMEOUT = 3,

  /**
   * @generated from enum value: RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED = 4;
   */
  MAXIMUM_ATTEMPTS_REACHED = 4,

  /**
   * @generated from enum value: RETRY_STATE_RETRY_POLICY_NOT_SET = 5;
   */
  RETRY_POLICY_NOT_SET = 5,

  /**
   * @generated from enum value: RETRY_STATE_INTERNAL_SERVER_ERROR = 6;
   */
  INTERNAL_SERVER_ERROR = 6,

  /**
   * @generated from enum value: RETRY_STATE_CANCEL_REQUESTED = 7;
   */
  CANCEL_REQUESTED = 7,
}

/**
 * Describes the enum temporal.api.enums.v1.RetryState.
 */
export const RetryStateSchema: GenEnum<RetryState> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 8);

/**
 * @generated from enum temporal.api.enums.v1.TimeoutType
 */
export enum TimeoutType {
  /**
   * @generated from enum value: TIMEOUT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TIMEOUT_TYPE_START_TO_CLOSE = 1;
   */
  START_TO_CLOSE = 1,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_START = 2;
   */
  SCHEDULE_TO_START = 2,

  /**
   * @generated from enum value: TIMEOUT_TYPE_SCHEDULE_TO_CLOSE = 3;
   */
  SCHEDULE_TO_CLOSE = 3,

  /**
   * @generated from enum value: TIMEOUT_TYPE_HEARTBEAT = 4;
   */
  HEARTBEAT = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.TimeoutType.
 */
export const TimeoutTypeSchema: GenEnum<TimeoutType> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 9);

/**
 * Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
 * Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
 * who completes the first task of the execution, but is also overridable manually for new and
 * existing workflows (see VersioningOverride).
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from enum temporal.api.enums.v1.VersioningBehavior
 */
export enum VersioningBehavior {
  /**
   * Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
   * legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
   * `WorkerVersioningMode`.)
   * User needs to use Patching to keep the new code compatible with prior versions when dealing
   * with Unversioned workflows.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow will start on its Target Version and then will be pinned to that same Deployment
   * Version until completion (the Version that this Workflow is pinned to is specified in
   * `versioning_info.version` and is the Pinned Version of the Workflow).
   *
   * The workflow's Target Version is the Current Version of its Task Queue, or, if the
   * Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
   * Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
   * Ramping group depends on its Workflow ID and and the Ramp Percentage.
   *
   * This behavior eliminates most of compatibility concerns users face when changing their code.
   * Patching is not needed when pinned workflows code change.
   * Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
   * execution to another Deployment Version.
   * Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
   * would be when the activity Task Queue workers are not present in the workflow's Deployment
   * Version, in which case the activity will be sent to the Current Deployment Version of its own
   * task queue.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,

  /**
   * Workflow will automatically move to its Target Version when the next workflow task is dispatched.
   *
   * The workflow's Target Version is the Current Version of its Task Queue, or, if the
   * Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
   * Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
   * Ramping group depends on its Workflow ID and and the Ramp Percentage.
   *
   * AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
   * latest Deployment Version, but the user still needs to use Patching to keep the new code
   * compatible with prior versions for changed workflow types.
   * Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
   * execution (as specified in versioning_info.version based on the last completed
   * workflow task). Exception to this would be when the activity Task Queue workers are not
   * present in the workflow's Deployment Version, in which case, the activity will be sent to a
   * different Deployment Version according to the Current or Ramping Deployment Version of its own
   * Task Queue.
   * Workflows stuck on a backlogged activity will still auto-upgrade if their Target Version
   * changes, without having to wait for the backlogged activity to complete on the old Version.
   *
   * @generated from enum value: VERSIONING_BEHAVIOR_AUTO_UPGRADE = 2;
   */
  AUTO_UPGRADE = 2,
}

/**
 * Describes the enum temporal.api.enums.v1.VersioningBehavior.
 */
export const VersioningBehaviorSchema: GenEnum<VersioningBehavior> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 10);

/**
 * Experimental. Defines the versioning behavior to be used by the first task of a new workflow run in a continue-as-new chain.
 *
 * @generated from enum temporal.api.enums.v1.ContinueAsNewVersioningBehavior
 */
export enum ContinueAsNewVersioningBehavior {
  /**
   * @generated from enum value: CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Start the new run with AutoUpgrade behavior. Use the Target Version of the workflow's task queue at
   * start-time, as AutoUpgrade workflows do. After the first workflow task completes, use whatever
   * Versioning Behavior the workflow is annotated with in the workflow code.
   *
   * Note that if the previous workflow had a Pinned override, that override will be inherited by the
   * new workflow run regardless of the ContinueAsNewVersioningBehavior specified in the continue-as-new
   * command. If a Pinned override is inherited by the new run, and the new run starts with AutoUpgrade
   * behavior, the base version of the new run will be the Target Version as described above, but the
   * effective version will be whatever is specified by the Versioning Override until the override is removed.
   *
   * @generated from enum value: CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_AUTO_UPGRADE = 1;
   */
  AUTO_UPGRADE = 1,
}

/**
 * Describes the enum temporal.api.enums.v1.ContinueAsNewVersioningBehavior.
 */
export const ContinueAsNewVersioningBehaviorSchema: GenEnum<ContinueAsNewVersioningBehavior> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 11);

/**
 * SuggestContinueAsNewReason specifies why SuggestContinueAsNew is true.
 *
 * @generated from enum temporal.api.enums.v1.SuggestContinueAsNewReason
 */
export enum SuggestContinueAsNewReason {
  /**
   * @generated from enum value: SUGGEST_CONTINUE_AS_NEW_REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow History size is getting too large.
   *
   * @generated from enum value: SUGGEST_CONTINUE_AS_NEW_REASON_HISTORY_SIZE_TOO_LARGE = 1;
   */
  HISTORY_SIZE_TOO_LARGE = 1,

  /**
   * Workflow History event count is getting too large.
   *
   * @generated from enum value: SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_HISTORY_EVENTS = 2;
   */
  TOO_MANY_HISTORY_EVENTS = 2,

  /**
   * Workflow's count of completed plus in-flight updates is too large.
   *
   * @generated from enum value: SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_UPDATES = 3;
   */
  TOO_MANY_UPDATES = 3,

  /**
   * Workflow's Target Worker Deployment Version is different from its
   * Current Version and the workflow is versioned.
   *
   * @generated from enum value: SUGGEST_CONTINUE_AS_NEW_REASON_TARGET_WORKER_DEPLOYMENT_VERSION_CHANGED = 4;
   */
  TARGET_WORKER_DEPLOYMENT_VERSION_CHANGED = 4,
}

/**
 * Describes the enum temporal.api.enums.v1.SuggestContinueAsNewReason.
 */
export const SuggestContinueAsNewReasonSchema: GenEnum<SuggestContinueAsNewReason> = /*@__PURE__*/
  enumDesc(file_temporal_api_enums_v1_workflow, 12);

