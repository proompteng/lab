// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/enums/v1/task_queue.proto (package temporal.api.enums.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum temporal.api.enums.v1.TaskQueueKind
 */
export enum TaskQueueKind {
  /**
   * @generated from enum value: TASK_QUEUE_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Tasks from a normal workflow task queue always include complete workflow history
   *
   * The task queue specified by the user is always a normal task queue. There can be as many
   * workers as desired for a single normal task queue. All those workers may pick up tasks from
   * that queue.
   *
   * @generated from enum value: TASK_QUEUE_KIND_NORMAL = 1;
   */
  NORMAL = 1,

  /**
   * A sticky queue only includes new history since the last workflow task, and they are
   * per-worker.
   *
   * Sticky queues are created dynamically by each worker during their start up. They only exist
   * for the lifetime of the worker process. Tasks in a sticky task queue are only available to
   * the worker that created the sticky queue.
   *
   * Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
   *
   * @generated from enum value: TASK_QUEUE_KIND_STICKY = 2;
   */
  STICKY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskQueueKind)
proto3.util.setEnumType(TaskQueueKind, "temporal.api.enums.v1.TaskQueueKind", [
  { no: 0, name: "TASK_QUEUE_KIND_UNSPECIFIED" },
  { no: 1, name: "TASK_QUEUE_KIND_NORMAL" },
  { no: 2, name: "TASK_QUEUE_KIND_STICKY" },
]);

/**
 * @generated from enum temporal.api.enums.v1.TaskQueueType
 */
export enum TaskQueueType {
  /**
   * @generated from enum value: TASK_QUEUE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Workflow type of task queue.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_WORKFLOW = 1;
   */
  WORKFLOW = 1,

  /**
   * Activity type of task queue.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_ACTIVITY = 2;
   */
  ACTIVITY = 2,

  /**
   * Task queue type for dispatching Nexus requests.
   *
   * @generated from enum value: TASK_QUEUE_TYPE_NEXUS = 3;
   */
  NEXUS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskQueueType)
proto3.util.setEnumType(TaskQueueType, "temporal.api.enums.v1.TaskQueueType", [
  { no: 0, name: "TASK_QUEUE_TYPE_UNSPECIFIED" },
  { no: 1, name: "TASK_QUEUE_TYPE_WORKFLOW" },
  { no: 2, name: "TASK_QUEUE_TYPE_ACTIVITY" },
  { no: 3, name: "TASK_QUEUE_TYPE_NEXUS" },
]);

/**
 * Specifies which category of tasks may reach a worker on a versioned task queue.
 * Used both in a reachability query and its response.
 * Deprecated.
 *
 * @generated from enum temporal.api.enums.v1.TaskReachability
 */
export enum TaskReachability {
  /**
   * @generated from enum value: TASK_REACHABILITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
   *
   * @generated from enum value: TASK_REACHABILITY_NEW_WORKFLOWS = 1;
   */
  NEW_WORKFLOWS = 1,

  /**
   * There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
   * should *not* be retired.
   * This enum value does not distinguish between open and closed workflows.
   *
   * @generated from enum value: TASK_REACHABILITY_EXISTING_WORKFLOWS = 2;
   */
  EXISTING_WORKFLOWS = 2,

  /**
   * There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
   * should *not* be retired.
   *
   * @generated from enum value: TASK_REACHABILITY_OPEN_WORKFLOWS = 3;
   */
  OPEN_WORKFLOWS = 3,

  /**
   * There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
   * retired dependending on application requirements. For example, if there's no need to query closed workflows.
   *
   * @generated from enum value: TASK_REACHABILITY_CLOSED_WORKFLOWS = 4;
   */
  CLOSED_WORKFLOWS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskReachability)
proto3.util.setEnumType(TaskReachability, "temporal.api.enums.v1.TaskReachability", [
  { no: 0, name: "TASK_REACHABILITY_UNSPECIFIED" },
  { no: 1, name: "TASK_REACHABILITY_NEW_WORKFLOWS" },
  { no: 2, name: "TASK_REACHABILITY_EXISTING_WORKFLOWS" },
  { no: 3, name: "TASK_REACHABILITY_OPEN_WORKFLOWS" },
  { no: 4, name: "TASK_REACHABILITY_CLOSED_WORKFLOWS" },
]);

/**
 * Specifies which category of tasks may reach a versioned worker of a certain Build ID.
 *
 * Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
 * converges to the most accurate value but it is designed in a way to take the more conservative
 * side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
 *
 * Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
 * accounted for reachability as server cannot know if they'll happen as they do not use
 * assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
 * who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
 * sure to query reachability for the parent/previous workflow's Task Queue as well.
 *
 * @generated from enum temporal.api.enums.v1.BuildIdTaskReachability
 */
export enum BuildIdTaskReachability {
  /**
   * Task reachability is not reported
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
   * be open workflows or backlogged activities assigned to it.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_REACHABLE = 1;
   */
  REACHABLE = 1,

  /**
   * Build ID does not have open workflows and is not reachable by new workflows,
   * but MAY have closed workflows within the namespace retention period.
   * Not applicable to activity-only task queues.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY = 2;
   */
  CLOSED_WORKFLOWS_ONLY = 2,

  /**
   * Build ID is not used for new executions, nor it has been used by any existing execution
   * within the retention period.
   *
   * @generated from enum value: BUILD_ID_TASK_REACHABILITY_UNREACHABLE = 3;
   */
  UNREACHABLE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(BuildIdTaskReachability)
proto3.util.setEnumType(BuildIdTaskReachability, "temporal.api.enums.v1.BuildIdTaskReachability", [
  { no: 0, name: "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED" },
  { no: 1, name: "BUILD_ID_TASK_REACHABILITY_REACHABLE" },
  { no: 2, name: "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY" },
  { no: 3, name: "BUILD_ID_TASK_REACHABILITY_UNREACHABLE" },
]);

/**
 * @generated from enum temporal.api.enums.v1.DescribeTaskQueueMode
 */
export enum DescribeTaskQueueMode {
  /**
   * Unspecified means legacy behavior.
   *
   * @generated from enum value: DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
   *
   * @generated from enum value: DESCRIBE_TASK_QUEUE_MODE_ENHANCED = 1;
   */
  ENHANCED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DescribeTaskQueueMode)
proto3.util.setEnumType(DescribeTaskQueueMode, "temporal.api.enums.v1.DescribeTaskQueueMode", [
  { no: 0, name: "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED" },
  { no: 1, name: "DESCRIBE_TASK_QUEUE_MODE_ENHANCED" },
]);

/**
 * Source for the effective rate limit.
 *
 * @generated from enum temporal.api.enums.v1.RateLimitSource
 */
export enum RateLimitSource {
  /**
   * @generated from enum value: RATE_LIMIT_SOURCE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The value was set by the API.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_API = 1;
   */
  API = 1,

  /**
   * The value was set by a worker.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_WORKER = 2;
   */
  WORKER = 2,

  /**
   * The value was set as the system default.
   *
   * @generated from enum value: RATE_LIMIT_SOURCE_SYSTEM = 3;
   */
  SYSTEM = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RateLimitSource)
proto3.util.setEnumType(RateLimitSource, "temporal.api.enums.v1.RateLimitSource", [
  { no: 0, name: "RATE_LIMIT_SOURCE_UNSPECIFIED" },
  { no: 1, name: "RATE_LIMIT_SOURCE_API" },
  { no: 2, name: "RATE_LIMIT_SOURCE_WORKER" },
  { no: 3, name: "RATE_LIMIT_SOURCE_SYSTEM" },
]);

/**
 * Indicates whether a change to the Routing Config has been
 * propagated to all relevant Task Queues and their partitions.
 *
 * @generated from enum temporal.api.enums.v1.RoutingConfigUpdateState
 */
export enum RoutingConfigUpdateState {
  /**
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Update to the RoutingConfig is currently in progress.
   *
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * Update to the RoutingConfig has completed successfully.
   *
   * @generated from enum value: ROUTING_CONFIG_UPDATE_STATE_COMPLETED = 2;
   */
  COMPLETED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(RoutingConfigUpdateState)
proto3.util.setEnumType(RoutingConfigUpdateState, "temporal.api.enums.v1.RoutingConfigUpdateState", [
  { no: 0, name: "ROUTING_CONFIG_UPDATE_STATE_UNSPECIFIED" },
  { no: 1, name: "ROUTING_CONFIG_UPDATE_STATE_IN_PROGRESS" },
  { no: 2, name: "ROUTING_CONFIG_UPDATE_STATE_COMPLETED" },
]);

