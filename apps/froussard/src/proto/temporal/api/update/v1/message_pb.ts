// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/update/v1/message.proto (package temporal.api.update.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { UpdateWorkflowExecutionLifecycleStage } from "../../enums/v1/update_pbts";
import { Header, Payloads, WorkflowExecution } from "../../common/v1/message_pbts";
import { Failure } from "../../failure/v1/message_pbts";

/**
 * Specifies client's intent to wait for Update results.
 *
 * @generated from message temporal.api.update.v1.WaitPolicy
 */
export class WaitPolicy extends Message<WaitPolicy> {
  /**
   * Indicates the Update lifecycle stage that the Update must reach before
   * API call is returned.
   * NOTE: This field works together with API call timeout which is limited by
   * server timeout (maximum wait time). If server timeout is expired before
   * user specified timeout, API call returns even if specified stage is not reached.
   *
   * @generated from field: temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage lifecycle_stage = 1;
   */
  lifecycleStage = UpdateWorkflowExecutionLifecycleStage.UNSPECIFIED;

  constructor(data?: PartialMessage<WaitPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.WaitPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lifecycle_stage", kind: "enum", T: proto3.getEnumType(UpdateWorkflowExecutionLifecycleStage) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitPolicy {
    return new WaitPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitPolicy {
    return new WaitPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitPolicy {
    return new WaitPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: WaitPolicy | PlainMessage<WaitPolicy> | undefined, b: WaitPolicy | PlainMessage<WaitPolicy> | undefined): boolean {
    return proto3.util.equals(WaitPolicy, a, b);
  }
}

/**
 * The data needed by a client to refer to a previously invoked Workflow Update.
 *
 * @generated from message temporal.api.update.v1.UpdateRef
 */
export class UpdateRef extends Message<UpdateRef> {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 1;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: string update_id = 2;
   */
  updateId = "";

  constructor(data?: PartialMessage<UpdateRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.UpdateRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 2, name: "update_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateRef {
    return new UpdateRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateRef {
    return new UpdateRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateRef {
    return new UpdateRef().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateRef | PlainMessage<UpdateRef> | undefined, b: UpdateRef | PlainMessage<UpdateRef> | undefined): boolean {
    return proto3.util.equals(UpdateRef, a, b);
  }
}

/**
 * The outcome of a Workflow Update: success or failure.
 *
 * @generated from message temporal.api.update.v1.Outcome
 */
export class Outcome extends Message<Outcome> {
  /**
   * @generated from oneof temporal.api.update.v1.Outcome.value
   */
  value: {
    /**
     * @generated from field: temporal.api.common.v1.Payloads success = 1;
     */
    value: Payloads;
    case: "success";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.Failure failure = 2;
     */
    value: Failure;
    case: "failure";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Outcome>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Outcome";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: Payloads, oneof: "value" },
    { no: 2, name: "failure", kind: "message", T: Failure, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Outcome {
    return new Outcome().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Outcome {
    return new Outcome().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Outcome {
    return new Outcome().fromJsonString(jsonString, options);
  }

  static equals(a: Outcome | PlainMessage<Outcome> | undefined, b: Outcome | PlainMessage<Outcome> | undefined): boolean {
    return proto3.util.equals(Outcome, a, b);
  }
}

/**
 * Metadata about a Workflow Update.
 *
 * @generated from message temporal.api.update.v1.Meta
 */
export class Meta extends Message<Meta> {
  /**
   * An ID with workflow-scoped uniqueness for this Update.
   *
   * @generated from field: string update_id = 1;
   */
  updateId = "";

  /**
   * A string identifying the agent that requested this Update.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  constructor(data?: PartialMessage<Meta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Meta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Meta {
    return new Meta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Meta {
    return new Meta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Meta {
    return new Meta().fromJsonString(jsonString, options);
  }

  static equals(a: Meta | PlainMessage<Meta> | undefined, b: Meta | PlainMessage<Meta> | undefined): boolean {
    return proto3.util.equals(Meta, a, b);
  }
}

/**
 * @generated from message temporal.api.update.v1.Input
 */
export class Input extends Message<Input> {
  /**
   * Headers that are passed with the Update from the requesting entity.
   * These can include things like auth or tracing tokens.
   *
   * @generated from field: temporal.api.common.v1.Header header = 1;
   */
  header?: Header;

  /**
   * The name of the Update handler to invoke on the target Workflow.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * The arguments to pass to the named Update handler.
   *
   * @generated from field: temporal.api.common.v1.Payloads args = 3;
   */
  args?: Payloads;

  constructor(data?: PartialMessage<Input>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Input";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: Header },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "message", T: Payloads },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Input {
    return new Input().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Input {
    return new Input().fromJsonString(jsonString, options);
  }

  static equals(a: Input | PlainMessage<Input> | undefined, b: Input | PlainMessage<Input> | undefined): boolean {
    return proto3.util.equals(Input, a, b);
  }
}

/**
 * The client request that triggers a Workflow Update.
 *
 * @generated from message temporal.api.update.v1.Request
 */
export class Request extends Message<Request> {
  /**
   * @generated from field: temporal.api.update.v1.Meta meta = 1;
   */
  meta?: Meta;

  /**
   * @generated from field: temporal.api.update.v1.Input input = 2;
   */
  input?: Input;

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: Meta },
    { no: 2, name: "input", kind: "message", T: Input },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * An Update protocol message indicating that a Workflow Update has been rejected.
 *
 * @generated from message temporal.api.update.v1.Rejection
 */
export class Rejection extends Message<Rejection> {
  /**
   * @generated from field: string rejected_request_message_id = 1;
   */
  rejectedRequestMessageId = "";

  /**
   * @generated from field: int64 rejected_request_sequencing_event_id = 2;
   */
  rejectedRequestSequencingEventId = protoInt64.zero;

  /**
   * @generated from field: temporal.api.update.v1.Request rejected_request = 3;
   */
  rejectedRequest?: Request;

  /**
   * @generated from field: temporal.api.failure.v1.Failure failure = 4;
   */
  failure?: Failure;

  constructor(data?: PartialMessage<Rejection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Rejection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rejected_request_message_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rejected_request_sequencing_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "rejected_request", kind: "message", T: Request },
    { no: 4, name: "failure", kind: "message", T: Failure },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rejection {
    return new Rejection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rejection {
    return new Rejection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rejection {
    return new Rejection().fromJsonString(jsonString, options);
  }

  static equals(a: Rejection | PlainMessage<Rejection> | undefined, b: Rejection | PlainMessage<Rejection> | undefined): boolean {
    return proto3.util.equals(Rejection, a, b);
  }
}

/**
 * An Update protocol message indicating that a Workflow Update has
 * been accepted (i.e. passed the worker-side validation phase).
 *
 * @generated from message temporal.api.update.v1.Acceptance
 */
export class Acceptance extends Message<Acceptance> {
  /**
   * @generated from field: string accepted_request_message_id = 1;
   */
  acceptedRequestMessageId = "";

  /**
   * @generated from field: int64 accepted_request_sequencing_event_id = 2;
   */
  acceptedRequestSequencingEventId = protoInt64.zero;

  /**
   * @generated from field: temporal.api.update.v1.Request accepted_request = 3;
   */
  acceptedRequest?: Request;

  constructor(data?: PartialMessage<Acceptance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Acceptance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accepted_request_message_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "accepted_request_sequencing_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "accepted_request", kind: "message", T: Request },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Acceptance {
    return new Acceptance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Acceptance {
    return new Acceptance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Acceptance {
    return new Acceptance().fromJsonString(jsonString, options);
  }

  static equals(a: Acceptance | PlainMessage<Acceptance> | undefined, b: Acceptance | PlainMessage<Acceptance> | undefined): boolean {
    return proto3.util.equals(Acceptance, a, b);
  }
}

/**
 * An Update protocol message indicating that a Workflow Update has
 * completed with the contained outcome.
 *
 * @generated from message temporal.api.update.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: temporal.api.update.v1.Meta meta = 1;
   */
  meta?: Meta;

  /**
   * @generated from field: temporal.api.update.v1.Outcome outcome = 2;
   */
  outcome?: Outcome;

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.update.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: Meta },
    { no: 2, name: "outcome", kind: "message", T: Outcome },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

