// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/failure/v1/message.proto (package temporal.api.failure.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ActivityType, Payload, Payloads, WorkflowExecution, WorkflowType } from "../../common/v1/message_pbts";
import { ApplicationErrorCategory } from "../../enums/v1/common_pbts";
import { RetryState, TimeoutType } from "../../enums/v1/workflow_pbts";
import { NexusHandlerErrorRetryBehavior } from "../../enums/v1/nexus_pbts";

/**
 * @generated from message temporal.api.failure.v1.ApplicationFailureInfo
 */
export class ApplicationFailureInfo extends Message<ApplicationFailureInfo> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: bool non_retryable = 2;
   */
  nonRetryable = false;

  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 3;
   */
  details?: Payloads;

  /**
   * next_retry_delay can be used by the client to override the activity
   * retry interval calculated by the retry policy. Retry attempts will
   * still be subject to the maximum retries limit and total time limit
   * defined by the policy.
   *
   * @generated from field: google.protobuf.Duration next_retry_delay = 4;
   */
  nextRetryDelay?: Duration;

  /**
   * @generated from field: temporal.api.enums.v1.ApplicationErrorCategory category = 5;
   */
  category = ApplicationErrorCategory.UNSPECIFIED;

  constructor(data?: PartialMessage<ApplicationFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.ApplicationFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "non_retryable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "details", kind: "message", T: Payloads },
    { no: 4, name: "next_retry_delay", kind: "message", T: Duration },
    { no: 5, name: "category", kind: "enum", T: proto3.getEnumType(ApplicationErrorCategory) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationFailureInfo {
    return new ApplicationFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationFailureInfo {
    return new ApplicationFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationFailureInfo {
    return new ApplicationFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ApplicationFailureInfo | PlainMessage<ApplicationFailureInfo> | undefined, b: ApplicationFailureInfo | PlainMessage<ApplicationFailureInfo> | undefined): boolean {
    return proto3.util.equals(ApplicationFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.TimeoutFailureInfo
 */
export class TimeoutFailureInfo extends Message<TimeoutFailureInfo> {
  /**
   * @generated from field: temporal.api.enums.v1.TimeoutType timeout_type = 1;
   */
  timeoutType = TimeoutType.UNSPECIFIED;

  /**
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 2;
   */
  lastHeartbeatDetails?: Payloads;

  constructor(data?: PartialMessage<TimeoutFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.TimeoutFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timeout_type", kind: "enum", T: proto3.getEnumType(TimeoutType) },
    { no: 2, name: "last_heartbeat_details", kind: "message", T: Payloads },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeoutFailureInfo {
    return new TimeoutFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeoutFailureInfo {
    return new TimeoutFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeoutFailureInfo {
    return new TimeoutFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TimeoutFailureInfo | PlainMessage<TimeoutFailureInfo> | undefined, b: TimeoutFailureInfo | PlainMessage<TimeoutFailureInfo> | undefined): boolean {
    return proto3.util.equals(TimeoutFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.CanceledFailureInfo
 */
export class CanceledFailureInfo extends Message<CanceledFailureInfo> {
  /**
   * @generated from field: temporal.api.common.v1.Payloads details = 1;
   */
  details?: Payloads;

  constructor(data?: PartialMessage<CanceledFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.CanceledFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "details", kind: "message", T: Payloads },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanceledFailureInfo {
    return new CanceledFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanceledFailureInfo {
    return new CanceledFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanceledFailureInfo {
    return new CanceledFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CanceledFailureInfo | PlainMessage<CanceledFailureInfo> | undefined, b: CanceledFailureInfo | PlainMessage<CanceledFailureInfo> | undefined): boolean {
    return proto3.util.equals(CanceledFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.TerminatedFailureInfo
 */
export class TerminatedFailureInfo extends Message<TerminatedFailureInfo> {
  constructor(data?: PartialMessage<TerminatedFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.TerminatedFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminatedFailureInfo {
    return new TerminatedFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminatedFailureInfo {
    return new TerminatedFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminatedFailureInfo {
    return new TerminatedFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TerminatedFailureInfo | PlainMessage<TerminatedFailureInfo> | undefined, b: TerminatedFailureInfo | PlainMessage<TerminatedFailureInfo> | undefined): boolean {
    return proto3.util.equals(TerminatedFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.ServerFailureInfo
 */
export class ServerFailureInfo extends Message<ServerFailureInfo> {
  /**
   * @generated from field: bool non_retryable = 1;
   */
  nonRetryable = false;

  constructor(data?: PartialMessage<ServerFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.ServerFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "non_retryable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerFailureInfo {
    return new ServerFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerFailureInfo {
    return new ServerFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerFailureInfo {
    return new ServerFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ServerFailureInfo | PlainMessage<ServerFailureInfo> | undefined, b: ServerFailureInfo | PlainMessage<ServerFailureInfo> | undefined): boolean {
    return proto3.util.equals(ServerFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.ResetWorkflowFailureInfo
 */
export class ResetWorkflowFailureInfo extends Message<ResetWorkflowFailureInfo> {
  /**
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 1;
   */
  lastHeartbeatDetails?: Payloads;

  constructor(data?: PartialMessage<ResetWorkflowFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.ResetWorkflowFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_heartbeat_details", kind: "message", T: Payloads },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetWorkflowFailureInfo {
    return new ResetWorkflowFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetWorkflowFailureInfo {
    return new ResetWorkflowFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetWorkflowFailureInfo {
    return new ResetWorkflowFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ResetWorkflowFailureInfo | PlainMessage<ResetWorkflowFailureInfo> | undefined, b: ResetWorkflowFailureInfo | PlainMessage<ResetWorkflowFailureInfo> | undefined): boolean {
    return proto3.util.equals(ResetWorkflowFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.ActivityFailureInfo
 */
export class ActivityFailureInfo extends Message<ActivityFailureInfo> {
  /**
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId = protoInt64.zero;

  /**
   * @generated from field: int64 started_event_id = 2;
   */
  startedEventId = protoInt64.zero;

  /**
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 4;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: string activity_id = 5;
   */
  activityId = "";

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 6;
   */
  retryState = RetryState.UNSPECIFIED;

  constructor(data?: PartialMessage<ActivityFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.ActivityFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scheduled_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "started_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_type", kind: "message", T: ActivityType },
    { no: 5, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "retry_state", kind: "enum", T: proto3.getEnumType(RetryState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivityFailureInfo {
    return new ActivityFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivityFailureInfo {
    return new ActivityFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivityFailureInfo {
    return new ActivityFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ActivityFailureInfo | PlainMessage<ActivityFailureInfo> | undefined, b: ActivityFailureInfo | PlainMessage<ActivityFailureInfo> | undefined): boolean {
    return proto3.util.equals(ActivityFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo
 */
export class ChildWorkflowExecutionFailureInfo extends Message<ChildWorkflowExecutionFailureInfo> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: int64 initiated_event_id = 4;
   */
  initiatedEventId = protoInt64.zero;

  /**
   * @generated from field: int64 started_event_id = 5;
   */
  startedEventId = protoInt64.zero;

  /**
   * @generated from field: temporal.api.enums.v1.RetryState retry_state = 6;
   */
  retryState = RetryState.UNSPECIFIED;

  constructor(data?: PartialMessage<ChildWorkflowExecutionFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 4, name: "initiated_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "started_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "retry_state", kind: "enum", T: proto3.getEnumType(RetryState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChildWorkflowExecutionFailureInfo {
    return new ChildWorkflowExecutionFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChildWorkflowExecutionFailureInfo {
    return new ChildWorkflowExecutionFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChildWorkflowExecutionFailureInfo {
    return new ChildWorkflowExecutionFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ChildWorkflowExecutionFailureInfo | PlainMessage<ChildWorkflowExecutionFailureInfo> | undefined, b: ChildWorkflowExecutionFailureInfo | PlainMessage<ChildWorkflowExecutionFailureInfo> | undefined): boolean {
    return proto3.util.equals(ChildWorkflowExecutionFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.NexusOperationFailureInfo
 */
export class NexusOperationFailureInfo extends Message<NexusOperationFailureInfo> {
  /**
   * The NexusOperationScheduled event ID.
   *
   * @generated from field: int64 scheduled_event_id = 1;
   */
  scheduledEventId = protoInt64.zero;

  /**
   * Endpoint name.
   *
   * @generated from field: string endpoint = 2;
   */
  endpoint = "";

  /**
   * Service name.
   *
   * @generated from field: string service = 3;
   */
  service = "";

  /**
   * Operation name.
   *
   * @generated from field: string operation = 4;
   */
  operation = "";

  /**
   * Operation ID - may be empty if the operation completed synchronously.
   *
   * Deprecated. Renamed to operation_token.
   *
   * @generated from field: string operation_id = 5 [deprecated = true];
   * @deprecated
   */
  operationId = "";

  /**
   * Operation token - may be empty if the operation completed synchronously.
   *
   * @generated from field: string operation_token = 6;
   */
  operationToken = "";

  constructor(data?: PartialMessage<NexusOperationFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.NexusOperationFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scheduled_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "operation_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NexusOperationFailureInfo {
    return new NexusOperationFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NexusOperationFailureInfo {
    return new NexusOperationFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NexusOperationFailureInfo {
    return new NexusOperationFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: NexusOperationFailureInfo | PlainMessage<NexusOperationFailureInfo> | undefined, b: NexusOperationFailureInfo | PlainMessage<NexusOperationFailureInfo> | undefined): boolean {
    return proto3.util.equals(NexusOperationFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.NexusHandlerFailureInfo
 */
export class NexusHandlerFailureInfo extends Message<NexusHandlerFailureInfo> {
  /**
   * The Nexus error type as defined in the spec:
   * https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
   *
   * @generated from field: temporal.api.enums.v1.NexusHandlerErrorRetryBehavior retry_behavior = 2;
   */
  retryBehavior = NexusHandlerErrorRetryBehavior.UNSPECIFIED;

  constructor(data?: PartialMessage<NexusHandlerFailureInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.NexusHandlerFailureInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "retry_behavior", kind: "enum", T: proto3.getEnumType(NexusHandlerErrorRetryBehavior) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NexusHandlerFailureInfo {
    return new NexusHandlerFailureInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NexusHandlerFailureInfo {
    return new NexusHandlerFailureInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NexusHandlerFailureInfo {
    return new NexusHandlerFailureInfo().fromJsonString(jsonString, options);
  }

  static equals(a: NexusHandlerFailureInfo | PlainMessage<NexusHandlerFailureInfo> | undefined, b: NexusHandlerFailureInfo | PlainMessage<NexusHandlerFailureInfo> | undefined): boolean {
    return proto3.util.equals(NexusHandlerFailureInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.Failure
 */
export class Failure extends Message<Failure> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
   * In some SDKs this is used to rehydrate the stack trace into an exception object.
   *
   * @generated from field: string source = 2;
   */
  source = "";

  /**
   * @generated from field: string stack_trace = 3;
   */
  stackTrace = "";

  /**
   * Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
   * errors originating in user code which might contain sensitive information.
   * The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
   * message.
   *
   * SDK authors:
   * - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
   *   - Uses a JSON object to represent `{ message, stack_trace }`.
   *   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
   *   - Overwrites the original stack_trace with an empty string.
   *   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
   *     by the user-provided PayloadCodec
   *
   * - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
   * (-- api-linter: core::0203::optional=disabled --)
   *
   * @generated from field: temporal.api.common.v1.Payload encoded_attributes = 20;
   */
  encodedAttributes?: Payload;

  /**
   * @generated from field: temporal.api.failure.v1.Failure cause = 4;
   */
  cause?: Failure;

  /**
   * @generated from oneof temporal.api.failure.v1.Failure.failure_info
   */
  failureInfo: {
    /**
     * @generated from field: temporal.api.failure.v1.ApplicationFailureInfo application_failure_info = 5;
     */
    value: ApplicationFailureInfo;
    case: "applicationFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.TimeoutFailureInfo timeout_failure_info = 6;
     */
    value: TimeoutFailureInfo;
    case: "timeoutFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.CanceledFailureInfo canceled_failure_info = 7;
     */
    value: CanceledFailureInfo;
    case: "canceledFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.TerminatedFailureInfo terminated_failure_info = 8;
     */
    value: TerminatedFailureInfo;
    case: "terminatedFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.ServerFailureInfo server_failure_info = 9;
     */
    value: ServerFailureInfo;
    case: "serverFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.ResetWorkflowFailureInfo reset_workflow_failure_info = 10;
     */
    value: ResetWorkflowFailureInfo;
    case: "resetWorkflowFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.ActivityFailureInfo activity_failure_info = 11;
     */
    value: ActivityFailureInfo;
    case: "activityFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo child_workflow_execution_failure_info = 12;
     */
    value: ChildWorkflowExecutionFailureInfo;
    case: "childWorkflowExecutionFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.NexusOperationFailureInfo nexus_operation_execution_failure_info = 13;
     */
    value: NexusOperationFailureInfo;
    case: "nexusOperationExecutionFailureInfo";
  } | {
    /**
     * @generated from field: temporal.api.failure.v1.NexusHandlerFailureInfo nexus_handler_failure_info = 14;
     */
    value: NexusHandlerFailureInfo;
    case: "nexusHandlerFailureInfo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Failure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.Failure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "stack_trace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "encoded_attributes", kind: "message", T: Payload },
    { no: 4, name: "cause", kind: "message", T: Failure },
    { no: 5, name: "application_failure_info", kind: "message", T: ApplicationFailureInfo, oneof: "failure_info" },
    { no: 6, name: "timeout_failure_info", kind: "message", T: TimeoutFailureInfo, oneof: "failure_info" },
    { no: 7, name: "canceled_failure_info", kind: "message", T: CanceledFailureInfo, oneof: "failure_info" },
    { no: 8, name: "terminated_failure_info", kind: "message", T: TerminatedFailureInfo, oneof: "failure_info" },
    { no: 9, name: "server_failure_info", kind: "message", T: ServerFailureInfo, oneof: "failure_info" },
    { no: 10, name: "reset_workflow_failure_info", kind: "message", T: ResetWorkflowFailureInfo, oneof: "failure_info" },
    { no: 11, name: "activity_failure_info", kind: "message", T: ActivityFailureInfo, oneof: "failure_info" },
    { no: 12, name: "child_workflow_execution_failure_info", kind: "message", T: ChildWorkflowExecutionFailureInfo, oneof: "failure_info" },
    { no: 13, name: "nexus_operation_execution_failure_info", kind: "message", T: NexusOperationFailureInfo, oneof: "failure_info" },
    { no: 14, name: "nexus_handler_failure_info", kind: "message", T: NexusHandlerFailureInfo, oneof: "failure_info" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Failure {
    return new Failure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Failure {
    return new Failure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Failure {
    return new Failure().fromJsonString(jsonString, options);
  }

  static equals(a: Failure | PlainMessage<Failure> | undefined, b: Failure | PlainMessage<Failure> | undefined): boolean {
    return proto3.util.equals(Failure, a, b);
  }
}

/**
 * @generated from message temporal.api.failure.v1.MultiOperationExecutionAborted
 */
export class MultiOperationExecutionAborted extends Message<MultiOperationExecutionAborted> {
  constructor(data?: PartialMessage<MultiOperationExecutionAborted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.failure.v1.MultiOperationExecutionAborted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiOperationExecutionAborted {
    return new MultiOperationExecutionAborted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiOperationExecutionAborted {
    return new MultiOperationExecutionAborted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiOperationExecutionAborted {
    return new MultiOperationExecutionAborted().fromJsonString(jsonString, options);
  }

  static equals(a: MultiOperationExecutionAborted | PlainMessage<MultiOperationExecutionAborted> | undefined, b: MultiOperationExecutionAborted | PlainMessage<MultiOperationExecutionAborted> | undefined): boolean {
    return proto3.util.equals(MultiOperationExecutionAborted, a, b);
  }
}

