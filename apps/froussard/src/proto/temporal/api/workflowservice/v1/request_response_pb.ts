// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/workflowservice/v1/request_response.proto (package temporal.api.workflowservice.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, FieldMask, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ClusterReplicationConfig, FailoverStatus, NamespaceReplicationConfig } from "../../replication/v1/message_pbts";
import { ArchivalState } from "../../enums/v1/namespace_pbts";
import { NamespaceConfig, NamespaceFilter, NamespaceInfo, UpdateNamespaceInfo } from "../../namespace/v1/message_pbts";
import { ActivityType, Callback, DataBlob, Header, Link, Memo, MeteringMetadata, Payload, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerSelector, WorkerVersionCapabilities, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pbts";
import { BuildIdAssignmentRule, BuildIdReachability, CompatibleBuildIdRedirectRule, CompatibleVersionSet, PollerInfo, PollerScalingDecision, RateLimit, StickyExecutionAttributes, TaskQueue, TaskQueueConfig, TaskQueueMetadata, TaskQueuePartitionMetadata, TaskQueueStats, TaskQueueStatus, TaskQueueVersionInfo, TaskQueueVersioningInfo, TaskQueueVersionSelection, TimestampedBuildIdAssignmentRule, TimestampedCompatibleBuildIdRedirectRule } from "../../taskqueue/v1/message_pbts";
import { HistoryEventFilterType, VersioningBehavior, WorkflowExecutionStatus, WorkflowIdConflictPolicy, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pbts";
import { Failure } from "../../failure/v1/message_pbts";
import { UserMetadata } from "../../sdk/v1/user_metadata_pbts";
import { CallbackInfo, OnConflictOptions, PendingActivityInfo, PendingChildExecutionInfo, PendingNexusOperationInfo, PendingWorkflowTaskInfo, PostResetOperation, VersioningOverride, WorkflowExecutionConfig, WorkflowExecutionExtendedInfo, WorkflowExecutionInfo, WorkflowExecutionOptions } from "../../workflow/v1/message_pbts";
import { Deployment, DeploymentInfo, DeploymentListInfo, RoutingConfig, UpdateDeploymentMetadata, VersionMetadata, WorkerDeploymentInfo, WorkerDeploymentInfo_WorkerDeploymentVersionSummary, WorkerDeploymentOptions, WorkerDeploymentVersion, WorkerDeploymentVersionInfo } from "../../deployment/v1/message_pbts";
import { History } from "../../history/v1/message_pbts";
import { QueryRejected, WorkflowQuery, WorkflowQueryResult } from "../../query/v1/message_pbts";
import { Message as Message$1 } from "../../protocol/v1/message_pbts";
import { Command } from "../../command/v1/message_pbts";
import { WorkflowTaskCompletedMetadata } from "../../sdk/v1/task_complete_metadata_pbts";
import { WorkflowTaskFailedCause } from "../../enums/v1/failed_cause_pbts";
import { ResetReapplyExcludeType, ResetReapplyType } from "../../enums/v1/reset_pbts";
import { StartTimeFilter, StatusFilter, WorkflowExecutionFilter, WorkflowTypeFilter } from "../../filter/v1/message_pbts";
import { IndexedValueType } from "../../enums/v1/common_pbts";
import { QueryRejectCondition, QueryResultType } from "../../enums/v1/query_pbts";
import { WorkerHeartbeat, WorkerInfo } from "../../worker/v1/message_pbts";
import { DescribeTaskQueueMode, RateLimitSource, TaskQueueType, TaskReachability } from "../../enums/v1/task_queue_pbts";
import { VersionInfo } from "../../version/v1/message_pbts";
import { Schedule, ScheduleInfo, ScheduleListEntry, SchedulePatch } from "../../schedule/v1/message_pbts";
import { Outcome, Request, UpdateRef, WaitPolicy } from "../../update/v1/message_pbts";
import { UpdateWorkflowExecutionLifecycleStage } from "../../enums/v1/update_pbts";
import { BatchOperationCancellation, BatchOperationDeletion, BatchOperationInfo, BatchOperationReset, BatchOperationResetActivities, BatchOperationSignal, BatchOperationTermination, BatchOperationUnpauseActivities, BatchOperationUpdateActivityOptions, BatchOperationUpdateWorkflowExecutionOptions } from "../../batch/v1/message_pbts";
import { BatchOperationState, BatchOperationType } from "../../enums/v1/batch_operation_pbts";
import { HandlerError, Request as Request$1, Response } from "../../nexus/v1/message_pbts";
import { ActivityOptions } from "../../activity/v1/message_pbts";
import { DeploymentReachability } from "../../enums/v1/deployment_pbts";
import { WorkflowRule, WorkflowRuleSpec } from "../../rules/v1/message_pbts";
import { WorkerConfig } from "../../sdk/v1/worker_config_pbts";

/**
 * @generated from message temporal.api.workflowservice.v1.RegisterNamespaceRequest
 */
export class RegisterNamespaceRequest extends Message<RegisterNamespaceRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string owner_email = 3;
   */
  ownerEmail = "";

  /**
   * @generated from field: google.protobuf.Duration workflow_execution_retention_period = 4;
   */
  workflowExecutionRetentionPeriod?: Duration;

  /**
   * @generated from field: repeated temporal.api.replication.v1.ClusterReplicationConfig clusters = 5;
   */
  clusters: ClusterReplicationConfig[] = [];

  /**
   * @generated from field: string active_cluster_name = 6;
   */
  activeClusterName = "";

  /**
   * A key-value map for any customized purpose.
   *
   * @generated from field: map<string, string> data = 7;
   */
  data: { [key: string]: string } = {};

  /**
   * @generated from field: string security_token = 8;
   */
  securityToken = "";

  /**
   * @generated from field: bool is_global_namespace = 9;
   */
  isGlobalNamespace = false;

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState history_archival_state = 10;
   */
  historyArchivalState = ArchivalState.UNSPECIFIED;

  /**
   * @generated from field: string history_archival_uri = 11;
   */
  historyArchivalUri = "";

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState visibility_archival_state = 12;
   */
  visibilityArchivalState = ArchivalState.UNSPECIFIED;

  /**
   * @generated from field: string visibility_archival_uri = 13;
   */
  visibilityArchivalUri = "";

  constructor(data?: PartialMessage<RegisterNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RegisterNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "owner_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "workflow_execution_retention_period", kind: "message", T: Duration },
    { no: 5, name: "clusters", kind: "message", T: ClusterReplicationConfig, repeated: true },
    { no: 6, name: "active_cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "security_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "is_global_namespace", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "history_archival_state", kind: "enum", T: proto3.getEnumType(ArchivalState) },
    { no: 11, name: "history_archival_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "visibility_archival_state", kind: "enum", T: proto3.getEnumType(ArchivalState) },
    { no: 13, name: "visibility_archival_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterNamespaceRequest {
    return new RegisterNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterNamespaceRequest {
    return new RegisterNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterNamespaceRequest {
    return new RegisterNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterNamespaceRequest | PlainMessage<RegisterNamespaceRequest> | undefined, b: RegisterNamespaceRequest | PlainMessage<RegisterNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(RegisterNamespaceRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RegisterNamespaceResponse
 */
export class RegisterNamespaceResponse extends Message<RegisterNamespaceResponse> {
  constructor(data?: PartialMessage<RegisterNamespaceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RegisterNamespaceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterNamespaceResponse {
    return new RegisterNamespaceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterNamespaceResponse {
    return new RegisterNamespaceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterNamespaceResponse {
    return new RegisterNamespaceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterNamespaceResponse | PlainMessage<RegisterNamespaceResponse> | undefined, b: RegisterNamespaceResponse | PlainMessage<RegisterNamespaceResponse> | undefined): boolean {
    return proto3.util.equals(RegisterNamespaceResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListNamespacesRequest
 */
export class ListNamespacesRequest extends Message<ListNamespacesRequest> {
  /**
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceFilter namespace_filter = 3;
   */
  namespaceFilter?: NamespaceFilter;

  constructor(data?: PartialMessage<ListNamespacesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListNamespacesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "namespace_filter", kind: "message", T: NamespaceFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNamespacesRequest {
    return new ListNamespacesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNamespacesRequest {
    return new ListNamespacesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNamespacesRequest {
    return new ListNamespacesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListNamespacesRequest | PlainMessage<ListNamespacesRequest> | undefined, b: ListNamespacesRequest | PlainMessage<ListNamespacesRequest> | undefined): boolean {
    return proto3.util.equals(ListNamespacesRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListNamespacesResponse
 */
export class ListNamespacesResponse extends Message<ListNamespacesResponse> {
  /**
   * @generated from field: repeated temporal.api.workflowservice.v1.DescribeNamespaceResponse namespaces = 1;
   */
  namespaces: DescribeNamespaceResponse[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListNamespacesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListNamespacesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespaces", kind: "message", T: DescribeNamespaceResponse, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNamespacesResponse {
    return new ListNamespacesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNamespacesResponse {
    return new ListNamespacesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNamespacesResponse {
    return new ListNamespacesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNamespacesResponse | PlainMessage<ListNamespacesResponse> | undefined, b: ListNamespacesResponse | PlainMessage<ListNamespacesResponse> | undefined): boolean {
    return proto3.util.equals(ListNamespacesResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeNamespaceRequest
 */
export class DescribeNamespaceRequest extends Message<DescribeNamespaceRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<DescribeNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeNamespaceRequest {
    return new DescribeNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeNamespaceRequest {
    return new DescribeNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeNamespaceRequest {
    return new DescribeNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeNamespaceRequest | PlainMessage<DescribeNamespaceRequest> | undefined, b: DescribeNamespaceRequest | PlainMessage<DescribeNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(DescribeNamespaceRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeNamespaceResponse
 */
export class DescribeNamespaceResponse extends Message<DescribeNamespaceResponse> {
  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
   */
  namespaceInfo?: NamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 2;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: int64 failover_version = 4;
   */
  failoverVersion = protoInt64.zero;

  /**
   * @generated from field: bool is_global_namespace = 5;
   */
  isGlobalNamespace = false;

  /**
   * Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
   * states to ensure that the list does not grow unbounded.
   *
   * @generated from field: repeated temporal.api.replication.v1.FailoverStatus failover_history = 6;
   */
  failoverHistory: FailoverStatus[] = [];

  constructor(data?: PartialMessage<DescribeNamespaceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeNamespaceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace_info", kind: "message", T: NamespaceInfo },
    { no: 2, name: "config", kind: "message", T: NamespaceConfig },
    { no: 3, name: "replication_config", kind: "message", T: NamespaceReplicationConfig },
    { no: 4, name: "failover_version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "is_global_namespace", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "failover_history", kind: "message", T: FailoverStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeNamespaceResponse {
    return new DescribeNamespaceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeNamespaceResponse {
    return new DescribeNamespaceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeNamespaceResponse {
    return new DescribeNamespaceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeNamespaceResponse | PlainMessage<DescribeNamespaceResponse> | undefined, b: DescribeNamespaceResponse | PlainMessage<DescribeNamespaceResponse> | undefined): boolean {
    return proto3.util.equals(DescribeNamespaceResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateNamespaceRequest
 */
export class UpdateNamespaceRequest extends Message<UpdateNamespaceRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.namespace.v1.UpdateNamespaceInfo update_info = 2;
   */
  updateInfo?: UpdateNamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 3;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 4;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: string security_token = 5;
   */
  securityToken = "";

  /**
   * @generated from field: string delete_bad_binary = 6;
   */
  deleteBadBinary = "";

  /**
   * promote local namespace to global namespace. Ignored if namespace is already global namespace.
   *
   * @generated from field: bool promote_namespace = 7;
   */
  promoteNamespace = false;

  constructor(data?: PartialMessage<UpdateNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "update_info", kind: "message", T: UpdateNamespaceInfo },
    { no: 3, name: "config", kind: "message", T: NamespaceConfig },
    { no: 4, name: "replication_config", kind: "message", T: NamespaceReplicationConfig },
    { no: 5, name: "security_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "delete_bad_binary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "promote_namespace", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateNamespaceRequest {
    return new UpdateNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateNamespaceRequest {
    return new UpdateNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateNamespaceRequest {
    return new UpdateNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateNamespaceRequest | PlainMessage<UpdateNamespaceRequest> | undefined, b: UpdateNamespaceRequest | PlainMessage<UpdateNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(UpdateNamespaceRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateNamespaceResponse
 */
export class UpdateNamespaceResponse extends Message<UpdateNamespaceResponse> {
  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
   */
  namespaceInfo?: NamespaceInfo;

  /**
   * @generated from field: temporal.api.namespace.v1.NamespaceConfig config = 2;
   */
  config?: NamespaceConfig;

  /**
   * @generated from field: temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
   */
  replicationConfig?: NamespaceReplicationConfig;

  /**
   * @generated from field: int64 failover_version = 4;
   */
  failoverVersion = protoInt64.zero;

  /**
   * @generated from field: bool is_global_namespace = 5;
   */
  isGlobalNamespace = false;

  constructor(data?: PartialMessage<UpdateNamespaceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateNamespaceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace_info", kind: "message", T: NamespaceInfo },
    { no: 2, name: "config", kind: "message", T: NamespaceConfig },
    { no: 3, name: "replication_config", kind: "message", T: NamespaceReplicationConfig },
    { no: 4, name: "failover_version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "is_global_namespace", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateNamespaceResponse {
    return new UpdateNamespaceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateNamespaceResponse {
    return new UpdateNamespaceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateNamespaceResponse {
    return new UpdateNamespaceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateNamespaceResponse | PlainMessage<UpdateNamespaceResponse> | undefined, b: UpdateNamespaceResponse | PlainMessage<UpdateNamespaceResponse> | undefined): boolean {
    return proto3.util.equals(UpdateNamespaceResponse, a, b);
  }
}

/**
 * Deprecated.
 *
 * @generated from message temporal.api.workflowservice.v1.DeprecateNamespaceRequest
 */
export class DeprecateNamespaceRequest extends Message<DeprecateNamespaceRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string security_token = 2;
   */
  securityToken = "";

  constructor(data?: PartialMessage<DeprecateNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeprecateNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "security_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeprecateNamespaceRequest {
    return new DeprecateNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeprecateNamespaceRequest {
    return new DeprecateNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeprecateNamespaceRequest {
    return new DeprecateNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeprecateNamespaceRequest | PlainMessage<DeprecateNamespaceRequest> | undefined, b: DeprecateNamespaceRequest | PlainMessage<DeprecateNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(DeprecateNamespaceRequest, a, b);
  }
}

/**
 * Deprecated.
 *
 * @generated from message temporal.api.workflowservice.v1.DeprecateNamespaceResponse
 */
export class DeprecateNamespaceResponse extends Message<DeprecateNamespaceResponse> {
  constructor(data?: PartialMessage<DeprecateNamespaceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeprecateNamespaceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeprecateNamespaceResponse {
    return new DeprecateNamespaceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeprecateNamespaceResponse {
    return new DeprecateNamespaceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeprecateNamespaceResponse {
    return new DeprecateNamespaceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeprecateNamespaceResponse | PlainMessage<DeprecateNamespaceResponse> | undefined, b: DeprecateNamespaceResponse | PlainMessage<DeprecateNamespaceResponse> | undefined): boolean {
    return proto3.util.equals(DeprecateNamespaceResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StartWorkflowExecutionRequest
 */
export class StartWorkflowExecutionRequest extends Message<StartWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow. These are passed as arguments to the workflow function.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 9;
   */
  identity = "";

  /**
   * A unique identifier for this start request. Typically UUIDv4.
   *
   * @generated from field: string request_id = 10;
   */
  requestId = "";

  /**
   * Defines whether to allow re-using the workflow id from a previously *closed* workflow.
   * The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy = WorkflowIdReusePolicy.UNSPECIFIED;

  /**
   * Defines how to resolve a workflow id conflict with a *running* workflow.
   * The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
   */
  workflowIdConflictPolicy = WorkflowIdConflictPolicy.UNSPECIFIED;

  /**
   * The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 12;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 13;
   */
  cronSchedule = "";

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 14;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 15;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 16;
   */
  header?: Header;

  /**
   * Request to get the first workflow task inline in the response bypassing matching service and worker polling.
   * If set to `true` the caller is expected to have a worker available and capable of processing the task.
   * The returned task will be marked as started and is expected to be completed by the specified
   * `workflow_task_timeout`.
   *
   * @generated from field: bool request_eager_execution = 17;
   */
  requestEagerExecution = false;

  /**
   * These values will be available as ContinuedFailure and LastCompletionResult in the
   * WorkflowExecutionStarted event and through SDKs. The are currently only used by the
   * server itself (for the schedules feature) and are not intended to be exposed in
   * StartWorkflowExecution.
   *
   * @generated from field: temporal.api.failure.v1.Failure continued_failure = 18;
   */
  continuedFailure?: Failure;

  /**
   * @generated from field: temporal.api.common.v1.Payloads last_completion_result = 19;
   */
  lastCompletionResult?: Payloads;

  /**
   * Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
   * If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
   * of the delay will be ignored.
   *
   * @generated from field: google.protobuf.Duration workflow_start_delay = 20;
   */
  workflowStartDelay?: Duration;

  /**
   * Callbacks to be called by the server when this workflow reaches a terminal state.
   * If the workflow continues-as-new, these callbacks will be carried over to the new execution.
   * Callback addresses must be whitelisted in the server's dynamic configuration.
   *
   * @generated from field: repeated temporal.api.common.v1.Callback completion_callbacks = 21;
   */
  completionCallbacks: Callback[] = [];

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 23;
   */
  userMetadata?: UserMetadata;

  /**
   * Links to be associated with the workflow.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 24;
   */
  links: Link[] = [];

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 25;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Defines actions to be done to the existing running workflow when the conflict policy
   * WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
   * empty object (ie., all options with default value), it won't do anything to the existing
   * running workflow. If set, it will add a history event to the running workflow.
   *
   * @generated from field: temporal.api.workflow.v1.OnConflictOptions on_conflict_options = 26;
   */
  onConflictOptions?: OnConflictOptions;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 27;
   */
  priority?: Priority;

  /**
   * Deployment Options of the worker who will process the eager task. Passed when `request_eager_execution=true`.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions eager_worker_deployment_options = 28;
   */
  eagerWorkerDeploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<StartWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StartWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 4, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 5, name: "input", kind: "message", T: Payloads },
    { no: 6, name: "workflow_execution_timeout", kind: "message", T: Duration },
    { no: 7, name: "workflow_run_timeout", kind: "message", T: Duration },
    { no: 8, name: "workflow_task_timeout", kind: "message", T: Duration },
    { no: 9, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "workflow_id_reuse_policy", kind: "enum", T: proto3.getEnumType(WorkflowIdReusePolicy) },
    { no: 22, name: "workflow_id_conflict_policy", kind: "enum", T: proto3.getEnumType(WorkflowIdConflictPolicy) },
    { no: 12, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 13, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "memo", kind: "message", T: Memo },
    { no: 15, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 16, name: "header", kind: "message", T: Header },
    { no: 17, name: "request_eager_execution", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "continued_failure", kind: "message", T: Failure },
    { no: 19, name: "last_completion_result", kind: "message", T: Payloads },
    { no: 20, name: "workflow_start_delay", kind: "message", T: Duration },
    { no: 21, name: "completion_callbacks", kind: "message", T: Callback, repeated: true },
    { no: 23, name: "user_metadata", kind: "message", T: UserMetadata },
    { no: 24, name: "links", kind: "message", T: Link, repeated: true },
    { no: 25, name: "versioning_override", kind: "message", T: VersioningOverride },
    { no: 26, name: "on_conflict_options", kind: "message", T: OnConflictOptions },
    { no: 27, name: "priority", kind: "message", T: Priority },
    { no: 28, name: "eager_worker_deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartWorkflowExecutionRequest {
    return new StartWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartWorkflowExecutionRequest {
    return new StartWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartWorkflowExecutionRequest {
    return new StartWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartWorkflowExecutionRequest | PlainMessage<StartWorkflowExecutionRequest> | undefined, b: StartWorkflowExecutionRequest | PlainMessage<StartWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(StartWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StartWorkflowExecutionResponse
 */
export class StartWorkflowExecutionResponse extends Message<StartWorkflowExecutionResponse> {
  /**
   * The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
   *
   * @generated from field: string run_id = 1;
   */
  runId = "";

  /**
   * If true, a new workflow was started.
   *
   * @generated from field: bool started = 3;
   */
  started = false;

  /**
   * Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING
   * unless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs).
   *
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
   */
  status = WorkflowExecutionStatus.UNSPECIFIED;

  /**
   * When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
   * return the first workflow task to be eagerly executed.
   * The caller is expected to have a worker available to process the task.
   *
   * @generated from field: temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse eager_workflow_task = 2;
   */
  eagerWorkflowTask?: PollWorkflowTaskQueueResponse;

  /**
   * Link to the workflow event.
   *
   * @generated from field: temporal.api.common.v1.Link link = 4;
   */
  link?: Link;

  constructor(data?: PartialMessage<StartWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StartWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "started", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "status", kind: "enum", T: proto3.getEnumType(WorkflowExecutionStatus) },
    { no: 2, name: "eager_workflow_task", kind: "message", T: PollWorkflowTaskQueueResponse },
    { no: 4, name: "link", kind: "message", T: Link },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartWorkflowExecutionResponse {
    return new StartWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartWorkflowExecutionResponse {
    return new StartWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartWorkflowExecutionResponse {
    return new StartWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartWorkflowExecutionResponse | PlainMessage<StartWorkflowExecutionResponse> | undefined, b: StartWorkflowExecutionResponse | PlainMessage<StartWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(StartWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest
 */
export class GetWorkflowExecutionHistoryRequest extends Message<GetWorkflowExecutionHistoryRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: int32 maximum_page_size = 3;
   */
  maximumPageSize = 0;

  /**
   * If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
   * these, it should be passed here to fetch the next page.
   *
   * @generated from field: bytes next_page_token = 4;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * If set to true, the RPC call will not resolve until there is a new event which matches
   * the `history_event_filter_type`, or a timeout is hit.
   *
   * @generated from field: bool wait_new_event = 5;
   */
  waitNewEvent = false;

  /**
   * Filter returned events such that they match the specified filter type.
   * Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
   *
   * @generated from field: temporal.api.enums.v1.HistoryEventFilterType history_event_filter_type = 6;
   */
  historyEventFilterType = HistoryEventFilterType.UNSPECIFIED;

  /**
   * @generated from field: bool skip_archival = 7;
   */
  skipArchival = false;

  constructor(data?: PartialMessage<GetWorkflowExecutionHistoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "maximum_page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "wait_new_event", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "history_event_filter_type", kind: "enum", T: proto3.getEnumType(HistoryEventFilterType) },
    { no: 7, name: "skip_archival", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkflowExecutionHistoryRequest {
    return new GetWorkflowExecutionHistoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryRequest {
    return new GetWorkflowExecutionHistoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryRequest {
    return new GetWorkflowExecutionHistoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkflowExecutionHistoryRequest | PlainMessage<GetWorkflowExecutionHistoryRequest> | undefined, b: GetWorkflowExecutionHistoryRequest | PlainMessage<GetWorkflowExecutionHistoryRequest> | undefined): boolean {
    return proto3.util.equals(GetWorkflowExecutionHistoryRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse
 */
export class GetWorkflowExecutionHistoryResponse extends Message<GetWorkflowExecutionHistoryResponse> {
  /**
   * @generated from field: temporal.api.history.v1.History history = 1;
   */
  history?: History;

  /**
   * Raw history is an alternate representation of history that may be returned if configured on
   * the frontend. This is not supported by all SDKs. Either this or `history` will be set.
   *
   * @generated from field: repeated temporal.api.common.v1.DataBlob raw_history = 2;
   */
  rawHistory: DataBlob[] = [];

  /**
   * Will be set if there are more history events than were included in this response
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: bool archived = 4;
   */
  archived = false;

  constructor(data?: PartialMessage<GetWorkflowExecutionHistoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "history", kind: "message", T: History },
    { no: 2, name: "raw_history", kind: "message", T: DataBlob, repeated: true },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "archived", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkflowExecutionHistoryResponse {
    return new GetWorkflowExecutionHistoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryResponse {
    return new GetWorkflowExecutionHistoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryResponse {
    return new GetWorkflowExecutionHistoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkflowExecutionHistoryResponse | PlainMessage<GetWorkflowExecutionHistoryResponse> | undefined, b: GetWorkflowExecutionHistoryResponse | PlainMessage<GetWorkflowExecutionHistoryResponse> | undefined): boolean {
    return proto3.util.equals(GetWorkflowExecutionHistoryResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest
 */
export class GetWorkflowExecutionHistoryReverseRequest extends Message<GetWorkflowExecutionHistoryReverseRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: int32 maximum_page_size = 3;
   */
  maximumPageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 4;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<GetWorkflowExecutionHistoryReverseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "maximum_page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkflowExecutionHistoryReverseRequest {
    return new GetWorkflowExecutionHistoryReverseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryReverseRequest {
    return new GetWorkflowExecutionHistoryReverseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryReverseRequest {
    return new GetWorkflowExecutionHistoryReverseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkflowExecutionHistoryReverseRequest | PlainMessage<GetWorkflowExecutionHistoryReverseRequest> | undefined, b: GetWorkflowExecutionHistoryReverseRequest | PlainMessage<GetWorkflowExecutionHistoryReverseRequest> | undefined): boolean {
    return proto3.util.equals(GetWorkflowExecutionHistoryReverseRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse
 */
export class GetWorkflowExecutionHistoryReverseResponse extends Message<GetWorkflowExecutionHistoryReverseResponse> {
  /**
   * @generated from field: temporal.api.history.v1.History history = 1;
   */
  history?: History;

  /**
   * Will be set if there are more history events than were included in this response
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<GetWorkflowExecutionHistoryReverseResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "history", kind: "message", T: History },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkflowExecutionHistoryReverseResponse {
    return new GetWorkflowExecutionHistoryReverseResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryReverseResponse {
    return new GetWorkflowExecutionHistoryReverseResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkflowExecutionHistoryReverseResponse {
    return new GetWorkflowExecutionHistoryReverseResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkflowExecutionHistoryReverseResponse | PlainMessage<GetWorkflowExecutionHistoryReverseResponse> | undefined, b: GetWorkflowExecutionHistoryReverseResponse | PlainMessage<GetWorkflowExecutionHistoryReverseResponse> | undefined): boolean {
    return proto3.util.equals(GetWorkflowExecutionHistoryReverseResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest
 */
export class PollWorkflowTaskQueueRequest extends Message<PollWorkflowTaskQueueRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * The identity of the worker/client who is polling this task queue
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * Deprecated. Use deployment_options instead.
   * Each worker process should provide an ID unique to the specific set of code it is running
   * "checksum" in this field name isn't very accurate, it should be though of as an id.
   *
   * @generated from field: string binary_checksum = 4 [deprecated = true];
   * @deprecated
   */
  binaryChecksum = "";

  /**
   * Deprecated. Use deployment_options instead.
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   * Experimental. Worker Deployments are experimental and might significantly change in the future.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<PollWorkflowTaskQueueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "binary_checksum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "worker_version_capabilities", kind: "message", T: WorkerVersionCapabilities },
    { no: 6, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollWorkflowTaskQueueRequest {
    return new PollWorkflowTaskQueueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollWorkflowTaskQueueRequest {
    return new PollWorkflowTaskQueueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollWorkflowTaskQueueRequest {
    return new PollWorkflowTaskQueueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PollWorkflowTaskQueueRequest | PlainMessage<PollWorkflowTaskQueueRequest> | undefined, b: PollWorkflowTaskQueueRequest | PlainMessage<PollWorkflowTaskQueueRequest> | undefined): boolean {
    return proto3.util.equals(PollWorkflowTaskQueueRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse
 */
export class PollWorkflowTaskQueueResponse extends Message<PollWorkflowTaskQueueResponse> {
  /**
   * A unique identifier for this task
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * The last workflow task started event which was processed by some worker for this execution.
   * Will be zero if no task has ever started.
   *
   * @generated from field: int64 previous_started_event_id = 4;
   */
  previousStartedEventId = protoInt64.zero;

  /**
   * The id of the most recent workflow task started event, which will have been generated as a
   * result of this poll request being served. Will be zero if the task
   * does not contain any events which would advance history (no new WFT started).
   * Currently this can happen for queries.
   *
   * @generated from field: int64 started_event_id = 5;
   */
  startedEventId = protoInt64.zero;

  /**
   * Starting at 1, the number of attempts to complete this task by any worker.
   *
   * @generated from field: int32 attempt = 6;
   */
  attempt = 0;

  /**
   * A hint that there are more tasks already present in this task queue
   * partition. Can be used to prioritize draining a sticky queue.
   *
   * Specifically, the returned number is the number of tasks remaining in
   * the in-memory buffer for this partition, which is currently capped at
   * 1000. Because sticky queues only have one partition, this number is
   * more useful when draining them. Normal queues, typically having more than one
   * partition, will return a number representing only some portion of the
   * overall backlog. Subsequent RPCs may not hit the same partition as
   * this call.
   *
   * @generated from field: int64 backlog_count_hint = 7;
   */
  backlogCountHint = protoInt64.zero;

  /**
   * The history for this workflow, which will either be complete or partial. Partial histories
   * are sent to workers who have signaled that they are using a sticky queue when completing
   * a workflow task.
   *
   * @generated from field: temporal.api.history.v1.History history = 8;
   */
  history?: History;

  /**
   * Will be set if there are more history events than were included in this response. Such events
   * should be fetched via `GetWorkflowExecutionHistory`.
   *
   * @generated from field: bytes next_page_token = 9;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * Legacy queries appear in this field. The query must be responded to via
   * `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
   * closed workflows) then the `history` field will be populated with the entire history. It
   * may also be populated if this task originates on a non-sticky queue.
   *
   * @generated from field: temporal.api.query.v1.WorkflowQuery query = 10;
   */
  query?: WorkflowQuery;

  /**
   * The task queue this task originated from, which will always be the original non-sticky name
   * for the queue, even if this response came from polling a sticky queue.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue workflow_execution_task_queue = 11;
   */
  workflowExecutionTaskQueue?: TaskQueue;

  /**
   * When this task was scheduled by the server
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 12;
   */
  scheduledTime?: Timestamp;

  /**
   * When the current workflow task started event was generated, meaning the current attempt.
   *
   * @generated from field: google.protobuf.Timestamp started_time = 13;
   */
  startedTime?: Timestamp;

  /**
   * Queries that should be executed after applying the history in this task. Responses should be
   * attached to `RespondWorkflowTaskCompletedRequest::query_results`
   *
   * @generated from field: map<string, temporal.api.query.v1.WorkflowQuery> queries = 14;
   */
  queries: { [key: string]: WorkflowQuery } = {};

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 15;
   */
  messages: Message$1[] = [];

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 16;
   */
  pollerScalingDecision?: PollerScalingDecision;

  constructor(data?: PartialMessage<PollWorkflowTaskQueueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 4, name: "previous_started_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "started_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "backlog_count_hint", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "history", kind: "message", T: History },
    { no: 9, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "query", kind: "message", T: WorkflowQuery },
    { no: 11, name: "workflow_execution_task_queue", kind: "message", T: TaskQueue },
    { no: 12, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 13, name: "started_time", kind: "message", T: Timestamp },
    { no: 14, name: "queries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WorkflowQuery} },
    { no: 15, name: "messages", kind: "message", T: Message$1, repeated: true },
    { no: 16, name: "poller_scaling_decision", kind: "message", T: PollerScalingDecision },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollWorkflowTaskQueueResponse {
    return new PollWorkflowTaskQueueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollWorkflowTaskQueueResponse {
    return new PollWorkflowTaskQueueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollWorkflowTaskQueueResponse {
    return new PollWorkflowTaskQueueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PollWorkflowTaskQueueResponse | PlainMessage<PollWorkflowTaskQueueResponse> | undefined, b: PollWorkflowTaskQueueResponse | PlainMessage<PollWorkflowTaskQueueResponse> | undefined): boolean {
    return proto3.util.equals(PollWorkflowTaskQueueResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest
 */
export class RespondWorkflowTaskCompletedRequest extends Message<RespondWorkflowTaskCompletedRequest> {
  /**
   * The task token as received in `PollWorkflowTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * A list of commands generated when driving the workflow code in response to the new task
   *
   * @generated from field: repeated temporal.api.command.v1.Command commands = 2;
   */
  commands: Command[] = [];

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * May be set by workers to indicate that the worker desires future tasks to be provided with
   * incremental history on a sticky queue.
   *
   * @generated from field: temporal.api.taskqueue.v1.StickyExecutionAttributes sticky_attributes = 4;
   */
  stickyAttributes?: StickyExecutionAttributes;

  /**
   * If set, the worker wishes to immediately receive the next workflow task as a response to
   * this completion. This can save on polling round-trips.
   *
   * @generated from field: bool return_new_workflow_task = 5;
   */
  returnNewWorkflowTask = false;

  /**
   * Can be used to *force* creation of a new workflow task, even if no commands have resolved or
   * one would not otherwise have been generated. This is used when the worker knows it is doing
   * something useful, but cannot complete it within the workflow task timeout. Local activities
   * which run for longer than the task timeout being the prime example.
   *
   * @generated from field: bool force_create_new_workflow_task = 6;
   */
  forceCreateNewWorkflowTask = false;

  /**
   * Deprecated. Use `deployment_options` instead.
   * Worker process' unique binary id
   *
   * @generated from field: string binary_checksum = 7 [deprecated = true];
   * @deprecated
   */
  binaryChecksum = "";

  /**
   * Responses to the `queries` field in the task being responded to
   *
   * @generated from field: map<string, temporal.api.query.v1.WorkflowQueryResult> query_results = 8;
   */
  queryResults: { [key: string]: WorkflowQueryResult } = {};

  /**
   * @generated from field: string namespace = 9;
   */
  namespace = "";

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` and `versioning_behavior` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version_stamp = 10 [deprecated = true];
   * @deprecated
   */
  workerVersionStamp?: WorkerVersionStamp;

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 11;
   */
  messages: Message$1[] = [];

  /**
   * Data the SDK wishes to record for itself, but server need not interpret, and does not
   * directly impact workflow state.
   *
   * @generated from field: temporal.api.sdk.v1.WorkflowTaskCompletedMetadata sdk_metadata = 12;
   */
  sdkMetadata?: WorkflowTaskCompletedMetadata;

  /**
   * Local usage data collected for metering
   *
   * @generated from field: temporal.api.common.v1.MeteringMetadata metering_metadata = 13;
   */
  meteringMetadata?: MeteringMetadata;

  /**
   * All capabilities the SDK supports.
   *
   * @generated from field: temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities capabilities = 14;
   */
  capabilities?: RespondWorkflowTaskCompletedRequest_Capabilities;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 15 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Versioning behavior of this workflow execution as set on the worker that completed this task.
   * UNSPECIFIED means versioning is not enabled in the worker.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior versioning_behavior = 16;
   */
  versioningBehavior = VersioningBehavior.UNSPECIFIED;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 17;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondWorkflowTaskCompletedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "commands", kind: "message", T: Command, repeated: true },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "sticky_attributes", kind: "message", T: StickyExecutionAttributes },
    { no: 5, name: "return_new_workflow_task", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "force_create_new_workflow_task", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "binary_checksum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "query_results", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WorkflowQueryResult} },
    { no: 9, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "worker_version_stamp", kind: "message", T: WorkerVersionStamp },
    { no: 11, name: "messages", kind: "message", T: Message$1, repeated: true },
    { no: 12, name: "sdk_metadata", kind: "message", T: WorkflowTaskCompletedMetadata },
    { no: 13, name: "metering_metadata", kind: "message", T: MeteringMetadata },
    { no: 14, name: "capabilities", kind: "message", T: RespondWorkflowTaskCompletedRequest_Capabilities },
    { no: 15, name: "deployment", kind: "message", T: Deployment },
    { no: 16, name: "versioning_behavior", kind: "enum", T: proto3.getEnumType(VersioningBehavior) },
    { no: 17, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondWorkflowTaskCompletedRequest {
    return new RespondWorkflowTaskCompletedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedRequest {
    return new RespondWorkflowTaskCompletedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedRequest {
    return new RespondWorkflowTaskCompletedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondWorkflowTaskCompletedRequest | PlainMessage<RespondWorkflowTaskCompletedRequest> | undefined, b: RespondWorkflowTaskCompletedRequest | PlainMessage<RespondWorkflowTaskCompletedRequest> | undefined): boolean {
    return proto3.util.equals(RespondWorkflowTaskCompletedRequest, a, b);
  }
}

/**
 * SDK capability details.
 *
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities
 */
export class RespondWorkflowTaskCompletedRequest_Capabilities extends Message<RespondWorkflowTaskCompletedRequest_Capabilities> {
  /**
   * True if the SDK can handle speculative workflow task with command events. If true, the
   * server may choose, at its discretion, to discard a speculative workflow task even if that
   * speculative task included command events the SDK had not previously processed.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "with" used to describe the workflow task. --)
   *
   * @generated from field: bool discard_speculative_workflow_task_with_events = 1;
   */
  discardSpeculativeWorkflowTaskWithEvents = false;

  constructor(data?: PartialMessage<RespondWorkflowTaskCompletedRequest_Capabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest.Capabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "discard_speculative_workflow_task_with_events", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondWorkflowTaskCompletedRequest_Capabilities {
    return new RespondWorkflowTaskCompletedRequest_Capabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedRequest_Capabilities {
    return new RespondWorkflowTaskCompletedRequest_Capabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedRequest_Capabilities {
    return new RespondWorkflowTaskCompletedRequest_Capabilities().fromJsonString(jsonString, options);
  }

  static equals(a: RespondWorkflowTaskCompletedRequest_Capabilities | PlainMessage<RespondWorkflowTaskCompletedRequest_Capabilities> | undefined, b: RespondWorkflowTaskCompletedRequest_Capabilities | PlainMessage<RespondWorkflowTaskCompletedRequest_Capabilities> | undefined): boolean {
    return proto3.util.equals(RespondWorkflowTaskCompletedRequest_Capabilities, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedResponse
 */
export class RespondWorkflowTaskCompletedResponse extends Message<RespondWorkflowTaskCompletedResponse> {
  /**
   * See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
   *
   * @generated from field: temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse workflow_task = 1;
   */
  workflowTask?: PollWorkflowTaskQueueResponse;

  /**
   * See `ScheduleActivityTaskCommandAttributes::request_eager_execution`
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.PollActivityTaskQueueResponse activity_tasks = 2;
   */
  activityTasks: PollActivityTaskQueueResponse[] = [];

  /**
   * If non zero, indicates the server has discarded the workflow task that was being responded to.
   * Will be the event ID of the last workflow task started event in the history before the new workflow task.
   * Server is only expected to discard a workflow task if it could not have modified the workflow state.
   *
   * @generated from field: int64 reset_history_event_id = 3;
   */
  resetHistoryEventId = protoInt64.zero;

  constructor(data?: PartialMessage<RespondWorkflowTaskCompletedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_task", kind: "message", T: PollWorkflowTaskQueueResponse },
    { no: 2, name: "activity_tasks", kind: "message", T: PollActivityTaskQueueResponse, repeated: true },
    { no: 3, name: "reset_history_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondWorkflowTaskCompletedResponse {
    return new RespondWorkflowTaskCompletedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedResponse {
    return new RespondWorkflowTaskCompletedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondWorkflowTaskCompletedResponse {
    return new RespondWorkflowTaskCompletedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondWorkflowTaskCompletedResponse | PlainMessage<RespondWorkflowTaskCompletedResponse> | undefined, b: RespondWorkflowTaskCompletedResponse | PlainMessage<RespondWorkflowTaskCompletedResponse> | undefined): boolean {
    return proto3.util.equals(RespondWorkflowTaskCompletedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest
 */
export class RespondWorkflowTaskFailedRequest extends Message<RespondWorkflowTaskFailedRequest> {
  /**
   * The task token as received in `PollWorkflowTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * Why did the task fail? It's important to note that many of the variants in this enum cannot
   * apply to worker responses. See the type's doc for more.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowTaskFailedCause cause = 2;
   */
  cause = WorkflowTaskFailedCause.UNSPECIFIED;

  /**
   * Failure details
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 3;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 4;
   */
  identity = "";

  /**
   * Deprecated. Use `deployment_options` instead.
   * Worker process' unique binary id
   *
   * @generated from field: string binary_checksum = 5 [deprecated = true];
   * @deprecated
   */
  binaryChecksum = "";

  /**
   * @generated from field: string namespace = 6;
   */
  namespace = "";

  /**
   * Protocol messages piggybacking on a WFT as a transport
   *
   * @generated from field: repeated temporal.api.protocol.v1.Message messages = 7;
   */
  messages: Message$1[] = [];

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 8 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 9 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 10;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondWorkflowTaskFailedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "cause", kind: "enum", T: proto3.getEnumType(WorkflowTaskFailedCause) },
    { no: 3, name: "failure", kind: "message", T: Failure },
    { no: 4, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "binary_checksum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "messages", kind: "message", T: Message$1, repeated: true },
    { no: 8, name: "worker_version", kind: "message", T: WorkerVersionStamp },
    { no: 9, name: "deployment", kind: "message", T: Deployment },
    { no: 10, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondWorkflowTaskFailedRequest {
    return new RespondWorkflowTaskFailedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondWorkflowTaskFailedRequest {
    return new RespondWorkflowTaskFailedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondWorkflowTaskFailedRequest {
    return new RespondWorkflowTaskFailedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondWorkflowTaskFailedRequest | PlainMessage<RespondWorkflowTaskFailedRequest> | undefined, b: RespondWorkflowTaskFailedRequest | PlainMessage<RespondWorkflowTaskFailedRequest> | undefined): boolean {
    return proto3.util.equals(RespondWorkflowTaskFailedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondWorkflowTaskFailedResponse
 */
export class RespondWorkflowTaskFailedResponse extends Message<RespondWorkflowTaskFailedResponse> {
  constructor(data?: PartialMessage<RespondWorkflowTaskFailedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondWorkflowTaskFailedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondWorkflowTaskFailedResponse {
    return new RespondWorkflowTaskFailedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondWorkflowTaskFailedResponse {
    return new RespondWorkflowTaskFailedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondWorkflowTaskFailedResponse {
    return new RespondWorkflowTaskFailedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondWorkflowTaskFailedResponse | PlainMessage<RespondWorkflowTaskFailedResponse> | undefined, b: RespondWorkflowTaskFailedResponse | PlainMessage<RespondWorkflowTaskFailedResponse> | undefined): boolean {
    return proto3.util.equals(RespondWorkflowTaskFailedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollActivityTaskQueueRequest
 */
export class PollActivityTaskQueueRequest extends Message<PollActivityTaskQueueRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueMetadata task_queue_metadata = 4;
   */
  taskQueueMetadata?: TaskQueueMetadata;

  /**
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<PollActivityTaskQueueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollActivityTaskQueueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "task_queue_metadata", kind: "message", T: TaskQueueMetadata },
    { no: 5, name: "worker_version_capabilities", kind: "message", T: WorkerVersionCapabilities },
    { no: 6, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollActivityTaskQueueRequest {
    return new PollActivityTaskQueueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollActivityTaskQueueRequest {
    return new PollActivityTaskQueueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollActivityTaskQueueRequest {
    return new PollActivityTaskQueueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PollActivityTaskQueueRequest | PlainMessage<PollActivityTaskQueueRequest> | undefined, b: PollActivityTaskQueueRequest | PlainMessage<PollActivityTaskQueueRequest> | undefined): boolean {
    return proto3.util.equals(PollActivityTaskQueueRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollActivityTaskQueueResponse
 */
export class PollActivityTaskQueueResponse extends Message<PollActivityTaskQueueResponse> {
  /**
   * A unique identifier for this task
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * The namespace the workflow which requested this activity lives in
   *
   * @generated from field: string workflow_namespace = 2;
   */
  workflowNamespace = "";

  /**
   * Type of the requesting workflow
   *
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * Execution info of the requesting workflow
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 5;
   */
  activityType?: ActivityType;

  /**
   * The autogenerated or user specified identifier of this activity. Can be used to complete the
   * activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
   * has resolved, but unique IDs for every activity invocation is a good idea.
   *
   * @generated from field: string activity_id = 6;
   */
  activityId = "";

  /**
   * Headers specified by the scheduling workflow. Commonly used to propagate contextual info
   * from the workflow to its activities. For example, tracing contexts.
   *
   * @generated from field: temporal.api.common.v1.Header header = 7;
   */
  header?: Header;

  /**
   * Arguments to the activity invocation
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 8;
   */
  input?: Payloads;

  /**
   * Details of the last heartbeat that was recorded for this activity as of the time this task
   * was delivered.
   *
   * @generated from field: temporal.api.common.v1.Payloads heartbeat_details = 9;
   */
  heartbeatDetails?: Payloads;

  /**
   * When was this task first scheduled
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 10;
   */
  scheduledTime?: Timestamp;

  /**
   * When was this task attempt scheduled
   *
   * @generated from field: google.protobuf.Timestamp current_attempt_scheduled_time = 11;
   */
  currentAttemptScheduledTime?: Timestamp;

  /**
   * When was this task started (this attempt)
   *
   * @generated from field: google.protobuf.Timestamp started_time = 12;
   */
  startedTime?: Timestamp;

  /**
   * Starting at 1, the number of attempts to perform this activity
   *
   * @generated from field: int32 attempt = 13;
   */
  attempt = 0;

  /**
   * First scheduled -> final result reported timeout
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 14;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Current attempt start -> final result reported timeout
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 15;
   */
  startToCloseTimeout?: Duration;

  /**
   * Window within which the activity must report a heartbeat, or be timed out.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 16;
   */
  heartbeatTimeout?: Duration;

  /**
   * This is the retry policy the service uses which may be different from the one provided
   * (or not) during activity scheduling. The service can override the provided one if some
   * values are not specified or exceed configured system limits.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 17;
   */
  retryPolicy?: RetryPolicy;

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 18;
   */
  pollerScalingDecision?: PollerScalingDecision;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 19;
   */
  priority?: Priority;

  constructor(data?: PartialMessage<PollActivityTaskQueueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollActivityTaskQueueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "workflow_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 4, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 5, name: "activity_type", kind: "message", T: ActivityType },
    { no: 6, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "header", kind: "message", T: Header },
    { no: 8, name: "input", kind: "message", T: Payloads },
    { no: 9, name: "heartbeat_details", kind: "message", T: Payloads },
    { no: 10, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 11, name: "current_attempt_scheduled_time", kind: "message", T: Timestamp },
    { no: 12, name: "started_time", kind: "message", T: Timestamp },
    { no: 13, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 14, name: "schedule_to_close_timeout", kind: "message", T: Duration },
    { no: 15, name: "start_to_close_timeout", kind: "message", T: Duration },
    { no: 16, name: "heartbeat_timeout", kind: "message", T: Duration },
    { no: 17, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 18, name: "poller_scaling_decision", kind: "message", T: PollerScalingDecision },
    { no: 19, name: "priority", kind: "message", T: Priority },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollActivityTaskQueueResponse {
    return new PollActivityTaskQueueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollActivityTaskQueueResponse {
    return new PollActivityTaskQueueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollActivityTaskQueueResponse {
    return new PollActivityTaskQueueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PollActivityTaskQueueResponse | PlainMessage<PollActivityTaskQueueResponse> | undefined, b: PollActivityTaskQueueResponse | PlainMessage<PollActivityTaskQueueResponse> | undefined): boolean {
    return proto3.util.equals(PollActivityTaskQueueResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest
 */
export class RecordActivityTaskHeartbeatRequest extends Message<RecordActivityTaskHeartbeatRequest> {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * Arbitrary data, of which the most recent call is kept, to store for this activity
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: string namespace = 4;
   */
  namespace = "";

  constructor(data?: PartialMessage<RecordActivityTaskHeartbeatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "details", kind: "message", T: Payloads },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordActivityTaskHeartbeatRequest {
    return new RecordActivityTaskHeartbeatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatRequest {
    return new RecordActivityTaskHeartbeatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatRequest {
    return new RecordActivityTaskHeartbeatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RecordActivityTaskHeartbeatRequest | PlainMessage<RecordActivityTaskHeartbeatRequest> | undefined, b: RecordActivityTaskHeartbeatRequest | PlainMessage<RecordActivityTaskHeartbeatRequest> | undefined): boolean {
    return proto3.util.equals(RecordActivityTaskHeartbeatRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatResponse
 */
export class RecordActivityTaskHeartbeatResponse extends Message<RecordActivityTaskHeartbeatResponse> {
  /**
   * Will be set to true if the activity has been asked to cancel itself. The SDK should then
   * notify the activity of cancellation if it is still running.
   *
   * @generated from field: bool cancel_requested = 1;
   */
  cancelRequested = false;

  /**
   * Will be set to true if the activity is paused.
   *
   * @generated from field: bool activity_paused = 2;
   */
  activityPaused = false;

  /**
   * Will be set to true if the activity was reset.
   * Applies only to the current run.
   *
   * @generated from field: bool activity_reset = 3;
   */
  activityReset = false;

  constructor(data?: PartialMessage<RecordActivityTaskHeartbeatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cancel_requested", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "activity_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "activity_reset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordActivityTaskHeartbeatResponse {
    return new RecordActivityTaskHeartbeatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatResponse {
    return new RecordActivityTaskHeartbeatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatResponse {
    return new RecordActivityTaskHeartbeatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RecordActivityTaskHeartbeatResponse | PlainMessage<RecordActivityTaskHeartbeatResponse> | undefined, b: RecordActivityTaskHeartbeatResponse | PlainMessage<RecordActivityTaskHeartbeatResponse> | undefined): boolean {
    return proto3.util.equals(RecordActivityTaskHeartbeatResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdRequest
 */
export class RecordActivityTaskHeartbeatByIdRequest extends Message<RecordActivityTaskHeartbeatByIdRequest> {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId = "";

  /**
   * Id of the activity we're heartbeating
   *
   * @generated from field: string activity_id = 4;
   */
  activityId = "";

  /**
   * Arbitrary data, of which the most recent call is kept, to store for this activity
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 5;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  constructor(data?: PartialMessage<RecordActivityTaskHeartbeatByIdRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "details", kind: "message", T: Payloads },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordActivityTaskHeartbeatByIdRequest {
    return new RecordActivityTaskHeartbeatByIdRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatByIdRequest {
    return new RecordActivityTaskHeartbeatByIdRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatByIdRequest {
    return new RecordActivityTaskHeartbeatByIdRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RecordActivityTaskHeartbeatByIdRequest | PlainMessage<RecordActivityTaskHeartbeatByIdRequest> | undefined, b: RecordActivityTaskHeartbeatByIdRequest | PlainMessage<RecordActivityTaskHeartbeatByIdRequest> | undefined): boolean {
    return proto3.util.equals(RecordActivityTaskHeartbeatByIdRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdResponse
 */
export class RecordActivityTaskHeartbeatByIdResponse extends Message<RecordActivityTaskHeartbeatByIdResponse> {
  /**
   * Will be set to true if the activity has been asked to cancel itself. The SDK should then
   * notify the activity of cancellation if it is still running.
   *
   * @generated from field: bool cancel_requested = 1;
   */
  cancelRequested = false;

  /**
   * Will be set to true if the activity is paused.
   *
   * @generated from field: bool activity_paused = 2;
   */
  activityPaused = false;

  /**
   * Will be set to true if the activity was reset.
   * Applies only to the current run.
   *
   * @generated from field: bool activity_reset = 3;
   */
  activityReset = false;

  constructor(data?: PartialMessage<RecordActivityTaskHeartbeatByIdResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatByIdResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cancel_requested", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "activity_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "activity_reset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordActivityTaskHeartbeatByIdResponse {
    return new RecordActivityTaskHeartbeatByIdResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatByIdResponse {
    return new RecordActivityTaskHeartbeatByIdResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordActivityTaskHeartbeatByIdResponse {
    return new RecordActivityTaskHeartbeatByIdResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RecordActivityTaskHeartbeatByIdResponse | PlainMessage<RecordActivityTaskHeartbeatByIdResponse> | undefined, b: RecordActivityTaskHeartbeatByIdResponse | PlainMessage<RecordActivityTaskHeartbeatByIdResponse> | undefined): boolean {
    return proto3.util.equals(RecordActivityTaskHeartbeatByIdResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest
 */
export class RespondActivityTaskCompletedRequest extends Message<RespondActivityTaskCompletedRequest> {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * The result of successfully executing the activity
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 2;
   */
  result?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: string namespace = 4;
   */
  namespace = "";

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 6 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondActivityTaskCompletedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "result", kind: "message", T: Payloads },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "worker_version", kind: "message", T: WorkerVersionStamp },
    { no: 6, name: "deployment", kind: "message", T: Deployment },
    { no: 7, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCompletedRequest {
    return new RespondActivityTaskCompletedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedRequest {
    return new RespondActivityTaskCompletedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedRequest {
    return new RespondActivityTaskCompletedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCompletedRequest | PlainMessage<RespondActivityTaskCompletedRequest> | undefined, b: RespondActivityTaskCompletedRequest | PlainMessage<RespondActivityTaskCompletedRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCompletedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedResponse
 */
export class RespondActivityTaskCompletedResponse extends Message<RespondActivityTaskCompletedResponse> {
  constructor(data?: PartialMessage<RespondActivityTaskCompletedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCompletedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCompletedResponse {
    return new RespondActivityTaskCompletedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedResponse {
    return new RespondActivityTaskCompletedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedResponse {
    return new RespondActivityTaskCompletedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCompletedResponse | PlainMessage<RespondActivityTaskCompletedResponse> | undefined, b: RespondActivityTaskCompletedResponse | PlainMessage<RespondActivityTaskCompletedResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCompletedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdRequest
 */
export class RespondActivityTaskCompletedByIdRequest extends Message<RespondActivityTaskCompletedByIdRequest> {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId = "";

  /**
   * Id of the activity to complete
   *
   * @generated from field: string activity_id = 4;
   */
  activityId = "";

  /**
   * The serialized result of activity execution
   *
   * @generated from field: temporal.api.common.v1.Payloads result = 5;
   */
  result?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  constructor(data?: PartialMessage<RespondActivityTaskCompletedByIdRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "result", kind: "message", T: Payloads },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCompletedByIdRequest {
    return new RespondActivityTaskCompletedByIdRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedByIdRequest {
    return new RespondActivityTaskCompletedByIdRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedByIdRequest {
    return new RespondActivityTaskCompletedByIdRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCompletedByIdRequest | PlainMessage<RespondActivityTaskCompletedByIdRequest> | undefined, b: RespondActivityTaskCompletedByIdRequest | PlainMessage<RespondActivityTaskCompletedByIdRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCompletedByIdRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdResponse
 */
export class RespondActivityTaskCompletedByIdResponse extends Message<RespondActivityTaskCompletedByIdResponse> {
  constructor(data?: PartialMessage<RespondActivityTaskCompletedByIdResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCompletedByIdResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCompletedByIdResponse {
    return new RespondActivityTaskCompletedByIdResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedByIdResponse {
    return new RespondActivityTaskCompletedByIdResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCompletedByIdResponse {
    return new RespondActivityTaskCompletedByIdResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCompletedByIdResponse | PlainMessage<RespondActivityTaskCompletedByIdResponse> | undefined, b: RespondActivityTaskCompletedByIdResponse | PlainMessage<RespondActivityTaskCompletedByIdResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCompletedByIdResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest
 */
export class RespondActivityTaskFailedRequest extends Message<RespondActivityTaskFailedRequest> {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * Detailed failure information
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 2;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: string namespace = 4;
   */
  namespace = "";

  /**
   * Additional details to be stored as last activity heartbeat
   *
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 5;
   */
  lastHeartbeatDetails?: Payloads;

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 6 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 7 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 8;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondActivityTaskFailedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "failure", kind: "message", T: Failure },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "last_heartbeat_details", kind: "message", T: Payloads },
    { no: 6, name: "worker_version", kind: "message", T: WorkerVersionStamp },
    { no: 7, name: "deployment", kind: "message", T: Deployment },
    { no: 8, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskFailedRequest {
    return new RespondActivityTaskFailedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedRequest {
    return new RespondActivityTaskFailedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedRequest {
    return new RespondActivityTaskFailedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskFailedRequest | PlainMessage<RespondActivityTaskFailedRequest> | undefined, b: RespondActivityTaskFailedRequest | PlainMessage<RespondActivityTaskFailedRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskFailedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedResponse
 */
export class RespondActivityTaskFailedResponse extends Message<RespondActivityTaskFailedResponse> {
  /**
   * Server validation failures could include
   * last_heartbeat_details payload is too large, request failure is too large
   *
   * @generated from field: repeated temporal.api.failure.v1.Failure failures = 1;
   */
  failures: Failure[] = [];

  constructor(data?: PartialMessage<RespondActivityTaskFailedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskFailedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "failures", kind: "message", T: Failure, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskFailedResponse {
    return new RespondActivityTaskFailedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedResponse {
    return new RespondActivityTaskFailedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedResponse {
    return new RespondActivityTaskFailedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskFailedResponse | PlainMessage<RespondActivityTaskFailedResponse> | undefined, b: RespondActivityTaskFailedResponse | PlainMessage<RespondActivityTaskFailedResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskFailedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdRequest
 */
export class RespondActivityTaskFailedByIdRequest extends Message<RespondActivityTaskFailedByIdRequest> {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId = "";

  /**
   * Id of the activity to fail
   *
   * @generated from field: string activity_id = 4;
   */
  activityId = "";

  /**
   * Detailed failure information
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 5;
   */
  failure?: Failure;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  /**
   * Additional details to be stored as last activity heartbeat
   *
   * @generated from field: temporal.api.common.v1.Payloads last_heartbeat_details = 7;
   */
  lastHeartbeatDetails?: Payloads;

  constructor(data?: PartialMessage<RespondActivityTaskFailedByIdRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "failure", kind: "message", T: Failure },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "last_heartbeat_details", kind: "message", T: Payloads },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskFailedByIdRequest {
    return new RespondActivityTaskFailedByIdRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedByIdRequest {
    return new RespondActivityTaskFailedByIdRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedByIdRequest {
    return new RespondActivityTaskFailedByIdRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskFailedByIdRequest | PlainMessage<RespondActivityTaskFailedByIdRequest> | undefined, b: RespondActivityTaskFailedByIdRequest | PlainMessage<RespondActivityTaskFailedByIdRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskFailedByIdRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdResponse
 */
export class RespondActivityTaskFailedByIdResponse extends Message<RespondActivityTaskFailedByIdResponse> {
  /**
   * Server validation failures could include
   * last_heartbeat_details payload is too large, request failure is too large
   *
   * @generated from field: repeated temporal.api.failure.v1.Failure failures = 1;
   */
  failures: Failure[] = [];

  constructor(data?: PartialMessage<RespondActivityTaskFailedByIdResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskFailedByIdResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "failures", kind: "message", T: Failure, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskFailedByIdResponse {
    return new RespondActivityTaskFailedByIdResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedByIdResponse {
    return new RespondActivityTaskFailedByIdResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskFailedByIdResponse {
    return new RespondActivityTaskFailedByIdResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskFailedByIdResponse | PlainMessage<RespondActivityTaskFailedByIdResponse> | undefined, b: RespondActivityTaskFailedByIdResponse | PlainMessage<RespondActivityTaskFailedByIdResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskFailedByIdResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest
 */
export class RespondActivityTaskCanceledRequest extends Message<RespondActivityTaskCanceledRequest> {
  /**
   * The task token as received in `PollActivityTaskQueueResponse`
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * Serialized additional information to attach to the cancellation
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 2;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: string namespace = 4;
   */
  namespace = "";

  /**
   * Version info of the worker who processed this task. This message's `build_id` field should
   * always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
   * field to true. See message docstrings for more.
   * Deprecated. Use `deployment_options` instead.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp worker_version = 5 [deprecated = true];
   * @deprecated
   */
  workerVersion?: WorkerVersionStamp;

  /**
   * Deployment info of the worker that completed this task. Must be present if user has set
   * `WorkerDeploymentOptions` regardless of versioning being enabled or not.
   * Deprecated. Replaced with `deployment_options`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 6 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondActivityTaskCanceledRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "details", kind: "message", T: Payloads },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "worker_version", kind: "message", T: WorkerVersionStamp },
    { no: 6, name: "deployment", kind: "message", T: Deployment },
    { no: 7, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCanceledRequest {
    return new RespondActivityTaskCanceledRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledRequest {
    return new RespondActivityTaskCanceledRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledRequest {
    return new RespondActivityTaskCanceledRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCanceledRequest | PlainMessage<RespondActivityTaskCanceledRequest> | undefined, b: RespondActivityTaskCanceledRequest | PlainMessage<RespondActivityTaskCanceledRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCanceledRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledResponse
 */
export class RespondActivityTaskCanceledResponse extends Message<RespondActivityTaskCanceledResponse> {
  constructor(data?: PartialMessage<RespondActivityTaskCanceledResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCanceledResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCanceledResponse {
    return new RespondActivityTaskCanceledResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledResponse {
    return new RespondActivityTaskCanceledResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledResponse {
    return new RespondActivityTaskCanceledResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCanceledResponse | PlainMessage<RespondActivityTaskCanceledResponse> | undefined, b: RespondActivityTaskCanceledResponse | PlainMessage<RespondActivityTaskCanceledResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCanceledResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdRequest
 */
export class RespondActivityTaskCanceledByIdRequest extends Message<RespondActivityTaskCanceledByIdRequest> {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Id of the workflow which scheduled this activity
   *
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * Run Id of the workflow which scheduled this activity
   *
   * @generated from field: string run_id = 3;
   */
  runId = "";

  /**
   * Id of the activity to confirm is cancelled
   *
   * @generated from field: string activity_id = 4;
   */
  activityId = "";

  /**
   * Serialized additional information to attach to the cancellation
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 5;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 7;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<RespondActivityTaskCanceledByIdRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "details", kind: "message", T: Payloads },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCanceledByIdRequest {
    return new RespondActivityTaskCanceledByIdRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledByIdRequest {
    return new RespondActivityTaskCanceledByIdRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledByIdRequest {
    return new RespondActivityTaskCanceledByIdRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCanceledByIdRequest | PlainMessage<RespondActivityTaskCanceledByIdRequest> | undefined, b: RespondActivityTaskCanceledByIdRequest | PlainMessage<RespondActivityTaskCanceledByIdRequest> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCanceledByIdRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdResponse
 */
export class RespondActivityTaskCanceledByIdResponse extends Message<RespondActivityTaskCanceledByIdResponse> {
  constructor(data?: PartialMessage<RespondActivityTaskCanceledByIdResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondActivityTaskCanceledByIdResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondActivityTaskCanceledByIdResponse {
    return new RespondActivityTaskCanceledByIdResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledByIdResponse {
    return new RespondActivityTaskCanceledByIdResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondActivityTaskCanceledByIdResponse {
    return new RespondActivityTaskCanceledByIdResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondActivityTaskCanceledByIdResponse | PlainMessage<RespondActivityTaskCanceledByIdResponse> | undefined, b: RespondActivityTaskCanceledByIdResponse | PlainMessage<RespondActivityTaskCanceledByIdResponse> | undefined): boolean {
    return proto3.util.equals(RespondActivityTaskCanceledByIdResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest
 */
export class RequestCancelWorkflowExecutionRequest extends Message<RequestCancelWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * Used to de-dupe cancellation requests
   *
   * @generated from field: string request_id = 4;
   */
  requestId = "";

  /**
   * If set, this call will error if the most recent (if no run id is set on
   * `workflow_execution`), or specified (if it is) workflow execution is not part of the same
   * execution chain as this id.
   *
   * @generated from field: string first_execution_run_id = 5;
   */
  firstExecutionRunId = "";

  /**
   * Reason for requesting the cancellation
   *
   * @generated from field: string reason = 6;
   */
  reason = "";

  /**
   * Links to be associated with the WorkflowExecutionCanceled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 7;
   */
  links: Link[] = [];

  constructor(data?: PartialMessage<RequestCancelWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "first_execution_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "links", kind: "message", T: Link, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestCancelWorkflowExecutionRequest {
    return new RequestCancelWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestCancelWorkflowExecutionRequest {
    return new RequestCancelWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestCancelWorkflowExecutionRequest {
    return new RequestCancelWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RequestCancelWorkflowExecutionRequest | PlainMessage<RequestCancelWorkflowExecutionRequest> | undefined, b: RequestCancelWorkflowExecutionRequest | PlainMessage<RequestCancelWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(RequestCancelWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionResponse
 */
export class RequestCancelWorkflowExecutionResponse extends Message<RequestCancelWorkflowExecutionResponse> {
  constructor(data?: PartialMessage<RequestCancelWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestCancelWorkflowExecutionResponse {
    return new RequestCancelWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestCancelWorkflowExecutionResponse {
    return new RequestCancelWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestCancelWorkflowExecutionResponse {
    return new RequestCancelWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RequestCancelWorkflowExecutionResponse | PlainMessage<RequestCancelWorkflowExecutionResponse> | undefined, b: RequestCancelWorkflowExecutionResponse | PlainMessage<RequestCancelWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(RequestCancelWorkflowExecutionResponse, a, b);
  }
}

/**
 * Keep the parameters in sync with:
 *   - temporal.api.batch.v1.BatchOperationSignal.
 *   - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
 *
 * @generated from message temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest
 */
export class SignalWorkflowExecutionRequest extends Message<SignalWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal_name = 3;
   */
  signalName = "";

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * Used to de-dupe sent signals
   *
   * @generated from field: string request_id = 6;
   */
  requestId = "";

  /**
   * Deprecated.
   *
   * @generated from field: string control = 7 [deprecated = true];
   * @deprecated
   */
  control = "";

  /**
   * Headers that are passed with the signal to the processing workflow.
   * These can include things like auth or tracing tokens.
   *
   * @generated from field: temporal.api.common.v1.Header header = 8;
   */
  header?: Header;

  /**
   * Links to be associated with the WorkflowExecutionSignaled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 10;
   */
  links: Link[] = [];

  constructor(data?: PartialMessage<SignalWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "signal_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "input", kind: "message", T: Payloads },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "control", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "header", kind: "message", T: Header },
    { no: 10, name: "links", kind: "message", T: Link, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalWorkflowExecutionRequest {
    return new SignalWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalWorkflowExecutionRequest {
    return new SignalWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalWorkflowExecutionRequest {
    return new SignalWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SignalWorkflowExecutionRequest | PlainMessage<SignalWorkflowExecutionRequest> | undefined, b: SignalWorkflowExecutionRequest | PlainMessage<SignalWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(SignalWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWorkflowExecutionResponse
 */
export class SignalWorkflowExecutionResponse extends Message<SignalWorkflowExecutionResponse> {
  constructor(data?: PartialMessage<SignalWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SignalWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalWorkflowExecutionResponse {
    return new SignalWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalWorkflowExecutionResponse {
    return new SignalWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalWorkflowExecutionResponse {
    return new SignalWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SignalWorkflowExecutionResponse | PlainMessage<SignalWorkflowExecutionResponse> | undefined, b: SignalWorkflowExecutionResponse | PlainMessage<SignalWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(SignalWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest
 */
export class SignalWithStartWorkflowExecutionRequest extends Message<SignalWithStartWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 3;
   */
  workflowType?: WorkflowType;

  /**
   * The task queue to start this workflow on, if it will be started
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow. These are passed as arguments to the workflow function.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 5;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 6;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 7;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 8;
   */
  workflowTaskTimeout?: Duration;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 9;
   */
  identity = "";

  /**
   * Used to de-dupe signal w/ start requests
   *
   * @generated from field: string request_id = 10;
   */
  requestId = "";

  /**
   * Defines whether to allow re-using the workflow id from a previously *closed* workflow.
   * The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
   */
  workflowIdReusePolicy = WorkflowIdReusePolicy.UNSPECIFIED;

  /**
   * Defines how to resolve a workflow id conflict with a *running* workflow.
   * The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
   * Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
   *
   * See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
   */
  workflowIdConflictPolicy = WorkflowIdConflictPolicy.UNSPECIFIED;

  /**
   * The workflow author-defined name of the signal to send to the workflow
   *
   * @generated from field: string signal_name = 12;
   */
  signalName = "";

  /**
   * Serialized value(s) to provide with the signal
   *
   * @generated from field: temporal.api.common.v1.Payloads signal_input = 13;
   */
  signalInput?: Payloads;

  /**
   * Deprecated.
   *
   * @generated from field: string control = 14 [deprecated = true];
   * @deprecated
   */
  control = "";

  /**
   * Retry policy for the workflow
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 15;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 16;
   */
  cronSchedule = "";

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 17;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 18;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 19;
   */
  header?: Header;

  /**
   * Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
   * Note that the signal will be delivered with the first workflow task. If the workflow gets
   * another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
   * and the rest of the delay period will be ignored, even if that request also had a delay.
   * Signal via SignalWorkflowExecution will not unblock the workflow.
   *
   * @generated from field: google.protobuf.Duration workflow_start_delay = 20;
   */
  workflowStartDelay?: Duration;

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 23;
   */
  userMetadata?: UserMetadata;

  /**
   * Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 24;
   */
  links: Link[] = [];

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 25;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 26;
   */
  priority?: Priority;

  constructor(data?: PartialMessage<SignalWithStartWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 4, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 5, name: "input", kind: "message", T: Payloads },
    { no: 6, name: "workflow_execution_timeout", kind: "message", T: Duration },
    { no: 7, name: "workflow_run_timeout", kind: "message", T: Duration },
    { no: 8, name: "workflow_task_timeout", kind: "message", T: Duration },
    { no: 9, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "workflow_id_reuse_policy", kind: "enum", T: proto3.getEnumType(WorkflowIdReusePolicy) },
    { no: 22, name: "workflow_id_conflict_policy", kind: "enum", T: proto3.getEnumType(WorkflowIdConflictPolicy) },
    { no: 12, name: "signal_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "signal_input", kind: "message", T: Payloads },
    { no: 14, name: "control", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 16, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "memo", kind: "message", T: Memo },
    { no: 18, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 19, name: "header", kind: "message", T: Header },
    { no: 20, name: "workflow_start_delay", kind: "message", T: Duration },
    { no: 23, name: "user_metadata", kind: "message", T: UserMetadata },
    { no: 24, name: "links", kind: "message", T: Link, repeated: true },
    { no: 25, name: "versioning_override", kind: "message", T: VersioningOverride },
    { no: 26, name: "priority", kind: "message", T: Priority },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalWithStartWorkflowExecutionRequest {
    return new SignalWithStartWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalWithStartWorkflowExecutionRequest {
    return new SignalWithStartWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalWithStartWorkflowExecutionRequest {
    return new SignalWithStartWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SignalWithStartWorkflowExecutionRequest | PlainMessage<SignalWithStartWorkflowExecutionRequest> | undefined, b: SignalWithStartWorkflowExecutionRequest | PlainMessage<SignalWithStartWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(SignalWithStartWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionResponse
 */
export class SignalWithStartWorkflowExecutionResponse extends Message<SignalWithStartWorkflowExecutionResponse> {
  /**
   * The run id of the workflow that was started - or just signaled, if it was already running.
   *
   * @generated from field: string run_id = 1;
   */
  runId = "";

  /**
   * If true, a new workflow was started.
   *
   * @generated from field: bool started = 2;
   */
  started = false;

  constructor(data?: PartialMessage<SignalWithStartWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "started", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignalWithStartWorkflowExecutionResponse {
    return new SignalWithStartWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignalWithStartWorkflowExecutionResponse {
    return new SignalWithStartWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignalWithStartWorkflowExecutionResponse {
    return new SignalWithStartWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SignalWithStartWorkflowExecutionResponse | PlainMessage<SignalWithStartWorkflowExecutionResponse> | undefined, b: SignalWithStartWorkflowExecutionResponse | PlainMessage<SignalWithStartWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(SignalWithStartWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest
 */
export class ResetWorkflowExecutionRequest extends Message<ResetWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The workflow to reset. If this contains a run ID then the workflow will be reset back to the
   * provided event ID in that run. Otherwise it will be reset to the provided event ID in the
   * current run. In all cases the current run will be terminated and a new run started.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
   * `WORKFLOW_TASK_STARTED` event to reset to.
   *
   * @generated from field: int64 workflow_task_finish_event_id = 4;
   */
  workflowTaskFinishEventId = protoInt64.zero;

  /**
   * Used to de-dupe reset requests
   *
   * @generated from field: string request_id = 5;
   */
  requestId = "";

  /**
   * Deprecated. Use `options`.
   * Default: RESET_REAPPLY_TYPE_SIGNAL
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 6 [deprecated = true];
   * @deprecated
   */
  resetReapplyType = ResetReapplyType.UNSPECIFIED;

  /**
   * Event types not to be reapplied
   *
   * @generated from field: repeated temporal.api.enums.v1.ResetReapplyExcludeType reset_reapply_exclude_types = 7;
   */
  resetReapplyExcludeTypes: ResetReapplyExcludeType[] = [];

  /**
   * Operations to perform after the workflow has been reset. These operations will be applied
   * to the *new* run of the workflow execution in the order they are provided.
   * All operations are applied to the workflow before the first new workflow task is generated
   *
   * @generated from field: repeated temporal.api.workflow.v1.PostResetOperation post_reset_operations = 8;
   */
  postResetOperations: PostResetOperation[] = [];

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 9;
   */
  identity = "";

  constructor(data?: PartialMessage<ResetWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "workflow_task_finish_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "reset_reapply_type", kind: "enum", T: proto3.getEnumType(ResetReapplyType) },
    { no: 7, name: "reset_reapply_exclude_types", kind: "enum", T: proto3.getEnumType(ResetReapplyExcludeType), repeated: true },
    { no: 8, name: "post_reset_operations", kind: "message", T: PostResetOperation, repeated: true },
    { no: 9, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetWorkflowExecutionRequest {
    return new ResetWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetWorkflowExecutionRequest {
    return new ResetWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetWorkflowExecutionRequest {
    return new ResetWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResetWorkflowExecutionRequest | PlainMessage<ResetWorkflowExecutionRequest> | undefined, b: ResetWorkflowExecutionRequest | PlainMessage<ResetWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(ResetWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ResetWorkflowExecutionResponse
 */
export class ResetWorkflowExecutionResponse extends Message<ResetWorkflowExecutionResponse> {
  /**
   * @generated from field: string run_id = 1;
   */
  runId = "";

  constructor(data?: PartialMessage<ResetWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetWorkflowExecutionResponse {
    return new ResetWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetWorkflowExecutionResponse {
    return new ResetWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetWorkflowExecutionResponse {
    return new ResetWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ResetWorkflowExecutionResponse | PlainMessage<ResetWorkflowExecutionResponse> | undefined, b: ResetWorkflowExecutionResponse | PlainMessage<ResetWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(ResetWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest
 */
export class TerminateWorkflowExecutionRequest extends Message<TerminateWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * Serialized additional information to attach to the termination event
   *
   * @generated from field: temporal.api.common.v1.Payloads details = 4;
   */
  details?: Payloads;

  /**
   * The identity of the worker/client
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * If set, this call will error if the most recent (if no run id is set on
   * `workflow_execution`), or specified (if it is) workflow execution is not part of the same
   * execution chain as this id.
   *
   * @generated from field: string first_execution_run_id = 6;
   */
  firstExecutionRunId = "";

  /**
   * Links to be associated with the WorkflowExecutionTerminated event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 7;
   */
  links: Link[] = [];

  constructor(data?: PartialMessage<TerminateWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "details", kind: "message", T: Payloads },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "first_execution_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "links", kind: "message", T: Link, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateWorkflowExecutionRequest {
    return new TerminateWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateWorkflowExecutionRequest {
    return new TerminateWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateWorkflowExecutionRequest {
    return new TerminateWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateWorkflowExecutionRequest | PlainMessage<TerminateWorkflowExecutionRequest> | undefined, b: TerminateWorkflowExecutionRequest | PlainMessage<TerminateWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(TerminateWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.TerminateWorkflowExecutionResponse
 */
export class TerminateWorkflowExecutionResponse extends Message<TerminateWorkflowExecutionResponse> {
  constructor(data?: PartialMessage<TerminateWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.TerminateWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateWorkflowExecutionResponse {
    return new TerminateWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateWorkflowExecutionResponse {
    return new TerminateWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateWorkflowExecutionResponse {
    return new TerminateWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateWorkflowExecutionResponse | PlainMessage<TerminateWorkflowExecutionResponse> | undefined, b: TerminateWorkflowExecutionResponse | PlainMessage<TerminateWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(TerminateWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest
 */
export class DeleteWorkflowExecutionRequest extends Message<DeleteWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Workflow Execution to delete. If run_id is not specified, the latest one is used.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  constructor(data?: PartialMessage<DeleteWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkflowExecutionRequest {
    return new DeleteWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkflowExecutionRequest {
    return new DeleteWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkflowExecutionRequest {
    return new DeleteWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkflowExecutionRequest | PlainMessage<DeleteWorkflowExecutionRequest> | undefined, b: DeleteWorkflowExecutionRequest | PlainMessage<DeleteWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowExecutionResponse
 */
export class DeleteWorkflowExecutionResponse extends Message<DeleteWorkflowExecutionResponse> {
  constructor(data?: PartialMessage<DeleteWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkflowExecutionResponse {
    return new DeleteWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkflowExecutionResponse {
    return new DeleteWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkflowExecutionResponse {
    return new DeleteWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkflowExecutionResponse | PlainMessage<DeleteWorkflowExecutionResponse> | undefined, b: DeleteWorkflowExecutionResponse | PlainMessage<DeleteWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(DeleteWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest
 */
export class ListOpenWorkflowExecutionsRequest extends Message<ListOpenWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
   */
  startTimeFilter?: StartTimeFilter;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest.filters
   */
  filters: {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
     */
    value: WorkflowExecutionFilter;
    case: "executionFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
     */
    value: WorkflowTypeFilter;
    case: "typeFilter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ListOpenWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "maximum_page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "start_time_filter", kind: "message", T: StartTimeFilter },
    { no: 5, name: "execution_filter", kind: "message", T: WorkflowExecutionFilter, oneof: "filters" },
    { no: 6, name: "type_filter", kind: "message", T: WorkflowTypeFilter, oneof: "filters" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOpenWorkflowExecutionsRequest {
    return new ListOpenWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOpenWorkflowExecutionsRequest {
    return new ListOpenWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOpenWorkflowExecutionsRequest {
    return new ListOpenWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListOpenWorkflowExecutionsRequest | PlainMessage<ListOpenWorkflowExecutionsRequest> | undefined, b: ListOpenWorkflowExecutionsRequest | PlainMessage<ListOpenWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(ListOpenWorkflowExecutionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsResponse
 */
export class ListOpenWorkflowExecutionsResponse extends Message<ListOpenWorkflowExecutionsResponse> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListOpenWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListOpenWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOpenWorkflowExecutionsResponse {
    return new ListOpenWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOpenWorkflowExecutionsResponse {
    return new ListOpenWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOpenWorkflowExecutionsResponse {
    return new ListOpenWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListOpenWorkflowExecutionsResponse | PlainMessage<ListOpenWorkflowExecutionsResponse> | undefined, b: ListOpenWorkflowExecutionsResponse | PlainMessage<ListOpenWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(ListOpenWorkflowExecutionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest
 */
export class ListClosedWorkflowExecutionsRequest extends Message<ListClosedWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
   */
  startTimeFilter?: StartTimeFilter;

  /**
   * @generated from oneof temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest.filters
   */
  filters: {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
     */
    value: WorkflowExecutionFilter;
    case: "executionFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
     */
    value: WorkflowTypeFilter;
    case: "typeFilter";
  } | {
    /**
     * @generated from field: temporal.api.filter.v1.StatusFilter status_filter = 7;
     */
    value: StatusFilter;
    case: "statusFilter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ListClosedWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "maximum_page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "start_time_filter", kind: "message", T: StartTimeFilter },
    { no: 5, name: "execution_filter", kind: "message", T: WorkflowExecutionFilter, oneof: "filters" },
    { no: 6, name: "type_filter", kind: "message", T: WorkflowTypeFilter, oneof: "filters" },
    { no: 7, name: "status_filter", kind: "message", T: StatusFilter, oneof: "filters" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClosedWorkflowExecutionsRequest {
    return new ListClosedWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClosedWorkflowExecutionsRequest {
    return new ListClosedWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClosedWorkflowExecutionsRequest {
    return new ListClosedWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClosedWorkflowExecutionsRequest | PlainMessage<ListClosedWorkflowExecutionsRequest> | undefined, b: ListClosedWorkflowExecutionsRequest | PlainMessage<ListClosedWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(ListClosedWorkflowExecutionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsResponse
 */
export class ListClosedWorkflowExecutionsResponse extends Message<ListClosedWorkflowExecutionsResponse> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListClosedWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListClosedWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClosedWorkflowExecutionsResponse {
    return new ListClosedWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClosedWorkflowExecutionsResponse {
    return new ListClosedWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClosedWorkflowExecutionsResponse {
    return new ListClosedWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClosedWorkflowExecutionsResponse | PlainMessage<ListClosedWorkflowExecutionsResponse> | undefined, b: ListClosedWorkflowExecutionsResponse | PlainMessage<ListClosedWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(ListClosedWorkflowExecutionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowExecutionsRequest
 */
export class ListWorkflowExecutionsRequest extends Message<ListWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: string query = 4;
   */
  query = "";

  constructor(data?: PartialMessage<ListWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkflowExecutionsRequest {
    return new ListWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkflowExecutionsRequest {
    return new ListWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkflowExecutionsRequest {
    return new ListWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkflowExecutionsRequest | PlainMessage<ListWorkflowExecutionsRequest> | undefined, b: ListWorkflowExecutionsRequest | PlainMessage<ListWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(ListWorkflowExecutionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowExecutionsResponse
 */
export class ListWorkflowExecutionsResponse extends Message<ListWorkflowExecutionsResponse> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkflowExecutionsResponse {
    return new ListWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkflowExecutionsResponse {
    return new ListWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkflowExecutionsResponse {
    return new ListWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkflowExecutionsResponse | PlainMessage<ListWorkflowExecutionsResponse> | undefined, b: ListWorkflowExecutionsResponse | PlainMessage<ListWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(ListWorkflowExecutionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsRequest
 */
export class ListArchivedWorkflowExecutionsRequest extends Message<ListArchivedWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: string query = 4;
   */
  query = "";

  constructor(data?: PartialMessage<ListArchivedWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListArchivedWorkflowExecutionsRequest {
    return new ListArchivedWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListArchivedWorkflowExecutionsRequest {
    return new ListArchivedWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListArchivedWorkflowExecutionsRequest {
    return new ListArchivedWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListArchivedWorkflowExecutionsRequest | PlainMessage<ListArchivedWorkflowExecutionsRequest> | undefined, b: ListArchivedWorkflowExecutionsRequest | PlainMessage<ListArchivedWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(ListArchivedWorkflowExecutionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsResponse
 */
export class ListArchivedWorkflowExecutionsResponse extends Message<ListArchivedWorkflowExecutionsResponse> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListArchivedWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListArchivedWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListArchivedWorkflowExecutionsResponse {
    return new ListArchivedWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListArchivedWorkflowExecutionsResponse {
    return new ListArchivedWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListArchivedWorkflowExecutionsResponse {
    return new ListArchivedWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListArchivedWorkflowExecutionsResponse | PlainMessage<ListArchivedWorkflowExecutionsResponse> | undefined, b: ListArchivedWorkflowExecutionsResponse | PlainMessage<ListArchivedWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(ListArchivedWorkflowExecutionsResponse, a, b);
  }
}

/**
 * Deprecated: Use with `ListWorkflowExecutions`.
 *
 * @generated from message temporal.api.workflowservice.v1.ScanWorkflowExecutionsRequest
 */
export class ScanWorkflowExecutionsRequest extends Message<ScanWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: string query = 4;
   */
  query = "";

  constructor(data?: PartialMessage<ScanWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ScanWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanWorkflowExecutionsRequest {
    return new ScanWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanWorkflowExecutionsRequest {
    return new ScanWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanWorkflowExecutionsRequest {
    return new ScanWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ScanWorkflowExecutionsRequest | PlainMessage<ScanWorkflowExecutionsRequest> | undefined, b: ScanWorkflowExecutionsRequest | PlainMessage<ScanWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(ScanWorkflowExecutionsRequest, a, b);
  }
}

/**
 * Deprecated: Use with `ListWorkflowExecutions`.
 *
 * @generated from message temporal.api.workflowservice.v1.ScanWorkflowExecutionsResponse
 */
export class ScanWorkflowExecutionsResponse extends Message<ScanWorkflowExecutionsResponse> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
   */
  executions: WorkflowExecutionInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ScanWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ScanWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executions", kind: "message", T: WorkflowExecutionInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanWorkflowExecutionsResponse {
    return new ScanWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanWorkflowExecutionsResponse {
    return new ScanWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanWorkflowExecutionsResponse {
    return new ScanWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ScanWorkflowExecutionsResponse | PlainMessage<ScanWorkflowExecutionsResponse> | undefined, b: ScanWorkflowExecutionsResponse | PlainMessage<ScanWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(ScanWorkflowExecutionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsRequest
 */
export class CountWorkflowExecutionsRequest extends Message<CountWorkflowExecutionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string query = 2;
   */
  query = "";

  constructor(data?: PartialMessage<CountWorkflowExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CountWorkflowExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountWorkflowExecutionsRequest {
    return new CountWorkflowExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsRequest {
    return new CountWorkflowExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsRequest {
    return new CountWorkflowExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CountWorkflowExecutionsRequest | PlainMessage<CountWorkflowExecutionsRequest> | undefined, b: CountWorkflowExecutionsRequest | PlainMessage<CountWorkflowExecutionsRequest> | undefined): boolean {
    return proto3.util.equals(CountWorkflowExecutionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse
 */
export class CountWorkflowExecutionsResponse extends Message<CountWorkflowExecutionsResponse> {
  /**
   * If `query` is not grouping by any field, the count is an approximate number
   * of workflows that matches the query.
   * If `query` is grouping by a field, the count is simply the sum of the counts
   * of the groups returned in the response. This number can be smaller than the
   * total number of workflows matching the query.
   *
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  /**
   * `groups` contains the groups if the request is grouping by a field.
   * The list might not be complete, and the counts of each group is approximate.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup groups = 2;
   */
  groups: CountWorkflowExecutionsResponse_AggregationGroup[] = [];

  constructor(data?: PartialMessage<CountWorkflowExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "groups", kind: "message", T: CountWorkflowExecutionsResponse_AggregationGroup, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountWorkflowExecutionsResponse {
    return new CountWorkflowExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsResponse {
    return new CountWorkflowExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsResponse {
    return new CountWorkflowExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountWorkflowExecutionsResponse | PlainMessage<CountWorkflowExecutionsResponse> | undefined, b: CountWorkflowExecutionsResponse | PlainMessage<CountWorkflowExecutionsResponse> | undefined): boolean {
    return proto3.util.equals(CountWorkflowExecutionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup
 */
export class CountWorkflowExecutionsResponse_AggregationGroup extends Message<CountWorkflowExecutionsResponse_AggregationGroup> {
  /**
   * @generated from field: repeated temporal.api.common.v1.Payload group_values = 1;
   */
  groupValues: Payload[] = [];

  /**
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<CountWorkflowExecutionsResponse_AggregationGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CountWorkflowExecutionsResponse.AggregationGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_values", kind: "message", T: Payload, repeated: true },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountWorkflowExecutionsResponse_AggregationGroup {
    return new CountWorkflowExecutionsResponse_AggregationGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsResponse_AggregationGroup {
    return new CountWorkflowExecutionsResponse_AggregationGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountWorkflowExecutionsResponse_AggregationGroup {
    return new CountWorkflowExecutionsResponse_AggregationGroup().fromJsonString(jsonString, options);
  }

  static equals(a: CountWorkflowExecutionsResponse_AggregationGroup | PlainMessage<CountWorkflowExecutionsResponse_AggregationGroup> | undefined, b: CountWorkflowExecutionsResponse_AggregationGroup | PlainMessage<CountWorkflowExecutionsResponse_AggregationGroup> | undefined): boolean {
    return proto3.util.equals(CountWorkflowExecutionsResponse_AggregationGroup, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetSearchAttributesRequest
 */
export class GetSearchAttributesRequest extends Message<GetSearchAttributesRequest> {
  constructor(data?: PartialMessage<GetSearchAttributesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetSearchAttributesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSearchAttributesRequest {
    return new GetSearchAttributesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSearchAttributesRequest {
    return new GetSearchAttributesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSearchAttributesRequest {
    return new GetSearchAttributesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSearchAttributesRequest | PlainMessage<GetSearchAttributesRequest> | undefined, b: GetSearchAttributesRequest | PlainMessage<GetSearchAttributesRequest> | undefined): boolean {
    return proto3.util.equals(GetSearchAttributesRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetSearchAttributesResponse
 */
export class GetSearchAttributesResponse extends Message<GetSearchAttributesResponse> {
  /**
   * @generated from field: map<string, temporal.api.enums.v1.IndexedValueType> keys = 1;
   */
  keys: { [key: string]: IndexedValueType } = {};

  constructor(data?: PartialMessage<GetSearchAttributesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetSearchAttributesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(IndexedValueType)} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSearchAttributesResponse {
    return new GetSearchAttributesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSearchAttributesResponse {
    return new GetSearchAttributesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSearchAttributesResponse {
    return new GetSearchAttributesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSearchAttributesResponse | PlainMessage<GetSearchAttributesResponse> | undefined, b: GetSearchAttributesResponse | PlainMessage<GetSearchAttributesResponse> | undefined): boolean {
    return proto3.util.equals(GetSearchAttributesResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondQueryTaskCompletedRequest
 */
export class RespondQueryTaskCompletedRequest extends Message<RespondQueryTaskCompletedRequest> {
  /**
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.enums.v1.QueryResultType completed_type = 2;
   */
  completedType = QueryResultType.UNSPECIFIED;

  /**
   * The result of the query.
   * Mutually exclusive with `error_message` and `failure`. Set when the query succeeds.
   *
   * @generated from field: temporal.api.common.v1.Payloads query_result = 3;
   */
  queryResult?: Payloads;

  /**
   * A plain error message that must be set if completed_type is QUERY_RESULT_TYPE_FAILED.
   * SDKs should also fill in the more complete `failure` field to provide the full context and
   * support encryption of failure information.
   * `error_message` will be duplicated if the `failure` field is present to support callers
   * that pre-date the addition of that field, regardless of whether or not a custom failure
   * converter is used.
   * Mutually exclusive with `query_result`. Set when the query fails.
   *
   * @generated from field: string error_message = 4;
   */
  errorMessage = "";

  /**
   * @generated from field: string namespace = 6;
   */
  namespace = "";

  /**
   * The full reason for this query failure. This field is newer than `error_message` and can be
   * encoded by the SDK's failure converter to support E2E encryption of messages and stack
   * traces.
   * Mutually exclusive with `query_result`. Set when the query fails.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 7;
   */
  failure?: Failure;

  /**
   * Why did the task fail? It's important to note that many of the variants in this enum cannot
   * apply to worker responses. See the type's doc for more.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowTaskFailedCause cause = 8;
   */
  cause = WorkflowTaskFailedCause.UNSPECIFIED;

  constructor(data?: PartialMessage<RespondQueryTaskCompletedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondQueryTaskCompletedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "completed_type", kind: "enum", T: proto3.getEnumType(QueryResultType) },
    { no: 3, name: "query_result", kind: "message", T: Payloads },
    { no: 4, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "failure", kind: "message", T: Failure },
    { no: 8, name: "cause", kind: "enum", T: proto3.getEnumType(WorkflowTaskFailedCause) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondQueryTaskCompletedRequest {
    return new RespondQueryTaskCompletedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondQueryTaskCompletedRequest {
    return new RespondQueryTaskCompletedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondQueryTaskCompletedRequest {
    return new RespondQueryTaskCompletedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondQueryTaskCompletedRequest | PlainMessage<RespondQueryTaskCompletedRequest> | undefined, b: RespondQueryTaskCompletedRequest | PlainMessage<RespondQueryTaskCompletedRequest> | undefined): boolean {
    return proto3.util.equals(RespondQueryTaskCompletedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondQueryTaskCompletedResponse
 */
export class RespondQueryTaskCompletedResponse extends Message<RespondQueryTaskCompletedResponse> {
  constructor(data?: PartialMessage<RespondQueryTaskCompletedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondQueryTaskCompletedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondQueryTaskCompletedResponse {
    return new RespondQueryTaskCompletedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondQueryTaskCompletedResponse {
    return new RespondQueryTaskCompletedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondQueryTaskCompletedResponse {
    return new RespondQueryTaskCompletedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondQueryTaskCompletedResponse | PlainMessage<RespondQueryTaskCompletedResponse> | undefined, b: RespondQueryTaskCompletedResponse | PlainMessage<RespondQueryTaskCompletedResponse> | undefined): boolean {
    return proto3.util.equals(RespondQueryTaskCompletedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ResetStickyTaskQueueRequest
 */
export class ResetStickyTaskQueueRequest extends Message<ResetStickyTaskQueueRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  constructor(data?: PartialMessage<ResetStickyTaskQueueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetStickyTaskQueueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetStickyTaskQueueRequest {
    return new ResetStickyTaskQueueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetStickyTaskQueueRequest {
    return new ResetStickyTaskQueueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetStickyTaskQueueRequest {
    return new ResetStickyTaskQueueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResetStickyTaskQueueRequest | PlainMessage<ResetStickyTaskQueueRequest> | undefined, b: ResetStickyTaskQueueRequest | PlainMessage<ResetStickyTaskQueueRequest> | undefined): boolean {
    return proto3.util.equals(ResetStickyTaskQueueRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ResetStickyTaskQueueResponse
 */
export class ResetStickyTaskQueueResponse extends Message<ResetStickyTaskQueueResponse> {
  constructor(data?: PartialMessage<ResetStickyTaskQueueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetStickyTaskQueueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetStickyTaskQueueResponse {
    return new ResetStickyTaskQueueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetStickyTaskQueueResponse {
    return new ResetStickyTaskQueueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetStickyTaskQueueResponse {
    return new ResetStickyTaskQueueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ResetStickyTaskQueueResponse | PlainMessage<ResetStickyTaskQueueResponse> | undefined, b: ResetStickyTaskQueueResponse | PlainMessage<ResetStickyTaskQueueResponse> | undefined): boolean {
    return proto3.util.equals(ResetStickyTaskQueueResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ShutdownWorkerRequest
 */
export class ShutdownWorkerRequest extends Message<ShutdownWorkerRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string sticky_task_queue = 2;
   */
  stickyTaskQueue = "";

  /**
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * @generated from field: string reason = 4;
   */
  reason = "";

  /**
   * @generated from field: temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 5;
   */
  workerHeartbeat?: WorkerHeartbeat;

  constructor(data?: PartialMessage<ShutdownWorkerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ShutdownWorkerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sticky_task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "worker_heartbeat", kind: "message", T: WorkerHeartbeat },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShutdownWorkerRequest {
    return new ShutdownWorkerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShutdownWorkerRequest {
    return new ShutdownWorkerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShutdownWorkerRequest {
    return new ShutdownWorkerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ShutdownWorkerRequest | PlainMessage<ShutdownWorkerRequest> | undefined, b: ShutdownWorkerRequest | PlainMessage<ShutdownWorkerRequest> | undefined): boolean {
    return proto3.util.equals(ShutdownWorkerRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ShutdownWorkerResponse
 */
export class ShutdownWorkerResponse extends Message<ShutdownWorkerResponse> {
  constructor(data?: PartialMessage<ShutdownWorkerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ShutdownWorkerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShutdownWorkerResponse {
    return new ShutdownWorkerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShutdownWorkerResponse {
    return new ShutdownWorkerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShutdownWorkerResponse {
    return new ShutdownWorkerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ShutdownWorkerResponse | PlainMessage<ShutdownWorkerResponse> | undefined, b: ShutdownWorkerResponse | PlainMessage<ShutdownWorkerResponse> | undefined): boolean {
    return proto3.util.equals(ShutdownWorkerResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.QueryWorkflowRequest
 */
export class QueryWorkflowRequest extends Message<QueryWorkflowRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.query.v1.WorkflowQuery query = 3;
   */
  query?: WorkflowQuery;

  /**
   * QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
   * Default: QUERY_REJECT_CONDITION_NONE.
   *
   * @generated from field: temporal.api.enums.v1.QueryRejectCondition query_reject_condition = 4;
   */
  queryRejectCondition = QueryRejectCondition.UNSPECIFIED;

  constructor(data?: PartialMessage<QueryWorkflowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.QueryWorkflowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "query", kind: "message", T: WorkflowQuery },
    { no: 4, name: "query_reject_condition", kind: "enum", T: proto3.getEnumType(QueryRejectCondition) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryWorkflowRequest {
    return new QueryWorkflowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryWorkflowRequest {
    return new QueryWorkflowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryWorkflowRequest {
    return new QueryWorkflowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryWorkflowRequest | PlainMessage<QueryWorkflowRequest> | undefined, b: QueryWorkflowRequest | PlainMessage<QueryWorkflowRequest> | undefined): boolean {
    return proto3.util.equals(QueryWorkflowRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.QueryWorkflowResponse
 */
export class QueryWorkflowResponse extends Message<QueryWorkflowResponse> {
  /**
   * @generated from field: temporal.api.common.v1.Payloads query_result = 1;
   */
  queryResult?: Payloads;

  /**
   * @generated from field: temporal.api.query.v1.QueryRejected query_rejected = 2;
   */
  queryRejected?: QueryRejected;

  constructor(data?: PartialMessage<QueryWorkflowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.QueryWorkflowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_result", kind: "message", T: Payloads },
    { no: 2, name: "query_rejected", kind: "message", T: QueryRejected },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryWorkflowResponse {
    return new QueryWorkflowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryWorkflowResponse {
    return new QueryWorkflowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryWorkflowResponse {
    return new QueryWorkflowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryWorkflowResponse | PlainMessage<QueryWorkflowResponse> | undefined, b: QueryWorkflowResponse | PlainMessage<QueryWorkflowResponse> | undefined): boolean {
    return proto3.util.equals(QueryWorkflowResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest
 */
export class DescribeWorkflowExecutionRequest extends Message<DescribeWorkflowExecutionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  constructor(data?: PartialMessage<DescribeWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkflowExecutionRequest {
    return new DescribeWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkflowExecutionRequest {
    return new DescribeWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkflowExecutionRequest {
    return new DescribeWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkflowExecutionRequest | PlainMessage<DescribeWorkflowExecutionRequest> | undefined, b: DescribeWorkflowExecutionRequest | PlainMessage<DescribeWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(DescribeWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse
 */
export class DescribeWorkflowExecutionResponse extends Message<DescribeWorkflowExecutionResponse> {
  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionConfig execution_config = 1;
   */
  executionConfig?: WorkflowExecutionConfig;

  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionInfo workflow_execution_info = 2;
   */
  workflowExecutionInfo?: WorkflowExecutionInfo;

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingActivityInfo pending_activities = 3;
   */
  pendingActivities: PendingActivityInfo[] = [];

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingChildExecutionInfo pending_children = 4;
   */
  pendingChildren: PendingChildExecutionInfo[] = [];

  /**
   * @generated from field: temporal.api.workflow.v1.PendingWorkflowTaskInfo pending_workflow_task = 5;
   */
  pendingWorkflowTask?: PendingWorkflowTaskInfo;

  /**
   * @generated from field: repeated temporal.api.workflow.v1.CallbackInfo callbacks = 6;
   */
  callbacks: CallbackInfo[] = [];

  /**
   * @generated from field: repeated temporal.api.workflow.v1.PendingNexusOperationInfo pending_nexus_operations = 7;
   */
  pendingNexusOperations: PendingNexusOperationInfo[] = [];

  /**
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionExtendedInfo workflow_extended_info = 8;
   */
  workflowExtendedInfo?: WorkflowExecutionExtendedInfo;

  constructor(data?: PartialMessage<DescribeWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execution_config", kind: "message", T: WorkflowExecutionConfig },
    { no: 2, name: "workflow_execution_info", kind: "message", T: WorkflowExecutionInfo },
    { no: 3, name: "pending_activities", kind: "message", T: PendingActivityInfo, repeated: true },
    { no: 4, name: "pending_children", kind: "message", T: PendingChildExecutionInfo, repeated: true },
    { no: 5, name: "pending_workflow_task", kind: "message", T: PendingWorkflowTaskInfo },
    { no: 6, name: "callbacks", kind: "message", T: CallbackInfo, repeated: true },
    { no: 7, name: "pending_nexus_operations", kind: "message", T: PendingNexusOperationInfo, repeated: true },
    { no: 8, name: "workflow_extended_info", kind: "message", T: WorkflowExecutionExtendedInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkflowExecutionResponse {
    return new DescribeWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkflowExecutionResponse {
    return new DescribeWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkflowExecutionResponse {
    return new DescribeWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkflowExecutionResponse | PlainMessage<DescribeWorkflowExecutionResponse> | undefined, b: DescribeWorkflowExecutionResponse | PlainMessage<DescribeWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(DescribeWorkflowExecutionResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0203::optional=disabled
 *     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueRequest
 */
export class DescribeTaskQueueRequest extends Message<DescribeTaskQueueRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Sticky queues are not supported in deprecated ENHANCED mode.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  /**
   * If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
   * Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
   *
   * @generated from field: temporal.api.enums.v1.TaskQueueType task_queue_type = 3;
   */
  taskQueueType = TaskQueueType.UNSPECIFIED;

  /**
   * Report stats for the requested task queue type(s).
   *
   * @generated from field: bool report_stats = 8;
   */
  reportStats = false;

  /**
   * Report Task Queue Config
   *
   * @generated from field: bool report_config = 11;
   */
  reportConfig = false;

  /**
   * Deprecated, use `report_stats` instead.
   * If true, the task queue status will be included in the response.
   *
   * @generated from field: bool include_task_queue_status = 4 [deprecated = true];
   * @deprecated
   */
  includeTaskQueueStatus = false;

  /**
   * Deprecated. ENHANCED mode is also being deprecated.
   * Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
   * Consult the documentation for each field to understand which mode it is supported in.
   *
   * @generated from field: temporal.api.enums.v1.DescribeTaskQueueMode api_mode = 5 [deprecated = true];
   * @deprecated
   */
  apiMode = DescribeTaskQueueMode.UNSPECIFIED;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
   * mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
   * unversioned queue will be returned.
   * (-- api-linter: core::0140::prepositions --)
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueVersionSelection versions = 6 [deprecated = true];
   * @deprecated
   */
  versions?: TaskQueueVersionSelection;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Task queue types to report info about. If not specified, all types are considered.
   *
   * @generated from field: repeated temporal.api.enums.v1.TaskQueueType task_queue_types = 7 [deprecated = true];
   * @deprecated
   */
  taskQueueTypes: TaskQueueType[] = [];

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Report list of pollers for requested task queue types and versions.
   *
   * @generated from field: bool report_pollers = 9 [deprecated = true];
   * @deprecated
   */
  reportPollers = false;

  /**
   * Deprecated (as part of the ENHANCED mode deprecation).
   * Report task reachability for the requested versions and all task types (task reachability is not reported
   * per task type).
   *
   * @generated from field: bool report_task_reachability = 10 [deprecated = true];
   * @deprecated
   */
  reportTaskReachability = false;

  constructor(data?: PartialMessage<DescribeTaskQueueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeTaskQueueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 3, name: "task_queue_type", kind: "enum", T: proto3.getEnumType(TaskQueueType) },
    { no: 8, name: "report_stats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "report_config", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "include_task_queue_status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "api_mode", kind: "enum", T: proto3.getEnumType(DescribeTaskQueueMode) },
    { no: 6, name: "versions", kind: "message", T: TaskQueueVersionSelection },
    { no: 7, name: "task_queue_types", kind: "enum", T: proto3.getEnumType(TaskQueueType), repeated: true },
    { no: 9, name: "report_pollers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "report_task_reachability", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeTaskQueueRequest {
    return new DescribeTaskQueueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeTaskQueueRequest {
    return new DescribeTaskQueueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeTaskQueueRequest {
    return new DescribeTaskQueueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeTaskQueueRequest | PlainMessage<DescribeTaskQueueRequest> | undefined, b: DescribeTaskQueueRequest | PlainMessage<DescribeTaskQueueRequest> | undefined): boolean {
    return proto3.util.equals(DescribeTaskQueueRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueResponse
 */
export class DescribeTaskQueueResponse extends Message<DescribeTaskQueueResponse> {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.PollerInfo pollers = 1;
   */
  pollers: PollerInfo[] = [];

  /**
   * Statistics for the task queue.
   * Only set if `report_stats` is set on the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 5;
   */
  stats?: TaskQueueStats;

  /**
   * Task queue stats breakdown by priority key. Only contains actively used priority keys.
   * Only set if `report_stats` is set on the request.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueStats> stats_by_priority_key = 8;
   */
  statsByPriorityKey: { [key: number]: TaskQueueStats } = {};

  /**
   * Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
   * When not present, it means the tasks are routed to Unversioned workers (workers with
   * UNVERSIONED or unspecified WorkerVersioningMode.)
   * Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
   * and SetWorkerDeploymentRampingVersion on Worker Deployments.
   * Note: This information is not relevant to Pinned workflow executions and their activities as
   * they are always routed to their Pinned Deployment Version. However, new workflow executions
   * are typically not Pinned until they complete their first task (unless they are started with
   * a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueVersioningInfo versioning_info = 4;
   */
  versioningInfo?: TaskQueueVersioningInfo;

  /**
   * Only populated if report_task_queue_config is set to true.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueConfig config = 6;
   */
  config?: TaskQueueConfig;

  /**
   * @generated from field: temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit effective_rate_limit = 7;
   */
  effectiveRateLimit?: DescribeTaskQueueResponse_EffectiveRateLimit;

  /**
   * Deprecated.
   * Status of the task queue. Only populated when `include_task_queue_status` is set to true in the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStatus task_queue_status = 2 [deprecated = true];
   * @deprecated
   */
  taskQueueStatus?: TaskQueueStatus;

  /**
   * Deprecated.
   * Only returned in ENHANCED mode.
   * This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
   *
   * @generated from field: map<string, temporal.api.taskqueue.v1.TaskQueueVersionInfo> versions_info = 3 [deprecated = true];
   * @deprecated
   */
  versionsInfo: { [key: string]: TaskQueueVersionInfo } = {};

  constructor(data?: PartialMessage<DescribeTaskQueueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeTaskQueueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pollers", kind: "message", T: PollerInfo, repeated: true },
    { no: 5, name: "stats", kind: "message", T: TaskQueueStats },
    { no: 8, name: "stats_by_priority_key", kind: "map", K: 5 /* ScalarType.INT32 */, V: {kind: "message", T: TaskQueueStats} },
    { no: 4, name: "versioning_info", kind: "message", T: TaskQueueVersioningInfo },
    { no: 6, name: "config", kind: "message", T: TaskQueueConfig },
    { no: 7, name: "effective_rate_limit", kind: "message", T: DescribeTaskQueueResponse_EffectiveRateLimit },
    { no: 2, name: "task_queue_status", kind: "message", T: TaskQueueStatus },
    { no: 3, name: "versions_info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: TaskQueueVersionInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeTaskQueueResponse {
    return new DescribeTaskQueueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeTaskQueueResponse {
    return new DescribeTaskQueueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeTaskQueueResponse {
    return new DescribeTaskQueueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeTaskQueueResponse | PlainMessage<DescribeTaskQueueResponse> | undefined, b: DescribeTaskQueueResponse | PlainMessage<DescribeTaskQueueResponse> | undefined): boolean {
    return proto3.util.equals(DescribeTaskQueueResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit
 */
export class DescribeTaskQueueResponse_EffectiveRateLimit extends Message<DescribeTaskQueueResponse_EffectiveRateLimit> {
  /**
   * The effective rate limit for the task queue.
   *
   * @generated from field: float requests_per_second = 1;
   */
  requestsPerSecond = 0;

  /**
   * Source of the RateLimit Configuration,which can be one of the following values:
   * - SOURCE_API: The rate limit that is set via the TaskQueueConfig api.
   * - SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.
   * - SOURCE_SYSTEM: The rate limit is the default value set by the system
   *
   * @generated from field: temporal.api.enums.v1.RateLimitSource rate_limit_source = 2;
   */
  rateLimitSource = RateLimitSource.UNSPECIFIED;

  constructor(data?: PartialMessage<DescribeTaskQueueResponse_EffectiveRateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeTaskQueueResponse.EffectiveRateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests_per_second", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "rate_limit_source", kind: "enum", T: proto3.getEnumType(RateLimitSource) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeTaskQueueResponse_EffectiveRateLimit {
    return new DescribeTaskQueueResponse_EffectiveRateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeTaskQueueResponse_EffectiveRateLimit {
    return new DescribeTaskQueueResponse_EffectiveRateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeTaskQueueResponse_EffectiveRateLimit {
    return new DescribeTaskQueueResponse_EffectiveRateLimit().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeTaskQueueResponse_EffectiveRateLimit | PlainMessage<DescribeTaskQueueResponse_EffectiveRateLimit> | undefined, b: DescribeTaskQueueResponse_EffectiveRateLimit | PlainMessage<DescribeTaskQueueResponse_EffectiveRateLimit> | undefined): boolean {
    return proto3.util.equals(DescribeTaskQueueResponse_EffectiveRateLimit, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetClusterInfoRequest
 */
export class GetClusterInfoRequest extends Message<GetClusterInfoRequest> {
  constructor(data?: PartialMessage<GetClusterInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetClusterInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterInfoRequest {
    return new GetClusterInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterInfoRequest {
    return new GetClusterInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterInfoRequest {
    return new GetClusterInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterInfoRequest | PlainMessage<GetClusterInfoRequest> | undefined, b: GetClusterInfoRequest | PlainMessage<GetClusterInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterInfoRequest, a, b);
  }
}

/**
 * GetClusterInfoResponse contains information about Temporal cluster.
 *
 * @generated from message temporal.api.workflowservice.v1.GetClusterInfoResponse
 */
export class GetClusterInfoResponse extends Message<GetClusterInfoResponse> {
  /**
   * Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
   * Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
   *
   * @generated from field: map<string, string> supported_clients = 1;
   */
  supportedClients: { [key: string]: string } = {};

  /**
   * @generated from field: string server_version = 2;
   */
  serverVersion = "";

  /**
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * @generated from field: temporal.api.version.v1.VersionInfo version_info = 4;
   */
  versionInfo?: VersionInfo;

  /**
   * @generated from field: string cluster_name = 5;
   */
  clusterName = "";

  /**
   * @generated from field: int32 history_shard_count = 6;
   */
  historyShardCount = 0;

  /**
   * @generated from field: string persistence_store = 7;
   */
  persistenceStore = "";

  /**
   * @generated from field: string visibility_store = 8;
   */
  visibilityStore = "";

  /**
   * @generated from field: int64 initial_failover_version = 9;
   */
  initialFailoverVersion = protoInt64.zero;

  /**
   * @generated from field: int64 failover_version_increment = 10;
   */
  failoverVersionIncrement = protoInt64.zero;

  constructor(data?: PartialMessage<GetClusterInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetClusterInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "supported_clients", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "server_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version_info", kind: "message", T: VersionInfo },
    { no: 5, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "history_shard_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "persistence_store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "visibility_store", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "initial_failover_version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "failover_version_increment", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterInfoResponse {
    return new GetClusterInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterInfoResponse {
    return new GetClusterInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterInfoResponse {
    return new GetClusterInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterInfoResponse | PlainMessage<GetClusterInfoResponse> | undefined, b: GetClusterInfoResponse | PlainMessage<GetClusterInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetClusterInfoResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoRequest
 */
export class GetSystemInfoRequest extends Message<GetSystemInfoRequest> {
  constructor(data?: PartialMessage<GetSystemInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetSystemInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSystemInfoRequest {
    return new GetSystemInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSystemInfoRequest {
    return new GetSystemInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSystemInfoRequest {
    return new GetSystemInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSystemInfoRequest | PlainMessage<GetSystemInfoRequest> | undefined, b: GetSystemInfoRequest | PlainMessage<GetSystemInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetSystemInfoRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoResponse
 */
export class GetSystemInfoResponse extends Message<GetSystemInfoResponse> {
  /**
   * Version of the server.
   *
   * @generated from field: string server_version = 1;
   */
  serverVersion = "";

  /**
   * All capabilities the system supports.
   *
   * @generated from field: temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities capabilities = 2;
   */
  capabilities?: GetSystemInfoResponse_Capabilities;

  constructor(data?: PartialMessage<GetSystemInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetSystemInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "capabilities", kind: "message", T: GetSystemInfoResponse_Capabilities },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSystemInfoResponse {
    return new GetSystemInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSystemInfoResponse {
    return new GetSystemInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSystemInfoResponse {
    return new GetSystemInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSystemInfoResponse | PlainMessage<GetSystemInfoResponse> | undefined, b: GetSystemInfoResponse | PlainMessage<GetSystemInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetSystemInfoResponse, a, b);
  }
}

/**
 * System capability details.
 *
 * @generated from message temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities
 */
export class GetSystemInfoResponse_Capabilities extends Message<GetSystemInfoResponse_Capabilities> {
  /**
   * True if signal and query headers are supported.
   *
   * @generated from field: bool signal_and_query_header = 1;
   */
  signalAndQueryHeader = false;

  /**
   * True if internal errors are differentiated from other types of errors for purposes of
   * retrying non-internal errors.
   *
   * When unset/false, clients retry all failures. When true, clients should only retry
   * non-internal errors.
   *
   * @generated from field: bool internal_error_differentiation = 2;
   */
  internalErrorDifferentiation = false;

  /**
   * True if RespondActivityTaskFailed API supports including heartbeat details
   *
   * @generated from field: bool activity_failure_include_heartbeat = 3;
   */
  activityFailureIncludeHeartbeat = false;

  /**
   * Supports scheduled workflow features.
   *
   * @generated from field: bool supports_schedules = 4;
   */
  supportsSchedules = false;

  /**
   * True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
   *
   * @generated from field: bool encoded_failure_attributes = 5;
   */
  encodedFailureAttributes = false;

  /**
   * True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
   * (see:
   * https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
   *
   * @generated from field: bool build_id_based_versioning = 6;
   */
  buildIdBasedVersioning = false;

  /**
   * True if server supports upserting workflow memo
   *
   * @generated from field: bool upsert_memo = 7;
   */
  upsertMemo = false;

  /**
   * True if server supports eager workflow task dispatching for the StartWorkflowExecution API
   *
   * @generated from field: bool eager_workflow_start = 8;
   */
  eagerWorkflowStart = false;

  /**
   * True if the server knows about the sdk metadata field on WFT completions and will record
   * it in history
   *
   * @generated from field: bool sdk_metadata = 9;
   */
  sdkMetadata = false;

  /**
   * True if the server supports count group by execution status
   * (-- api-linter: core::0140::prepositions=disabled --)
   *
   * @generated from field: bool count_group_by_execution_status = 10;
   */
  countGroupByExecutionStatus = false;

  /**
   * True if the server supports Nexus operations.
   * This flag is dependent both on server version and for Nexus to be enabled via server configuration.
   *
   * @generated from field: bool nexus = 11;
   */
  nexus = false;

  constructor(data?: PartialMessage<GetSystemInfoResponse_Capabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetSystemInfoResponse.Capabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signal_and_query_header", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "internal_error_differentiation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "activity_failure_include_heartbeat", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "supports_schedules", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "encoded_failure_attributes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "build_id_based_versioning", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "upsert_memo", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "eager_workflow_start", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "sdk_metadata", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "count_group_by_execution_status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "nexus", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSystemInfoResponse_Capabilities {
    return new GetSystemInfoResponse_Capabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSystemInfoResponse_Capabilities {
    return new GetSystemInfoResponse_Capabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSystemInfoResponse_Capabilities {
    return new GetSystemInfoResponse_Capabilities().fromJsonString(jsonString, options);
  }

  static equals(a: GetSystemInfoResponse_Capabilities | PlainMessage<GetSystemInfoResponse_Capabilities> | undefined, b: GetSystemInfoResponse_Capabilities | PlainMessage<GetSystemInfoResponse_Capabilities> | undefined): boolean {
    return proto3.util.equals(GetSystemInfoResponse_Capabilities, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListTaskQueuePartitionsRequest
 */
export class ListTaskQueuePartitionsRequest extends Message<ListTaskQueuePartitionsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
   */
  taskQueue?: TaskQueue;

  constructor(data?: PartialMessage<ListTaskQueuePartitionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListTaskQueuePartitionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "message", T: TaskQueue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTaskQueuePartitionsRequest {
    return new ListTaskQueuePartitionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTaskQueuePartitionsRequest {
    return new ListTaskQueuePartitionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTaskQueuePartitionsRequest {
    return new ListTaskQueuePartitionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTaskQueuePartitionsRequest | PlainMessage<ListTaskQueuePartitionsRequest> | undefined, b: ListTaskQueuePartitionsRequest | PlainMessage<ListTaskQueuePartitionsRequest> | undefined): boolean {
    return proto3.util.equals(ListTaskQueuePartitionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListTaskQueuePartitionsResponse
 */
export class ListTaskQueuePartitionsResponse extends Message<ListTaskQueuePartitionsResponse> {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata activity_task_queue_partitions = 1;
   */
  activityTaskQueuePartitions: TaskQueuePartitionMetadata[] = [];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata workflow_task_queue_partitions = 2;
   */
  workflowTaskQueuePartitions: TaskQueuePartitionMetadata[] = [];

  constructor(data?: PartialMessage<ListTaskQueuePartitionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListTaskQueuePartitionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "activity_task_queue_partitions", kind: "message", T: TaskQueuePartitionMetadata, repeated: true },
    { no: 2, name: "workflow_task_queue_partitions", kind: "message", T: TaskQueuePartitionMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTaskQueuePartitionsResponse {
    return new ListTaskQueuePartitionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTaskQueuePartitionsResponse {
    return new ListTaskQueuePartitionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTaskQueuePartitionsResponse {
    return new ListTaskQueuePartitionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTaskQueuePartitionsResponse | PlainMessage<ListTaskQueuePartitionsResponse> | undefined, b: ListTaskQueuePartitionsResponse | PlainMessage<ListTaskQueuePartitionsResponse> | undefined): boolean {
    return proto3.util.equals(ListTaskQueuePartitionsResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0203::optional=disabled
 *     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
 *
 * @generated from message temporal.api.workflowservice.v1.CreateScheduleRequest
 */
export class CreateScheduleRequest extends Message<CreateScheduleRequest> {
  /**
   * The namespace the schedule should be created in.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the new schedule.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  /**
   * The schedule spec, policies, action, and initial state.
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 3;
   */
  schedule?: Schedule;

  /**
   * Optional initial patch (e.g. to run the action once immediately).
   *
   * @generated from field: temporal.api.schedule.v1.SchedulePatch initial_patch = 4;
   */
  initialPatch?: SchedulePatch;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * A unique identifier for this create request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 6;
   */
  requestId = "";

  /**
   * Memo and search attributes to attach to the schedule itself.
   *
   * @generated from field: temporal.api.common.v1.Memo memo = 7;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 8;
   */
  searchAttributes?: SearchAttributes;

  constructor(data?: PartialMessage<CreateScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CreateScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "schedule", kind: "message", T: Schedule },
    { no: 4, name: "initial_patch", kind: "message", T: SchedulePatch },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "memo", kind: "message", T: Memo },
    { no: 8, name: "search_attributes", kind: "message", T: SearchAttributes },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateScheduleRequest {
    return new CreateScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateScheduleRequest {
    return new CreateScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateScheduleRequest {
    return new CreateScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateScheduleRequest | PlainMessage<CreateScheduleRequest> | undefined, b: CreateScheduleRequest | PlainMessage<CreateScheduleRequest> | undefined): boolean {
    return proto3.util.equals(CreateScheduleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CreateScheduleResponse
 */
export class CreateScheduleResponse extends Message<CreateScheduleResponse> {
  /**
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken = new Uint8Array(0);

  constructor(data?: PartialMessage<CreateScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CreateScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateScheduleResponse {
    return new CreateScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateScheduleResponse {
    return new CreateScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateScheduleResponse {
    return new CreateScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateScheduleResponse | PlainMessage<CreateScheduleResponse> | undefined, b: CreateScheduleResponse | PlainMessage<CreateScheduleResponse> | undefined): boolean {
    return proto3.util.equals(CreateScheduleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeScheduleRequest
 */
export class DescribeScheduleRequest extends Message<DescribeScheduleRequest> {
  /**
   * The namespace of the schedule to describe.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the schedule to describe.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  constructor(data?: PartialMessage<DescribeScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeScheduleRequest {
    return new DescribeScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeScheduleRequest {
    return new DescribeScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeScheduleRequest {
    return new DescribeScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeScheduleRequest | PlainMessage<DescribeScheduleRequest> | undefined, b: DescribeScheduleRequest | PlainMessage<DescribeScheduleRequest> | undefined): boolean {
    return proto3.util.equals(DescribeScheduleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeScheduleResponse
 */
export class DescribeScheduleResponse extends Message<DescribeScheduleResponse> {
  /**
   * The complete current schedule details. This may not match the schedule as
   * created because:
   * - some types of schedule specs may get compiled into others (e.g.
   *   CronString into StructuredCalendarSpec)
   * - some unspecified fields may be replaced by defaults
   * - some fields in the state are modified automatically
   * - the schedule may have been modified by UpdateSchedule or PatchSchedule
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 1;
   */
  schedule?: Schedule;

  /**
   * Extra schedule state info.
   *
   * @generated from field: temporal.api.schedule.v1.ScheduleInfo info = 2;
   */
  info?: ScheduleInfo;

  /**
   * The memo and search attributes that the schedule was created with.
   *
   * @generated from field: temporal.api.common.v1.Memo memo = 3;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 4;
   */
  searchAttributes?: SearchAttributes;

  /**
   * This value can be passed back to UpdateSchedule to ensure that the
   * schedule was not modified between a Describe and an Update, which could
   * lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken = new Uint8Array(0);

  constructor(data?: PartialMessage<DescribeScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule", kind: "message", T: Schedule },
    { no: 2, name: "info", kind: "message", T: ScheduleInfo },
    { no: 3, name: "memo", kind: "message", T: Memo },
    { no: 4, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 5, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeScheduleResponse {
    return new DescribeScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeScheduleResponse {
    return new DescribeScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeScheduleResponse {
    return new DescribeScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeScheduleResponse | PlainMessage<DescribeScheduleResponse> | undefined, b: DescribeScheduleResponse | PlainMessage<DescribeScheduleResponse> | undefined): boolean {
    return proto3.util.equals(DescribeScheduleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateScheduleRequest
 */
export class UpdateScheduleRequest extends Message<UpdateScheduleRequest> {
  /**
   * The namespace of the schedule to update.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the schedule to update.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  /**
   * The new schedule. The four main fields of the schedule (spec, action,
   * policies, state) are replaced completely by the values in this message.
   *
   * @generated from field: temporal.api.schedule.v1.Schedule schedule = 3;
   */
  schedule?: Schedule;

  /**
   * This can be the value of conflict_token from a DescribeScheduleResponse,
   * which will cause this request to fail if the schedule has been modified
   * between the Describe and this Update.
   * If missing, the schedule will be updated unconditionally.
   *
   * @generated from field: bytes conflict_token = 4;
   */
  conflictToken = new Uint8Array(0);

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * A unique identifier for this update request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 6;
   */
  requestId = "";

  /**
   * Schedule search attributes to be updated.
   * Do not set this field if you do not want to update the search attributes.
   * A non-null empty object will set the search attributes to an empty map.
   * Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
   * you must also set the `schedule` field; otherwise, it will unset the schedule.
   *
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 7;
   */
  searchAttributes?: SearchAttributes;

  constructor(data?: PartialMessage<UpdateScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "schedule", kind: "message", T: Schedule },
    { no: 4, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "search_attributes", kind: "message", T: SearchAttributes },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateScheduleRequest {
    return new UpdateScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateScheduleRequest {
    return new UpdateScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateScheduleRequest {
    return new UpdateScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateScheduleRequest | PlainMessage<UpdateScheduleRequest> | undefined, b: UpdateScheduleRequest | PlainMessage<UpdateScheduleRequest> | undefined): boolean {
    return proto3.util.equals(UpdateScheduleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateScheduleResponse
 */
export class UpdateScheduleResponse extends Message<UpdateScheduleResponse> {
  constructor(data?: PartialMessage<UpdateScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateScheduleResponse {
    return new UpdateScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateScheduleResponse {
    return new UpdateScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateScheduleResponse {
    return new UpdateScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateScheduleResponse | PlainMessage<UpdateScheduleResponse> | undefined, b: UpdateScheduleResponse | PlainMessage<UpdateScheduleResponse> | undefined): boolean {
    return proto3.util.equals(UpdateScheduleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PatchScheduleRequest
 */
export class PatchScheduleRequest extends Message<PatchScheduleRequest> {
  /**
   * The namespace of the schedule to patch.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the schedule to patch.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  /**
   * @generated from field: temporal.api.schedule.v1.SchedulePatch patch = 3;
   */
  patch?: SchedulePatch;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 4;
   */
  identity = "";

  /**
   * A unique identifier for this update request for idempotence. Typically UUIDv4.
   *
   * @generated from field: string request_id = 5;
   */
  requestId = "";

  constructor(data?: PartialMessage<PatchScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PatchScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "patch", kind: "message", T: SchedulePatch },
    { no: 4, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PatchScheduleRequest {
    return new PatchScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PatchScheduleRequest {
    return new PatchScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PatchScheduleRequest {
    return new PatchScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PatchScheduleRequest | PlainMessage<PatchScheduleRequest> | undefined, b: PatchScheduleRequest | PlainMessage<PatchScheduleRequest> | undefined): boolean {
    return proto3.util.equals(PatchScheduleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PatchScheduleResponse
 */
export class PatchScheduleResponse extends Message<PatchScheduleResponse> {
  constructor(data?: PartialMessage<PatchScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PatchScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PatchScheduleResponse {
    return new PatchScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PatchScheduleResponse {
    return new PatchScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PatchScheduleResponse {
    return new PatchScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PatchScheduleResponse | PlainMessage<PatchScheduleResponse> | undefined, b: PatchScheduleResponse | PlainMessage<PatchScheduleResponse> | undefined): boolean {
    return proto3.util.equals(PatchScheduleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListScheduleMatchingTimesRequest
 */
export class ListScheduleMatchingTimesRequest extends Message<ListScheduleMatchingTimesRequest> {
  /**
   * The namespace of the schedule to query.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the schedule to query.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  /**
   * Time range to query.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 4;
   */
  endTime?: Timestamp;

  constructor(data?: PartialMessage<ListScheduleMatchingTimesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListScheduleMatchingTimesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_time", kind: "message", T: Timestamp },
    { no: 4, name: "end_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListScheduleMatchingTimesRequest {
    return new ListScheduleMatchingTimesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListScheduleMatchingTimesRequest {
    return new ListScheduleMatchingTimesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListScheduleMatchingTimesRequest {
    return new ListScheduleMatchingTimesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListScheduleMatchingTimesRequest | PlainMessage<ListScheduleMatchingTimesRequest> | undefined, b: ListScheduleMatchingTimesRequest | PlainMessage<ListScheduleMatchingTimesRequest> | undefined): boolean {
    return proto3.util.equals(ListScheduleMatchingTimesRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListScheduleMatchingTimesResponse
 */
export class ListScheduleMatchingTimesResponse extends Message<ListScheduleMatchingTimesResponse> {
  /**
   * @generated from field: repeated google.protobuf.Timestamp start_time = 1;
   */
  startTime: Timestamp[] = [];

  constructor(data?: PartialMessage<ListScheduleMatchingTimesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListScheduleMatchingTimesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListScheduleMatchingTimesResponse {
    return new ListScheduleMatchingTimesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListScheduleMatchingTimesResponse {
    return new ListScheduleMatchingTimesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListScheduleMatchingTimesResponse {
    return new ListScheduleMatchingTimesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListScheduleMatchingTimesResponse | PlainMessage<ListScheduleMatchingTimesResponse> | undefined, b: ListScheduleMatchingTimesResponse | PlainMessage<ListScheduleMatchingTimesResponse> | undefined): boolean {
    return proto3.util.equals(ListScheduleMatchingTimesResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteScheduleRequest
 */
export class DeleteScheduleRequest extends Message<DeleteScheduleRequest> {
  /**
   * The namespace of the schedule to delete.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The id of the schedule to delete.
   *
   * @generated from field: string schedule_id = 2;
   */
  scheduleId = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  constructor(data?: PartialMessage<DeleteScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteScheduleRequest {
    return new DeleteScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteScheduleRequest {
    return new DeleteScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteScheduleRequest {
    return new DeleteScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteScheduleRequest | PlainMessage<DeleteScheduleRequest> | undefined, b: DeleteScheduleRequest | PlainMessage<DeleteScheduleRequest> | undefined): boolean {
    return proto3.util.equals(DeleteScheduleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteScheduleResponse
 */
export class DeleteScheduleResponse extends Message<DeleteScheduleResponse> {
  constructor(data?: PartialMessage<DeleteScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteScheduleResponse {
    return new DeleteScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteScheduleResponse {
    return new DeleteScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteScheduleResponse {
    return new DeleteScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteScheduleResponse | PlainMessage<DeleteScheduleResponse> | undefined, b: DeleteScheduleResponse | PlainMessage<DeleteScheduleResponse> | undefined): boolean {
    return proto3.util.equals(DeleteScheduleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListSchedulesRequest
 */
export class ListSchedulesRequest extends Message<ListSchedulesRequest> {
  /**
   * The namespace to list schedules in.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * How many to return at once.
   *
   * @generated from field: int32 maximum_page_size = 2;
   */
  maximumPageSize = 0;

  /**
   * Token to get the next page of results.
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * Query to filter schedules.
   *
   * @generated from field: string query = 4;
   */
  query = "";

  constructor(data?: PartialMessage<ListSchedulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListSchedulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "maximum_page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSchedulesRequest {
    return new ListSchedulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSchedulesRequest {
    return new ListSchedulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSchedulesRequest {
    return new ListSchedulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSchedulesRequest | PlainMessage<ListSchedulesRequest> | undefined, b: ListSchedulesRequest | PlainMessage<ListSchedulesRequest> | undefined): boolean {
    return proto3.util.equals(ListSchedulesRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListSchedulesResponse
 */
export class ListSchedulesResponse extends Message<ListSchedulesResponse> {
  /**
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleListEntry schedules = 1;
   */
  schedules: ScheduleListEntry[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListSchedulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListSchedulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedules", kind: "message", T: ScheduleListEntry, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSchedulesResponse {
    return new ListSchedulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSchedulesResponse {
    return new ListSchedulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSchedulesResponse {
    return new ListSchedulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSchedulesResponse | PlainMessage<ListSchedulesResponse> | undefined, b: ListSchedulesResponse | PlainMessage<ListSchedulesResponse> | undefined): boolean {
    return proto3.util.equals(ListSchedulesResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest
 */
export class UpdateWorkerBuildIdCompatibilityRequest extends Message<UpdateWorkerBuildIdCompatibilityRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Must be set, the task queue to apply changes to. Because all workers on a given task queue
   * must have the same set of workflow & activity implementations, there is no reason to specify
   * a task queue type here.
   *
   * @generated from field: string task_queue = 2;
   */
  taskQueue = "";

  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.operation
   */
  operation: {
    /**
     * A new build id. This operation will create a new set which will be the new overall
     * default version for the queue, with this id as its only member. This new set is
     * incompatible with all previous sets/versions.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: In makes perfect sense here. --)
     *
     * @generated from field: string add_new_build_id_in_new_default_set = 3;
     */
    value: string;
    case: "addNewBuildIdInNewDefaultSet";
  } | {
    /**
     * Adds a new id to an existing compatible set, see sub-message definition for more.
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion add_new_compatible_build_id = 4;
     */
    value: UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion;
    case: "addNewCompatibleBuildId";
  } | {
    /**
     * Promote an existing set to be the current default (if it isn't already) by targeting
     * an existing build id within it. This field's value is the extant build id.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: Names are hard. --)
     *
     * @generated from field: string promote_set_by_build_id = 5;
     */
    value: string;
    case: "promoteSetByBuildId";
  } | {
    /**
     * Promote an existing build id within some set to be the current default for that set.
     *
     * (-- api-linter: core::0140::prepositions=disabled
     *     aip.dev/not-precedent: Within makes perfect sense here. --)
     *
     * @generated from field: string promote_build_id_within_set = 6;
     */
    value: string;
    case: "promoteBuildIdWithinSet";
  } | {
    /**
     * Merge two existing sets together, thus declaring all build IDs in both sets compatible
     * with one another. The primary set's default will become the default for the merged set.
     * This is useful if you've accidentally declared a new ID as incompatible you meant to
     * declare as compatible. The unusual case of incomplete replication during failover could
     * also result in a split set, which this operation can repair.
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets merge_sets = 7;
     */
    value: UpdateWorkerBuildIdCompatibilityRequest_MergeSets;
    case: "mergeSets";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpdateWorkerBuildIdCompatibilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "add_new_build_id_in_new_default_set", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "operation" },
    { no: 4, name: "add_new_compatible_build_id", kind: "message", T: UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion, oneof: "operation" },
    { no: 5, name: "promote_set_by_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "operation" },
    { no: 6, name: "promote_build_id_within_set", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "operation" },
    { no: 7, name: "merge_sets", kind: "message", T: UpdateWorkerBuildIdCompatibilityRequest_MergeSets, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerBuildIdCompatibilityRequest {
    return new UpdateWorkerBuildIdCompatibilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest {
    return new UpdateWorkerBuildIdCompatibilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest {
    return new UpdateWorkerBuildIdCompatibilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerBuildIdCompatibilityRequest | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest> | undefined, b: UpdateWorkerBuildIdCompatibilityRequest | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerBuildIdCompatibilityRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion
 */
export class UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion extends Message<UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion> {
  /**
   * A new id to be added to an existing compatible set.
   *
   * @generated from field: string new_build_id = 1;
   */
  newBuildId = "";

  /**
   * A build id which must already exist in the version sets known by the task queue. The new
   * id will be stored in the set containing this id, marking it as compatible with
   * the versions within.
   *
   * @generated from field: string existing_compatible_build_id = 2;
   */
  existingCompatibleBuildId = "";

  /**
   * When set, establishes the compatible set being targeted as the overall default for the
   * queue. If a different set was the current default, the targeted set will replace it as
   * the new default.
   *
   * @generated from field: bool make_set_default = 3;
   */
  makeSetDefault = false;

  constructor(data?: PartialMessage<UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "existing_compatible_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "make_set_default", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion {
    return new UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion {
    return new UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion {
    return new UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion> | undefined, b: UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerBuildIdCompatibilityRequest_AddNewCompatibleVersion, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets
 */
export class UpdateWorkerBuildIdCompatibilityRequest_MergeSets extends Message<UpdateWorkerBuildIdCompatibilityRequest_MergeSets> {
  /**
   * A build ID in the set whose default will become the merged set default
   *
   * @generated from field: string primary_set_build_id = 1;
   */
  primarySetBuildId = "";

  /**
   * A build ID in the set which will be merged into the primary set
   *
   * @generated from field: string secondary_set_build_id = 2;
   */
  secondarySetBuildId = "";

  constructor(data?: PartialMessage<UpdateWorkerBuildIdCompatibilityRequest_MergeSets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_set_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secondary_set_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_MergeSets {
    return new UpdateWorkerBuildIdCompatibilityRequest_MergeSets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_MergeSets {
    return new UpdateWorkerBuildIdCompatibilityRequest_MergeSets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityRequest_MergeSets {
    return new UpdateWorkerBuildIdCompatibilityRequest_MergeSets().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerBuildIdCompatibilityRequest_MergeSets | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest_MergeSets> | undefined, b: UpdateWorkerBuildIdCompatibilityRequest_MergeSets | PlainMessage<UpdateWorkerBuildIdCompatibilityRequest_MergeSets> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerBuildIdCompatibilityRequest_MergeSets, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityResponse
 */
export class UpdateWorkerBuildIdCompatibilityResponse extends Message<UpdateWorkerBuildIdCompatibilityResponse> {
  constructor(data?: PartialMessage<UpdateWorkerBuildIdCompatibilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerBuildIdCompatibilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerBuildIdCompatibilityResponse {
    return new UpdateWorkerBuildIdCompatibilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityResponse {
    return new UpdateWorkerBuildIdCompatibilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerBuildIdCompatibilityResponse {
    return new UpdateWorkerBuildIdCompatibilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerBuildIdCompatibilityResponse | PlainMessage<UpdateWorkerBuildIdCompatibilityResponse> | undefined, b: UpdateWorkerBuildIdCompatibilityResponse | PlainMessage<UpdateWorkerBuildIdCompatibilityResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerBuildIdCompatibilityResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityRequest
 */
export class GetWorkerBuildIdCompatibilityRequest extends Message<GetWorkerBuildIdCompatibilityRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Must be set, the task queue to interrogate about worker id compatibility.
   *
   * @generated from field: string task_queue = 2;
   */
  taskQueue = "";

  /**
   * Limits how many compatible sets will be returned. Specify 1 to only return the current
   * default major version set. 0 returns all sets.
   *
   * @generated from field: int32 max_sets = 3;
   */
  maxSets = 0;

  constructor(data?: PartialMessage<GetWorkerBuildIdCompatibilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "max_sets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerBuildIdCompatibilityRequest {
    return new GetWorkerBuildIdCompatibilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerBuildIdCompatibilityRequest {
    return new GetWorkerBuildIdCompatibilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerBuildIdCompatibilityRequest {
    return new GetWorkerBuildIdCompatibilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerBuildIdCompatibilityRequest | PlainMessage<GetWorkerBuildIdCompatibilityRequest> | undefined, b: GetWorkerBuildIdCompatibilityRequest | PlainMessage<GetWorkerBuildIdCompatibilityRequest> | undefined): boolean {
    return proto3.util.equals(GetWorkerBuildIdCompatibilityRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityResponse
 */
export class GetWorkerBuildIdCompatibilityResponse extends Message<GetWorkerBuildIdCompatibilityResponse> {
  /**
   * Major version sets, in order from oldest to newest. The last element of the list will always
   * be the current default major version. IE: New workflows will target the most recent version
   * in that version set.
   *
   * There may be fewer sets returned than exist, if the request chose to limit this response.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.CompatibleVersionSet major_version_sets = 1;
   */
  majorVersionSets: CompatibleVersionSet[] = [];

  constructor(data?: PartialMessage<GetWorkerBuildIdCompatibilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerBuildIdCompatibilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "major_version_sets", kind: "message", T: CompatibleVersionSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerBuildIdCompatibilityResponse {
    return new GetWorkerBuildIdCompatibilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerBuildIdCompatibilityResponse {
    return new GetWorkerBuildIdCompatibilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerBuildIdCompatibilityResponse {
    return new GetWorkerBuildIdCompatibilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerBuildIdCompatibilityResponse | PlainMessage<GetWorkerBuildIdCompatibilityResponse> | undefined, b: GetWorkerBuildIdCompatibilityResponse | PlainMessage<GetWorkerBuildIdCompatibilityResponse> | undefined): boolean {
    return proto3.util.equals(GetWorkerBuildIdCompatibilityResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0134::request-mask-required=disabled
 *     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
 * (-- api-linter: core::0134::request-resource-required=disabled
 *     aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest
 */
export class UpdateWorkerVersioningRulesRequest extends Message<UpdateWorkerVersioningRulesRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string task_queue = 2;
   */
  taskQueue = "";

  /**
   * A valid conflict_token can be taken from the previous
   * ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
   * An invalid token will cause this request to fail, ensuring that if the rules
   * for this Task Queue have been modified between the previous and current
   * operation, the request will fail instead of causing an unpredictable mutation.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken = new Uint8Array(0);

  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.operation
   */
  operation: {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule insert_assignment_rule = 4;
     */
    value: UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule;
    case: "insertAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule replace_assignment_rule = 5;
     */
    value: UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule;
    case: "replaceAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule delete_assignment_rule = 6;
     */
    value: UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule;
    case: "deleteAssignmentRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule add_compatible_redirect_rule = 7;
     */
    value: UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule;
    case: "addCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule replace_compatible_redirect_rule = 8;
     */
    value: UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule;
    case: "replaceCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule delete_compatible_redirect_rule = 9;
     */
    value: UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule;
    case: "deleteCompatibleRedirectRule";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId commit_build_id = 10;
     */
    value: UpdateWorkerVersioningRulesRequest_CommitBuildId;
    case: "commitBuildId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "insert_assignment_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule, oneof: "operation" },
    { no: 5, name: "replace_assignment_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule, oneof: "operation" },
    { no: 6, name: "delete_assignment_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule, oneof: "operation" },
    { no: 7, name: "add_compatible_redirect_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule, oneof: "operation" },
    { no: 8, name: "replace_compatible_redirect_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule, oneof: "operation" },
    { no: 9, name: "delete_compatible_redirect_rule", kind: "message", T: UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule, oneof: "operation" },
    { no: 10, name: "commit_build_id", kind: "message", T: UpdateWorkerVersioningRulesRequest_CommitBuildId, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest {
    return new UpdateWorkerVersioningRulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest {
    return new UpdateWorkerVersioningRulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest {
    return new UpdateWorkerVersioningRulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest | PlainMessage<UpdateWorkerVersioningRulesRequest> | undefined, b: UpdateWorkerVersioningRulesRequest | PlainMessage<UpdateWorkerVersioningRulesRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest, a, b);
  }
}

/**
 * Inserts the rule to the list of assignment rules for this Task Queue.
 * The rules are evaluated in order, starting from index 0. The first
 * applicable rule will be applied and the rest will be ignored.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule
 */
export class UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule extends Message<UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule> {
  /**
   * Use this option to insert the rule in a particular index. By
   * default, the new rule is inserted at the beginning of the list
   * (index 0). If the given index is too larger the rule will be
   * inserted at the end of the list.
   *
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex = 0;

  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;
   */
  rule?: BuildIdAssignmentRule;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "rule", kind: "message", T: BuildIdAssignmentRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule> | undefined, b: UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_InsertBuildIdAssignmentRule, a, b);
  }
}

/**
 * Replaces the assignment rule at a given index.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule
 */
export class UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule extends Message<UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule> {
  /**
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex = 0;

  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;
   */
  rule?: BuildIdAssignmentRule;

  /**
   * By default presence of one unconditional rule is enforced, otherwise
   * the replace operation will be rejected. Set `force` to true to
   * bypass this validation. An unconditional assignment rule:
   *   - Has no hint filter
   *   - Has no ramp
   *
   * @generated from field: bool force = 3;
   */
  force = false;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "rule", kind: "message", T: BuildIdAssignmentRule },
    { no: 3, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule> | undefined, b: UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_ReplaceBuildIdAssignmentRule, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule
 */
export class UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule extends Message<UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule> {
  /**
   * @generated from field: int32 rule_index = 1;
   */
  ruleIndex = 0;

  /**
   * By default presence of one unconditional rule is enforced, otherwise
   * the delete operation will be rejected. Set `force` to true to
   * bypass this validation. An unconditional assignment rule:
   *   - Has no hint filter
   *   - Has no ramp
   *
   * @generated from field: bool force = 2;
   */
  force = false;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule> | undefined, b: UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule | PlainMessage<UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_DeleteBuildIdAssignmentRule, a, b);
  }
}

/**
 * Adds the rule to the list of redirect rules for this Task Queue. There
 * can be at most one redirect rule for each distinct Source Build ID.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule
 */
export class UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule extends Message<UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: CompatibleBuildIdRedirectRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule> | undefined, b: UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_AddCompatibleBuildIdRedirectRule, a, b);
  }
}

/**
 * Replaces the routing rule with the given source Build ID.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule
 */
export class UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule extends Message<UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: CompatibleBuildIdRedirectRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule> | undefined, b: UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_ReplaceCompatibleBuildIdRedirectRule, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule
 */
export class UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule extends Message<UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule> {
  /**
   * @generated from field: string source_build_id = 1;
   */
  sourceBuildId = "";

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule {
    return new UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule> | undefined, b: UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule | PlainMessage<UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_DeleteCompatibleBuildIdRedirectRule, a, b);
  }
}

/**
 * This command is intended to be used to complete the rollout of a Build
 * ID and cleanup unnecessary rules possibly created during a gradual
 * rollout. Specifically, this command will make the following changes
 * atomically:
 *  1. Adds an assignment rule (with full ramp) for the target Build ID at
 *     the end of the list.
 *  2. Removes all previously added assignment rules to the given target
 *     Build ID (if any).
 *  3. Removes any fully-ramped assignment rule for other Build IDs.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId
 */
export class UpdateWorkerVersioningRulesRequest_CommitBuildId extends Message<UpdateWorkerVersioningRulesRequest_CommitBuildId> {
  /**
   * @generated from field: string target_build_id = 1;
   */
  targetBuildId = "";

  /**
   * To prevent committing invalid Build IDs, we reject the request if no
   * pollers has been seen recently for this Build ID. Use the `force`
   * option to disable this validation.
   *
   * @generated from field: bool force = 2;
   */
  force = false;

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesRequest_CommitBuildId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesRequest.CommitBuildId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesRequest_CommitBuildId {
    return new UpdateWorkerVersioningRulesRequest_CommitBuildId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_CommitBuildId {
    return new UpdateWorkerVersioningRulesRequest_CommitBuildId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesRequest_CommitBuildId {
    return new UpdateWorkerVersioningRulesRequest_CommitBuildId().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesRequest_CommitBuildId | PlainMessage<UpdateWorkerVersioningRulesRequest_CommitBuildId> | undefined, b: UpdateWorkerVersioningRulesRequest_CommitBuildId | PlainMessage<UpdateWorkerVersioningRulesRequest_CommitBuildId> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesRequest_CommitBuildId, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesResponse
 */
export class UpdateWorkerVersioningRulesResponse extends Message<UpdateWorkerVersioningRulesResponse> {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
   */
  assignmentRules: TimestampedBuildIdAssignmentRule[] = [];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;
   */
  compatibleRedirectRules: TimestampedCompatibleBuildIdRedirectRule[] = [];

  /**
   * This value can be passed back to UpdateWorkerVersioningRulesRequest to
   * ensure that the rules were not modified between the two updates, which
   * could lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken = new Uint8Array(0);

  constructor(data?: PartialMessage<UpdateWorkerVersioningRulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerVersioningRulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assignment_rules", kind: "message", T: TimestampedBuildIdAssignmentRule, repeated: true },
    { no: 2, name: "compatible_redirect_rules", kind: "message", T: TimestampedCompatibleBuildIdRedirectRule, repeated: true },
    { no: 3, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerVersioningRulesResponse {
    return new UpdateWorkerVersioningRulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesResponse {
    return new UpdateWorkerVersioningRulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerVersioningRulesResponse {
    return new UpdateWorkerVersioningRulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerVersioningRulesResponse | PlainMessage<UpdateWorkerVersioningRulesResponse> | undefined, b: UpdateWorkerVersioningRulesResponse | PlainMessage<UpdateWorkerVersioningRulesResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerVersioningRulesResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerVersioningRulesRequest
 */
export class GetWorkerVersioningRulesRequest extends Message<GetWorkerVersioningRulesRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string task_queue = 2;
   */
  taskQueue = "";

  constructor(data?: PartialMessage<GetWorkerVersioningRulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerVersioningRulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerVersioningRulesRequest {
    return new GetWorkerVersioningRulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerVersioningRulesRequest {
    return new GetWorkerVersioningRulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerVersioningRulesRequest {
    return new GetWorkerVersioningRulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerVersioningRulesRequest | PlainMessage<GetWorkerVersioningRulesRequest> | undefined, b: GetWorkerVersioningRulesRequest | PlainMessage<GetWorkerVersioningRulesRequest> | undefined): boolean {
    return proto3.util.equals(GetWorkerVersioningRulesRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerVersioningRulesResponse
 */
export class GetWorkerVersioningRulesResponse extends Message<GetWorkerVersioningRulesResponse> {
  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
   */
  assignmentRules: TimestampedBuildIdAssignmentRule[] = [];

  /**
   * @generated from field: repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;
   */
  compatibleRedirectRules: TimestampedCompatibleBuildIdRedirectRule[] = [];

  /**
   * This value can be passed back to UpdateWorkerVersioningRulesRequest to
   * ensure that the rules were not modified between this List and the Update,
   * which could lead to lost updates and other confusion.
   *
   * @generated from field: bytes conflict_token = 3;
   */
  conflictToken = new Uint8Array(0);

  constructor(data?: PartialMessage<GetWorkerVersioningRulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerVersioningRulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assignment_rules", kind: "message", T: TimestampedBuildIdAssignmentRule, repeated: true },
    { no: 2, name: "compatible_redirect_rules", kind: "message", T: TimestampedCompatibleBuildIdRedirectRule, repeated: true },
    { no: 3, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerVersioningRulesResponse {
    return new GetWorkerVersioningRulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerVersioningRulesResponse {
    return new GetWorkerVersioningRulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerVersioningRulesResponse {
    return new GetWorkerVersioningRulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerVersioningRulesResponse | PlainMessage<GetWorkerVersioningRulesResponse> | undefined, b: GetWorkerVersioningRulesResponse | PlainMessage<GetWorkerVersioningRulesResponse> | undefined): boolean {
    return proto3.util.equals(GetWorkerVersioningRulesResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 * Deprecated. Use `DescribeTaskQueue`.
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityRequest
 */
export class GetWorkerTaskReachabilityRequest extends Message<GetWorkerTaskReachabilityRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
   * The number of build ids that can be queried in a single API call is limited.
   * Open source users can adjust this limit by setting the server's dynamic config value for
   * `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
   *
   * @generated from field: repeated string build_ids = 2;
   */
  buildIds: string[] = [];

  /**
   * Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
   * build ids in the namespace.
   * Must specify at least one task queue if querying for an unversioned worker.
   * The number of task queues that the server will fetch reachability information for is limited.
   * See the `GetWorkerTaskReachabilityResponse` documentation for more information.
   *
   * @generated from field: repeated string task_queues = 3;
   */
  taskQueues: string[] = [];

  /**
   * Type of reachability to query for.
   * `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
   * Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
   * Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
   * unspecified.
   * See the TaskReachability docstring for information about each enum variant.
   *
   * @generated from field: temporal.api.enums.v1.TaskReachability reachability = 4;
   */
  reachability = TaskReachability.UNSPECIFIED;

  constructor(data?: PartialMessage<GetWorkerTaskReachabilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerTaskReachabilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "build_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "task_queues", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "reachability", kind: "enum", T: proto3.getEnumType(TaskReachability) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerTaskReachabilityRequest {
    return new GetWorkerTaskReachabilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerTaskReachabilityRequest {
    return new GetWorkerTaskReachabilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerTaskReachabilityRequest {
    return new GetWorkerTaskReachabilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerTaskReachabilityRequest | PlainMessage<GetWorkerTaskReachabilityRequest> | undefined, b: GetWorkerTaskReachabilityRequest | PlainMessage<GetWorkerTaskReachabilityRequest> | undefined): boolean {
    return proto3.util.equals(GetWorkerTaskReachabilityRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release]
 * Deprecated. Use `DescribeTaskQueue`.
 *
 * @generated from message temporal.api.workflowservice.v1.GetWorkerTaskReachabilityResponse
 */
export class GetWorkerTaskReachabilityResponse extends Message<GetWorkerTaskReachabilityResponse> {
  /**
   * Task reachability, broken down by build id and then task queue.
   * When requesting a large number of task queues or all task queues associated with the given build ids in a
   * namespace, all task queues will be listed in the response but some of them may not contain reachability
   * information due to a server enforced limit. When reaching the limit, task queues that reachability information
   * could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
   * another call to get the reachability for those task queues.
   *
   * Open source users can adjust this limit by setting the server's dynamic config value for
   * `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.BuildIdReachability build_id_reachability = 1;
   */
  buildIdReachability: BuildIdReachability[] = [];

  constructor(data?: PartialMessage<GetWorkerTaskReachabilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetWorkerTaskReachabilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_id_reachability", kind: "message", T: BuildIdReachability, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWorkerTaskReachabilityResponse {
    return new GetWorkerTaskReachabilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWorkerTaskReachabilityResponse {
    return new GetWorkerTaskReachabilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWorkerTaskReachabilityResponse {
    return new GetWorkerTaskReachabilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWorkerTaskReachabilityResponse | PlainMessage<GetWorkerTaskReachabilityResponse> | undefined, b: GetWorkerTaskReachabilityResponse | PlainMessage<GetWorkerTaskReachabilityResponse> | undefined): boolean {
    return proto3.util.equals(GetWorkerTaskReachabilityResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0134=disabled
 *     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest
 */
export class UpdateWorkflowExecutionRequest extends Message<UpdateWorkflowExecutionRequest> {
  /**
   * The namespace name of the target Workflow.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The target Workflow Id and (optionally) a specific Run Id thereof.
   * (-- api-linter: core::0203::optional=disabled
   *     aip.dev/not-precedent: false positive triggered by the word "optional" --)
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * If set, this call will error if the most recent (if no Run Id is set on
   * `workflow_execution`), or specified (if it is) Workflow Execution is not
   * part of the same execution chain as this Id.
   *
   * @generated from field: string first_execution_run_id = 3;
   */
  firstExecutionRunId = "";

  /**
   * Specifies client's intent to wait for Update results.
   * NOTE: This field works together with API call timeout which is limited by
   * server timeout (maximum wait time). If server timeout is expired before
   * user specified timeout, API call returns even if specified stage is not reached.
   * Actual reached stage will be included in the response.
   *
   * @generated from field: temporal.api.update.v1.WaitPolicy wait_policy = 4;
   */
  waitPolicy?: WaitPolicy;

  /**
   * The request information that will be delivered all the way down to the
   * Workflow Execution.
   *
   * @generated from field: temporal.api.update.v1.Request request = 5;
   */
  request?: Request;

  constructor(data?: PartialMessage<UpdateWorkflowExecutionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "first_execution_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "wait_policy", kind: "message", T: WaitPolicy },
    { no: 5, name: "request", kind: "message", T: Request },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkflowExecutionRequest {
    return new UpdateWorkflowExecutionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionRequest {
    return new UpdateWorkflowExecutionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionRequest {
    return new UpdateWorkflowExecutionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkflowExecutionRequest | PlainMessage<UpdateWorkflowExecutionRequest> | undefined, b: UpdateWorkflowExecutionRequest | PlainMessage<UpdateWorkflowExecutionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkflowExecutionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse
 */
export class UpdateWorkflowExecutionResponse extends Message<UpdateWorkflowExecutionResponse> {
  /**
   * Enough information for subsequent poll calls if needed. Never null.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 1;
   */
  updateRef?: UpdateRef;

  /**
   * The outcome of the Update if and only if the Workflow Update
   * has completed. If this response is being returned before the Update has
   * completed then this field will not be set.
   *
   * @generated from field: temporal.api.update.v1.Outcome outcome = 2;
   */
  outcome?: Outcome;

  /**
   * The most advanced lifecycle stage that the Update is known to have
   * reached, where lifecycle stages are ordered
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
   * UNSPECIFIED will be returned if and only if the server's maximum wait
   * time was reached before the Update reached the stage specified in the
   * request WaitPolicy, and before the context deadline expired; clients may
   * may then retry the call as needed.
   *
   * @generated from field: temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 3;
   */
  stage = UpdateWorkflowExecutionLifecycleStage.UNSPECIFIED;

  constructor(data?: PartialMessage<UpdateWorkflowExecutionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_ref", kind: "message", T: UpdateRef },
    { no: 2, name: "outcome", kind: "message", T: Outcome },
    { no: 3, name: "stage", kind: "enum", T: proto3.getEnumType(UpdateWorkflowExecutionLifecycleStage) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkflowExecutionResponse {
    return new UpdateWorkflowExecutionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionResponse {
    return new UpdateWorkflowExecutionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionResponse {
    return new UpdateWorkflowExecutionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkflowExecutionResponse | PlainMessage<UpdateWorkflowExecutionResponse> | undefined, b: UpdateWorkflowExecutionResponse | PlainMessage<UpdateWorkflowExecutionResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkflowExecutionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StartBatchOperationRequest
 */
export class StartBatchOperationRequest extends Message<StartBatchOperationRequest> {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Visibility query defines the the group of workflow to apply the batch operation
   * This field and `executions` are mutually exclusive
   *
   * @generated from field: string visibility_query = 2;
   */
  visibilityQuery = "";

  /**
   * Job ID defines the unique ID for the batch job
   *
   * @generated from field: string job_id = 3;
   */
  jobId = "";

  /**
   * Reason to perform the batch operation
   *
   * @generated from field: string reason = 4;
   */
  reason = "";

  /**
   * Executions to apply the batch operation
   * This field and `visibility_query` are mutually exclusive
   *
   * @generated from field: repeated temporal.api.common.v1.WorkflowExecution executions = 5;
   */
  executions: WorkflowExecution[] = [];

  /**
   * Limit for the number of operations processed per second within this batch.
   * Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
   * overload and minimize potential delays in executing ongoing tasks for user workers.
   * Note that when no explicit limit is provided, the server will operate according to its limit defined by the
   * dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
   * server's configured limit.
   *
   * @generated from field: float max_operations_per_second = 6;
   */
  maxOperationsPerSecond = 0;

  /**
   * Operation input
   *
   * @generated from oneof temporal.api.workflowservice.v1.StartBatchOperationRequest.operation
   */
  operation: {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationTermination termination_operation = 10;
     */
    value: BatchOperationTermination;
    case: "terminationOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationSignal signal_operation = 11;
     */
    value: BatchOperationSignal;
    case: "signalOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationCancellation cancellation_operation = 12;
     */
    value: BatchOperationCancellation;
    case: "cancellationOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationDeletion deletion_operation = 13;
     */
    value: BatchOperationDeletion;
    case: "deletionOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationReset reset_operation = 14;
     */
    value: BatchOperationReset;
    case: "resetOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions update_workflow_options_operation = 15;
     */
    value: BatchOperationUpdateWorkflowExecutionOptions;
    case: "updateWorkflowOptionsOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUnpauseActivities unpause_activities_operation = 16;
     */
    value: BatchOperationUnpauseActivities;
    case: "unpauseActivitiesOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationResetActivities reset_activities_operation = 17;
     */
    value: BatchOperationResetActivities;
    case: "resetActivitiesOperation";
  } | {
    /**
     * @generated from field: temporal.api.batch.v1.BatchOperationUpdateActivityOptions update_activity_options_operation = 18;
     */
    value: BatchOperationUpdateActivityOptions;
    case: "updateActivityOptionsOperation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StartBatchOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StartBatchOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "visibility_query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "executions", kind: "message", T: WorkflowExecution, repeated: true },
    { no: 6, name: "max_operations_per_second", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 10, name: "termination_operation", kind: "message", T: BatchOperationTermination, oneof: "operation" },
    { no: 11, name: "signal_operation", kind: "message", T: BatchOperationSignal, oneof: "operation" },
    { no: 12, name: "cancellation_operation", kind: "message", T: BatchOperationCancellation, oneof: "operation" },
    { no: 13, name: "deletion_operation", kind: "message", T: BatchOperationDeletion, oneof: "operation" },
    { no: 14, name: "reset_operation", kind: "message", T: BatchOperationReset, oneof: "operation" },
    { no: 15, name: "update_workflow_options_operation", kind: "message", T: BatchOperationUpdateWorkflowExecutionOptions, oneof: "operation" },
    { no: 16, name: "unpause_activities_operation", kind: "message", T: BatchOperationUnpauseActivities, oneof: "operation" },
    { no: 17, name: "reset_activities_operation", kind: "message", T: BatchOperationResetActivities, oneof: "operation" },
    { no: 18, name: "update_activity_options_operation", kind: "message", T: BatchOperationUpdateActivityOptions, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartBatchOperationRequest {
    return new StartBatchOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartBatchOperationRequest {
    return new StartBatchOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartBatchOperationRequest {
    return new StartBatchOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartBatchOperationRequest | PlainMessage<StartBatchOperationRequest> | undefined, b: StartBatchOperationRequest | PlainMessage<StartBatchOperationRequest> | undefined): boolean {
    return proto3.util.equals(StartBatchOperationRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StartBatchOperationResponse
 */
export class StartBatchOperationResponse extends Message<StartBatchOperationResponse> {
  constructor(data?: PartialMessage<StartBatchOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StartBatchOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartBatchOperationResponse {
    return new StartBatchOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartBatchOperationResponse {
    return new StartBatchOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartBatchOperationResponse {
    return new StartBatchOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartBatchOperationResponse | PlainMessage<StartBatchOperationResponse> | undefined, b: StartBatchOperationResponse | PlainMessage<StartBatchOperationResponse> | undefined): boolean {
    return proto3.util.equals(StartBatchOperationResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StopBatchOperationRequest
 */
export class StopBatchOperationRequest extends Message<StopBatchOperationRequest> {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Batch job id
   *
   * @generated from field: string job_id = 2;
   */
  jobId = "";

  /**
   * Reason to stop a batch operation
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * Identity of the operator
   *
   * @generated from field: string identity = 4;
   */
  identity = "";

  constructor(data?: PartialMessage<StopBatchOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StopBatchOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopBatchOperationRequest {
    return new StopBatchOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopBatchOperationRequest {
    return new StopBatchOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopBatchOperationRequest {
    return new StopBatchOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StopBatchOperationRequest | PlainMessage<StopBatchOperationRequest> | undefined, b: StopBatchOperationRequest | PlainMessage<StopBatchOperationRequest> | undefined): boolean {
    return proto3.util.equals(StopBatchOperationRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.StopBatchOperationResponse
 */
export class StopBatchOperationResponse extends Message<StopBatchOperationResponse> {
  constructor(data?: PartialMessage<StopBatchOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.StopBatchOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopBatchOperationResponse {
    return new StopBatchOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopBatchOperationResponse {
    return new StopBatchOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopBatchOperationResponse {
    return new StopBatchOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StopBatchOperationResponse | PlainMessage<StopBatchOperationResponse> | undefined, b: StopBatchOperationResponse | PlainMessage<StopBatchOperationResponse> | undefined): boolean {
    return proto3.util.equals(StopBatchOperationResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeBatchOperationRequest
 */
export class DescribeBatchOperationRequest extends Message<DescribeBatchOperationRequest> {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Batch job id
   *
   * @generated from field: string job_id = 2;
   */
  jobId = "";

  constructor(data?: PartialMessage<DescribeBatchOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeBatchOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeBatchOperationRequest {
    return new DescribeBatchOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeBatchOperationRequest {
    return new DescribeBatchOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeBatchOperationRequest {
    return new DescribeBatchOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeBatchOperationRequest | PlainMessage<DescribeBatchOperationRequest> | undefined, b: DescribeBatchOperationRequest | PlainMessage<DescribeBatchOperationRequest> | undefined): boolean {
    return proto3.util.equals(DescribeBatchOperationRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeBatchOperationResponse
 */
export class DescribeBatchOperationResponse extends Message<DescribeBatchOperationResponse> {
  /**
   * Batch operation type
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationType operation_type = 1;
   */
  operationType = BatchOperationType.UNSPECIFIED;

  /**
   * Batch job ID
   *
   * @generated from field: string job_id = 2;
   */
  jobId = "";

  /**
   * Batch operation state
   *
   * @generated from field: temporal.api.enums.v1.BatchOperationState state = 3;
   */
  state = BatchOperationState.UNSPECIFIED;

  /**
   * Batch operation start time
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * Batch operation close time
   *
   * @generated from field: google.protobuf.Timestamp close_time = 5;
   */
  closeTime?: Timestamp;

  /**
   * Total operation count
   *
   * @generated from field: int64 total_operation_count = 6;
   */
  totalOperationCount = protoInt64.zero;

  /**
   * Complete operation count
   *
   * @generated from field: int64 complete_operation_count = 7;
   */
  completeOperationCount = protoInt64.zero;

  /**
   * Failure operation count
   *
   * @generated from field: int64 failure_operation_count = 8;
   */
  failureOperationCount = protoInt64.zero;

  /**
   * Identity indicates the operator identity
   *
   * @generated from field: string identity = 9;
   */
  identity = "";

  /**
   * Reason indicates the reason to stop a operation
   *
   * @generated from field: string reason = 10;
   */
  reason = "";

  constructor(data?: PartialMessage<DescribeBatchOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeBatchOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_type", kind: "enum", T: proto3.getEnumType(BatchOperationType) },
    { no: 2, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(BatchOperationState) },
    { no: 4, name: "start_time", kind: "message", T: Timestamp },
    { no: 5, name: "close_time", kind: "message", T: Timestamp },
    { no: 6, name: "total_operation_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "complete_operation_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "failure_operation_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeBatchOperationResponse {
    return new DescribeBatchOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeBatchOperationResponse {
    return new DescribeBatchOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeBatchOperationResponse {
    return new DescribeBatchOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeBatchOperationResponse | PlainMessage<DescribeBatchOperationResponse> | undefined, b: DescribeBatchOperationResponse | PlainMessage<DescribeBatchOperationResponse> | undefined): boolean {
    return proto3.util.equals(DescribeBatchOperationResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListBatchOperationsRequest
 */
export class ListBatchOperationsRequest extends Message<ListBatchOperationsRequest> {
  /**
   * Namespace that contains the batch operation
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * List page size
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Next page token
   *
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListBatchOperationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListBatchOperationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListBatchOperationsRequest {
    return new ListBatchOperationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListBatchOperationsRequest {
    return new ListBatchOperationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListBatchOperationsRequest {
    return new ListBatchOperationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListBatchOperationsRequest | PlainMessage<ListBatchOperationsRequest> | undefined, b: ListBatchOperationsRequest | PlainMessage<ListBatchOperationsRequest> | undefined): boolean {
    return proto3.util.equals(ListBatchOperationsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListBatchOperationsResponse
 */
export class ListBatchOperationsResponse extends Message<ListBatchOperationsResponse> {
  /**
   * BatchOperationInfo contains the basic info about batch operation
   *
   * @generated from field: repeated temporal.api.batch.v1.BatchOperationInfo operation_info = 1;
   */
  operationInfo: BatchOperationInfo[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListBatchOperationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListBatchOperationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_info", kind: "message", T: BatchOperationInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListBatchOperationsResponse {
    return new ListBatchOperationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListBatchOperationsResponse {
    return new ListBatchOperationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListBatchOperationsResponse {
    return new ListBatchOperationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListBatchOperationsResponse | PlainMessage<ListBatchOperationsResponse> | undefined, b: ListBatchOperationsResponse | PlainMessage<ListBatchOperationsResponse> | undefined): boolean {
    return proto3.util.equals(ListBatchOperationsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest
 */
export class PollWorkflowExecutionUpdateRequest extends Message<PollWorkflowExecutionUpdateRequest> {
  /**
   * The namespace of the Workflow Execution to which the Update was
   * originally issued.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The Update reference returned in the initial UpdateWorkflowExecutionResponse.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 2;
   */
  updateRef?: UpdateRef;

  /**
   * The identity of the worker/client who is polling this Update outcome.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * Specifies client's intent to wait for Update results.
   * Omit to request a non-blocking poll.
   *
   * @generated from field: temporal.api.update.v1.WaitPolicy wait_policy = 4;
   */
  waitPolicy?: WaitPolicy;

  constructor(data?: PartialMessage<PollWorkflowExecutionUpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "update_ref", kind: "message", T: UpdateRef },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "wait_policy", kind: "message", T: WaitPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollWorkflowExecutionUpdateRequest {
    return new PollWorkflowExecutionUpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollWorkflowExecutionUpdateRequest {
    return new PollWorkflowExecutionUpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollWorkflowExecutionUpdateRequest {
    return new PollWorkflowExecutionUpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PollWorkflowExecutionUpdateRequest | PlainMessage<PollWorkflowExecutionUpdateRequest> | undefined, b: PollWorkflowExecutionUpdateRequest | PlainMessage<PollWorkflowExecutionUpdateRequest> | undefined): boolean {
    return proto3.util.equals(PollWorkflowExecutionUpdateRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse
 */
export class PollWorkflowExecutionUpdateResponse extends Message<PollWorkflowExecutionUpdateResponse> {
  /**
   * The outcome of the update if and only if the update has completed. If
   * this response is being returned before the update has completed (e.g. due
   * to the specification of a wait policy that only waits on
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
   * not be set.
   *
   * @generated from field: temporal.api.update.v1.Outcome outcome = 1;
   */
  outcome?: Outcome;

  /**
   * The most advanced lifecycle stage that the Update is known to have
   * reached, where lifecycle stages are ordered
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
   * UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
   * UNSPECIFIED will be returned if and only if the server's maximum wait
   * time was reached before the Update reached the stage specified in the
   * request WaitPolicy, and before the context deadline expired; clients may
   * may then retry the call as needed.
   *
   * @generated from field: temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 2;
   */
  stage = UpdateWorkflowExecutionLifecycleStage.UNSPECIFIED;

  /**
   * Sufficient information to address this Update.
   *
   * @generated from field: temporal.api.update.v1.UpdateRef update_ref = 3;
   */
  updateRef?: UpdateRef;

  constructor(data?: PartialMessage<PollWorkflowExecutionUpdateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "outcome", kind: "message", T: Outcome },
    { no: 2, name: "stage", kind: "enum", T: proto3.getEnumType(UpdateWorkflowExecutionLifecycleStage) },
    { no: 3, name: "update_ref", kind: "message", T: UpdateRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollWorkflowExecutionUpdateResponse {
    return new PollWorkflowExecutionUpdateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollWorkflowExecutionUpdateResponse {
    return new PollWorkflowExecutionUpdateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollWorkflowExecutionUpdateResponse {
    return new PollWorkflowExecutionUpdateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PollWorkflowExecutionUpdateResponse | PlainMessage<PollWorkflowExecutionUpdateResponse> | undefined, b: PollWorkflowExecutionUpdateResponse | PlainMessage<PollWorkflowExecutionUpdateResponse> | undefined): boolean {
    return proto3.util.equals(PollWorkflowExecutionUpdateResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollNexusTaskQueueRequest
 */
export class PollNexusTaskQueueRequest extends Message<PollNexusTaskQueueRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * Information about this worker's build identifier and if it is choosing to use the versioning
   * feature. See the `WorkerVersionCapabilities` docstring for more.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that user has set in the worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 6;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  /**
   * Worker info to be sent to the server.
   *
   * @generated from field: repeated temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 7;
   */
  workerHeartbeat: WorkerHeartbeat[] = [];

  constructor(data?: PartialMessage<PollNexusTaskQueueRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollNexusTaskQueueRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 4, name: "worker_version_capabilities", kind: "message", T: WorkerVersionCapabilities },
    { no: 6, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
    { no: 7, name: "worker_heartbeat", kind: "message", T: WorkerHeartbeat, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollNexusTaskQueueRequest {
    return new PollNexusTaskQueueRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollNexusTaskQueueRequest {
    return new PollNexusTaskQueueRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollNexusTaskQueueRequest {
    return new PollNexusTaskQueueRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PollNexusTaskQueueRequest | PlainMessage<PollNexusTaskQueueRequest> | undefined, b: PollNexusTaskQueueRequest | PlainMessage<PollNexusTaskQueueRequest> | undefined): boolean {
    return proto3.util.equals(PollNexusTaskQueueRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PollNexusTaskQueueResponse
 */
export class PollNexusTaskQueueResponse extends Message<PollNexusTaskQueueResponse> {
  /**
   * An opaque unique identifier for this task for correlating a completion request the embedded request.
   *
   * @generated from field: bytes task_token = 1;
   */
  taskToken = new Uint8Array(0);

  /**
   * Embedded request as translated from the incoming frontend request.
   *
   * @generated from field: temporal.api.nexus.v1.Request request = 2;
   */
  request?: Request$1;

  /**
   * Server-advised information the SDK may use to adjust its poller count.
   *
   * @generated from field: temporal.api.taskqueue.v1.PollerScalingDecision poller_scaling_decision = 3;
   */
  pollerScalingDecision?: PollerScalingDecision;

  constructor(data?: PartialMessage<PollNexusTaskQueueResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PollNexusTaskQueueResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "request", kind: "message", T: Request$1 },
    { no: 3, name: "poller_scaling_decision", kind: "message", T: PollerScalingDecision },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollNexusTaskQueueResponse {
    return new PollNexusTaskQueueResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollNexusTaskQueueResponse {
    return new PollNexusTaskQueueResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollNexusTaskQueueResponse {
    return new PollNexusTaskQueueResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PollNexusTaskQueueResponse | PlainMessage<PollNexusTaskQueueResponse> | undefined, b: PollNexusTaskQueueResponse | PlainMessage<PollNexusTaskQueueResponse> | undefined): boolean {
    return proto3.util.equals(PollNexusTaskQueueResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskCompletedRequest
 */
export class RespondNexusTaskCompletedRequest extends Message<RespondNexusTaskCompletedRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * A unique identifier for this task as received via a poll response.
   *
   * @generated from field: bytes task_token = 3;
   */
  taskToken = new Uint8Array(0);

  /**
   * Embedded response to be translated into a frontend response.
   *
   * @generated from field: temporal.api.nexus.v1.Response response = 4;
   */
  response?: Response;

  constructor(data?: PartialMessage<RespondNexusTaskCompletedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondNexusTaskCompletedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "response", kind: "message", T: Response },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondNexusTaskCompletedRequest {
    return new RespondNexusTaskCompletedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondNexusTaskCompletedRequest {
    return new RespondNexusTaskCompletedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondNexusTaskCompletedRequest {
    return new RespondNexusTaskCompletedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondNexusTaskCompletedRequest | PlainMessage<RespondNexusTaskCompletedRequest> | undefined, b: RespondNexusTaskCompletedRequest | PlainMessage<RespondNexusTaskCompletedRequest> | undefined): boolean {
    return proto3.util.equals(RespondNexusTaskCompletedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskCompletedResponse
 */
export class RespondNexusTaskCompletedResponse extends Message<RespondNexusTaskCompletedResponse> {
  constructor(data?: PartialMessage<RespondNexusTaskCompletedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondNexusTaskCompletedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondNexusTaskCompletedResponse {
    return new RespondNexusTaskCompletedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondNexusTaskCompletedResponse {
    return new RespondNexusTaskCompletedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondNexusTaskCompletedResponse {
    return new RespondNexusTaskCompletedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondNexusTaskCompletedResponse | PlainMessage<RespondNexusTaskCompletedResponse> | undefined, b: RespondNexusTaskCompletedResponse | PlainMessage<RespondNexusTaskCompletedResponse> | undefined): boolean {
    return proto3.util.equals(RespondNexusTaskCompletedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskFailedRequest
 */
export class RespondNexusTaskFailedRequest extends Message<RespondNexusTaskFailedRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * A unique identifier for this task.
   *
   * @generated from field: bytes task_token = 3;
   */
  taskToken = new Uint8Array(0);

  /**
   * The error the handler failed with.
   *
   * @generated from field: temporal.api.nexus.v1.HandlerError error = 4;
   */
  error?: HandlerError;

  constructor(data?: PartialMessage<RespondNexusTaskFailedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondNexusTaskFailedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "error", kind: "message", T: HandlerError },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondNexusTaskFailedRequest {
    return new RespondNexusTaskFailedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondNexusTaskFailedRequest {
    return new RespondNexusTaskFailedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondNexusTaskFailedRequest {
    return new RespondNexusTaskFailedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondNexusTaskFailedRequest | PlainMessage<RespondNexusTaskFailedRequest> | undefined, b: RespondNexusTaskFailedRequest | PlainMessage<RespondNexusTaskFailedRequest> | undefined): boolean {
    return proto3.util.equals(RespondNexusTaskFailedRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RespondNexusTaskFailedResponse
 */
export class RespondNexusTaskFailedResponse extends Message<RespondNexusTaskFailedResponse> {
  constructor(data?: PartialMessage<RespondNexusTaskFailedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RespondNexusTaskFailedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondNexusTaskFailedResponse {
    return new RespondNexusTaskFailedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondNexusTaskFailedResponse {
    return new RespondNexusTaskFailedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondNexusTaskFailedResponse {
    return new RespondNexusTaskFailedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RespondNexusTaskFailedResponse | PlainMessage<RespondNexusTaskFailedResponse> | undefined, b: RespondNexusTaskFailedResponse | PlainMessage<RespondNexusTaskFailedResponse> | undefined): boolean {
    return proto3.util.equals(RespondNexusTaskFailedResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest
 */
export class ExecuteMultiOperationRequest extends Message<ExecuteMultiOperationRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * List of operations to execute within a single workflow.
   *
   * Preconditions:
   * - The list of operations must not be empty.
   * - The workflow ids must match across operations.
   * - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
   *
   * Note that additional operation-specific restrictions have to be considered.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation operations = 2;
   */
  operations: ExecuteMultiOperationRequest_Operation[] = [];

  constructor(data?: PartialMessage<ExecuteMultiOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ExecuteMultiOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operations", kind: "message", T: ExecuteMultiOperationRequest_Operation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteMultiOperationRequest {
    return new ExecuteMultiOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteMultiOperationRequest {
    return new ExecuteMultiOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteMultiOperationRequest {
    return new ExecuteMultiOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteMultiOperationRequest | PlainMessage<ExecuteMultiOperationRequest> | undefined, b: ExecuteMultiOperationRequest | PlainMessage<ExecuteMultiOperationRequest> | undefined): boolean {
    return proto3.util.equals(ExecuteMultiOperationRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation
 */
export class ExecuteMultiOperationRequest_Operation extends Message<ExecuteMultiOperationRequest_Operation> {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation.operation
   */
  operation: {
    /**
     * Additional restrictions:
     * - setting `cron_schedule` is invalid
     * - setting `request_eager_execution` is invalid
     * - setting `workflow_start_delay` is invalid
     *
     * @generated from field: temporal.api.workflowservice.v1.StartWorkflowExecutionRequest start_workflow = 1;
     */
    value: StartWorkflowExecutionRequest;
    case: "startWorkflow";
  } | {
    /**
     * Additional restrictions:
     * - setting `first_execution_run_id` is invalid
     * - setting `workflow_execution.run_id` is invalid
     *
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest update_workflow = 2;
     */
    value: UpdateWorkflowExecutionRequest;
    case: "updateWorkflow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExecuteMultiOperationRequest_Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ExecuteMultiOperationRequest.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_workflow", kind: "message", T: StartWorkflowExecutionRequest, oneof: "operation" },
    { no: 2, name: "update_workflow", kind: "message", T: UpdateWorkflowExecutionRequest, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteMultiOperationRequest_Operation {
    return new ExecuteMultiOperationRequest_Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteMultiOperationRequest_Operation {
    return new ExecuteMultiOperationRequest_Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteMultiOperationRequest_Operation {
    return new ExecuteMultiOperationRequest_Operation().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteMultiOperationRequest_Operation | PlainMessage<ExecuteMultiOperationRequest_Operation> | undefined, b: ExecuteMultiOperationRequest_Operation | PlainMessage<ExecuteMultiOperationRequest_Operation> | undefined): boolean {
    return proto3.util.equals(ExecuteMultiOperationRequest_Operation, a, b);
  }
}

/**
 * IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination ("Update-with-Start") when both
 *   1. the workflow update for the requested update ID has already completed, and
 *   2. the workflow for the requested workflow ID has already been closed,
 * then you'll receive
 *   - an update response containing the update's outcome, and
 *   - a start response with a `status` field that reflects the workflow's current state.
 *
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse
 */
export class ExecuteMultiOperationResponse extends Message<ExecuteMultiOperationResponse> {
  /**
   * @generated from field: repeated temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response responses = 1;
   */
  responses: ExecuteMultiOperationResponse_Response[] = [];

  constructor(data?: PartialMessage<ExecuteMultiOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ExecuteMultiOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: ExecuteMultiOperationResponse_Response, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteMultiOperationResponse {
    return new ExecuteMultiOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteMultiOperationResponse {
    return new ExecuteMultiOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteMultiOperationResponse {
    return new ExecuteMultiOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteMultiOperationResponse | PlainMessage<ExecuteMultiOperationResponse> | undefined, b: ExecuteMultiOperationResponse | PlainMessage<ExecuteMultiOperationResponse> | undefined): boolean {
    return proto3.util.equals(ExecuteMultiOperationResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response
 */
export class ExecuteMultiOperationResponse_Response extends Message<ExecuteMultiOperationResponse_Response> {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response.response
   */
  response: {
    /**
     * @generated from field: temporal.api.workflowservice.v1.StartWorkflowExecutionResponse start_workflow = 1;
     */
    value: StartWorkflowExecutionResponse;
    case: "startWorkflow";
  } | {
    /**
     * @generated from field: temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse update_workflow = 2;
     */
    value: UpdateWorkflowExecutionResponse;
    case: "updateWorkflow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExecuteMultiOperationResponse_Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ExecuteMultiOperationResponse.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_workflow", kind: "message", T: StartWorkflowExecutionResponse, oneof: "response" },
    { no: 2, name: "update_workflow", kind: "message", T: UpdateWorkflowExecutionResponse, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteMultiOperationResponse_Response {
    return new ExecuteMultiOperationResponse_Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteMultiOperationResponse_Response {
    return new ExecuteMultiOperationResponse_Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteMultiOperationResponse_Response {
    return new ExecuteMultiOperationResponse_Response().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteMultiOperationResponse_Response | PlainMessage<ExecuteMultiOperationResponse_Response> | undefined, b: ExecuteMultiOperationResponse_Response | PlainMessage<ExecuteMultiOperationResponse_Response> | undefined): boolean {
    return proto3.util.equals(ExecuteMultiOperationResponse_Response, a, b);
  }
}

/**
 * NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateActivityOptionsRequest
 */
export class UpdateActivityOptionsRequest extends Message<UpdateActivityOptionsRequest> {
  /**
   * Namespace of the workflow which scheduled this activity
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * Activity options. Partial updates are accepted and controlled by update_mask
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 4;
   */
  activityOptions?: ActivityOptions;

  /**
   * Controls which fields from `activity_options` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;

  /**
   * either activity id, activity type or update_all must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.UpdateActivityOptionsRequest.activity
   */
  activity: {
    /**
     * Only activity with this ID will be updated.
     *
     * @generated from field: string id = 6;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Update all running activities of this type.
     *
     * @generated from field: string type = 7;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Update all running activities.
     *
     * @generated from field: bool match_all = 9;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * If set, the activity options will be restored to the default.
   * Default options are then options activity was created with.
   * They are part of the first SCHEDULE event.
   * This flag cannot be combined with any other option; if you supply
   * restore_original together with other options, the request will be rejected.
   *
   * @generated from field: bool restore_original = 8;
   */
  restoreOriginal = false;

  constructor(data?: PartialMessage<UpdateActivityOptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateActivityOptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "activity_options", kind: "message", T: ActivityOptions },
    { no: 5, name: "update_mask", kind: "message", T: FieldMask },
    { no: 6, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 7, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 9, name: "match_all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "activity" },
    { no: 8, name: "restore_original", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateActivityOptionsRequest {
    return new UpdateActivityOptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateActivityOptionsRequest {
    return new UpdateActivityOptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateActivityOptionsRequest {
    return new UpdateActivityOptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateActivityOptionsRequest | PlainMessage<UpdateActivityOptionsRequest> | undefined, b: UpdateActivityOptionsRequest | PlainMessage<UpdateActivityOptionsRequest> | undefined): boolean {
    return proto3.util.equals(UpdateActivityOptionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateActivityOptionsResponse
 */
export class UpdateActivityOptionsResponse extends Message<UpdateActivityOptionsResponse> {
  /**
   * Activity options after an update
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 1;
   */
  activityOptions?: ActivityOptions;

  constructor(data?: PartialMessage<UpdateActivityOptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateActivityOptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "activity_options", kind: "message", T: ActivityOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateActivityOptionsResponse {
    return new UpdateActivityOptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateActivityOptionsResponse {
    return new UpdateActivityOptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateActivityOptionsResponse {
    return new UpdateActivityOptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateActivityOptionsResponse | PlainMessage<UpdateActivityOptionsResponse> | undefined, b: UpdateActivityOptionsResponse | PlainMessage<UpdateActivityOptionsResponse> | undefined): boolean {
    return proto3.util.equals(UpdateActivityOptionsResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PauseActivityRequest
 */
export class PauseActivityRequest extends Message<PauseActivityRequest> {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * either activity id or activity type must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.PauseActivityRequest.activity
   */
  activity: {
    /**
     * Only the activity with this ID will be paused.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Pause all running activities of this type.
     * Note: Experimental - the behavior of pause by activity type might change in a future release.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Reason to pause the activity.
   *
   * @generated from field: string reason = 6;
   */
  reason = "";

  constructor(data?: PartialMessage<PauseActivityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PauseActivityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 5, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 6, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseActivityRequest {
    return new PauseActivityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseActivityRequest {
    return new PauseActivityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseActivityRequest {
    return new PauseActivityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PauseActivityRequest | PlainMessage<PauseActivityRequest> | undefined, b: PauseActivityRequest | PlainMessage<PauseActivityRequest> | undefined): boolean {
    return proto3.util.equals(PauseActivityRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.PauseActivityResponse
 */
export class PauseActivityResponse extends Message<PauseActivityResponse> {
  constructor(data?: PartialMessage<PauseActivityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.PauseActivityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseActivityResponse {
    return new PauseActivityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseActivityResponse {
    return new PauseActivityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseActivityResponse {
    return new PauseActivityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PauseActivityResponse | PlainMessage<PauseActivityResponse> | undefined, b: PauseActivityResponse | PlainMessage<PauseActivityResponse> | undefined): boolean {
    return proto3.util.equals(PauseActivityResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UnpauseActivityRequest
 */
export class UnpauseActivityRequest extends Message<UnpauseActivityRequest> {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * either activity id or activity type must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.UnpauseActivityRequest.activity
   */
  activity: {
    /**
     * Only the activity with this ID will be unpaused.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Unpause all running activities with of this type.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Unpause all running activities.
     *
     * @generated from field: bool unpause_all = 6;
     */
    value: boolean;
    case: "unpauseAll";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Providing this flag will also reset the number of attempts.
   *
   * @generated from field: bool reset_attempts = 7;
   */
  resetAttempts = false;

  /**
   * Providing this flag will also reset the heartbeat details.
   *
   * @generated from field: bool reset_heartbeat = 8;
   */
  resetHeartbeat = false;

  /**
   * If set, the activity will start at a random time within the specified jitter duration.
   *
   * @generated from field: google.protobuf.Duration jitter = 9;
   */
  jitter?: Duration;

  constructor(data?: PartialMessage<UnpauseActivityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UnpauseActivityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 5, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 6, name: "unpause_all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "activity" },
    { no: 7, name: "reset_attempts", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "reset_heartbeat", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "jitter", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnpauseActivityRequest {
    return new UnpauseActivityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnpauseActivityRequest {
    return new UnpauseActivityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnpauseActivityRequest {
    return new UnpauseActivityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnpauseActivityRequest | PlainMessage<UnpauseActivityRequest> | undefined, b: UnpauseActivityRequest | PlainMessage<UnpauseActivityRequest> | undefined): boolean {
    return proto3.util.equals(UnpauseActivityRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UnpauseActivityResponse
 */
export class UnpauseActivityResponse extends Message<UnpauseActivityResponse> {
  constructor(data?: PartialMessage<UnpauseActivityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UnpauseActivityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnpauseActivityResponse {
    return new UnpauseActivityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnpauseActivityResponse {
    return new UnpauseActivityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnpauseActivityResponse {
    return new UnpauseActivityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnpauseActivityResponse | PlainMessage<UnpauseActivityResponse> | undefined, b: UnpauseActivityResponse | PlainMessage<UnpauseActivityResponse> | undefined): boolean {
    return proto3.util.equals(UnpauseActivityResponse, a, b);
  }
}

/**
 * NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities
 *
 * @generated from message temporal.api.workflowservice.v1.ResetActivityRequest
 */
export class ResetActivityRequest extends Message<ResetActivityRequest> {
  /**
   * Namespace of the workflow which scheduled this activity.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * either activity id, activity type or update_all must be provided
   *
   * @generated from oneof temporal.api.workflowservice.v1.ResetActivityRequest.activity
   */
  activity: {
    /**
     * Only activity with this ID will be reset.
     *
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Reset all running activities with of this type.
     *
     * @generated from field: string type = 5;
     */
    value: string;
    case: "type";
  } | {
    /**
     * Reset all running activities.
     *
     * @generated from field: bool match_all = 10;
     */
    value: boolean;
    case: "matchAll";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Indicates that activity should reset heartbeat details.
   * This flag will be applied only to the new instance of the activity.
   *
   * @generated from field: bool reset_heartbeat = 6;
   */
  resetHeartbeat = false;

  /**
   * If activity is paused, it will remain paused after reset
   *
   * @generated from field: bool keep_paused = 7;
   */
  keepPaused = false;

  /**
   * If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
   * (unless it is paused and keep_paused is set)
   *
   * @generated from field: google.protobuf.Duration jitter = 8;
   */
  jitter?: Duration;

  /**
   * If set, the activity options will be restored to the defaults.
   * Default options are then options activity was created with.
   * They are part of the first SCHEDULE event.
   *
   * @generated from field: bool restore_original_options = 9;
   */
  restoreOriginalOptions = false;

  constructor(data?: PartialMessage<ResetActivityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetActivityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 5, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "activity" },
    { no: 10, name: "match_all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "activity" },
    { no: 6, name: "reset_heartbeat", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "keep_paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "jitter", kind: "message", T: Duration },
    { no: 9, name: "restore_original_options", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetActivityRequest {
    return new ResetActivityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetActivityRequest {
    return new ResetActivityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetActivityRequest {
    return new ResetActivityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResetActivityRequest | PlainMessage<ResetActivityRequest> | undefined, b: ResetActivityRequest | PlainMessage<ResetActivityRequest> | undefined): boolean {
    return proto3.util.equals(ResetActivityRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ResetActivityResponse
 */
export class ResetActivityResponse extends Message<ResetActivityResponse> {
  constructor(data?: PartialMessage<ResetActivityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ResetActivityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetActivityResponse {
    return new ResetActivityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetActivityResponse {
    return new ResetActivityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetActivityResponse {
    return new ResetActivityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ResetActivityResponse | PlainMessage<ResetActivityResponse> | undefined, b: ResetActivityResponse | PlainMessage<ResetActivityResponse> | undefined): boolean {
    return proto3.util.equals(ResetActivityResponse, a, b);
  }
}

/**
 * Keep the parameters in sync with:
 *   - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
 *   - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest
 */
export class UpdateWorkflowExecutionOptionsRequest extends Message<UpdateWorkflowExecutionOptionsRequest> {
  /**
   * The namespace name of the target Workflow.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The target Workflow Id and (optionally) a specific Run Id thereof.
   * (-- api-linter: core::0203::optional=disabled
   *     aip.dev/not-precedent: false positive triggered by the word "optional" --)
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
   */
  workflowExecution?: WorkflowExecution;

  /**
   * Workflow Execution options. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 3;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 4;
   */
  updateMask?: FieldMask;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  constructor(data?: PartialMessage<UpdateWorkflowExecutionOptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_execution", kind: "message", T: WorkflowExecution },
    { no: 3, name: "workflow_execution_options", kind: "message", T: WorkflowExecutionOptions },
    { no: 4, name: "update_mask", kind: "message", T: FieldMask },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkflowExecutionOptionsRequest {
    return new UpdateWorkflowExecutionOptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionOptionsRequest {
    return new UpdateWorkflowExecutionOptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionOptionsRequest {
    return new UpdateWorkflowExecutionOptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkflowExecutionOptionsRequest | PlainMessage<UpdateWorkflowExecutionOptionsRequest> | undefined, b: UpdateWorkflowExecutionOptionsRequest | PlainMessage<UpdateWorkflowExecutionOptionsRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkflowExecutionOptionsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsResponse
 */
export class UpdateWorkflowExecutionOptionsResponse extends Message<UpdateWorkflowExecutionOptionsResponse> {
  /**
   * Workflow Execution options after update.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 1;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  constructor(data?: PartialMessage<UpdateWorkflowExecutionOptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_execution_options", kind: "message", T: WorkflowExecutionOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkflowExecutionOptionsResponse {
    return new UpdateWorkflowExecutionOptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionOptionsResponse {
    return new UpdateWorkflowExecutionOptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkflowExecutionOptionsResponse {
    return new UpdateWorkflowExecutionOptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkflowExecutionOptionsResponse | PlainMessage<UpdateWorkflowExecutionOptionsResponse> | undefined, b: UpdateWorkflowExecutionOptionsResponse | PlainMessage<UpdateWorkflowExecutionOptionsResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkflowExecutionOptionsResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeDeploymentRequest
 */
export class DescribeDeploymentRequest extends Message<DescribeDeploymentRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;

  constructor(data?: PartialMessage<DescribeDeploymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeDeploymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment", kind: "message", T: Deployment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeDeploymentRequest {
    return new DescribeDeploymentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeDeploymentRequest {
    return new DescribeDeploymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeDeploymentRequest {
    return new DescribeDeploymentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeDeploymentRequest | PlainMessage<DescribeDeploymentRequest> | undefined, b: DescribeDeploymentRequest | PlainMessage<DescribeDeploymentRequest> | undefined): boolean {
    return proto3.util.equals(DescribeDeploymentRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeDeploymentResponse
 */
export class DescribeDeploymentResponse extends Message<DescribeDeploymentResponse> {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo deployment_info = 1;
   */
  deploymentInfo?: DeploymentInfo;

  constructor(data?: PartialMessage<DescribeDeploymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeDeploymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment_info", kind: "message", T: DeploymentInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeDeploymentResponse {
    return new DescribeDeploymentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeDeploymentResponse {
    return new DescribeDeploymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeDeploymentResponse {
    return new DescribeDeploymentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeDeploymentResponse | PlainMessage<DescribeDeploymentResponse> | undefined, b: DescribeDeploymentResponse | PlainMessage<DescribeDeploymentResponse> | undefined): boolean {
    return proto3.util.equals(DescribeDeploymentResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionRequest
 */
export class DescribeWorkerDeploymentVersionRequest extends Message<DescribeWorkerDeploymentVersionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 3;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Report stats for task queues which have been polled by this version.
   *
   * @generated from field: bool report_task_queue_stats = 4;
   */
  reportTaskQueueStats = false;

  constructor(data?: PartialMessage<DescribeWorkerDeploymentVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 4, name: "report_task_queue_stats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerDeploymentVersionRequest {
    return new DescribeWorkerDeploymentVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionRequest {
    return new DescribeWorkerDeploymentVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionRequest {
    return new DescribeWorkerDeploymentVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerDeploymentVersionRequest | PlainMessage<DescribeWorkerDeploymentVersionRequest> | undefined, b: DescribeWorkerDeploymentVersionRequest | PlainMessage<DescribeWorkerDeploymentVersionRequest> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerDeploymentVersionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse
 */
export class DescribeWorkerDeploymentVersionResponse extends Message<DescribeWorkerDeploymentVersionResponse> {
  /**
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersionInfo worker_deployment_version_info = 1;
   */
  workerDeploymentVersionInfo?: WorkerDeploymentVersionInfo;

  /**
   * All the Task Queues that have ever polled from this Deployment version.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue version_task_queues = 2;
   */
  versionTaskQueues: DescribeWorkerDeploymentVersionResponse_VersionTaskQueue[] = [];

  constructor(data?: PartialMessage<DescribeWorkerDeploymentVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_deployment_version_info", kind: "message", T: WorkerDeploymentVersionInfo },
    { no: 2, name: "version_task_queues", kind: "message", T: DescribeWorkerDeploymentVersionResponse_VersionTaskQueue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerDeploymentVersionResponse {
    return new DescribeWorkerDeploymentVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionResponse {
    return new DescribeWorkerDeploymentVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionResponse {
    return new DescribeWorkerDeploymentVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerDeploymentVersionResponse | PlainMessage<DescribeWorkerDeploymentVersionResponse> | undefined, b: DescribeWorkerDeploymentVersionResponse | PlainMessage<DescribeWorkerDeploymentVersionResponse> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerDeploymentVersionResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0123::resource-annotation=disabled --)
 *
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue
 */
export class DescribeWorkerDeploymentVersionResponse_VersionTaskQueue extends Message<DescribeWorkerDeploymentVersionResponse_VersionTaskQueue> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType type = 2;
   */
  type = TaskQueueType.UNSPECIFIED;

  /**
   * Only set if `report_task_queue_stats` is set on the request.
   *
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 3;
   */
  stats?: TaskQueueStats;

  /**
   * Task queue stats breakdown by priority key. Only contains actively used priority keys.
   * Only set if `report_task_queue_stats` is set to true in the request.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "by" is used to clarify the key. --)
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueStats> stats_by_priority_key = 4;
   */
  statsByPriorityKey: { [key: number]: TaskQueueStats } = {};

  constructor(data?: PartialMessage<DescribeWorkerDeploymentVersionResponse_VersionTaskQueue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TaskQueueType) },
    { no: 3, name: "stats", kind: "message", T: TaskQueueStats },
    { no: 4, name: "stats_by_priority_key", kind: "map", K: 5 /* ScalarType.INT32 */, V: {kind: "message", T: TaskQueueStats} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerDeploymentVersionResponse_VersionTaskQueue {
    return new DescribeWorkerDeploymentVersionResponse_VersionTaskQueue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionResponse_VersionTaskQueue {
    return new DescribeWorkerDeploymentVersionResponse_VersionTaskQueue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentVersionResponse_VersionTaskQueue {
    return new DescribeWorkerDeploymentVersionResponse_VersionTaskQueue().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerDeploymentVersionResponse_VersionTaskQueue | PlainMessage<DescribeWorkerDeploymentVersionResponse_VersionTaskQueue> | undefined, b: DescribeWorkerDeploymentVersionResponse_VersionTaskQueue | PlainMessage<DescribeWorkerDeploymentVersionResponse_VersionTaskQueue> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerDeploymentVersionResponse_VersionTaskQueue, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentRequest
 */
export class DescribeWorkerDeploymentRequest extends Message<DescribeWorkerDeploymentRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  constructor(data?: PartialMessage<DescribeWorkerDeploymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerDeploymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerDeploymentRequest {
    return new DescribeWorkerDeploymentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentRequest {
    return new DescribeWorkerDeploymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentRequest {
    return new DescribeWorkerDeploymentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerDeploymentRequest | PlainMessage<DescribeWorkerDeploymentRequest> | undefined, b: DescribeWorkerDeploymentRequest | PlainMessage<DescribeWorkerDeploymentRequest> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerDeploymentRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerDeploymentResponse
 */
export class DescribeWorkerDeploymentResponse extends Message<DescribeWorkerDeploymentResponse> {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this read and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken = new Uint8Array(0);

  /**
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo worker_deployment_info = 2;
   */
  workerDeploymentInfo?: WorkerDeploymentInfo;

  constructor(data?: PartialMessage<DescribeWorkerDeploymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerDeploymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "worker_deployment_info", kind: "message", T: WorkerDeploymentInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerDeploymentResponse {
    return new DescribeWorkerDeploymentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentResponse {
    return new DescribeWorkerDeploymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerDeploymentResponse {
    return new DescribeWorkerDeploymentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerDeploymentResponse | PlainMessage<DescribeWorkerDeploymentResponse> | undefined, b: DescribeWorkerDeploymentResponse | PlainMessage<DescribeWorkerDeploymentResponse> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerDeploymentResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.ListDeploymentsRequest
 */
export class ListDeploymentsRequest extends Message<ListDeploymentsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * Optional. Use to filter based on exact series name match.
   *
   * @generated from field: string series_name = 4;
   */
  seriesName = "";

  constructor(data?: PartialMessage<ListDeploymentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListDeploymentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "series_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDeploymentsRequest {
    return new ListDeploymentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDeploymentsRequest {
    return new ListDeploymentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDeploymentsRequest {
    return new ListDeploymentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDeploymentsRequest | PlainMessage<ListDeploymentsRequest> | undefined, b: ListDeploymentsRequest | PlainMessage<ListDeploymentsRequest> | undefined): boolean {
    return proto3.util.equals(ListDeploymentsRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.ListDeploymentsResponse
 */
export class ListDeploymentsResponse extends Message<ListDeploymentsResponse> {
  /**
   * @generated from field: bytes next_page_token = 1;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * @generated from field: repeated temporal.api.deployment.v1.DeploymentListInfo deployments = 2;
   */
  deployments: DeploymentListInfo[] = [];

  constructor(data?: PartialMessage<ListDeploymentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListDeploymentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "deployments", kind: "message", T: DeploymentListInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDeploymentsResponse {
    return new ListDeploymentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDeploymentsResponse {
    return new ListDeploymentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDeploymentsResponse {
    return new ListDeploymentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDeploymentsResponse | PlainMessage<ListDeploymentsResponse> | undefined, b: ListDeploymentsResponse | PlainMessage<ListDeploymentsResponse> | undefined): boolean {
    return proto3.util.equals(ListDeploymentsResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.SetCurrentDeploymentRequest
 */
export class SetCurrentDeploymentRequest extends Message<SetCurrentDeploymentRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  /**
   * Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
   * when describing a deployment. It is a good place for information such as operator name,
   * links to internal deployment pipelines, etc.
   *
   * @generated from field: temporal.api.deployment.v1.UpdateDeploymentMetadata update_metadata = 4;
   */
  updateMetadata?: UpdateDeploymentMetadata;

  constructor(data?: PartialMessage<SetCurrentDeploymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetCurrentDeploymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment", kind: "message", T: Deployment },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "update_metadata", kind: "message", T: UpdateDeploymentMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCurrentDeploymentRequest {
    return new SetCurrentDeploymentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCurrentDeploymentRequest {
    return new SetCurrentDeploymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCurrentDeploymentRequest {
    return new SetCurrentDeploymentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetCurrentDeploymentRequest | PlainMessage<SetCurrentDeploymentRequest> | undefined, b: SetCurrentDeploymentRequest | PlainMessage<SetCurrentDeploymentRequest> | undefined): boolean {
    return proto3.util.equals(SetCurrentDeploymentRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.SetCurrentDeploymentResponse
 */
export class SetCurrentDeploymentResponse extends Message<SetCurrentDeploymentResponse> {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo current_deployment_info = 1;
   */
  currentDeploymentInfo?: DeploymentInfo;

  /**
   * Info of the deployment that was current before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo previous_deployment_info = 2;
   */
  previousDeploymentInfo?: DeploymentInfo;

  constructor(data?: PartialMessage<SetCurrentDeploymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetCurrentDeploymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_deployment_info", kind: "message", T: DeploymentInfo },
    { no: 2, name: "previous_deployment_info", kind: "message", T: DeploymentInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCurrentDeploymentResponse {
    return new SetCurrentDeploymentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCurrentDeploymentResponse {
    return new SetCurrentDeploymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCurrentDeploymentResponse {
    return new SetCurrentDeploymentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetCurrentDeploymentResponse | PlainMessage<SetCurrentDeploymentResponse> | undefined, b: SetCurrentDeploymentResponse | PlainMessage<SetCurrentDeploymentResponse> | undefined): boolean {
    return proto3.util.equals(SetCurrentDeploymentResponse, a, b);
  }
}

/**
 * Set/unset the Current Version of a Worker Deployment.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionRequest
 */
export class SetWorkerDeploymentCurrentVersionRequest extends Message<SetWorkerDeploymentCurrentVersionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  /**
   * Deprecated. Use `build_id`.
   *
   * @generated from field: string version = 3 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The build id of the Version that you want to set as Current.
   * Pass an empty value to set the Current Version to nil.
   * A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   *
   * @generated from field: string build_id = 7;
   */
  buildId = "";

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 4;
   */
  conflictToken = new Uint8Array(0);

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * Optional. By default this request would be rejected if not all the expected Task Queues are
   * being polled by the new Version, to protect against accidental removal of Task Queues, or
   * worker health issues. Pass `true` here to bypass this protection.
   * The set of expected Task Queues is the set of all the Task Queues that were ever poller by
   * the existing Current Version of the Deployment, with the following exclusions:
   *   - Task Queues that are not used anymore (inferred by having empty backlog and a task
   *     add_rate of 0.)
   *   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
   *     having a different Current Version than the Current Version of this deployment.)
   * WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
   * needed. If the request is unexpectedly rejected due to missing pollers, then that means the
   * pollers have not reached to the server yet. Only set this if you expect those pollers to
   * never arrive.
   *
   * @generated from field: bool ignore_missing_task_queues = 6;
   */
  ignoreMissingTaskQueues = false;

  /**
   * Optional. By default this request will be rejected if no pollers have been seen for the proposed
   * Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
   * to possible timeouts. Pass `true` here to bypass this protection.
   *
   * @generated from field: bool allow_no_pollers = 9;
   */
  allowNoPollers = false;

  constructor(data?: PartialMessage<SetWorkerDeploymentCurrentVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ignore_missing_task_queues", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "allow_no_pollers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentCurrentVersionRequest {
    return new SetWorkerDeploymentCurrentVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentCurrentVersionRequest {
    return new SetWorkerDeploymentCurrentVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentCurrentVersionRequest {
    return new SetWorkerDeploymentCurrentVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentCurrentVersionRequest | PlainMessage<SetWorkerDeploymentCurrentVersionRequest> | undefined, b: SetWorkerDeploymentCurrentVersionRequest | PlainMessage<SetWorkerDeploymentCurrentVersionRequest> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentCurrentVersionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionResponse
 */
export class SetWorkerDeploymentCurrentVersionResponse extends Message<SetWorkerDeploymentCurrentVersionResponse> {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken = new Uint8Array(0);

  /**
   * Deprecated. Use `previous_deployment_version`.
   *
   * @generated from field: string previous_version = 2 [deprecated = true];
   * @deprecated
   */
  previousVersion = "";

  /**
   * The version that was current before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion previous_deployment_version = 3;
   */
  previousDeploymentVersion?: WorkerDeploymentVersion;

  constructor(data?: PartialMessage<SetWorkerDeploymentCurrentVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentCurrentVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "previous_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "previous_deployment_version", kind: "message", T: WorkerDeploymentVersion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentCurrentVersionResponse {
    return new SetWorkerDeploymentCurrentVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentCurrentVersionResponse {
    return new SetWorkerDeploymentCurrentVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentCurrentVersionResponse {
    return new SetWorkerDeploymentCurrentVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentCurrentVersionResponse | PlainMessage<SetWorkerDeploymentCurrentVersionResponse> | undefined, b: SetWorkerDeploymentCurrentVersionResponse | PlainMessage<SetWorkerDeploymentCurrentVersionResponse> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentCurrentVersionResponse, a, b);
  }
}

/**
 * Set/unset the Ramping Version of a Worker Deployment and its ramp percentage.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionRequest
 */
export class SetWorkerDeploymentRampingVersionRequest extends Message<SetWorkerDeploymentRampingVersionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  /**
   * Deprecated. Use `build_id`.
   *
   * @generated from field: string version = 3 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The build id of the Version that you want to ramp traffic to.
   * Pass an empty value to set the Ramping Version to nil.
   * A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   *
   * @generated from field: string build_id = 8;
   */
  buildId = "";

  /**
   * Ramp percentage to set. Valid range: [0,100].
   *
   * @generated from field: float percentage = 4;
   */
  percentage = 0;

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken = new Uint8Array(0);

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  /**
   * Optional. By default this request would be rejected if not all the expected Task Queues are
   * being polled by the new Version, to protect against accidental removal of Task Queues, or
   * worker health issues. Pass `true` here to bypass this protection.
   * The set of expected Task Queues equals to all the Task Queues ever polled from the existing
   * Current Version of the Deployment, with the following exclusions:
   *   - Task Queues that are not used anymore (inferred by having empty backlog and a task
   *     add_rate of 0.)
   *   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
   *     having a different Current Version than the Current Version of this deployment.)
   * WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
   * needed. If the request is unexpectedly rejected due to missing pollers, then that means the
   * pollers have not reached to the server yet. Only set this if you expect those pollers to
   * never arrive.
   * Note: this check only happens when the ramping version is about to change, not every time
   * that the percentage changes. Also note that the check is against the deployment's Current
   * Version, not the previous Ramping Version.
   *
   * @generated from field: bool ignore_missing_task_queues = 7;
   */
  ignoreMissingTaskQueues = false;

  /**
   * Optional. By default this request will be rejected if no pollers have been seen for the proposed
   * Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
   * to possible timeouts. Pass `true` here to bypass this protection.
   *
   * @generated from field: bool allow_no_pollers = 10;
   */
  allowNoPollers = false;

  constructor(data?: PartialMessage<SetWorkerDeploymentRampingVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ignore_missing_task_queues", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "allow_no_pollers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentRampingVersionRequest {
    return new SetWorkerDeploymentRampingVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentRampingVersionRequest {
    return new SetWorkerDeploymentRampingVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentRampingVersionRequest {
    return new SetWorkerDeploymentRampingVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentRampingVersionRequest | PlainMessage<SetWorkerDeploymentRampingVersionRequest> | undefined, b: SetWorkerDeploymentRampingVersionRequest | PlainMessage<SetWorkerDeploymentRampingVersionRequest> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentRampingVersionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionResponse
 */
export class SetWorkerDeploymentRampingVersionResponse extends Message<SetWorkerDeploymentRampingVersionResponse> {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken = new Uint8Array(0);

  /**
   * Deprecated. Use `previous_deployment_version`.
   *
   * @generated from field: string previous_version = 2 [deprecated = true];
   * @deprecated
   */
  previousVersion = "";

  /**
   * The version that was ramping before executing this operation.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion previous_deployment_version = 4;
   */
  previousDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * The ramping version percentage before executing this operation.
   *
   * @generated from field: float previous_percentage = 3;
   */
  previousPercentage = 0;

  constructor(data?: PartialMessage<SetWorkerDeploymentRampingVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentRampingVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "previous_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "previous_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 3, name: "previous_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentRampingVersionResponse {
    return new SetWorkerDeploymentRampingVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentRampingVersionResponse {
    return new SetWorkerDeploymentRampingVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentRampingVersionResponse {
    return new SetWorkerDeploymentRampingVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentRampingVersionResponse | PlainMessage<SetWorkerDeploymentRampingVersionResponse> | undefined, b: SetWorkerDeploymentRampingVersionResponse | PlainMessage<SetWorkerDeploymentRampingVersionResponse> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentRampingVersionResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsRequest
 */
export class ListWorkerDeploymentsRequest extends Message<ListWorkerDeploymentsRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListWorkerDeploymentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkerDeploymentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkerDeploymentsRequest {
    return new ListWorkerDeploymentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsRequest {
    return new ListWorkerDeploymentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsRequest {
    return new ListWorkerDeploymentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkerDeploymentsRequest | PlainMessage<ListWorkerDeploymentsRequest> | undefined, b: ListWorkerDeploymentsRequest | PlainMessage<ListWorkerDeploymentsRequest> | undefined): boolean {
    return proto3.util.equals(ListWorkerDeploymentsRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse
 */
export class ListWorkerDeploymentsResponse extends Message<ListWorkerDeploymentsResponse> {
  /**
   * @generated from field: bytes next_page_token = 1;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * The list of worker deployments.
   *
   * @generated from field: repeated temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary worker_deployments = 2;
   */
  workerDeployments: ListWorkerDeploymentsResponse_WorkerDeploymentSummary[] = [];

  constructor(data?: PartialMessage<ListWorkerDeploymentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "worker_deployments", kind: "message", T: ListWorkerDeploymentsResponse_WorkerDeploymentSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkerDeploymentsResponse {
    return new ListWorkerDeploymentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsResponse {
    return new ListWorkerDeploymentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsResponse {
    return new ListWorkerDeploymentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkerDeploymentsResponse | PlainMessage<ListWorkerDeploymentsResponse> | undefined, b: ListWorkerDeploymentsResponse | PlainMessage<ListWorkerDeploymentsResponse> | undefined): boolean {
    return proto3.util.equals(ListWorkerDeploymentsResponse, a, b);
  }
}

/**
 * (-- api-linter: core::0123::resource-annotation=disabled --)
 * A subset of WorkerDeploymentInfo
 *
 * @generated from message temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary
 */
export class ListWorkerDeploymentsResponse_WorkerDeploymentSummary extends Message<ListWorkerDeploymentsResponse_WorkerDeploymentSummary> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: temporal.api.deployment.v1.RoutingConfig routing_config = 3;
   */
  routingConfig?: RoutingConfig;

  /**
   * Summary of the version that was added most recently in the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary latest_version_summary = 4;
   */
  latestVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;

  /**
   * Summary of the current version of the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary current_version_summary = 5;
   */
  currentVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;

  /**
   * Summary of the ramping version of the Worker Deployment.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary ramping_version_summary = 6;
   */
  rampingVersionSummary?: WorkerDeploymentInfo_WorkerDeploymentVersionSummary;

  constructor(data?: PartialMessage<ListWorkerDeploymentsResponse_WorkerDeploymentSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
    { no: 3, name: "routing_config", kind: "message", T: RoutingConfig },
    { no: 4, name: "latest_version_summary", kind: "message", T: WorkerDeploymentInfo_WorkerDeploymentVersionSummary },
    { no: 5, name: "current_version_summary", kind: "message", T: WorkerDeploymentInfo_WorkerDeploymentVersionSummary },
    { no: 6, name: "ramping_version_summary", kind: "message", T: WorkerDeploymentInfo_WorkerDeploymentVersionSummary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkerDeploymentsResponse_WorkerDeploymentSummary {
    return new ListWorkerDeploymentsResponse_WorkerDeploymentSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsResponse_WorkerDeploymentSummary {
    return new ListWorkerDeploymentsResponse_WorkerDeploymentSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkerDeploymentsResponse_WorkerDeploymentSummary {
    return new ListWorkerDeploymentsResponse_WorkerDeploymentSummary().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkerDeploymentsResponse_WorkerDeploymentSummary | PlainMessage<ListWorkerDeploymentsResponse_WorkerDeploymentSummary> | undefined, b: ListWorkerDeploymentsResponse_WorkerDeploymentSummary | PlainMessage<ListWorkerDeploymentsResponse_WorkerDeploymentSummary> | undefined): boolean {
    return proto3.util.equals(ListWorkerDeploymentsResponse_WorkerDeploymentSummary, a, b);
  }
}

/**
 * Used for manual deletion of Versions. User can delete a Version only when all the
 * following conditions are met:
 *  - It is not the Current or Ramping Version of its Deployment.
 *  - It has no active pollers (none of the task queues in the Version have pollers)
 *  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
 *    can be skipped by passing `skip-drainage=true`.
 *
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionRequest
 */
export class DeleteWorkerDeploymentVersionRequest extends Message<DeleteWorkerDeploymentVersionRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 5;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Pass to force deletion even if the Version is draining. In this case the open pinned
   * workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
   *
   * @generated from field: bool skip_drainage = 3;
   */
  skipDrainage = false;

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 4;
   */
  identity = "";

  constructor(data?: PartialMessage<DeleteWorkerDeploymentVersionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 3, name: "skip_drainage", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkerDeploymentVersionRequest {
    return new DeleteWorkerDeploymentVersionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentVersionRequest {
    return new DeleteWorkerDeploymentVersionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentVersionRequest {
    return new DeleteWorkerDeploymentVersionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkerDeploymentVersionRequest | PlainMessage<DeleteWorkerDeploymentVersionRequest> | undefined, b: DeleteWorkerDeploymentVersionRequest | PlainMessage<DeleteWorkerDeploymentVersionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWorkerDeploymentVersionRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionResponse
 */
export class DeleteWorkerDeploymentVersionResponse extends Message<DeleteWorkerDeploymentVersionResponse> {
  constructor(data?: PartialMessage<DeleteWorkerDeploymentVersionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkerDeploymentVersionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkerDeploymentVersionResponse {
    return new DeleteWorkerDeploymentVersionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentVersionResponse {
    return new DeleteWorkerDeploymentVersionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentVersionResponse {
    return new DeleteWorkerDeploymentVersionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkerDeploymentVersionResponse | PlainMessage<DeleteWorkerDeploymentVersionResponse> | undefined, b: DeleteWorkerDeploymentVersionResponse | PlainMessage<DeleteWorkerDeploymentVersionResponse> | undefined): boolean {
    return proto3.util.equals(DeleteWorkerDeploymentVersionResponse, a, b);
  }
}

/**
 * Deletes records of (an old) Deployment. A deployment can only be deleted if
 * it has no Version in it.
 *
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentRequest
 */
export class DeleteWorkerDeploymentRequest extends Message<DeleteWorkerDeploymentRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  constructor(data?: PartialMessage<DeleteWorkerDeploymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkerDeploymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkerDeploymentRequest {
    return new DeleteWorkerDeploymentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentRequest {
    return new DeleteWorkerDeploymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentRequest {
    return new DeleteWorkerDeploymentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkerDeploymentRequest | PlainMessage<DeleteWorkerDeploymentRequest> | undefined, b: DeleteWorkerDeploymentRequest | PlainMessage<DeleteWorkerDeploymentRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWorkerDeploymentRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkerDeploymentResponse
 */
export class DeleteWorkerDeploymentResponse extends Message<DeleteWorkerDeploymentResponse> {
  constructor(data?: PartialMessage<DeleteWorkerDeploymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkerDeploymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkerDeploymentResponse {
    return new DeleteWorkerDeploymentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentResponse {
    return new DeleteWorkerDeploymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkerDeploymentResponse {
    return new DeleteWorkerDeploymentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkerDeploymentResponse | PlainMessage<DeleteWorkerDeploymentResponse> | undefined, b: DeleteWorkerDeploymentResponse | PlainMessage<DeleteWorkerDeploymentResponse> | undefined): boolean {
    return proto3.util.equals(DeleteWorkerDeploymentResponse, a, b);
  }
}

/**
 * Used to update the user-defined metadata of a Worker Deployment Version.
 *
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataRequest
 */
export class UpdateWorkerDeploymentVersionMetadataRequest extends Message<UpdateWorkerDeploymentVersionMetadataRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 5;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> upsert_entries = 3;
   */
  upsertEntries: { [key: string]: Payload } = {};

  /**
   * List of keys to remove from the metadata.
   *
   * @generated from field: repeated string remove_entries = 4;
   */
  removeEntries: string[] = [];

  /**
   * Optional. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  constructor(data?: PartialMessage<UpdateWorkerDeploymentVersionMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 3, name: "upsert_entries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
    { no: 4, name: "remove_entries", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerDeploymentVersionMetadataRequest {
    return new UpdateWorkerDeploymentVersionMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerDeploymentVersionMetadataRequest {
    return new UpdateWorkerDeploymentVersionMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerDeploymentVersionMetadataRequest {
    return new UpdateWorkerDeploymentVersionMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerDeploymentVersionMetadataRequest | PlainMessage<UpdateWorkerDeploymentVersionMetadataRequest> | undefined, b: UpdateWorkerDeploymentVersionMetadataRequest | PlainMessage<UpdateWorkerDeploymentVersionMetadataRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerDeploymentVersionMetadataRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataResponse
 */
export class UpdateWorkerDeploymentVersionMetadataResponse extends Message<UpdateWorkerDeploymentVersionMetadataResponse> {
  /**
   * Full metadata after performing the update.
   *
   * @generated from field: temporal.api.deployment.v1.VersionMetadata metadata = 1;
   */
  metadata?: VersionMetadata;

  constructor(data?: PartialMessage<UpdateWorkerDeploymentVersionMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerDeploymentVersionMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: VersionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerDeploymentVersionMetadataResponse {
    return new UpdateWorkerDeploymentVersionMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerDeploymentVersionMetadataResponse {
    return new UpdateWorkerDeploymentVersionMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerDeploymentVersionMetadataResponse {
    return new UpdateWorkerDeploymentVersionMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerDeploymentVersionMetadataResponse | PlainMessage<UpdateWorkerDeploymentVersionMetadataResponse> | undefined, b: UpdateWorkerDeploymentVersionMetadataResponse | PlainMessage<UpdateWorkerDeploymentVersionMetadataResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerDeploymentVersionMetadataResponse, a, b);
  }
}

/**
 * Update the ManagerIdentity of a Worker Deployment.
 *
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest
 */
export class SetWorkerDeploymentManagerRequest extends Message<SetWorkerDeploymentManagerRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  /**
   * @generated from oneof temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest.new_manager_identity
   */
  newManagerIdentity: {
    /**
     * Arbitrary value for `manager_identity`.
     * Empty will unset the field.
     *
     * @generated from field: string manager_identity = 3;
     */
    value: string;
    case: "managerIdentity";
  } | {
    /**
     * True will set `manager_identity` to `identity`.
     *
     * @generated from field: bool self = 4;
     */
    value: boolean;
    case: "self";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Optional. This can be the value of conflict_token from a Describe, or another Worker
   * Deployment API. Passing a non-nil conflict token will cause this request to fail if the
   * Deployment's configuration has been modified between the API call that generated the
   * token and this one.
   *
   * @generated from field: bytes conflict_token = 5;
   */
  conflictToken = new Uint8Array(0);

  /**
   * Required. The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 6;
   */
  identity = "";

  constructor(data?: PartialMessage<SetWorkerDeploymentManagerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentManagerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "manager_identity", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "new_manager_identity" },
    { no: 4, name: "self", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "new_manager_identity" },
    { no: 5, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentManagerRequest {
    return new SetWorkerDeploymentManagerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentManagerRequest {
    return new SetWorkerDeploymentManagerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentManagerRequest {
    return new SetWorkerDeploymentManagerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentManagerRequest | PlainMessage<SetWorkerDeploymentManagerRequest> | undefined, b: SetWorkerDeploymentManagerRequest | PlainMessage<SetWorkerDeploymentManagerRequest> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentManagerRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.SetWorkerDeploymentManagerResponse
 */
export class SetWorkerDeploymentManagerResponse extends Message<SetWorkerDeploymentManagerResponse> {
  /**
   * This value is returned so that it can be optionally passed to APIs
   * that write to the Worker Deployment state to ensure that the state
   * did not change between this API call and a future write.
   *
   * @generated from field: bytes conflict_token = 1;
   */
  conflictToken = new Uint8Array(0);

  /**
   * What the `manager_identity` field was before this change.
   *
   * @generated from field: string previous_manager_identity = 2;
   */
  previousManagerIdentity = "";

  constructor(data?: PartialMessage<SetWorkerDeploymentManagerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.SetWorkerDeploymentManagerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conflict_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "previous_manager_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetWorkerDeploymentManagerResponse {
    return new SetWorkerDeploymentManagerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetWorkerDeploymentManagerResponse {
    return new SetWorkerDeploymentManagerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetWorkerDeploymentManagerResponse {
    return new SetWorkerDeploymentManagerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetWorkerDeploymentManagerResponse | PlainMessage<SetWorkerDeploymentManagerResponse> | undefined, b: SetWorkerDeploymentManagerResponse | PlainMessage<SetWorkerDeploymentManagerResponse> | undefined): boolean {
    return proto3.util.equals(SetWorkerDeploymentManagerResponse, a, b);
  }
}

/**
 * Returns the Current Deployment of a deployment series.
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetCurrentDeploymentRequest
 */
export class GetCurrentDeploymentRequest extends Message<GetCurrentDeploymentRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string series_name = 2;
   */
  seriesName = "";

  constructor(data?: PartialMessage<GetCurrentDeploymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetCurrentDeploymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "series_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCurrentDeploymentRequest {
    return new GetCurrentDeploymentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCurrentDeploymentRequest {
    return new GetCurrentDeploymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCurrentDeploymentRequest {
    return new GetCurrentDeploymentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCurrentDeploymentRequest | PlainMessage<GetCurrentDeploymentRequest> | undefined, b: GetCurrentDeploymentRequest | PlainMessage<GetCurrentDeploymentRequest> | undefined): boolean {
    return proto3.util.equals(GetCurrentDeploymentRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetCurrentDeploymentResponse
 */
export class GetCurrentDeploymentResponse extends Message<GetCurrentDeploymentResponse> {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo current_deployment_info = 1;
   */
  currentDeploymentInfo?: DeploymentInfo;

  constructor(data?: PartialMessage<GetCurrentDeploymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetCurrentDeploymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_deployment_info", kind: "message", T: DeploymentInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCurrentDeploymentResponse {
    return new GetCurrentDeploymentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCurrentDeploymentResponse {
    return new GetCurrentDeploymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCurrentDeploymentResponse {
    return new GetCurrentDeploymentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCurrentDeploymentResponse | PlainMessage<GetCurrentDeploymentResponse> | undefined, b: GetCurrentDeploymentResponse | PlainMessage<GetCurrentDeploymentResponse> | undefined): boolean {
    return proto3.util.equals(GetCurrentDeploymentResponse, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetDeploymentReachabilityRequest
 */
export class GetDeploymentReachabilityRequest extends Message<GetDeploymentReachabilityRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2;
   */
  deployment?: Deployment;

  constructor(data?: PartialMessage<GetDeploymentReachabilityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetDeploymentReachabilityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment", kind: "message", T: Deployment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDeploymentReachabilityRequest {
    return new GetDeploymentReachabilityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDeploymentReachabilityRequest {
    return new GetDeploymentReachabilityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDeploymentReachabilityRequest {
    return new GetDeploymentReachabilityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDeploymentReachabilityRequest | PlainMessage<GetDeploymentReachabilityRequest> | undefined, b: GetDeploymentReachabilityRequest | PlainMessage<GetDeploymentReachabilityRequest> | undefined): boolean {
    return proto3.util.equals(GetDeploymentReachabilityRequest, a, b);
  }
}

/**
 * [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
 *
 * @generated from message temporal.api.workflowservice.v1.GetDeploymentReachabilityResponse
 */
export class GetDeploymentReachabilityResponse extends Message<GetDeploymentReachabilityResponse> {
  /**
   * @generated from field: temporal.api.deployment.v1.DeploymentInfo deployment_info = 1;
   */
  deploymentInfo?: DeploymentInfo;

  /**
   * @generated from field: temporal.api.enums.v1.DeploymentReachability reachability = 2;
   */
  reachability = DeploymentReachability.UNSPECIFIED;

  /**
   * Reachability level might come from server cache. This timestamp specifies when the value
   * was actually calculated.
   *
   * @generated from field: google.protobuf.Timestamp last_update_time = 3;
   */
  lastUpdateTime?: Timestamp;

  constructor(data?: PartialMessage<GetDeploymentReachabilityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.GetDeploymentReachabilityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment_info", kind: "message", T: DeploymentInfo },
    { no: 2, name: "reachability", kind: "enum", T: proto3.getEnumType(DeploymentReachability) },
    { no: 3, name: "last_update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDeploymentReachabilityResponse {
    return new GetDeploymentReachabilityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDeploymentReachabilityResponse {
    return new GetDeploymentReachabilityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDeploymentReachabilityResponse {
    return new GetDeploymentReachabilityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDeploymentReachabilityResponse | PlainMessage<GetDeploymentReachabilityResponse> | undefined, b: GetDeploymentReachabilityResponse | PlainMessage<GetDeploymentReachabilityResponse> | undefined): boolean {
    return proto3.util.equals(GetDeploymentReachabilityResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CreateWorkflowRuleRequest
 */
export class CreateWorkflowRuleRequest extends Message<CreateWorkflowRuleRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The rule specification .
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 2;
   */
  spec?: WorkflowRuleSpec;

  /**
   * If true, the rule will be applied to the currently running workflows via batch job.
   * If not set , the rule will only be applied when triggering condition is satisfied.
   * visibility_query in the rule will be used to select the workflows to apply the rule to.
   *
   * @generated from field: bool force_scan = 3;
   */
  forceScan = false;

  /**
   * Used to de-dupe requests. Typically should be UUID.
   *
   * @generated from field: string request_id = 4;
   */
  requestId = "";

  /**
   * Identity of the actor who created the rule. Will be stored with the rule.
   *
   * @generated from field: string identity = 5;
   */
  identity = "";

  /**
   * Rule description.Will be stored with the rule.
   *
   * @generated from field: string description = 6;
   */
  description = "";

  constructor(data?: PartialMessage<CreateWorkflowRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CreateWorkflowRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spec", kind: "message", T: WorkflowRuleSpec },
    { no: 3, name: "force_scan", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateWorkflowRuleRequest {
    return new CreateWorkflowRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateWorkflowRuleRequest {
    return new CreateWorkflowRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateWorkflowRuleRequest {
    return new CreateWorkflowRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateWorkflowRuleRequest | PlainMessage<CreateWorkflowRuleRequest> | undefined, b: CreateWorkflowRuleRequest | PlainMessage<CreateWorkflowRuleRequest> | undefined): boolean {
    return proto3.util.equals(CreateWorkflowRuleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.CreateWorkflowRuleResponse
 */
export class CreateWorkflowRuleResponse extends Message<CreateWorkflowRuleResponse> {
  /**
   * Created rule.
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRule rule = 1;
   */
  rule?: WorkflowRule;

  /**
   * Batch Job ID if force-scan flag was provided. Otherwise empty.
   *
   * @generated from field: string job_id = 2;
   */
  jobId = "";

  constructor(data?: PartialMessage<CreateWorkflowRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.CreateWorkflowRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: WorkflowRule },
    { no: 2, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateWorkflowRuleResponse {
    return new CreateWorkflowRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateWorkflowRuleResponse {
    return new CreateWorkflowRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateWorkflowRuleResponse {
    return new CreateWorkflowRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateWorkflowRuleResponse | PlainMessage<CreateWorkflowRuleResponse> | undefined, b: CreateWorkflowRuleResponse | PlainMessage<CreateWorkflowRuleResponse> | undefined): boolean {
    return proto3.util.equals(CreateWorkflowRuleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowRuleRequest
 */
export class DescribeWorkflowRuleRequest extends Message<DescribeWorkflowRuleRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * User-specified ID of the rule to read. Unique within the namespace.
   *
   * @generated from field: string rule_id = 2;
   */
  ruleId = "";

  constructor(data?: PartialMessage<DescribeWorkflowRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkflowRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkflowRuleRequest {
    return new DescribeWorkflowRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkflowRuleRequest {
    return new DescribeWorkflowRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkflowRuleRequest {
    return new DescribeWorkflowRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkflowRuleRequest | PlainMessage<DescribeWorkflowRuleRequest> | undefined, b: DescribeWorkflowRuleRequest | PlainMessage<DescribeWorkflowRuleRequest> | undefined): boolean {
    return proto3.util.equals(DescribeWorkflowRuleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkflowRuleResponse
 */
export class DescribeWorkflowRuleResponse extends Message<DescribeWorkflowRuleResponse> {
  /**
   * The rule that was read.
   *
   * @generated from field: temporal.api.rules.v1.WorkflowRule rule = 1;
   */
  rule?: WorkflowRule;

  constructor(data?: PartialMessage<DescribeWorkflowRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkflowRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: WorkflowRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkflowRuleResponse {
    return new DescribeWorkflowRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkflowRuleResponse {
    return new DescribeWorkflowRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkflowRuleResponse {
    return new DescribeWorkflowRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkflowRuleResponse | PlainMessage<DescribeWorkflowRuleResponse> | undefined, b: DescribeWorkflowRuleResponse | PlainMessage<DescribeWorkflowRuleResponse> | undefined): boolean {
    return proto3.util.equals(DescribeWorkflowRuleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowRuleRequest
 */
export class DeleteWorkflowRuleRequest extends Message<DeleteWorkflowRuleRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * ID of the rule to delete. Unique within the namespace.
   *
   * @generated from field: string rule_id = 2;
   */
  ruleId = "";

  constructor(data?: PartialMessage<DeleteWorkflowRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkflowRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkflowRuleRequest {
    return new DeleteWorkflowRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkflowRuleRequest {
    return new DeleteWorkflowRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkflowRuleRequest {
    return new DeleteWorkflowRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkflowRuleRequest | PlainMessage<DeleteWorkflowRuleRequest> | undefined, b: DeleteWorkflowRuleRequest | PlainMessage<DeleteWorkflowRuleRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWorkflowRuleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DeleteWorkflowRuleResponse
 */
export class DeleteWorkflowRuleResponse extends Message<DeleteWorkflowRuleResponse> {
  constructor(data?: PartialMessage<DeleteWorkflowRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DeleteWorkflowRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWorkflowRuleResponse {
    return new DeleteWorkflowRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWorkflowRuleResponse {
    return new DeleteWorkflowRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWorkflowRuleResponse {
    return new DeleteWorkflowRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWorkflowRuleResponse | PlainMessage<DeleteWorkflowRuleResponse> | undefined, b: DeleteWorkflowRuleResponse | PlainMessage<DeleteWorkflowRuleResponse> | undefined): boolean {
    return proto3.util.equals(DeleteWorkflowRuleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowRulesRequest
 */
export class ListWorkflowRulesRequest extends Message<ListWorkflowRulesRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListWorkflowRulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkflowRulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkflowRulesRequest {
    return new ListWorkflowRulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkflowRulesRequest {
    return new ListWorkflowRulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkflowRulesRequest {
    return new ListWorkflowRulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkflowRulesRequest | PlainMessage<ListWorkflowRulesRequest> | undefined, b: ListWorkflowRulesRequest | PlainMessage<ListWorkflowRulesRequest> | undefined): boolean {
    return proto3.util.equals(ListWorkflowRulesRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkflowRulesResponse
 */
export class ListWorkflowRulesResponse extends Message<ListWorkflowRulesResponse> {
  /**
   * @generated from field: repeated temporal.api.rules.v1.WorkflowRule rules = 1;
   */
  rules: WorkflowRule[] = [];

  /**
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListWorkflowRulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkflowRulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: WorkflowRule, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkflowRulesResponse {
    return new ListWorkflowRulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkflowRulesResponse {
    return new ListWorkflowRulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkflowRulesResponse {
    return new ListWorkflowRulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkflowRulesResponse | PlainMessage<ListWorkflowRulesResponse> | undefined, b: ListWorkflowRulesResponse | PlainMessage<ListWorkflowRulesResponse> | undefined): boolean {
    return proto3.util.equals(ListWorkflowRulesResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest
 */
export class TriggerWorkflowRuleRequest extends Message<TriggerWorkflowRuleRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Execution info of the workflow which scheduled this activity
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 2;
   */
  execution?: WorkflowExecution;

  /**
   * Either provide id of existing rule, or rule specification
   *
   * @generated from oneof temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest.rule
   */
  rule: {
    /**
     * @generated from field: string id = 4;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Note: Rule ID and expiration date are not used in the trigger request.
     *
     * @generated from field: temporal.api.rules.v1.WorkflowRuleSpec spec = 5;
     */
    value: WorkflowRuleSpec;
    case: "spec";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The identity of the client who initiated this request
   *
   * @generated from field: string identity = 3;
   */
  identity = "";

  constructor(data?: PartialMessage<TriggerWorkflowRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.TriggerWorkflowRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "rule" },
    { no: 5, name: "spec", kind: "message", T: WorkflowRuleSpec, oneof: "rule" },
    { no: 3, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerWorkflowRuleRequest {
    return new TriggerWorkflowRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerWorkflowRuleRequest {
    return new TriggerWorkflowRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerWorkflowRuleRequest {
    return new TriggerWorkflowRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerWorkflowRuleRequest | PlainMessage<TriggerWorkflowRuleRequest> | undefined, b: TriggerWorkflowRuleRequest | PlainMessage<TriggerWorkflowRuleRequest> | undefined): boolean {
    return proto3.util.equals(TriggerWorkflowRuleRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.TriggerWorkflowRuleResponse
 */
export class TriggerWorkflowRuleResponse extends Message<TriggerWorkflowRuleResponse> {
  /**
   * True is the rule was applied, based on the rule conditions (predicate/visibility_query).
   *
   * @generated from field: bool applied = 1;
   */
  applied = false;

  constructor(data?: PartialMessage<TriggerWorkflowRuleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.TriggerWorkflowRuleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerWorkflowRuleResponse {
    return new TriggerWorkflowRuleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerWorkflowRuleResponse {
    return new TriggerWorkflowRuleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerWorkflowRuleResponse {
    return new TriggerWorkflowRuleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerWorkflowRuleResponse | PlainMessage<TriggerWorkflowRuleResponse> | undefined, b: TriggerWorkflowRuleResponse | PlainMessage<TriggerWorkflowRuleResponse> | undefined): boolean {
    return proto3.util.equals(TriggerWorkflowRuleResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordWorkerHeartbeatRequest
 */
export class RecordWorkerHeartbeatRequest extends Message<RecordWorkerHeartbeatRequest> {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * @generated from field: repeated temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 3;
   */
  workerHeartbeat: WorkerHeartbeat[] = [];

  constructor(data?: PartialMessage<RecordWorkerHeartbeatRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordWorkerHeartbeatRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "worker_heartbeat", kind: "message", T: WorkerHeartbeat, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordWorkerHeartbeatRequest {
    return new RecordWorkerHeartbeatRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordWorkerHeartbeatRequest {
    return new RecordWorkerHeartbeatRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordWorkerHeartbeatRequest {
    return new RecordWorkerHeartbeatRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RecordWorkerHeartbeatRequest | PlainMessage<RecordWorkerHeartbeatRequest> | undefined, b: RecordWorkerHeartbeatRequest | PlainMessage<RecordWorkerHeartbeatRequest> | undefined): boolean {
    return proto3.util.equals(RecordWorkerHeartbeatRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.RecordWorkerHeartbeatResponse
 */
export class RecordWorkerHeartbeatResponse extends Message<RecordWorkerHeartbeatResponse> {
  constructor(data?: PartialMessage<RecordWorkerHeartbeatResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.RecordWorkerHeartbeatResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordWorkerHeartbeatResponse {
    return new RecordWorkerHeartbeatResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordWorkerHeartbeatResponse {
    return new RecordWorkerHeartbeatResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordWorkerHeartbeatResponse {
    return new RecordWorkerHeartbeatResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RecordWorkerHeartbeatResponse | PlainMessage<RecordWorkerHeartbeatResponse> | undefined, b: RecordWorkerHeartbeatResponse | PlainMessage<RecordWorkerHeartbeatResponse> | undefined): boolean {
    return proto3.util.equals(RecordWorkerHeartbeatResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkersRequest
 */
export class ListWorkersRequest extends Message<ListWorkersRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: bytes next_page_token = 3;
   */
  nextPageToken = new Uint8Array(0);

  /**
   * `query` in ListWorkers is used to filter workers based on worker status info.
   * The following worker status attributes are expected are supported as part of the query:
   * * WorkerInstanceKey
   * * WorkerIdentity
   * * HostName
   * * TaskQueue
   * * DeploymentName
   * * BuildId
   * * SdkName
   * * SdkVersion
   * * StartTime
   * * LastHeartbeatTime
   * * Status
   * Currently metrics are not supported as a part of ListWorkers query.
   *
   * @generated from field: string query = 4;
   */
  query = "";

  constructor(data?: PartialMessage<ListWorkersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkersRequest {
    return new ListWorkersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkersRequest {
    return new ListWorkersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkersRequest {
    return new ListWorkersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkersRequest | PlainMessage<ListWorkersRequest> | undefined, b: ListWorkersRequest | PlainMessage<ListWorkersRequest> | undefined): boolean {
    return proto3.util.equals(ListWorkersRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.ListWorkersResponse
 */
export class ListWorkersResponse extends Message<ListWorkersResponse> {
  /**
   * @generated from field: repeated temporal.api.worker.v1.WorkerInfo workers_info = 1;
   */
  workersInfo: WorkerInfo[] = [];

  /**
   * Next page token
   *
   * @generated from field: bytes next_page_token = 2;
   */
  nextPageToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ListWorkersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.ListWorkersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workers_info", kind: "message", T: WorkerInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWorkersResponse {
    return new ListWorkersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWorkersResponse {
    return new ListWorkersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWorkersResponse {
    return new ListWorkersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWorkersResponse | PlainMessage<ListWorkersResponse> | undefined, b: ListWorkersResponse | PlainMessage<ListWorkersResponse> | undefined): boolean {
    return proto3.util.equals(ListWorkersResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest
 */
export class UpdateTaskQueueConfigRequest extends Message<UpdateTaskQueueConfigRequest> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * Selects the task queue to update.
   *
   * @generated from field: string task_queue = 3;
   */
  taskQueue = "";

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType task_queue_type = 4;
   */
  taskQueueType = TaskQueueType.UNSPECIFIED;

  /**
   * Update to queue-wide rate limit.
   * If not set, this configuration is unchanged.
   * NOTE: A limit set by the worker is overriden; and restored again when reset.
   * If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
   *
   * @generated from field: temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate update_queue_rate_limit = 5;
   */
  updateQueueRateLimit?: UpdateTaskQueueConfigRequest_RateLimitUpdate;

  /**
   * Update to the default fairness key rate limit.
   * If not set, this configuration is unchanged.
   * If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
   *
   * @generated from field: temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate update_fairness_key_rate_limit_default = 6;
   */
  updateFairnessKeyRateLimitDefault?: UpdateTaskQueueConfigRequest_RateLimitUpdate;

  /**
   * If set, overrides the fairness weight for each specified fairness key.
   * Fairness keys not listed in this map will keep their existing overrides (if any).
   *
   * @generated from field: map<string, float> set_fairness_weight_overrides = 7;
   */
  setFairnessWeightOverrides: { [key: string]: number } = {};

  /**
   * If set, removes any existing fairness weight overrides for each specified fairness key.
   * Fairness weights for corresponding keys fall back to the values set during task creation (if any),
   * or to the default weight of 1.0.
   *
   * @generated from field: repeated string unset_fairness_weight_overrides = 8;
   */
  unsetFairnessWeightOverrides: string[] = [];

  constructor(data?: PartialMessage<UpdateTaskQueueConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "task_queue_type", kind: "enum", T: proto3.getEnumType(TaskQueueType) },
    { no: 5, name: "update_queue_rate_limit", kind: "message", T: UpdateTaskQueueConfigRequest_RateLimitUpdate },
    { no: 6, name: "update_fairness_key_rate_limit_default", kind: "message", T: UpdateTaskQueueConfigRequest_RateLimitUpdate },
    { no: 7, name: "set_fairness_weight_overrides", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 2 /* ScalarType.FLOAT */} },
    { no: 8, name: "unset_fairness_weight_overrides", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTaskQueueConfigRequest {
    return new UpdateTaskQueueConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigRequest {
    return new UpdateTaskQueueConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigRequest {
    return new UpdateTaskQueueConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTaskQueueConfigRequest | PlainMessage<UpdateTaskQueueConfigRequest> | undefined, b: UpdateTaskQueueConfigRequest | PlainMessage<UpdateTaskQueueConfigRequest> | undefined): boolean {
    return proto3.util.equals(UpdateTaskQueueConfigRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate
 */
export class UpdateTaskQueueConfigRequest_RateLimitUpdate extends Message<UpdateTaskQueueConfigRequest_RateLimitUpdate> {
  /**
   * Rate Limit to be updated
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimit rate_limit = 1;
   */
  rateLimit?: RateLimit;

  /**
   * Reason for why the rate limit was set.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<UpdateTaskQueueConfigRequest_RateLimitUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateTaskQueueConfigRequest.RateLimitUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rate_limit", kind: "message", T: RateLimit },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTaskQueueConfigRequest_RateLimitUpdate {
    return new UpdateTaskQueueConfigRequest_RateLimitUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigRequest_RateLimitUpdate {
    return new UpdateTaskQueueConfigRequest_RateLimitUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigRequest_RateLimitUpdate {
    return new UpdateTaskQueueConfigRequest_RateLimitUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTaskQueueConfigRequest_RateLimitUpdate | PlainMessage<UpdateTaskQueueConfigRequest_RateLimitUpdate> | undefined, b: UpdateTaskQueueConfigRequest_RateLimitUpdate | PlainMessage<UpdateTaskQueueConfigRequest_RateLimitUpdate> | undefined): boolean {
    return proto3.util.equals(UpdateTaskQueueConfigRequest_RateLimitUpdate, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateTaskQueueConfigResponse
 */
export class UpdateTaskQueueConfigResponse extends Message<UpdateTaskQueueConfigResponse> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueConfig config = 1;
   */
  config?: TaskQueueConfig;

  constructor(data?: PartialMessage<UpdateTaskQueueConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateTaskQueueConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: TaskQueueConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTaskQueueConfigResponse {
    return new UpdateTaskQueueConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigResponse {
    return new UpdateTaskQueueConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTaskQueueConfigResponse {
    return new UpdateTaskQueueConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTaskQueueConfigResponse | PlainMessage<UpdateTaskQueueConfigResponse> | undefined, b: UpdateTaskQueueConfigResponse | PlainMessage<UpdateTaskQueueConfigResponse> | undefined): boolean {
    return proto3.util.equals(UpdateTaskQueueConfigResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.FetchWorkerConfigRequest
 */
export class FetchWorkerConfigRequest extends Message<FetchWorkerConfigRequest> {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * Reason for sending worker command, can be used for audit purpose.
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * Defines which workers should receive this command.
   * only single worker is supported at this time.
   *
   * @generated from field: temporal.api.common.v1.WorkerSelector selector = 6;
   */
  selector?: WorkerSelector;

  constructor(data?: PartialMessage<FetchWorkerConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.FetchWorkerConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "selector", kind: "message", T: WorkerSelector },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchWorkerConfigRequest {
    return new FetchWorkerConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchWorkerConfigRequest {
    return new FetchWorkerConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchWorkerConfigRequest {
    return new FetchWorkerConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FetchWorkerConfigRequest | PlainMessage<FetchWorkerConfigRequest> | undefined, b: FetchWorkerConfigRequest | PlainMessage<FetchWorkerConfigRequest> | undefined): boolean {
    return proto3.util.equals(FetchWorkerConfigRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.FetchWorkerConfigResponse
 */
export class FetchWorkerConfigResponse extends Message<FetchWorkerConfigResponse> {
  /**
   * The worker configuration.
   *
   * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 1;
   */
  workerConfig?: WorkerConfig;

  constructor(data?: PartialMessage<FetchWorkerConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.FetchWorkerConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_config", kind: "message", T: WorkerConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchWorkerConfigResponse {
    return new FetchWorkerConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchWorkerConfigResponse {
    return new FetchWorkerConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchWorkerConfigResponse {
    return new FetchWorkerConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FetchWorkerConfigResponse | PlainMessage<FetchWorkerConfigResponse> | undefined, b: FetchWorkerConfigResponse | PlainMessage<FetchWorkerConfigResponse> | undefined): boolean {
    return proto3.util.equals(FetchWorkerConfigResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerConfigRequest
 */
export class UpdateWorkerConfigRequest extends Message<UpdateWorkerConfigRequest> {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * The identity of the client who initiated this request.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * Reason for sending worker command, can be used for audit purpose.
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * Partial updates are accepted and controlled by update_mask.
   * The worker configuration to set.
   *
   * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 4;
   */
  workerConfig?: WorkerConfig;

  /**
   * Controls which fields from `worker_config` will be applied
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 5;
   */
  updateMask?: FieldMask;

  /**
   * Defines which workers should receive this command.
   *
   * @generated from field: temporal.api.common.v1.WorkerSelector selector = 6;
   */
  selector?: WorkerSelector;

  constructor(data?: PartialMessage<UpdateWorkerConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "worker_config", kind: "message", T: WorkerConfig },
    { no: 5, name: "update_mask", kind: "message", T: FieldMask },
    { no: 6, name: "selector", kind: "message", T: WorkerSelector },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerConfigRequest {
    return new UpdateWorkerConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerConfigRequest {
    return new UpdateWorkerConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerConfigRequest {
    return new UpdateWorkerConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerConfigRequest | PlainMessage<UpdateWorkerConfigRequest> | undefined, b: UpdateWorkerConfigRequest | PlainMessage<UpdateWorkerConfigRequest> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerConfigRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.UpdateWorkerConfigResponse
 */
export class UpdateWorkerConfigResponse extends Message<UpdateWorkerConfigResponse> {
  /**
   * @generated from oneof temporal.api.workflowservice.v1.UpdateWorkerConfigResponse.response
   */
  response: {
    /**
     * The worker configuration. Will be returned if the command was sent to a single worker.
     *
     * @generated from field: temporal.api.sdk.v1.WorkerConfig worker_config = 1;
     */
    value: WorkerConfig;
    case: "workerConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpdateWorkerConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.UpdateWorkerConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_config", kind: "message", T: WorkerConfig, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateWorkerConfigResponse {
    return new UpdateWorkerConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateWorkerConfigResponse {
    return new UpdateWorkerConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateWorkerConfigResponse {
    return new UpdateWorkerConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateWorkerConfigResponse | PlainMessage<UpdateWorkerConfigResponse> | undefined, b: UpdateWorkerConfigResponse | PlainMessage<UpdateWorkerConfigResponse> | undefined): boolean {
    return proto3.util.equals(UpdateWorkerConfigResponse, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerRequest
 */
export class DescribeWorkerRequest extends Message<DescribeWorkerRequest> {
  /**
   * Namespace this worker belongs to.
   *
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * Worker instance key to describe.
   *
   * @generated from field: string worker_instance_key = 2;
   */
  workerInstanceKey = "";

  constructor(data?: PartialMessage<DescribeWorkerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "worker_instance_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerRequest {
    return new DescribeWorkerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerRequest {
    return new DescribeWorkerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerRequest {
    return new DescribeWorkerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerRequest | PlainMessage<DescribeWorkerRequest> | undefined, b: DescribeWorkerRequest | PlainMessage<DescribeWorkerRequest> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.workflowservice.v1.DescribeWorkerResponse
 */
export class DescribeWorkerResponse extends Message<DescribeWorkerResponse> {
  /**
   * @generated from field: temporal.api.worker.v1.WorkerInfo worker_info = 1;
   */
  workerInfo?: WorkerInfo;

  constructor(data?: PartialMessage<DescribeWorkerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflowservice.v1.DescribeWorkerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_info", kind: "message", T: WorkerInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DescribeWorkerResponse {
    return new DescribeWorkerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DescribeWorkerResponse {
    return new DescribeWorkerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DescribeWorkerResponse {
    return new DescribeWorkerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DescribeWorkerResponse | PlainMessage<DescribeWorkerResponse> | undefined, b: DescribeWorkerResponse | PlainMessage<DescribeWorkerResponse> | undefined): boolean {
    return proto3.util.equals(DescribeWorkerResponse, a, b);
  }
}

