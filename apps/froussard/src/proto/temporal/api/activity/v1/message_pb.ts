// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/activity/v1/message.proto (package temporal.api.activity.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";
import { TaskQueue } from "../../taskqueue/v1/message_pbts";
import { RetryPolicy } from "../../common/v1/message_pbts";

/**
 * @generated from message temporal.api.activity.v1.ActivityOptions
 */
export class ActivityOptions extends Message<ActivityOptions> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
   */
  taskQueue?: TaskQueue;

  /**
   * Indicates how long the caller is willing to wait for an activity completion. Limits how long
   * retries will be attempted. Either this or `start_to_close_timeout` must be specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 2;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * Limits time an activity task can stay in a task queue before a worker picks it up. This
   * timeout is always non retryable, as all a retry would achieve is to put it back into the same
   * queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
   * specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 3;
   */
  scheduleToStartTimeout?: Duration;

  /**
   * Maximum time an activity is allowed to execute after being picked up by a worker. This
   * timeout is always retryable. Either this or `schedule_to_close_timeout` must be
   * specified.
   *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration start_to_close_timeout = 4;
   */
  startToCloseTimeout?: Duration;

  /**
   * Maximum permitted time between successful worker heartbeats.
   *
   * @generated from field: google.protobuf.Duration heartbeat_timeout = 5;
   */
  heartbeatTimeout?: Duration;

  /**
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 6;
   */
  retryPolicy?: RetryPolicy;

  constructor(data?: PartialMessage<ActivityOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.activity.v1.ActivityOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 2, name: "schedule_to_close_timeout", kind: "message", T: Duration },
    { no: 3, name: "schedule_to_start_timeout", kind: "message", T: Duration },
    { no: 4, name: "start_to_close_timeout", kind: "message", T: Duration },
    { no: 5, name: "heartbeat_timeout", kind: "message", T: Duration },
    { no: 6, name: "retry_policy", kind: "message", T: RetryPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivityOptions {
    return new ActivityOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivityOptions {
    return new ActivityOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivityOptions {
    return new ActivityOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ActivityOptions | PlainMessage<ActivityOptions> | undefined, b: ActivityOptions | PlainMessage<ActivityOptions> | undefined): boolean {
    return proto3.util.equals(ActivityOptions, a, b);
  }
}

