// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/deployment/v1/message.proto (package temporal.api.deployment.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { VersionDrainageStatus, WorkerDeploymentVersionStatus, WorkerVersioningMode } from "../../enums/v1/deployment_pbts";
import { Payload } from "../../common/v1/message_pbts";
import { RoutingConfigUpdateState, TaskQueueType } from "../../enums/v1/task_queue_pbts";

/**
 * Worker Deployment options set in SDK that need to be sent to server in every poll.
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentOptions
 */
export class WorkerDeploymentOptions extends Message<WorkerDeploymentOptions> {
  /**
   * Required. Worker Deployment name.
   *
   * @generated from field: string deployment_name = 1;
   */
  deploymentName = "";

  /**
   * The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,
   * the worker will be part of a Deployment Version.
   *
   * @generated from field: string build_id = 2;
   */
  buildId = "";

  /**
   * Required. Versioning Mode for this worker. Must be the same for all workers with the
   * same `deployment_name` and `build_id` combination, across all Task Queues.
   * When `worker_versioning_mode==VERSIONED`, the worker will be part of a Deployment Version.
   *
   * @generated from field: temporal.api.enums.v1.WorkerVersioningMode worker_versioning_mode = 3;
   */
  workerVersioningMode = WorkerVersioningMode.UNSPECIFIED;

  constructor(data?: PartialMessage<WorkerDeploymentOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "worker_versioning_mode", kind: "enum", T: proto3.getEnumType(WorkerVersioningMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentOptions {
    return new WorkerDeploymentOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentOptions {
    return new WorkerDeploymentOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentOptions {
    return new WorkerDeploymentOptions().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentOptions | PlainMessage<WorkerDeploymentOptions> | undefined, b: WorkerDeploymentOptions | PlainMessage<WorkerDeploymentOptions> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentOptions, a, b);
  }
}

/**
 * `Deployment` identifies a deployment of Temporal workers. The combination of deployment series
 * name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker
 * programs to specify these values.
 * Deprecated.
 *
 * @generated from message temporal.api.deployment.v1.Deployment
 */
export class Deployment extends Message<Deployment> {
  /**
   * Different versions of the same worker service/application are related together by having a
   * shared series name.
   * Out of all deployments of a series, one can be designated as the current deployment, which
   * receives new workflow executions and new tasks of workflows with
   * `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.
   *
   * @generated from field: string series_name = 1;
   */
  seriesName = "";

  /**
   * Build ID changes with each version of the worker when the worker program code and/or config
   * changes.
   *
   * @generated from field: string build_id = 2;
   */
  buildId = "";

  constructor(data?: PartialMessage<Deployment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.Deployment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "series_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Deployment {
    return new Deployment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Deployment {
    return new Deployment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Deployment {
    return new Deployment().fromJsonString(jsonString, options);
  }

  static equals(a: Deployment | PlainMessage<Deployment> | undefined, b: Deployment | PlainMessage<Deployment> | undefined): boolean {
    return proto3.util.equals(Deployment, a, b);
  }
}

/**
 * `DeploymentInfo` holds information about a deployment. Deployment information is tracked
 * automatically by server as soon as the first poll from that deployment reaches the server. There
 * can be multiple task queue workers in a single deployment which are listed in this message.
 * Deprecated.
 *
 * @generated from message temporal.api.deployment.v1.DeploymentInfo
 */
export class DeploymentInfo extends Message<DeploymentInfo> {
  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 1;
   */
  deployment?: Deployment;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: repeated temporal.api.deployment.v1.DeploymentInfo.TaskQueueInfo task_queue_infos = 3;
   */
  taskQueueInfos: DeploymentInfo_TaskQueueInfo[] = [];

  /**
   * A user-defined set of key-values. Can be updated as part of write operations to the
   * deployment, such as `SetCurrentDeployment`.
   *
   * @generated from field: map<string, temporal.api.common.v1.Payload> metadata = 4;
   */
  metadata: { [key: string]: Payload } = {};

  /**
   * If this deployment is the current deployment of its deployment series.
   *
   * @generated from field: bool is_current = 5;
   */
  isCurrent = false;

  constructor(data?: PartialMessage<DeploymentInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.DeploymentInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment", kind: "message", T: Deployment },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
    { no: 3, name: "task_queue_infos", kind: "message", T: DeploymentInfo_TaskQueueInfo, repeated: true },
    { no: 4, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
    { no: 5, name: "is_current", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeploymentInfo {
    return new DeploymentInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeploymentInfo {
    return new DeploymentInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeploymentInfo {
    return new DeploymentInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DeploymentInfo | PlainMessage<DeploymentInfo> | undefined, b: DeploymentInfo | PlainMessage<DeploymentInfo> | undefined): boolean {
    return proto3.util.equals(DeploymentInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.deployment.v1.DeploymentInfo.TaskQueueInfo
 */
export class DeploymentInfo_TaskQueueInfo extends Message<DeploymentInfo_TaskQueueInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType type = 2;
   */
  type = TaskQueueType.UNSPECIFIED;

  /**
   * When server saw the first poller for this task queue in this deployment.
   *
   * @generated from field: google.protobuf.Timestamp first_poller_time = 3;
   */
  firstPollerTime?: Timestamp;

  constructor(data?: PartialMessage<DeploymentInfo_TaskQueueInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.DeploymentInfo.TaskQueueInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TaskQueueType) },
    { no: 3, name: "first_poller_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeploymentInfo_TaskQueueInfo {
    return new DeploymentInfo_TaskQueueInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeploymentInfo_TaskQueueInfo {
    return new DeploymentInfo_TaskQueueInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeploymentInfo_TaskQueueInfo {
    return new DeploymentInfo_TaskQueueInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DeploymentInfo_TaskQueueInfo | PlainMessage<DeploymentInfo_TaskQueueInfo> | undefined, b: DeploymentInfo_TaskQueueInfo | PlainMessage<DeploymentInfo_TaskQueueInfo> | undefined): boolean {
    return proto3.util.equals(DeploymentInfo_TaskQueueInfo, a, b);
  }
}

/**
 * Used as part of Deployment write APIs to update metadata attached to a deployment.
 * Deprecated.
 *
 * @generated from message temporal.api.deployment.v1.UpdateDeploymentMetadata
 */
export class UpdateDeploymentMetadata extends Message<UpdateDeploymentMetadata> {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> upsert_entries = 1;
   */
  upsertEntries: { [key: string]: Payload } = {};

  /**
   * List of keys to remove from the metadata.
   *
   * @generated from field: repeated string remove_entries = 2;
   */
  removeEntries: string[] = [];

  constructor(data?: PartialMessage<UpdateDeploymentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.UpdateDeploymentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "upsert_entries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
    { no: 2, name: "remove_entries", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDeploymentMetadata {
    return new UpdateDeploymentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDeploymentMetadata {
    return new UpdateDeploymentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDeploymentMetadata {
    return new UpdateDeploymentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDeploymentMetadata | PlainMessage<UpdateDeploymentMetadata> | undefined, b: UpdateDeploymentMetadata | PlainMessage<UpdateDeploymentMetadata> | undefined): boolean {
    return proto3.util.equals(UpdateDeploymentMetadata, a, b);
  }
}

/**
 * DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in
 * ListDeployments.
 * Deprecated.
 *
 * @generated from message temporal.api.deployment.v1.DeploymentListInfo
 */
export class DeploymentListInfo extends Message<DeploymentListInfo> {
  /**
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 1;
   */
  deployment?: Deployment;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * If this deployment is the current deployment of its deployment series.
   *
   * @generated from field: bool is_current = 3;
   */
  isCurrent = false;

  constructor(data?: PartialMessage<DeploymentListInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.DeploymentListInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment", kind: "message", T: Deployment },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
    { no: 3, name: "is_current", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeploymentListInfo {
    return new DeploymentListInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeploymentListInfo {
    return new DeploymentListInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeploymentListInfo {
    return new DeploymentListInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DeploymentListInfo | PlainMessage<DeploymentListInfo> | undefined, b: DeploymentListInfo | PlainMessage<DeploymentListInfo> | undefined): boolean {
    return proto3.util.equals(DeploymentListInfo, a, b);
  }
}

/**
 * A Worker Deployment Version (Version, for short) represents all workers of the same 
 * code and config within a Deployment. Workers of the same Version are expected to 
 * behave exactly the same so when executions move between them there are no 
 * non-determinism issues.
 * Worker Deployment Versions are created in Temporal server automatically when 
 * their first poller arrives to the server.
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentVersionInfo
 */
export class WorkerDeploymentVersionInfo extends Message<WorkerDeploymentVersionInfo> {
  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 1 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The status of the Worker Deployment Version.
   *
   * @generated from field: temporal.api.enums.v1.WorkerDeploymentVersionStatus status = 14;
   */
  status = WorkerDeploymentVersionStatus.UNSPECIFIED;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 11;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
   *
   * @generated from field: google.protobuf.Timestamp routing_changed_time = 4;
   */
  routingChangedTime?: Timestamp;

  /**
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
   * Unset if not current.
   *
   * @generated from field: google.protobuf.Timestamp current_since_time = 5;
   */
  currentSinceTime?: Timestamp;

  /**
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
   * Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
   *
   * @generated from field: google.protobuf.Timestamp ramping_since_time = 6;
   */
  rampingSinceTime?: Timestamp;

  /**
   * Timestamp when this version first became current or ramping.
   *
   * @generated from field: google.protobuf.Timestamp first_activation_time = 12;
   */
  firstActivationTime?: Timestamp;

  /**
   * Timestamp when this version last stopped being current or ramping.
   *
   * @generated from field: google.protobuf.Timestamp last_deactivation_time = 13;
   */
  lastDeactivationTime?: Timestamp;

  /**
   * Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).
   * Can be in the range [0, 100] if the version is ramping.
   *
   * @generated from field: float ramp_percentage = 7;
   */
  rampPercentage = 0;

  /**
   * All the Task Queues that have ever polled from this Deployment version.
   * Deprecated. Use `version_task_queues` in DescribeWorkerDeploymentVersionResponse instead.
   *
   * @generated from field: repeated temporal.api.deployment.v1.WorkerDeploymentVersionInfo.VersionTaskQueueInfo task_queue_infos = 8;
   */
  taskQueueInfos: WorkerDeploymentVersionInfo_VersionTaskQueueInfo[] = [];

  /**
   * Helps user determine when it is safe to decommission the workers of this
   * Version. Not present when version is current or ramping.
   * Current limitations:
   * - Not supported for Unversioned mode.
   * - Periodically refreshed, may have delays up to few minutes (consult the
   *   last_checked_time value).
   * - Refreshed only when version is not current or ramping AND the status is not
   *   "drained" yet.
   * - Once the status is changed to "drained", it is not changed until the Version
   *   becomes Current or Ramping again, at which time the drainage info is cleared.
   *   This means if the Version is "drained" but new workflows are sent to it via
   *   Pinned Versioning Override, the status does not account for those Pinned-override
   *   executions and remains "drained".
   *
   * @generated from field: temporal.api.deployment.v1.VersionDrainageInfo drainage_info = 9;
   */
  drainageInfo?: VersionDrainageInfo;

  /**
   * Arbitrary user-provided metadata attached to this version.
   *
   * @generated from field: temporal.api.deployment.v1.VersionMetadata metadata = 10;
   */
  metadata?: VersionMetadata;

  constructor(data?: PartialMessage<WorkerDeploymentVersionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentVersionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(WorkerDeploymentVersionStatus) },
    { no: 11, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "create_time", kind: "message", T: Timestamp },
    { no: 4, name: "routing_changed_time", kind: "message", T: Timestamp },
    { no: 5, name: "current_since_time", kind: "message", T: Timestamp },
    { no: 6, name: "ramping_since_time", kind: "message", T: Timestamp },
    { no: 12, name: "first_activation_time", kind: "message", T: Timestamp },
    { no: 13, name: "last_deactivation_time", kind: "message", T: Timestamp },
    { no: 7, name: "ramp_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "task_queue_infos", kind: "message", T: WorkerDeploymentVersionInfo_VersionTaskQueueInfo, repeated: true },
    { no: 9, name: "drainage_info", kind: "message", T: VersionDrainageInfo },
    { no: 10, name: "metadata", kind: "message", T: VersionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentVersionInfo {
    return new WorkerDeploymentVersionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentVersionInfo {
    return new WorkerDeploymentVersionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentVersionInfo {
    return new WorkerDeploymentVersionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentVersionInfo | PlainMessage<WorkerDeploymentVersionInfo> | undefined, b: WorkerDeploymentVersionInfo | PlainMessage<WorkerDeploymentVersionInfo> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentVersionInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentVersionInfo.VersionTaskQueueInfo
 */
export class WorkerDeploymentVersionInfo_VersionTaskQueueInfo extends Message<WorkerDeploymentVersionInfo_VersionTaskQueueInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: temporal.api.enums.v1.TaskQueueType type = 2;
   */
  type = TaskQueueType.UNSPECIFIED;

  constructor(data?: PartialMessage<WorkerDeploymentVersionInfo_VersionTaskQueueInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentVersionInfo.VersionTaskQueueInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TaskQueueType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentVersionInfo_VersionTaskQueueInfo {
    return new WorkerDeploymentVersionInfo_VersionTaskQueueInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentVersionInfo_VersionTaskQueueInfo {
    return new WorkerDeploymentVersionInfo_VersionTaskQueueInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentVersionInfo_VersionTaskQueueInfo {
    return new WorkerDeploymentVersionInfo_VersionTaskQueueInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentVersionInfo_VersionTaskQueueInfo | PlainMessage<WorkerDeploymentVersionInfo_VersionTaskQueueInfo> | undefined, b: WorkerDeploymentVersionInfo_VersionTaskQueueInfo | PlainMessage<WorkerDeploymentVersionInfo_VersionTaskQueueInfo> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentVersionInfo_VersionTaskQueueInfo, a, b);
  }
}

/**
 * Information about workflow drainage to help the user determine when it is safe
 * to decommission a Version. Not present while version is current or ramping.
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.deployment.v1.VersionDrainageInfo
 */
export class VersionDrainageInfo extends Message<VersionDrainageInfo> {
  /**
   * Set to DRAINING when the version first stops accepting new executions (is no longer current or ramping).
   * Set to DRAINED when no more open pinned workflows exist on this version.
   *
   * @generated from field: temporal.api.enums.v1.VersionDrainageStatus status = 1;
   */
  status = VersionDrainageStatus.UNSPECIFIED;

  /**
   * Last time the drainage status changed.
   *
   * @generated from field: google.protobuf.Timestamp last_changed_time = 2;
   */
  lastChangedTime?: Timestamp;

  /**
   * Last time the system checked for drainage of this version.
   *
   * @generated from field: google.protobuf.Timestamp last_checked_time = 3;
   */
  lastCheckedTime?: Timestamp;

  constructor(data?: PartialMessage<VersionDrainageInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.VersionDrainageInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(VersionDrainageStatus) },
    { no: 2, name: "last_changed_time", kind: "message", T: Timestamp },
    { no: 3, name: "last_checked_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersionDrainageInfo {
    return new VersionDrainageInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersionDrainageInfo {
    return new VersionDrainageInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersionDrainageInfo {
    return new VersionDrainageInfo().fromJsonString(jsonString, options);
  }

  static equals(a: VersionDrainageInfo | PlainMessage<VersionDrainageInfo> | undefined, b: VersionDrainageInfo | PlainMessage<VersionDrainageInfo> | undefined): boolean {
    return proto3.util.equals(VersionDrainageInfo, a, b);
  }
}

/**
 * A Worker Deployment (Deployment, for short) represents all workers serving 
 * a shared set of Task Queues. Typically, a Deployment represents one service or 
 * application.
 * A Deployment contains multiple Deployment Versions, each representing a different 
 * version of workers. (see documentation of WorkerDeploymentVersionInfo)
 * Deployment records are created in Temporal server automatically when their
 * first poller arrives to the server.
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentInfo
 */
export class WorkerDeploymentInfo extends Message<WorkerDeploymentInfo> {
  /**
   * Identifies a Worker Deployment. Must be unique within the namespace.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be
   * cleaned up automatically if all the following conditions meet:
   * - It does not receive new executions (is not current or ramping)
   * - It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status) 
   * - It is drained (see WorkerDeploymentVersionInfo.drainage_status) 
   *
   * @generated from field: repeated temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary version_summaries = 2;
   */
  versionSummaries: WorkerDeploymentInfo_WorkerDeploymentVersionSummary[] = [];

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: temporal.api.deployment.v1.RoutingConfig routing_config = 4;
   */
  routingConfig?: RoutingConfig;

  /**
   * Identity of the last client who modified the configuration of this Deployment. Set to the
   * `identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and
   * `SetWorkerDeploymentRampingVersion`.
   *
   * @generated from field: string last_modifier_identity = 5;
   */
  lastModifierIdentity = "";

  /**
   * Identity of the client that has the exclusive right to make changes to this Worker Deployment.
   * Empty by default.
   * If this is set, clients whose identity does not match `manager_identity` will not be able to make changes
   * to this Worker Deployment. They can either set their own identity as the manager or unset the field to proceed.
   *
   * @generated from field: string manager_identity = 6;
   */
  managerIdentity = "";

  /**
   * Indicates whether the routing_config has been fully propagated to all
   * relevant task queues and their partitions.
   *
   * @generated from field: temporal.api.enums.v1.RoutingConfigUpdateState routing_config_update_state = 7;
   */
  routingConfigUpdateState = RoutingConfigUpdateState.UNSPECIFIED;

  constructor(data?: PartialMessage<WorkerDeploymentInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version_summaries", kind: "message", T: WorkerDeploymentInfo_WorkerDeploymentVersionSummary, repeated: true },
    { no: 3, name: "create_time", kind: "message", T: Timestamp },
    { no: 4, name: "routing_config", kind: "message", T: RoutingConfig },
    { no: 5, name: "last_modifier_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "manager_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "routing_config_update_state", kind: "enum", T: proto3.getEnumType(RoutingConfigUpdateState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentInfo {
    return new WorkerDeploymentInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentInfo {
    return new WorkerDeploymentInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentInfo {
    return new WorkerDeploymentInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentInfo | PlainMessage<WorkerDeploymentInfo> | undefined, b: WorkerDeploymentInfo | PlainMessage<WorkerDeploymentInfo> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary
 */
export class WorkerDeploymentInfo_WorkerDeploymentVersionSummary extends Message<WorkerDeploymentInfo_WorkerDeploymentVersionSummary> {
  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 1 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The status of the Worker Deployment Version.
   *
   * @generated from field: temporal.api.enums.v1.WorkerDeploymentVersionStatus status = 11;
   */
  status = WorkerDeploymentVersionStatus.UNSPECIFIED;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 4;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * Deprecated. Use `drainage_info` instead.
   *
   * @generated from field: temporal.api.enums.v1.VersionDrainageStatus drainage_status = 3;
   */
  drainageStatus = VersionDrainageStatus.UNSPECIFIED;

  /**
   * Information about workflow drainage to help the user determine when it is safe
   * to decommission a Version. Not present while version is current or ramping
   *
   * @generated from field: temporal.api.deployment.v1.VersionDrainageInfo drainage_info = 5;
   */
  drainageInfo?: VersionDrainageInfo;

  /**
   * Unset if not current.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
   *
   * @generated from field: google.protobuf.Timestamp current_since_time = 6;
   */
  currentSinceTime?: Timestamp;

  /**
   * Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
   *
   * @generated from field: google.protobuf.Timestamp ramping_since_time = 7;
   */
  rampingSinceTime?: Timestamp;

  /**
   * Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
   *
   * @generated from field: google.protobuf.Timestamp routing_update_time = 8;
   */
  routingUpdateTime?: Timestamp;

  /**
   * Timestamp when this version first became current or ramping.
   *
   * @generated from field: google.protobuf.Timestamp first_activation_time = 9;
   */
  firstActivationTime?: Timestamp;

  /**
   * Timestamp when this version last stopped being current or ramping.
   *
   * @generated from field: google.protobuf.Timestamp last_deactivation_time = 10;
   */
  lastDeactivationTime?: Timestamp;

  constructor(data?: PartialMessage<WorkerDeploymentInfo_WorkerDeploymentVersionSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "status", kind: "enum", T: proto3.getEnumType(WorkerDeploymentVersionStatus) },
    { no: 4, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
    { no: 3, name: "drainage_status", kind: "enum", T: proto3.getEnumType(VersionDrainageStatus) },
    { no: 5, name: "drainage_info", kind: "message", T: VersionDrainageInfo },
    { no: 6, name: "current_since_time", kind: "message", T: Timestamp },
    { no: 7, name: "ramping_since_time", kind: "message", T: Timestamp },
    { no: 8, name: "routing_update_time", kind: "message", T: Timestamp },
    { no: 9, name: "first_activation_time", kind: "message", T: Timestamp },
    { no: 10, name: "last_deactivation_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentInfo_WorkerDeploymentVersionSummary {
    return new WorkerDeploymentInfo_WorkerDeploymentVersionSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentInfo_WorkerDeploymentVersionSummary {
    return new WorkerDeploymentInfo_WorkerDeploymentVersionSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentInfo_WorkerDeploymentVersionSummary {
    return new WorkerDeploymentInfo_WorkerDeploymentVersionSummary().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentInfo_WorkerDeploymentVersionSummary | PlainMessage<WorkerDeploymentInfo_WorkerDeploymentVersionSummary> | undefined, b: WorkerDeploymentInfo_WorkerDeploymentVersionSummary | PlainMessage<WorkerDeploymentInfo_WorkerDeploymentVersionSummary> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentInfo_WorkerDeploymentVersionSummary, a, b);
  }
}

/**
 * A Worker Deployment Version (Version, for short) represents a
 * version of workers within a Worker Deployment. (see documentation of WorkerDeploymentVersionInfo)
 * Version records are created in Temporal server automatically when their
 * first poller arrives to the server.
 * Experimental. Worker Deployment Versions are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.deployment.v1.WorkerDeploymentVersion
 */
export class WorkerDeploymentVersion extends Message<WorkerDeploymentVersion> {
  /**
   * A unique identifier for this Version within the Deployment it is a part of.
   * Not necessarily unique within the namespace.
   * The combination of `deployment_name` and `build_id` uniquely identifies this
   * Version within the namespace, because Deployment names are unique within a namespace.
   *
   * @generated from field: string build_id = 1;
   */
  buildId = "";

  /**
   * Identifies the Worker Deployment this Version is part of.
   *
   * @generated from field: string deployment_name = 2;
   */
  deploymentName = "";

  constructor(data?: PartialMessage<WorkerDeploymentVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.WorkerDeploymentVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerDeploymentVersion {
    return new WorkerDeploymentVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerDeploymentVersion {
    return new WorkerDeploymentVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerDeploymentVersion {
    return new WorkerDeploymentVersion().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerDeploymentVersion | PlainMessage<WorkerDeploymentVersion> | undefined, b: WorkerDeploymentVersion | PlainMessage<WorkerDeploymentVersion> | undefined): boolean {
    return proto3.util.equals(WorkerDeploymentVersion, a, b);
  }
}

/**
 * @generated from message temporal.api.deployment.v1.VersionMetadata
 */
export class VersionMetadata extends Message<VersionMetadata> {
  /**
   * Arbitrary key-values.
   *
   * @generated from field: map<string, temporal.api.common.v1.Payload> entries = 1;
   */
  entries: { [key: string]: Payload } = {};

  constructor(data?: PartialMessage<VersionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.VersionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersionMetadata {
    return new VersionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersionMetadata {
    return new VersionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersionMetadata {
    return new VersionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: VersionMetadata | PlainMessage<VersionMetadata> | undefined, b: VersionMetadata | PlainMessage<VersionMetadata> | undefined): boolean {
    return proto3.util.equals(VersionMetadata, a, b);
  }
}

/**
 * @generated from message temporal.api.deployment.v1.RoutingConfig
 */
export class RoutingConfig extends Message<RoutingConfig> {
  /**
   * Specifies which Deployment Version should receive new workflow executions and tasks of
   * existing unversioned or AutoUpgrade workflows.
   * Nil value means no Version in this Deployment (except Ramping Version, if present) receives traffic other than tasks of previously Pinned workflows. In absence of a Current Version, remaining traffic after any ramp (if set)  goes to unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.). 
   * Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
   * is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion current_deployment_version = 7;
   */
  currentDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `current_deployment_version`.
   *
   * @generated from field: string current_version = 1 [deprecated = true];
   * @deprecated
   */
  currentVersion = "";

  /**
   * When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
   * Must always be different from `current_deployment_version` unless both are nil.
   * Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   * Note that it is possible to ramp from one Version to another Version, or from unversioned
   * workers to a particular Version, or from a particular Version to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion ramping_deployment_version = 9;
   */
  rampingDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `ramping_deployment_version`.
   *
   * @generated from field: string ramping_version = 2 [deprecated = true];
   * @deprecated
   */
  rampingVersion = "";

  /**
   * Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
   * Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
   * not yet "promoted" to be the Current Version, likely due to pending validations.
   * A 0% value means the Ramping Version is receiving no traffic.
   *
   * @generated from field: float ramping_version_percentage = 3;
   */
  rampingVersionPercentage = 0;

  /**
   * Last time current version was changed.
   *
   * @generated from field: google.protobuf.Timestamp current_version_changed_time = 4;
   */
  currentVersionChangedTime?: Timestamp;

  /**
   * Last time ramping version was changed. Not updated if only the ramp percentage changes.
   *
   * @generated from field: google.protobuf.Timestamp ramping_version_changed_time = 5;
   */
  rampingVersionChangedTime?: Timestamp;

  /**
   * Last time ramping version percentage was changed.
   * If ramping version is changed, this is also updated, even if the percentage stays the same.
   *
   * @generated from field: google.protobuf.Timestamp ramping_version_percentage_changed_time = 6;
   */
  rampingVersionPercentageChangedTime?: Timestamp;

  /**
   * Monotonically increasing value which is incremented on every mutation 
   * to any field of this message to achieve eventual consistency between task queues and their partitions.
   *
   * @generated from field: int64 revision_number = 10;
   */
  revisionNumber = protoInt64.zero;

  constructor(data?: PartialMessage<RoutingConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.deployment.v1.RoutingConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "current_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 1, name: "current_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ramping_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 2, name: "ramping_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ramping_version_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "current_version_changed_time", kind: "message", T: Timestamp },
    { no: 5, name: "ramping_version_changed_time", kind: "message", T: Timestamp },
    { no: 6, name: "ramping_version_percentage_changed_time", kind: "message", T: Timestamp },
    { no: 10, name: "revision_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoutingConfig {
    return new RoutingConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoutingConfig {
    return new RoutingConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoutingConfig {
    return new RoutingConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RoutingConfig | PlainMessage<RoutingConfig> | undefined, b: RoutingConfig | PlainMessage<RoutingConfig> | undefined): boolean {
    return proto3.util.equals(RoutingConfig, a, b);
  }
}

