// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/query/v1/message.proto (package temporal.api.query.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Header, Payloads } from "../../common/v1/message_pbts";
import { QueryResultType } from "../../enums/v1/query_pbts";
import { Failure } from "../../failure/v1/message_pbts";
import { WorkflowExecutionStatus } from "../../enums/v1/workflow_pbts";

/**
 * See https://docs.temporal.io/docs/concepts/queries/
 *
 * @generated from message temporal.api.query.v1.WorkflowQuery
 */
export class WorkflowQuery extends Message<WorkflowQuery> {
  /**
   * The workflow-author-defined identifier of the query. Typically a function name.
   *
   * @generated from field: string query_type = 1;
   */
  queryType = "";

  /**
   * Serialized arguments that will be provided to the query handler.
   *
   * @generated from field: temporal.api.common.v1.Payloads query_args = 2;
   */
  queryArgs?: Payloads;

  /**
   * Headers that were passed by the caller of the query and copied by temporal
   * server into the workflow task.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  constructor(data?: PartialMessage<WorkflowQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.query.v1.WorkflowQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query_args", kind: "message", T: Payloads },
    { no: 3, name: "header", kind: "message", T: Header },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowQuery {
    return new WorkflowQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowQuery {
    return new WorkflowQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowQuery {
    return new WorkflowQuery().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowQuery | PlainMessage<WorkflowQuery> | undefined, b: WorkflowQuery | PlainMessage<WorkflowQuery> | undefined): boolean {
    return proto3.util.equals(WorkflowQuery, a, b);
  }
}

/**
 * Answer to a `WorkflowQuery`
 *
 * @generated from message temporal.api.query.v1.WorkflowQueryResult
 */
export class WorkflowQueryResult extends Message<WorkflowQueryResult> {
  /**
   * Did the query succeed or fail?
   *
   * @generated from field: temporal.api.enums.v1.QueryResultType result_type = 1;
   */
  resultType = QueryResultType.UNSPECIFIED;

  /**
   * Set when the query succeeds with the results.
   * Mutually exclusive with `error_message` and `failure`.
   *
   * @generated from field: temporal.api.common.v1.Payloads answer = 2;
   */
  answer?: Payloads;

  /**
   * Mutually exclusive with `answer`. Set when the query fails.
   * See also the newer `failure` field.
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage = "";

  /**
   * The full reason for this query failure. This field is newer than `error_message` and can be encoded by the SDK's
   * failure converter to support E2E encryption of messages and stack traces.
   * Mutually exclusive with `answer`. Set when the query fails.
   *
   * @generated from field: temporal.api.failure.v1.Failure failure = 4;
   */
  failure?: Failure;

  constructor(data?: PartialMessage<WorkflowQueryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.query.v1.WorkflowQueryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result_type", kind: "enum", T: proto3.getEnumType(QueryResultType) },
    { no: 2, name: "answer", kind: "message", T: Payloads },
    { no: 3, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "failure", kind: "message", T: Failure },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowQueryResult {
    return new WorkflowQueryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowQueryResult {
    return new WorkflowQueryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowQueryResult {
    return new WorkflowQueryResult().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowQueryResult | PlainMessage<WorkflowQueryResult> | undefined, b: WorkflowQueryResult | PlainMessage<WorkflowQueryResult> | undefined): boolean {
    return proto3.util.equals(WorkflowQueryResult, a, b);
  }
}

/**
 * @generated from message temporal.api.query.v1.QueryRejected
 */
export class QueryRejected extends Message<QueryRejected> {
  /**
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 1;
   */
  status = WorkflowExecutionStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<QueryRejected>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.query.v1.QueryRejected";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(WorkflowExecutionStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRejected {
    return new QueryRejected().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRejected {
    return new QueryRejected().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRejected {
    return new QueryRejected().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRejected | PlainMessage<QueryRejected> | undefined, b: QueryRejected | PlainMessage<QueryRejected> | undefined): boolean {
    return proto3.util.equals(QueryRejected, a, b);
  }
}

