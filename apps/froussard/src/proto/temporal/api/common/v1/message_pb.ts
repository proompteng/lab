// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/common/v1/message.proto (package temporal.api.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Empty, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EncodingType } from "../../enums/v1/common_pbts";
import { ResetReapplyExcludeType, ResetReapplyType } from "../../enums/v1/reset_pbts";
import { EventType } from "../../enums/v1/event_type_pbts";

/**
 * @generated from message temporal.api.common.v1.DataBlob
 */
export class DataBlob extends Message<DataBlob> {
  /**
   * @generated from field: temporal.api.enums.v1.EncodingType encoding_type = 1;
   */
  encodingType = EncodingType.UNSPECIFIED;

  /**
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<DataBlob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.DataBlob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encoding_type", kind: "enum", T: proto3.getEnumType(EncodingType) },
    { no: 2, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataBlob {
    return new DataBlob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataBlob {
    return new DataBlob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataBlob {
    return new DataBlob().fromJsonString(jsonString, options);
  }

  static equals(a: DataBlob | PlainMessage<DataBlob> | undefined, b: DataBlob | PlainMessage<DataBlob> | undefined): boolean {
    return proto3.util.equals(DataBlob, a, b);
  }
}

/**
 * See `Payload`
 *
 * @generated from message temporal.api.common.v1.Payloads
 */
export class Payloads extends Message<Payloads> {
  /**
   * @generated from field: repeated temporal.api.common.v1.Payload payloads = 1;
   */
  payloads: Payload[] = [];

  constructor(data?: PartialMessage<Payloads>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Payloads";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payloads", kind: "message", T: Payload, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payloads {
    return new Payloads().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payloads {
    return new Payloads().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payloads {
    return new Payloads().fromJsonString(jsonString, options);
  }

  static equals(a: Payloads | PlainMessage<Payloads> | undefined, b: Payloads | PlainMessage<Payloads> | undefined): boolean {
    return proto3.util.equals(Payloads, a, b);
  }
}

/**
 * Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
 * metadata which describes this binary data (format, encoding, encryption, etc). Serialization
 * of the data may be user-defined.
 *
 * @generated from message temporal.api.common.v1.Payload
 */
export class Payload extends Message<Payload> {
  /**
   * @generated from field: map<string, bytes> metadata = 1;
   */
  metadata: { [key: string]: Uint8Array } = {};

  /**
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
    { no: 2, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payload {
    return new Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Payload | PlainMessage<Payload> | undefined, b: Payload | PlainMessage<Payload> | undefined): boolean {
    return proto3.util.equals(Payload, a, b);
  }
}

/**
 * A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
 * The payload is not serialized in a user-defined way.
 *
 * @generated from message temporal.api.common.v1.SearchAttributes
 */
export class SearchAttributes extends Message<SearchAttributes> {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> indexed_fields = 1;
   */
  indexedFields: { [key: string]: Payload } = {};

  constructor(data?: PartialMessage<SearchAttributes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.SearchAttributes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "indexed_fields", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchAttributes {
    return new SearchAttributes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchAttributes {
    return new SearchAttributes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchAttributes {
    return new SearchAttributes().fromJsonString(jsonString, options);
  }

  static equals(a: SearchAttributes | PlainMessage<SearchAttributes> | undefined, b: SearchAttributes | PlainMessage<SearchAttributes> | undefined): boolean {
    return proto3.util.equals(SearchAttributes, a, b);
  }
}

/**
 * A user-defined set of *unindexed* fields that are exposed when listing/searching workflows
 *
 * @generated from message temporal.api.common.v1.Memo
 */
export class Memo extends Message<Memo> {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> fields = 1;
   */
  fields: { [key: string]: Payload } = {};

  constructor(data?: PartialMessage<Memo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Memo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Memo {
    return new Memo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Memo {
    return new Memo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Memo {
    return new Memo().fromJsonString(jsonString, options);
  }

  static equals(a: Memo | PlainMessage<Memo> | undefined, b: Memo | PlainMessage<Memo> | undefined): boolean {
    return proto3.util.equals(Memo, a, b);
  }
}

/**
 * Contains metadata that can be attached to a variety of requests, like starting a workflow, and
 * can be propagated between, for example, workflows and activities.
 *
 * @generated from message temporal.api.common.v1.Header
 */
export class Header extends Message<Header> {
  /**
   * @generated from field: map<string, temporal.api.common.v1.Payload> fields = 1;
   */
  fields: { [key: string]: Payload } = {};

  constructor(data?: PartialMessage<Header>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Header";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Payload} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Header {
    return new Header().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJsonString(jsonString, options);
  }

  static equals(a: Header | PlainMessage<Header> | undefined, b: Header | PlainMessage<Header> | undefined): boolean {
    return proto3.util.equals(Header, a, b);
  }
}

/**
 * Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
 * uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
 * run id as a way of saying "target the latest run of the workflow".
 *
 * @generated from message temporal.api.common.v1.WorkflowExecution
 */
export class WorkflowExecution extends Message<WorkflowExecution> {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId = "";

  /**
   * @generated from field: string run_id = 2;
   */
  runId = "";

  constructor(data?: PartialMessage<WorkflowExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.WorkflowExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecution | PlainMessage<WorkflowExecution> | undefined, b: WorkflowExecution | PlainMessage<WorkflowExecution> | undefined): boolean {
    return proto3.util.equals(WorkflowExecution, a, b);
  }
}

/**
 * Represents the identifier used by a workflow author to define the workflow. Typically, the
 * name of a function. This is sometimes referred to as the workflow's "name"
 *
 * @generated from message temporal.api.common.v1.WorkflowType
 */
export class WorkflowType extends Message<WorkflowType> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<WorkflowType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.WorkflowType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowType {
    return new WorkflowType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowType {
    return new WorkflowType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowType {
    return new WorkflowType().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowType | PlainMessage<WorkflowType> | undefined, b: WorkflowType | PlainMessage<WorkflowType> | undefined): boolean {
    return proto3.util.equals(WorkflowType, a, b);
  }
}

/**
 * Represents the identifier used by a activity author to define the activity. Typically, the
 * name of a function. This is sometimes referred to as the activity's "name"
 *
 * @generated from message temporal.api.common.v1.ActivityType
 */
export class ActivityType extends Message<ActivityType> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<ActivityType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.ActivityType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivityType {
    return new ActivityType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivityType {
    return new ActivityType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivityType {
    return new ActivityType().fromJsonString(jsonString, options);
  }

  static equals(a: ActivityType | PlainMessage<ActivityType> | undefined, b: ActivityType | PlainMessage<ActivityType> | undefined): boolean {
    return proto3.util.equals(ActivityType, a, b);
  }
}

/**
 * How retries ought to be handled, usable by both workflows and activities
 *
 * @generated from message temporal.api.common.v1.RetryPolicy
 */
export class RetryPolicy extends Message<RetryPolicy> {
  /**
   * Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries.
   *
   * @generated from field: google.protobuf.Duration initial_interval = 1;
   */
  initialInterval?: Duration;

  /**
   * Coefficient used to calculate the next retry interval.
   * The next retry interval is previous interval multiplied by the coefficient.
   * Must be 1 or larger.
   *
   * @generated from field: double backoff_coefficient = 2;
   */
  backoffCoefficient = 0;

  /**
   * Maximum interval between retries. Exponential backoff leads to interval increase.
   * This value is the cap of the increase. Default is 100x of the initial interval.
   *
   * @generated from field: google.protobuf.Duration maximum_interval = 3;
   */
  maximumInterval?: Duration;

  /**
   * Maximum number of attempts. When exceeded the retries stop even if not expired yet.
   * 1 disables retries. 0 means unlimited (up to the timeouts)
   *
   * @generated from field: int32 maximum_attempts = 4;
   */
  maximumAttempts = 0;

  /**
   * Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
   * this is not a substring match, the error *type* (not message) must match exactly.
   *
   * @generated from field: repeated string non_retryable_error_types = 5;
   */
  nonRetryableErrorTypes: string[] = [];

  constructor(data?: PartialMessage<RetryPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.RetryPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "initial_interval", kind: "message", T: Duration },
    { no: 2, name: "backoff_coefficient", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "maximum_interval", kind: "message", T: Duration },
    { no: 4, name: "maximum_attempts", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "non_retryable_error_types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy {
    return new RetryPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy {
    return new RetryPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy {
    return new RetryPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: RetryPolicy | PlainMessage<RetryPolicy> | undefined, b: RetryPolicy | PlainMessage<RetryPolicy> | undefined): boolean {
    return proto3.util.equals(RetryPolicy, a, b);
  }
}

/**
 * Metadata relevant for metering purposes
 *
 * @generated from message temporal.api.common.v1.MeteringMetadata
 */
export class MeteringMetadata extends Message<MeteringMetadata> {
  /**
   * Count of local activities which have begun an execution attempt during this workflow task,
   * and whose first attempt occurred in some previous task. This is used for metering
   * purposes, and does not affect workflow state.
   *
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: Negative values make no sense to represent. --)
   *
   * @generated from field: uint32 nonfirst_local_activity_execution_attempts = 13;
   */
  nonfirstLocalActivityExecutionAttempts = 0;

  constructor(data?: PartialMessage<MeteringMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.MeteringMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 13, name: "nonfirst_local_activity_execution_attempts", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MeteringMetadata {
    return new MeteringMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MeteringMetadata {
    return new MeteringMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MeteringMetadata {
    return new MeteringMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MeteringMetadata | PlainMessage<MeteringMetadata> | undefined, b: MeteringMetadata | PlainMessage<MeteringMetadata> | undefined): boolean {
    return proto3.util.equals(MeteringMetadata, a, b);
  }
}

/**
 * Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
 * Identifies the version(s) of a worker that processed a task
 *
 * @generated from message temporal.api.common.v1.WorkerVersionStamp
 */
export class WorkerVersionStamp extends Message<WorkerVersionStamp> {
  /**
   * An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
   * message is included in requests which previously used that.
   *
   * @generated from field: string build_id = 1;
   */
  buildId = "";

  /**
   * If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
   * marker for workflow reset points and the BuildIDs search attribute.
   *
   * @generated from field: bool use_versioning = 3;
   */
  useVersioning = false;

  constructor(data?: PartialMessage<WorkerVersionStamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.WorkerVersionStamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "use_versioning", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerVersionStamp {
    return new WorkerVersionStamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerVersionStamp {
    return new WorkerVersionStamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerVersionStamp {
    return new WorkerVersionStamp().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerVersionStamp | PlainMessage<WorkerVersionStamp> | undefined, b: WorkerVersionStamp | PlainMessage<WorkerVersionStamp> | undefined): boolean {
    return proto3.util.equals(WorkerVersionStamp, a, b);
  }
}

/**
 * Identifies the version that a worker is compatible with when polling or identifying itself,
 * and whether or not this worker is opting into the build-id based versioning feature. This is
 * used by matching to determine which workers ought to receive what tasks.
 * Deprecated. Use WorkerDeploymentOptions instead.
 *
 * @generated from message temporal.api.common.v1.WorkerVersionCapabilities
 */
export class WorkerVersionCapabilities extends Message<WorkerVersionCapabilities> {
  /**
   * An opaque whole-worker identifier
   *
   * @generated from field: string build_id = 1;
   */
  buildId = "";

  /**
   * If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
   * tasks.
   *
   * @generated from field: bool use_versioning = 2;
   */
  useVersioning = false;

  /**
   * Must be sent if user has set a deployment series name (versioning-3).
   *
   * @generated from field: string deployment_series_name = 4;
   */
  deploymentSeriesName = "";

  constructor(data?: PartialMessage<WorkerVersionCapabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.WorkerVersionCapabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "use_versioning", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "deployment_series_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerVersionCapabilities {
    return new WorkerVersionCapabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerVersionCapabilities {
    return new WorkerVersionCapabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerVersionCapabilities {
    return new WorkerVersionCapabilities().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerVersionCapabilities | PlainMessage<WorkerVersionCapabilities> | undefined, b: WorkerVersionCapabilities | PlainMessage<WorkerVersionCapabilities> | undefined): boolean {
    return proto3.util.equals(WorkerVersionCapabilities, a, b);
  }
}

/**
 * Describes where and how to reset a workflow, used for batch reset currently
 * and may be used for single-workflow reset later.
 *
 * @generated from message temporal.api.common.v1.ResetOptions
 */
export class ResetOptions extends Message<ResetOptions> {
  /**
   * Which workflow task to reset to.
   *
   * @generated from oneof temporal.api.common.v1.ResetOptions.target
   */
  target: {
    /**
     * Resets to the first workflow task completed or started event.
     *
     * @generated from field: google.protobuf.Empty first_workflow_task = 1;
     */
    value: Empty;
    case: "firstWorkflowTask";
  } | {
    /**
     * Resets to the last workflow task completed or started event.
     *
     * @generated from field: google.protobuf.Empty last_workflow_task = 2;
     */
    value: Empty;
    case: "lastWorkflowTask";
  } | {
    /**
     * The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
     * `WORKFLOW_TASK_STARTED` event to reset to.
     * Note that this option doesn't make sense when used as part of a batch request.
     *
     * @generated from field: int64 workflow_task_id = 3;
     */
    value: bigint;
    case: "workflowTaskId";
  } | {
    /**
     * Resets to the first workflow task processed by this build id.
     * If the workflow was not processed by the build id, or the workflow task can't be
     * determined, no reset will be performed.
     * Note that by default, this reset is allowed to be to a prior run in a chain of
     * continue-as-new.
     *
     * @generated from field: string build_id = 4;
     */
    value: string;
    case: "buildId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Deprecated. Use `options`.
   * Default: RESET_REAPPLY_TYPE_SIGNAL
   *
   * @generated from field: temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 10 [deprecated = true];
   * @deprecated
   */
  resetReapplyType = ResetReapplyType.UNSPECIFIED;

  /**
   * If true, limit the reset to only within the current run. (Applies to build_id targets and
   * possibly others in the future.)
   *
   * @generated from field: bool current_run_only = 11;
   */
  currentRunOnly = false;

  /**
   * Event types not to be reapplied
   *
   * @generated from field: repeated temporal.api.enums.v1.ResetReapplyExcludeType reset_reapply_exclude_types = 12;
   */
  resetReapplyExcludeTypes: ResetReapplyExcludeType[] = [];

  constructor(data?: PartialMessage<ResetOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.ResetOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "first_workflow_task", kind: "message", T: Empty, oneof: "target" },
    { no: 2, name: "last_workflow_task", kind: "message", T: Empty, oneof: "target" },
    { no: 3, name: "workflow_task_id", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "target" },
    { no: 4, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "target" },
    { no: 10, name: "reset_reapply_type", kind: "enum", T: proto3.getEnumType(ResetReapplyType) },
    { no: 11, name: "current_run_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "reset_reapply_exclude_types", kind: "enum", T: proto3.getEnumType(ResetReapplyExcludeType), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetOptions {
    return new ResetOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetOptions {
    return new ResetOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetOptions {
    return new ResetOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ResetOptions | PlainMessage<ResetOptions> | undefined, b: ResetOptions | PlainMessage<ResetOptions> | undefined): boolean {
    return proto3.util.equals(ResetOptions, a, b);
  }
}

/**
 * Callback to attach to various events in the system, e.g. workflow run completion.
 *
 * @generated from message temporal.api.common.v1.Callback
 */
export class Callback extends Message<Callback> {
  /**
   * @generated from oneof temporal.api.common.v1.Callback.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.common.v1.Callback.Nexus nexus = 2;
     */
    value: Callback_Nexus;
    case: "nexus";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Callback.Internal internal = 3;
     */
    value: Callback_Internal;
    case: "internal";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Links associated with the callback. It can be used to link to underlying resources of the
   * callback.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 100;
   */
  links: Link[] = [];

  constructor(data?: PartialMessage<Callback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Callback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "nexus", kind: "message", T: Callback_Nexus, oneof: "variant" },
    { no: 3, name: "internal", kind: "message", T: Callback_Internal, oneof: "variant" },
    { no: 100, name: "links", kind: "message", T: Link, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callback {
    return new Callback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callback {
    return new Callback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callback {
    return new Callback().fromJsonString(jsonString, options);
  }

  static equals(a: Callback | PlainMessage<Callback> | undefined, b: Callback | PlainMessage<Callback> | undefined): boolean {
    return proto3.util.equals(Callback, a, b);
  }
}

/**
 * @generated from message temporal.api.common.v1.Callback.Nexus
 */
export class Callback_Nexus extends Message<Callback_Nexus> {
  /**
   * Callback URL.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * Header to attach to callback request.
   *
   * @generated from field: map<string, string> header = 2;
   */
  header: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Callback_Nexus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Callback.Nexus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "header", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callback_Nexus {
    return new Callback_Nexus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callback_Nexus {
    return new Callback_Nexus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callback_Nexus {
    return new Callback_Nexus().fromJsonString(jsonString, options);
  }

  static equals(a: Callback_Nexus | PlainMessage<Callback_Nexus> | undefined, b: Callback_Nexus | PlainMessage<Callback_Nexus> | undefined): boolean {
    return proto3.util.equals(Callback_Nexus, a, b);
  }
}

/**
 * Callbacks to be delivered internally within the system.
 * This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
 * The only reason that this is exposed is because callbacks are replicated across clusters via the
 * WorkflowExecutionStarted event, which is defined in the public API.
 *
 * @generated from message temporal.api.common.v1.Callback.Internal
 */
export class Callback_Internal extends Message<Callback_Internal> {
  /**
   * Opaque internal data.
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<Callback_Internal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Callback.Internal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callback_Internal {
    return new Callback_Internal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callback_Internal {
    return new Callback_Internal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callback_Internal {
    return new Callback_Internal().fromJsonString(jsonString, options);
  }

  static equals(a: Callback_Internal | PlainMessage<Callback_Internal> | undefined, b: Callback_Internal | PlainMessage<Callback_Internal> | undefined): boolean {
    return proto3.util.equals(Callback_Internal, a, b);
  }
}

/**
 * Link can be associated with history events. It might contain information about an external entity
 * related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
 * in this case, a history event in workflow A could contain a Link to the workflow started event in
 * workflow B, and vice-versa.
 *
 * @generated from message temporal.api.common.v1.Link
 */
export class Link extends Message<Link> {
  /**
   * @generated from oneof temporal.api.common.v1.Link.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent workflow_event = 1;
     */
    value: Link_WorkflowEvent;
    case: "workflowEvent";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Link.BatchJob batch_job = 2;
     */
    value: Link_BatchJob;
    case: "batchJob";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Link>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Link";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_event", kind: "message", T: Link_WorkflowEvent, oneof: "variant" },
    { no: 2, name: "batch_job", kind: "message", T: Link_BatchJob, oneof: "variant" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link {
    return new Link().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link {
    return new Link().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link {
    return new Link().fromJsonString(jsonString, options);
  }

  static equals(a: Link | PlainMessage<Link> | undefined, b: Link | PlainMessage<Link> | undefined): boolean {
    return proto3.util.equals(Link, a, b);
  }
}

/**
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent
 */
export class Link_WorkflowEvent extends Message<Link_WorkflowEvent> {
  /**
   * @generated from field: string namespace = 1;
   */
  namespace = "";

  /**
   * @generated from field: string workflow_id = 2;
   */
  workflowId = "";

  /**
   * @generated from field: string run_id = 3;
   */
  runId = "";

  /**
   * Additional information about the workflow event.
   * Eg: the caller workflow can send the history event details that made the Nexus call.
   *
   * @generated from oneof temporal.api.common.v1.Link.WorkflowEvent.reference
   */
  reference: {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent.EventReference event_ref = 100;
     */
    value: Link_WorkflowEvent_EventReference;
    case: "eventRef";
  } | {
    /**
     * @generated from field: temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference request_id_ref = 101;
     */
    value: Link_WorkflowEvent_RequestIdReference;
    case: "requestIdRef";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Link_WorkflowEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Link.WorkflowEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 100, name: "event_ref", kind: "message", T: Link_WorkflowEvent_EventReference, oneof: "reference" },
    { no: 101, name: "request_id_ref", kind: "message", T: Link_WorkflowEvent_RequestIdReference, oneof: "reference" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link_WorkflowEvent {
    return new Link_WorkflowEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link_WorkflowEvent {
    return new Link_WorkflowEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link_WorkflowEvent {
    return new Link_WorkflowEvent().fromJsonString(jsonString, options);
  }

  static equals(a: Link_WorkflowEvent | PlainMessage<Link_WorkflowEvent> | undefined, b: Link_WorkflowEvent | PlainMessage<Link_WorkflowEvent> | undefined): boolean {
    return proto3.util.equals(Link_WorkflowEvent, a, b);
  }
}

/**
 * EventReference is a direct reference to a history event through the event ID.
 *
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent.EventReference
 */
export class Link_WorkflowEvent_EventReference extends Message<Link_WorkflowEvent_EventReference> {
  /**
   * @generated from field: int64 event_id = 1;
   */
  eventId = protoInt64.zero;

  /**
   * @generated from field: temporal.api.enums.v1.EventType event_type = 2;
   */
  eventType = EventType.UNSPECIFIED;

  constructor(data?: PartialMessage<Link_WorkflowEvent_EventReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Link.WorkflowEvent.EventReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link_WorkflowEvent_EventReference {
    return new Link_WorkflowEvent_EventReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link_WorkflowEvent_EventReference {
    return new Link_WorkflowEvent_EventReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link_WorkflowEvent_EventReference {
    return new Link_WorkflowEvent_EventReference().fromJsonString(jsonString, options);
  }

  static equals(a: Link_WorkflowEvent_EventReference | PlainMessage<Link_WorkflowEvent_EventReference> | undefined, b: Link_WorkflowEvent_EventReference | PlainMessage<Link_WorkflowEvent_EventReference> | undefined): boolean {
    return proto3.util.equals(Link_WorkflowEvent_EventReference, a, b);
  }
}

/**
 * RequestIdReference is a indirect reference to a history event through the request ID.
 *
 * @generated from message temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference
 */
export class Link_WorkflowEvent_RequestIdReference extends Message<Link_WorkflowEvent_RequestIdReference> {
  /**
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * @generated from field: temporal.api.enums.v1.EventType event_type = 2;
   */
  eventType = EventType.UNSPECIFIED;

  constructor(data?: PartialMessage<Link_WorkflowEvent_RequestIdReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Link.WorkflowEvent.RequestIdReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link_WorkflowEvent_RequestIdReference {
    return new Link_WorkflowEvent_RequestIdReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link_WorkflowEvent_RequestIdReference {
    return new Link_WorkflowEvent_RequestIdReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link_WorkflowEvent_RequestIdReference {
    return new Link_WorkflowEvent_RequestIdReference().fromJsonString(jsonString, options);
  }

  static equals(a: Link_WorkflowEvent_RequestIdReference | PlainMessage<Link_WorkflowEvent_RequestIdReference> | undefined, b: Link_WorkflowEvent_RequestIdReference | PlainMessage<Link_WorkflowEvent_RequestIdReference> | undefined): boolean {
    return proto3.util.equals(Link_WorkflowEvent_RequestIdReference, a, b);
  }
}

/**
 * A link to a built-in batch job.
 * Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
 * This link can be put on workflow history events generated by actions taken by a batch job.
 *
 * @generated from message temporal.api.common.v1.Link.BatchJob
 */
export class Link_BatchJob extends Message<Link_BatchJob> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<Link_BatchJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Link.BatchJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link_BatchJob {
    return new Link_BatchJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link_BatchJob {
    return new Link_BatchJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link_BatchJob {
    return new Link_BatchJob().fromJsonString(jsonString, options);
  }

  static equals(a: Link_BatchJob | PlainMessage<Link_BatchJob> | undefined, b: Link_BatchJob | PlainMessage<Link_BatchJob> | undefined): boolean {
    return proto3.util.equals(Link_BatchJob, a, b);
  }
}

/**
 * Priority contains metadata that controls relative ordering of task processing
 * when tasks are backed up in a queue. Initially, Priority will be used in
 * matching (workflow and activity) task queues. Later it may be used in history
 * task queues and in rate limiting decisions.
 *
 * Priority is attached to workflows and activities. By default, activities
 * inherit Priority from the workflow that created them, but may override fields
 * when an activity is started or modified.
 *
 * Despite being named "Priority", this message also contains fields that
 * control "fairness" mechanisms.
 *
 * For all fields, the field not present or equal to zero/empty string means to
 * inherit the value from the calling workflow, or if there is no calling
 * workflow, then use the default value.
 *
 * For all fields other than fairness_key, the zero value isn't meaningful so
 * there's no confusion between inherit/default and a meaningful value. For
 * fairness_key, the empty string will be interpreted as "inherit". This means
 * that if a workflow has a non-empty fairness key, you can't override the
 * fairness key of its activity to the empty string.
 *
 * The overall semantics of Priority are:
 * 1. First, consider "priority": higher priority (lower number) goes first.
 * 2. Then, consider fairness: try to dispatch tasks for different fairness keys
 *    in proportion to their weight.
 *
 * Applications may use any subset of mechanisms that are useful to them and
 * leave the other fields to use default values.
 *
 * Not all queues in the system may support the "full" semantics of all priority
 * fields. (Currently only support in matching task queues is planned.)
 *
 * @generated from message temporal.api.common.v1.Priority
 */
export class Priority extends Message<Priority> {
  /**
   * Priority key is a positive integer from 1 to n, where smaller integers
   * correspond to higher priorities (tasks run sooner). In general, tasks in
   * a queue should be processed in close to priority order, although small
   * deviations are possible.
   *
   * The maximum priority value (minimum priority) is determined by server
   * configuration, and defaults to 5.
   *
   * If priority is not present (or zero), then the effective priority will be
   * the default priority, which is calculated by (min+max)/2. With the
   * default max of 5, and min of 1, that comes out to 3.
   *
   * @generated from field: int32 priority_key = 1;
   */
  priorityKey = 0;

  /**
   * Fairness key is a short string that's used as a key for a fairness
   * balancing mechanism. It may correspond to a tenant id, or to a fixed
   * string like "high" or "low". The default is the empty string.
   *
   * The fairness mechanism attempts to dispatch tasks for a given key in
   * proportion to its weight. For example, using a thousand distinct tenant
   * ids, each with a weight of 1.0 (the default) will result in each tenant
   * getting a roughly equal share of task dispatch throughput.
   *
   * (Note: this does not imply equal share of worker capacity! Fairness
   * decisions are made based on queue statistics, not
   * current worker load.)
   *
   * As another example, using keys "high" and "low" with weight 9.0 and 1.0
   * respectively will prefer dispatching "high" tasks over "low" tasks at a
   * 9:1 ratio, while allowing either key to use all worker capacity if the
   * other is not present.
   *
   * All fairness mechanisms, including rate limits, are best-effort and
   * probabilistic. The results may not match what a "perfect" algorithm with
   * infinite resources would produce. The more unique keys are used, the less
   * accurate the results will be.
   *
   * Fairness keys are limited to 64 bytes.
   *
   * @generated from field: string fairness_key = 2;
   */
  fairnessKey = "";

  /**
   * Fairness weight for a task can come from multiple sources for
   * flexibility. From highest to lowest precedence:
   * 1. Weights for a small set of keys can be overridden in task queue
   *    configuration with an API.
   * 2. It can be attached to the workflow/activity in this field.
   * 3. The default weight of 1.0 will be used.
   *
   * Weight values are clamped to the range [0.001, 1000].
   *
   * @generated from field: float fairness_weight = 3;
   */
  fairnessWeight = 0;

  constructor(data?: PartialMessage<Priority>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.Priority";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "priority_key", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "fairness_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "fairness_weight", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Priority {
    return new Priority().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Priority {
    return new Priority().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Priority {
    return new Priority().fromJsonString(jsonString, options);
  }

  static equals(a: Priority | PlainMessage<Priority> | undefined, b: Priority | PlainMessage<Priority> | undefined): boolean {
    return proto3.util.equals(Priority, a, b);
  }
}

/**
 * This is used to send commands to a specific worker or a group of workers.
 * Right now, it is used to send commands to a specific worker instance.
 * Will be extended to be able to send command to multiple workers.
 *
 * @generated from message temporal.api.common.v1.WorkerSelector
 */
export class WorkerSelector extends Message<WorkerSelector> {
  /**
   * Options are:
   * - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
   * - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
   * - etc.
   *   All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
   * string query = 5;
   * string task_queue = 6;
   * ...
   *
   * @generated from oneof temporal.api.common.v1.WorkerSelector.selector
   */
  selector: {
    /**
     * Worker instance key to which the command should be sent.
     *
     * @generated from field: string worker_instance_key = 1;
     */
    value: string;
    case: "workerInstanceKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WorkerSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.common.v1.WorkerSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_instance_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerSelector {
    return new WorkerSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerSelector {
    return new WorkerSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerSelector {
    return new WorkerSelector().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerSelector | PlainMessage<WorkerSelector> | undefined, b: WorkerSelector | PlainMessage<WorkerSelector> | undefined): boolean {
    return proto3.util.equals(WorkerSelector, a, b);
  }
}

