// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/namespace/v1/message.proto (package temporal.api.namespace.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { ArchivalState, NamespaceState } from "../../enums/v1/namespace_pbts";

/**
 * @generated from message temporal.api.namespace.v1.NamespaceInfo
 */
export class NamespaceInfo extends Message<NamespaceInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: temporal.api.enums.v1.NamespaceState state = 2;
   */
  state = NamespaceState.UNSPECIFIED;

  /**
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * @generated from field: string owner_email = 4;
   */
  ownerEmail = "";

  /**
   * A key-value map for any customized purpose.
   *
   * @generated from field: map<string, string> data = 5;
   */
  data: { [key: string]: string } = {};

  /**
   * @generated from field: string id = 6;
   */
  id = "";

  /**
   * All capabilities the namespace supports.
   *
   * @generated from field: temporal.api.namespace.v1.NamespaceInfo.Capabilities capabilities = 7;
   */
  capabilities?: NamespaceInfo_Capabilities;

  /**
   * Whether scheduled workflows are supported on this namespace. This is only needed
   * temporarily while the feature is experimental, so we can give it a high tag.
   *
   * @generated from field: bool supports_schedules = 100;
   */
  supportsSchedules = false;

  constructor(data?: PartialMessage<NamespaceInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.NamespaceInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(NamespaceState) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "owner_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "capabilities", kind: "message", T: NamespaceInfo_Capabilities },
    { no: 100, name: "supports_schedules", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceInfo {
    return new NamespaceInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceInfo {
    return new NamespaceInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceInfo {
    return new NamespaceInfo().fromJsonString(jsonString, options);
  }

  static equals(a: NamespaceInfo | PlainMessage<NamespaceInfo> | undefined, b: NamespaceInfo | PlainMessage<NamespaceInfo> | undefined): boolean {
    return proto3.util.equals(NamespaceInfo, a, b);
  }
}

/**
 * Namespace capability details. Should contain what features are enabled in a namespace.
 *
 * @generated from message temporal.api.namespace.v1.NamespaceInfo.Capabilities
 */
export class NamespaceInfo_Capabilities extends Message<NamespaceInfo_Capabilities> {
  /**
   * True if the namespace supports eager workflow start.
   *
   * @generated from field: bool eager_workflow_start = 1;
   */
  eagerWorkflowStart = false;

  /**
   * True if the namespace supports sync update
   *
   * @generated from field: bool sync_update = 2;
   */
  syncUpdate = false;

  /**
   * True if the namespace supports async update
   *
   * @generated from field: bool async_update = 3;
   */
  asyncUpdate = false;

  /**
   * True if the namespace supports worker heartbeats
   *
   * @generated from field: bool worker_heartbeats = 4;
   */
  workerHeartbeats = false;

  /**
   * True if the namespace supports reported problems search attribute
   *
   * @generated from field: bool reported_problems_search_attribute = 5;
   */
  reportedProblemsSearchAttribute = false;

  constructor(data?: PartialMessage<NamespaceInfo_Capabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.NamespaceInfo.Capabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eager_workflow_start", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "sync_update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "async_update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "worker_heartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "reported_problems_search_attribute", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceInfo_Capabilities {
    return new NamespaceInfo_Capabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceInfo_Capabilities {
    return new NamespaceInfo_Capabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceInfo_Capabilities {
    return new NamespaceInfo_Capabilities().fromJsonString(jsonString, options);
  }

  static equals(a: NamespaceInfo_Capabilities | PlainMessage<NamespaceInfo_Capabilities> | undefined, b: NamespaceInfo_Capabilities | PlainMessage<NamespaceInfo_Capabilities> | undefined): boolean {
    return proto3.util.equals(NamespaceInfo_Capabilities, a, b);
  }
}

/**
 * @generated from message temporal.api.namespace.v1.NamespaceConfig
 */
export class NamespaceConfig extends Message<NamespaceConfig> {
  /**
   * @generated from field: google.protobuf.Duration workflow_execution_retention_ttl = 1;
   */
  workflowExecutionRetentionTtl?: Duration;

  /**
   * @generated from field: temporal.api.namespace.v1.BadBinaries bad_binaries = 2;
   */
  badBinaries?: BadBinaries;

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState history_archival_state = 3;
   */
  historyArchivalState = ArchivalState.UNSPECIFIED;

  /**
   * @generated from field: string history_archival_uri = 4;
   */
  historyArchivalUri = "";

  /**
   * If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
   *
   * @generated from field: temporal.api.enums.v1.ArchivalState visibility_archival_state = 5;
   */
  visibilityArchivalState = ArchivalState.UNSPECIFIED;

  /**
   * @generated from field: string visibility_archival_uri = 6;
   */
  visibilityArchivalUri = "";

  /**
   * Map from field name to alias.
   *
   * @generated from field: map<string, string> custom_search_attribute_aliases = 7;
   */
  customSearchAttributeAliases: { [key: string]: string } = {};

  constructor(data?: PartialMessage<NamespaceConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.NamespaceConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_execution_retention_ttl", kind: "message", T: Duration },
    { no: 2, name: "bad_binaries", kind: "message", T: BadBinaries },
    { no: 3, name: "history_archival_state", kind: "enum", T: proto3.getEnumType(ArchivalState) },
    { no: 4, name: "history_archival_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "visibility_archival_state", kind: "enum", T: proto3.getEnumType(ArchivalState) },
    { no: 6, name: "visibility_archival_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "custom_search_attribute_aliases", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceConfig {
    return new NamespaceConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceConfig {
    return new NamespaceConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceConfig {
    return new NamespaceConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NamespaceConfig | PlainMessage<NamespaceConfig> | undefined, b: NamespaceConfig | PlainMessage<NamespaceConfig> | undefined): boolean {
    return proto3.util.equals(NamespaceConfig, a, b);
  }
}

/**
 * @generated from message temporal.api.namespace.v1.BadBinaries
 */
export class BadBinaries extends Message<BadBinaries> {
  /**
   * @generated from field: map<string, temporal.api.namespace.v1.BadBinaryInfo> binaries = 1;
   */
  binaries: { [key: string]: BadBinaryInfo } = {};

  constructor(data?: PartialMessage<BadBinaries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.BadBinaries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "binaries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: BadBinaryInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadBinaries {
    return new BadBinaries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadBinaries {
    return new BadBinaries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadBinaries {
    return new BadBinaries().fromJsonString(jsonString, options);
  }

  static equals(a: BadBinaries | PlainMessage<BadBinaries> | undefined, b: BadBinaries | PlainMessage<BadBinaries> | undefined): boolean {
    return proto3.util.equals(BadBinaries, a, b);
  }
}

/**
 * @generated from message temporal.api.namespace.v1.BadBinaryInfo
 */
export class BadBinaryInfo extends Message<BadBinaryInfo> {
  /**
   * @generated from field: string reason = 1;
   */
  reason = "";

  /**
   * @generated from field: string operator = 2;
   */
  operator = "";

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  constructor(data?: PartialMessage<BadBinaryInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.BadBinaryInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "create_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadBinaryInfo {
    return new BadBinaryInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadBinaryInfo {
    return new BadBinaryInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BadBinaryInfo {
    return new BadBinaryInfo().fromJsonString(jsonString, options);
  }

  static equals(a: BadBinaryInfo | PlainMessage<BadBinaryInfo> | undefined, b: BadBinaryInfo | PlainMessage<BadBinaryInfo> | undefined): boolean {
    return proto3.util.equals(BadBinaryInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.namespace.v1.UpdateNamespaceInfo
 */
export class UpdateNamespaceInfo extends Message<UpdateNamespaceInfo> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: string owner_email = 2;
   */
  ownerEmail = "";

  /**
   * A key-value map for any customized purpose.
   * If data already exists on the namespace,
   * this will merge with the existing key values.
   *
   * @generated from field: map<string, string> data = 3;
   */
  data: { [key: string]: string } = {};

  /**
   * New namespace state, server will reject if transition is not allowed.
   * Allowed transitions are:
   *  Registered -> [ Deleted | Deprecated | Handover ]
   *  Handover -> [ Registered ]
   * Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
   *
   * @generated from field: temporal.api.enums.v1.NamespaceState state = 4;
   */
  state = NamespaceState.UNSPECIFIED;

  constructor(data?: PartialMessage<UpdateNamespaceInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.UpdateNamespaceInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "state", kind: "enum", T: proto3.getEnumType(NamespaceState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateNamespaceInfo {
    return new UpdateNamespaceInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateNamespaceInfo {
    return new UpdateNamespaceInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateNamespaceInfo {
    return new UpdateNamespaceInfo().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateNamespaceInfo | PlainMessage<UpdateNamespaceInfo> | undefined, b: UpdateNamespaceInfo | PlainMessage<UpdateNamespaceInfo> | undefined): boolean {
    return proto3.util.equals(UpdateNamespaceInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.namespace.v1.NamespaceFilter
 */
export class NamespaceFilter extends Message<NamespaceFilter> {
  /**
   * By default namespaces in NAMESPACE_STATE_DELETED state are not included.
   * Setting include_deleted to true will include deleted namespaces.
   * Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
   *
   * @generated from field: bool include_deleted = 1;
   */
  includeDeleted = false;

  constructor(data?: PartialMessage<NamespaceFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.namespace.v1.NamespaceFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include_deleted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceFilter {
    return new NamespaceFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceFilter {
    return new NamespaceFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceFilter {
    return new NamespaceFilter().fromJsonString(jsonString, options);
  }

  static equals(a: NamespaceFilter | PlainMessage<NamespaceFilter> | undefined, b: NamespaceFilter | PlainMessage<NamespaceFilter> | undefined): boolean {
    return proto3.util.equals(NamespaceFilter, a, b);
  }
}

