// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/taskqueue/v1/message.proto (package temporal.api.taskqueue.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { DoubleValue, Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { BuildIdTaskReachability, TaskQueueKind, TaskReachability } from "../../enums/v1/task_queue_pbts";
import { WorkerDeploymentOptions, WorkerDeploymentVersion } from "../../deployment/v1/message_pbts";
import { WorkerVersionCapabilities } from "../../common/v1/message_pbts";

/**
 * See https://docs.temporal.io/docs/concepts/task-queues/
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueue
 */
export class TaskQueue extends Message<TaskQueue> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Default: TASK_QUEUE_KIND_NORMAL.
   *
   * @generated from field: temporal.api.enums.v1.TaskQueueKind kind = 2;
   */
  kind = TaskQueueKind.UNSPECIFIED;

  /**
   * Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
   * the normal task queue that the sticky worker is running on.
   *
   * @generated from field: string normal_name = 3;
   */
  normalName = "";

  constructor(data?: PartialMessage<TaskQueue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "kind", kind: "enum", T: proto3.getEnumType(TaskQueueKind) },
    { no: 3, name: "normal_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueue {
    return new TaskQueue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueue {
    return new TaskQueue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueue {
    return new TaskQueue().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueue | PlainMessage<TaskQueue> | undefined, b: TaskQueue | PlainMessage<TaskQueue> | undefined): boolean {
    return proto3.util.equals(TaskQueue, a, b);
  }
}

/**
 * Only applies to activity task queues
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueMetadata
 */
export class TaskQueueMetadata extends Message<TaskQueueMetadata> {
  /**
   * Allows throttling dispatch of tasks from this queue
   *
   * @generated from field: google.protobuf.DoubleValue max_tasks_per_second = 1;
   */
  maxTasksPerSecond?: number;

  constructor(data?: PartialMessage<TaskQueueMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_tasks_per_second", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueMetadata {
    return new TaskQueueMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueMetadata {
    return new TaskQueueMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueMetadata {
    return new TaskQueueMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueMetadata | PlainMessage<TaskQueueMetadata> | undefined, b: TaskQueueMetadata | PlainMessage<TaskQueueMetadata> | undefined): boolean {
    return proto3.util.equals(TaskQueueMetadata, a, b);
  }
}

/**
 * Experimental. Worker Deployments are experimental and might significantly change in the future.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersioningInfo
 */
export class TaskQueueVersioningInfo extends Message<TaskQueueVersioningInfo> {
  /**
   * Specifies which Deployment Version should receive new workflow executions and tasks of
   * existing unversioned or AutoUpgrade workflows.
   * Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   * Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
   * is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion current_deployment_version = 7;
   */
  currentDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `current_deployment_version`.
   *
   * @generated from field: string current_version = 1 [deprecated = true];
   * @deprecated
   */
  currentVersion = "";

  /**
   * When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
   * Must always be different from `current_deployment_version` unless both are nil.
   * Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
   * Note that it is possible to ramp from one Version to another Version, or from unversioned
   * workers to a particular Version, or from a particular Version to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion ramping_deployment_version = 9;
   */
  rampingDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Deprecated. Use `ramping_deployment_version`.
   *
   * @generated from field: string ramping_version = 2 [deprecated = true];
   * @deprecated
   */
  rampingVersion = "";

  /**
   * Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
   * Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
   * not yet "promoted" to be the Current Version, likely due to pending validations.
   * A 0% value means the Ramping Version is receiving no traffic.
   *
   * @generated from field: float ramping_version_percentage = 3;
   */
  rampingVersionPercentage = 0;

  /**
   * Last time versioning information of this Task Queue changed.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 4;
   */
  updateTime?: Timestamp;

  constructor(data?: PartialMessage<TaskQueueVersioningInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueVersioningInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "current_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 1, name: "current_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ramping_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 2, name: "ramping_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ramping_version_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueVersioningInfo {
    return new TaskQueueVersioningInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueVersioningInfo {
    return new TaskQueueVersioningInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueVersioningInfo {
    return new TaskQueueVersioningInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueVersioningInfo | PlainMessage<TaskQueueVersioningInfo> | undefined, b: TaskQueueVersioningInfo | PlainMessage<TaskQueueVersioningInfo> | undefined): boolean {
    return proto3.util.equals(TaskQueueVersioningInfo, a, b);
  }
}

/**
 * Used for specifying versions the caller is interested in.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersionSelection
 */
export class TaskQueueVersionSelection extends Message<TaskQueueVersionSelection> {
  /**
   * Include specific Build IDs.
   *
   * @generated from field: repeated string build_ids = 1;
   */
  buildIds: string[] = [];

  /**
   * Include the unversioned queue.
   *
   * @generated from field: bool unversioned = 2;
   */
  unversioned = false;

  /**
   * Include all active versions. A version is considered active if, in the last few minutes,
   * it has had new tasks or polls, or it has been the subject of certain task queue API calls.
   *
   * @generated from field: bool all_active = 3;
   */
  allActive = false;

  constructor(data?: PartialMessage<TaskQueueVersionSelection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueVersionSelection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "unversioned", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "all_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueVersionSelection {
    return new TaskQueueVersionSelection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueVersionSelection {
    return new TaskQueueVersionSelection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueVersionSelection {
    return new TaskQueueVersionSelection().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueVersionSelection | PlainMessage<TaskQueueVersionSelection> | undefined, b: TaskQueueVersionSelection | PlainMessage<TaskQueueVersionSelection> | undefined): boolean {
    return proto3.util.equals(TaskQueueVersionSelection, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueVersionInfo
 */
export class TaskQueueVersionInfo extends Message<TaskQueueVersionInfo> {
  /**
   * Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
   *
   * @generated from field: map<int32, temporal.api.taskqueue.v1.TaskQueueTypeInfo> types_info = 1;
   */
  typesInfo: { [key: number]: TaskQueueTypeInfo } = {};

  /**
   * Task Reachability is eventually consistent; there may be a delay until it converges to the most
   * accurate value but it is designed in a way to take the more conservative side until it converges.
   * For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
   *
   * Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
   * accounted for reachability as server cannot know if they'll happen as they do not use
   * assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
   * who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
   * sure to query reachability for the parent/previous workflow's Task Queue as well.
   *
   * @generated from field: temporal.api.enums.v1.BuildIdTaskReachability task_reachability = 2;
   */
  taskReachability = BuildIdTaskReachability.UNSPECIFIED;

  constructor(data?: PartialMessage<TaskQueueVersionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueVersionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types_info", kind: "map", K: 5 /* ScalarType.INT32 */, V: {kind: "message", T: TaskQueueTypeInfo} },
    { no: 2, name: "task_reachability", kind: "enum", T: proto3.getEnumType(BuildIdTaskReachability) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueVersionInfo {
    return new TaskQueueVersionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueVersionInfo {
    return new TaskQueueVersionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueVersionInfo {
    return new TaskQueueVersionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueVersionInfo | PlainMessage<TaskQueueVersionInfo> | undefined, b: TaskQueueVersionInfo | PlainMessage<TaskQueueVersionInfo> | undefined): boolean {
    return proto3.util.equals(TaskQueueVersionInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueTypeInfo
 */
export class TaskQueueTypeInfo extends Message<TaskQueueTypeInfo> {
  /**
   * Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.PollerInfo pollers = 1;
   */
  pollers: PollerInfo[] = [];

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueueStats stats = 2;
   */
  stats?: TaskQueueStats;

  constructor(data?: PartialMessage<TaskQueueTypeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueTypeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pollers", kind: "message", T: PollerInfo, repeated: true },
    { no: 2, name: "stats", kind: "message", T: TaskQueueStats },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueTypeInfo {
    return new TaskQueueTypeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueTypeInfo {
    return new TaskQueueTypeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueTypeInfo {
    return new TaskQueueTypeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueTypeInfo | PlainMessage<TaskQueueTypeInfo> | undefined, b: TaskQueueTypeInfo | PlainMessage<TaskQueueTypeInfo> | undefined): boolean {
    return proto3.util.equals(TaskQueueTypeInfo, a, b);
  }
}

/**
 * TaskQueueStats contains statistics about task queue backlog and activity.
 *
 * For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
 * comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueStats
 */
export class TaskQueueStats extends Message<TaskQueueStats> {
  /**
   * The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
   * converges to the right value. Can be relied upon for scaling decisions.
   *
   * Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
   * those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
   * grows.
   *
   * @generated from field: int64 approximate_backlog_count = 1;
   */
  approximateBacklogCount = protoInt64.zero;

  /**
   * Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
   * the queue. Can be relied upon for scaling decisions.
   *
   * Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
   * those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
   * few seconds.
   *
   * @generated from field: google.protobuf.Duration approximate_backlog_age = 2;
   */
  approximateBacklogAge?: Duration;

  /**
   * The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
   * whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
   * to the backlog (sync-matched).
   *
   * The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
   * backlog grows/shrinks.
   *
   * Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
   * tasks_add_rate, because:
   * - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
   *   enable for activities by default in the latest SDKs.
   * - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
   *   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
   *   worker instance.
   *
   * @generated from field: float tasks_add_rate = 3;
   */
  tasksAddRate = 0;

  /**
   * The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
   * tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
   * going to the backlog (sync-matched).
   *
   * The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
   * backlog grows/shrinks.
   *
   * Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
   * tasks_dispatch_rate, because:
   * - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
   *   enable for activities by default in the latest SDKs.
   * - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
   *   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
   *   worker instance.
   *
   * @generated from field: float tasks_dispatch_rate = 4;
   */
  tasksDispatchRate = 0;

  constructor(data?: PartialMessage<TaskQueueStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approximate_backlog_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "approximate_backlog_age", kind: "message", T: Duration },
    { no: 3, name: "tasks_add_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "tasks_dispatch_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueStats {
    return new TaskQueueStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueStats {
    return new TaskQueueStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueStats {
    return new TaskQueueStats().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueStats | PlainMessage<TaskQueueStats> | undefined, b: TaskQueueStats | PlainMessage<TaskQueueStats> | undefined): boolean {
    return proto3.util.equals(TaskQueueStats, a, b);
  }
}

/**
 * Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueStatus
 */
export class TaskQueueStatus extends Message<TaskQueueStatus> {
  /**
   * @generated from field: int64 backlog_count_hint = 1;
   */
  backlogCountHint = protoInt64.zero;

  /**
   * @generated from field: int64 read_level = 2;
   */
  readLevel = protoInt64.zero;

  /**
   * @generated from field: int64 ack_level = 3;
   */
  ackLevel = protoInt64.zero;

  /**
   * @generated from field: double rate_per_second = 4;
   */
  ratePerSecond = 0;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskIdBlock task_id_block = 5;
   */
  taskIdBlock?: TaskIdBlock;

  constructor(data?: PartialMessage<TaskQueueStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backlog_count_hint", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "read_level", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "ack_level", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "rate_per_second", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "task_id_block", kind: "message", T: TaskIdBlock },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueStatus {
    return new TaskQueueStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueStatus {
    return new TaskQueueStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueStatus {
    return new TaskQueueStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueStatus | PlainMessage<TaskQueueStatus> | undefined, b: TaskQueueStatus | PlainMessage<TaskQueueStatus> | undefined): boolean {
    return proto3.util.equals(TaskQueueStatus, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TaskIdBlock
 */
export class TaskIdBlock extends Message<TaskIdBlock> {
  /**
   * @generated from field: int64 start_id = 1;
   */
  startId = protoInt64.zero;

  /**
   * @generated from field: int64 end_id = 2;
   */
  endId = protoInt64.zero;

  constructor(data?: PartialMessage<TaskIdBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskIdBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "end_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskIdBlock {
    return new TaskIdBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskIdBlock {
    return new TaskIdBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskIdBlock {
    return new TaskIdBlock().fromJsonString(jsonString, options);
  }

  static equals(a: TaskIdBlock | PlainMessage<TaskIdBlock> | undefined, b: TaskIdBlock | PlainMessage<TaskIdBlock> | undefined): boolean {
    return proto3.util.equals(TaskIdBlock, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueuePartitionMetadata
 */
export class TaskQueuePartitionMetadata extends Message<TaskQueuePartitionMetadata> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: string owner_host_name = 2;
   */
  ownerHostName = "";

  constructor(data?: PartialMessage<TaskQueuePartitionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueuePartitionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner_host_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueuePartitionMetadata {
    return new TaskQueuePartitionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueuePartitionMetadata {
    return new TaskQueuePartitionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueuePartitionMetadata {
    return new TaskQueuePartitionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueuePartitionMetadata | PlainMessage<TaskQueuePartitionMetadata> | undefined, b: TaskQueuePartitionMetadata | PlainMessage<TaskQueuePartitionMetadata> | undefined): boolean {
    return proto3.util.equals(TaskQueuePartitionMetadata, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.PollerInfo
 */
export class PollerInfo extends Message<PollerInfo> {
  /**
   * @generated from field: google.protobuf.Timestamp last_access_time = 1;
   */
  lastAccessTime?: Timestamp;

  /**
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * @generated from field: double rate_per_second = 3;
   */
  ratePerSecond = 0;

  /**
   * If a worker has opted into the worker versioning feature while polling, its capabilities will
   * appear here.
   * Deprecated. Replaced by deployment_options.
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4 [deprecated = true];
   * @deprecated
   */
  workerVersionCapabilities?: WorkerVersionCapabilities;

  /**
   * Worker deployment options that SDK sent to server.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentOptions deployment_options = 5;
   */
  deploymentOptions?: WorkerDeploymentOptions;

  constructor(data?: PartialMessage<PollerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.PollerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "last_access_time", kind: "message", T: Timestamp },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rate_per_second", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "worker_version_capabilities", kind: "message", T: WorkerVersionCapabilities },
    { no: 5, name: "deployment_options", kind: "message", T: WorkerDeploymentOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollerInfo {
    return new PollerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollerInfo {
    return new PollerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollerInfo {
    return new PollerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PollerInfo | PlainMessage<PollerInfo> | undefined, b: PollerInfo | PlainMessage<PollerInfo> | undefined): boolean {
    return proto3.util.equals(PollerInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.StickyExecutionAttributes
 */
export class StickyExecutionAttributes extends Message<StickyExecutionAttributes> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue worker_task_queue = 1;
   */
  workerTaskQueue?: TaskQueue;

  /**
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_start_timeout = 2;
   */
  scheduleToStartTimeout?: Duration;

  constructor(data?: PartialMessage<StickyExecutionAttributes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.StickyExecutionAttributes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_task_queue", kind: "message", T: TaskQueue },
    { no: 2, name: "schedule_to_start_timeout", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StickyExecutionAttributes {
    return new StickyExecutionAttributes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StickyExecutionAttributes {
    return new StickyExecutionAttributes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StickyExecutionAttributes {
    return new StickyExecutionAttributes().fromJsonString(jsonString, options);
  }

  static equals(a: StickyExecutionAttributes | PlainMessage<StickyExecutionAttributes> | undefined, b: StickyExecutionAttributes | PlainMessage<StickyExecutionAttributes> | undefined): boolean {
    return proto3.util.equals(StickyExecutionAttributes, a, b);
  }
}

/**
 * Used by the worker versioning APIs, represents an unordered set of one or more versions which are
 * considered to be compatible with each other. Currently the versions are always worker build IDs.
 *
 * @generated from message temporal.api.taskqueue.v1.CompatibleVersionSet
 */
export class CompatibleVersionSet extends Message<CompatibleVersionSet> {
  /**
   * All the compatible versions, unordered, except for the last element, which is considered the set "default".
   *
   * @generated from field: repeated string build_ids = 1;
   */
  buildIds: string[] = [];

  constructor(data?: PartialMessage<CompatibleVersionSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.CompatibleVersionSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompatibleVersionSet {
    return new CompatibleVersionSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompatibleVersionSet {
    return new CompatibleVersionSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompatibleVersionSet {
    return new CompatibleVersionSet().fromJsonString(jsonString, options);
  }

  static equals(a: CompatibleVersionSet | PlainMessage<CompatibleVersionSet> | undefined, b: CompatibleVersionSet | PlainMessage<CompatibleVersionSet> | undefined): boolean {
    return proto3.util.equals(CompatibleVersionSet, a, b);
  }
}

/**
 * Reachability of tasks for a worker on a single task queue.
 *
 * @generated from message temporal.api.taskqueue.v1.TaskQueueReachability
 */
export class TaskQueueReachability extends Message<TaskQueueReachability> {
  /**
   * @generated from field: string task_queue = 1;
   */
  taskQueue = "";

  /**
   * Task reachability for a worker in a single task queue.
   * See the TaskReachability docstring for information about each enum variant.
   * If reachability is empty, this worker is considered unreachable in this task queue.
   *
   * @generated from field: repeated temporal.api.enums.v1.TaskReachability reachability = 2;
   */
  reachability: TaskReachability[] = [];

  constructor(data?: PartialMessage<TaskQueueReachability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueReachability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reachability", kind: "enum", T: proto3.getEnumType(TaskReachability), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueReachability {
    return new TaskQueueReachability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueReachability {
    return new TaskQueueReachability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueReachability {
    return new TaskQueueReachability().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueReachability | PlainMessage<TaskQueueReachability> | undefined, b: TaskQueueReachability | PlainMessage<TaskQueueReachability> | undefined): boolean {
    return proto3.util.equals(TaskQueueReachability, a, b);
  }
}

/**
 * Reachability of tasks for a worker by build id, in one or more task queues.
 *
 * @generated from message temporal.api.taskqueue.v1.BuildIdReachability
 */
export class BuildIdReachability extends Message<BuildIdReachability> {
  /**
   * A build id or empty if unversioned.
   *
   * @generated from field: string build_id = 1;
   */
  buildId = "";

  /**
   * Reachability per task queue.
   *
   * @generated from field: repeated temporal.api.taskqueue.v1.TaskQueueReachability task_queue_reachability = 2;
   */
  taskQueueReachability: TaskQueueReachability[] = [];

  constructor(data?: PartialMessage<BuildIdReachability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.BuildIdReachability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "task_queue_reachability", kind: "message", T: TaskQueueReachability, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildIdReachability {
    return new BuildIdReachability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildIdReachability {
    return new BuildIdReachability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildIdReachability {
    return new BuildIdReachability().fromJsonString(jsonString, options);
  }

  static equals(a: BuildIdReachability | PlainMessage<BuildIdReachability> | undefined, b: BuildIdReachability | PlainMessage<BuildIdReachability> | undefined): boolean {
    return proto3.util.equals(BuildIdReachability, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.RampByPercentage
 */
export class RampByPercentage extends Message<RampByPercentage> {
  /**
   * Acceptable range is [0,100).
   *
   * @generated from field: float ramp_percentage = 1;
   */
  rampPercentage = 0;

  constructor(data?: PartialMessage<RampByPercentage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.RampByPercentage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ramp_percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RampByPercentage {
    return new RampByPercentage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RampByPercentage {
    return new RampByPercentage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RampByPercentage {
    return new RampByPercentage().fromJsonString(jsonString, options);
  }

  static equals(a: RampByPercentage | PlainMessage<RampByPercentage> | undefined, b: RampByPercentage | PlainMessage<RampByPercentage> | undefined): boolean {
    return proto3.util.equals(RampByPercentage, a, b);
  }
}

/**
 * Assignment rules are applied to *new* Workflow and Activity executions at
 * schedule time to assign them to a Build ID.
 *
 * Assignment rules will not be used in the following cases:
 *    - Child Workflows or Continue-As-New Executions who inherit their
 *      parent/previous Workflow's assigned Build ID (by setting the
 *      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
 *      is used.)
 *    - An Activity that inherits the assigned Build ID of its Workflow (by
 *      setting the `use_workflow_build_id` flag - default behavior in SDKs
 *      when the same Task Queue is used.)
 *
 * In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
 * the task will be dispatched to Workers of the Build ID determined by the
 * assignment rules (or inherited). Otherwise, the final Build ID will be
 * determined by the redirect rules.
 *
 * Once a Workflow completes its first Workflow Task in a particular Build ID it
 * stays in that Build ID regardless of changes to assignment rules. Redirect
 * rules can be used to move the workflow to another compatible Build ID.
 *
 * When using Worker Versioning on a Task Queue, in the steady state,
 * there should typically be a single assignment rule to send all new executions
 * to the latest Build ID. Existence of at least one such "unconditional"
 * rule at all times is enforces by the system, unless the `force` flag is used
 * by the user when replacing/deleting these rules (for exceptional cases).
 *
 * During a deployment, one or more additional rules can be added to assign a
 * subset of the tasks to a new Build ID based on a "ramp percentage".
 *
 * When there are multiple assignment rules for a Task Queue, the rules are
 * evaluated in order, starting from index 0. The first applicable rule will be
 * applied and the rest will be ignored.
 *
 * In the event that no assignment rule is applicable on a task (or the Task
 * Queue is simply not versioned), the tasks will be dispatched to an
 * unversioned Worker.
 *
 * @generated from message temporal.api.taskqueue.v1.BuildIdAssignmentRule
 */
export class BuildIdAssignmentRule extends Message<BuildIdAssignmentRule> {
  /**
   * @generated from field: string target_build_id = 1;
   */
  targetBuildId = "";

  /**
   * If a ramp is provided, this rule will be applied only to a sample of
   * tasks according to the provided percentage.
   * This option can be used only on "terminal" Build IDs (the ones not used
   * as source in any redirect rules).
   *
   * @generated from oneof temporal.api.taskqueue.v1.BuildIdAssignmentRule.ramp
   */
  ramp: {
    /**
     * This ramp is useful for gradual Blue/Green deployments (and similar)
     * where you want to send a certain portion of the traffic to the target
     * Build ID.
     *
     * @generated from field: temporal.api.taskqueue.v1.RampByPercentage percentage_ramp = 3;
     */
    value: RampByPercentage;
    case: "percentageRamp";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BuildIdAssignmentRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.BuildIdAssignmentRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "percentage_ramp", kind: "message", T: RampByPercentage, oneof: "ramp" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildIdAssignmentRule {
    return new BuildIdAssignmentRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildIdAssignmentRule {
    return new BuildIdAssignmentRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildIdAssignmentRule {
    return new BuildIdAssignmentRule().fromJsonString(jsonString, options);
  }

  static equals(a: BuildIdAssignmentRule | PlainMessage<BuildIdAssignmentRule> | undefined, b: BuildIdAssignmentRule | PlainMessage<BuildIdAssignmentRule> | undefined): boolean {
    return proto3.util.equals(BuildIdAssignmentRule, a, b);
  }
}

/**
 * These rules apply to tasks assigned to a particular Build ID
 * (`source_build_id`) to redirect them to another *compatible* Build ID
 * (`target_build_id`).
 *
 * It is user's responsibility to ensure that the target Build ID is compatible
 * with the source Build ID (e.g. by using the Patching API).
 *
 * Most deployments are not expected to need these rules, however following
 * situations can greatly benefit from redirects:
 *  - Need to move long-running Workflow Executions from an old Build ID to a
 *    newer one.
 *  - Need to hotfix some broken or stuck Workflow Executions.
 *
 * In steady state, redirect rules are beneficial when dealing with old
 * Executions ran on now-decommissioned Build IDs:
 *  - To redirecting the Workflow Queries to the current (compatible) Build ID.
 *  - To be able to Reset an old Execution so it can run on the current
 *    (compatible) Build ID.
 *
 * Redirect rules can be chained.
 *
 * @generated from message temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule
 */
export class CompatibleBuildIdRedirectRule extends Message<CompatibleBuildIdRedirectRule> {
  /**
   * @generated from field: string source_build_id = 1;
   */
  sourceBuildId = "";

  /**
   * Target Build ID must be compatible with the Source Build ID; that is it
   * must be able to process event histories made by the Source Build ID by
   * using [Patching](https://docs.temporal.io/workflows#patching) or other
   * means.
   *
   * @generated from field: string target_build_id = 2;
   */
  targetBuildId = "";

  constructor(data?: PartialMessage<CompatibleBuildIdRedirectRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompatibleBuildIdRedirectRule {
    return new CompatibleBuildIdRedirectRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompatibleBuildIdRedirectRule {
    return new CompatibleBuildIdRedirectRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompatibleBuildIdRedirectRule {
    return new CompatibleBuildIdRedirectRule().fromJsonString(jsonString, options);
  }

  static equals(a: CompatibleBuildIdRedirectRule | PlainMessage<CompatibleBuildIdRedirectRule> | undefined, b: CompatibleBuildIdRedirectRule | PlainMessage<CompatibleBuildIdRedirectRule> | undefined): boolean {
    return proto3.util.equals(CompatibleBuildIdRedirectRule, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule
 */
export class TimestampedBuildIdAssignmentRule extends Message<TimestampedBuildIdAssignmentRule> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 1;
   */
  rule?: BuildIdAssignmentRule;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  constructor(data?: PartialMessage<TimestampedBuildIdAssignmentRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: BuildIdAssignmentRule },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampedBuildIdAssignmentRule {
    return new TimestampedBuildIdAssignmentRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampedBuildIdAssignmentRule {
    return new TimestampedBuildIdAssignmentRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampedBuildIdAssignmentRule {
    return new TimestampedBuildIdAssignmentRule().fromJsonString(jsonString, options);
  }

  static equals(a: TimestampedBuildIdAssignmentRule | PlainMessage<TimestampedBuildIdAssignmentRule> | undefined, b: TimestampedBuildIdAssignmentRule | PlainMessage<TimestampedBuildIdAssignmentRule> | undefined): boolean {
    return proto3.util.equals(TimestampedBuildIdAssignmentRule, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule
 */
export class TimestampedCompatibleBuildIdRedirectRule extends Message<TimestampedCompatibleBuildIdRedirectRule> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
   */
  rule?: CompatibleBuildIdRedirectRule;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  constructor(data?: PartialMessage<TimestampedCompatibleBuildIdRedirectRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: CompatibleBuildIdRedirectRule },
    { no: 2, name: "create_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampedCompatibleBuildIdRedirectRule {
    return new TimestampedCompatibleBuildIdRedirectRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampedCompatibleBuildIdRedirectRule {
    return new TimestampedCompatibleBuildIdRedirectRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampedCompatibleBuildIdRedirectRule {
    return new TimestampedCompatibleBuildIdRedirectRule().fromJsonString(jsonString, options);
  }

  static equals(a: TimestampedCompatibleBuildIdRedirectRule | PlainMessage<TimestampedCompatibleBuildIdRedirectRule> | undefined, b: TimestampedCompatibleBuildIdRedirectRule | PlainMessage<TimestampedCompatibleBuildIdRedirectRule> | undefined): boolean {
    return proto3.util.equals(TimestampedCompatibleBuildIdRedirectRule, a, b);
  }
}

/**
 * Attached to task responses to give hints to the SDK about how it may adjust its number of
 * pollers.
 *
 * @generated from message temporal.api.taskqueue.v1.PollerScalingDecision
 */
export class PollerScalingDecision extends Message<PollerScalingDecision> {
  /**
   * How many poll requests to suggest should be added or removed, if any. As of now, server only
   * scales up or down by 1. However, SDKs should allow for other values (while staying within
   * defined min/max).
   *
   * The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
   * all slots are already occupied.
   *
   * @generated from field: int32 poll_request_delta_suggestion = 1;
   */
  pollRequestDeltaSuggestion = 0;

  constructor(data?: PartialMessage<PollerScalingDecision>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.PollerScalingDecision";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "poll_request_delta_suggestion", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollerScalingDecision {
    return new PollerScalingDecision().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollerScalingDecision {
    return new PollerScalingDecision().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollerScalingDecision {
    return new PollerScalingDecision().fromJsonString(jsonString, options);
  }

  static equals(a: PollerScalingDecision | PlainMessage<PollerScalingDecision> | undefined, b: PollerScalingDecision | PlainMessage<PollerScalingDecision> | undefined): boolean {
    return proto3.util.equals(PollerScalingDecision, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.RateLimit
 */
export class RateLimit extends Message<RateLimit> {
  /**
   * Zero is a valid rate limit.
   *
   * @generated from field: float requests_per_second = 1;
   */
  requestsPerSecond = 0;

  constructor(data?: PartialMessage<RateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.RateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests_per_second", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit {
    return new RateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJsonString(jsonString, options);
  }

  static equals(a: RateLimit | PlainMessage<RateLimit> | undefined, b: RateLimit | PlainMessage<RateLimit> | undefined): boolean {
    return proto3.util.equals(RateLimit, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.ConfigMetadata
 */
export class ConfigMetadata extends Message<ConfigMetadata> {
  /**
   * Reason for why the config was set.
   *
   * @generated from field: string reason = 1;
   */
  reason = "";

  /**
   * Identity of the last updater.
   * Set by the request's identity field.
   *
   * @generated from field: string update_identity = 2;
   */
  updateIdentity = "";

  /**
   * Time of the last update.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 3;
   */
  updateTime?: Timestamp;

  constructor(data?: PartialMessage<ConfigMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.ConfigMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "update_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigMetadata {
    return new ConfigMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigMetadata {
    return new ConfigMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigMetadata {
    return new ConfigMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigMetadata | PlainMessage<ConfigMetadata> | undefined, b: ConfigMetadata | PlainMessage<ConfigMetadata> | undefined): boolean {
    return proto3.util.equals(ConfigMetadata, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.RateLimitConfig
 */
export class RateLimitConfig extends Message<RateLimitConfig> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.RateLimit rate_limit = 1;
   */
  rateLimit?: RateLimit;

  /**
   * @generated from field: temporal.api.taskqueue.v1.ConfigMetadata metadata = 2;
   */
  metadata?: ConfigMetadata;

  constructor(data?: PartialMessage<RateLimitConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.RateLimitConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rate_limit", kind: "message", T: RateLimit },
    { no: 2, name: "metadata", kind: "message", T: ConfigMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig {
    return new RateLimitConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig {
    return new RateLimitConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig {
    return new RateLimitConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RateLimitConfig | PlainMessage<RateLimitConfig> | undefined, b: RateLimitConfig | PlainMessage<RateLimitConfig> | undefined): boolean {
    return proto3.util.equals(RateLimitConfig, a, b);
  }
}

/**
 * @generated from message temporal.api.taskqueue.v1.TaskQueueConfig
 */
export class TaskQueueConfig extends Message<TaskQueueConfig> {
  /**
   * Unless modified, this is the system-defined rate limit.
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimitConfig queue_rate_limit = 1;
   */
  queueRateLimit?: RateLimitConfig;

  /**
   * If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key.
   *
   * @generated from field: temporal.api.taskqueue.v1.RateLimitConfig fairness_keys_rate_limit_default = 2;
   */
  fairnessKeysRateLimitDefault?: RateLimitConfig;

  /**
   * If set, overrides the fairness weights for the corresponding fairness keys.
   *
   * @generated from field: map<string, float> fairness_weight_overrides = 3;
   */
  fairnessWeightOverrides: { [key: string]: number } = {};

  constructor(data?: PartialMessage<TaskQueueConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.taskqueue.v1.TaskQueueConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "queue_rate_limit", kind: "message", T: RateLimitConfig },
    { no: 2, name: "fairness_keys_rate_limit_default", kind: "message", T: RateLimitConfig },
    { no: 3, name: "fairness_weight_overrides", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 2 /* ScalarType.FLOAT */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskQueueConfig {
    return new TaskQueueConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskQueueConfig {
    return new TaskQueueConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskQueueConfig {
    return new TaskQueueConfig().fromJsonString(jsonString, options);
  }

  static equals(a: TaskQueueConfig | PlainMessage<TaskQueueConfig> | undefined, b: TaskQueueConfig | PlainMessage<TaskQueueConfig> | undefined): boolean {
    return proto3.util.equals(TaskQueueConfig, a, b);
  }
}

