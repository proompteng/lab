// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/worker/v1/message.proto (package temporal.api.worker.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { WorkerDeploymentVersion } from "../../deployment/v1/message_pbts";
import { WorkerStatus } from "../../enums/v1/common_pbts";

/**
 * @generated from message temporal.api.worker.v1.WorkerPollerInfo
 */
export class WorkerPollerInfo extends Message<WorkerPollerInfo> {
  /**
   * Number of polling RPCs that are currently in flight.
   *
   * @generated from field: int32 current_pollers = 1;
   */
  currentPollers = 0;

  /**
   * @generated from field: google.protobuf.Timestamp last_successful_poll_time = 2;
   */
  lastSuccessfulPollTime?: Timestamp;

  /**
   * Set true if the number of concurrent pollers is auto-scaled
   *
   * @generated from field: bool is_autoscaling = 3;
   */
  isAutoscaling = false;

  constructor(data?: PartialMessage<WorkerPollerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.WorkerPollerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_pollers", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "last_successful_poll_time", kind: "message", T: Timestamp },
    { no: 3, name: "is_autoscaling", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerPollerInfo {
    return new WorkerPollerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerPollerInfo {
    return new WorkerPollerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerPollerInfo {
    return new WorkerPollerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerPollerInfo | PlainMessage<WorkerPollerInfo> | undefined, b: WorkerPollerInfo | PlainMessage<WorkerPollerInfo> | undefined): boolean {
    return proto3.util.equals(WorkerPollerInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.worker.v1.WorkerSlotsInfo
 */
export class WorkerSlotsInfo extends Message<WorkerSlotsInfo> {
  /**
   * Number of slots available for the worker to specific tasks.
   * May be -1 if the upper bound is not known.
   *
   * @generated from field: int32 current_available_slots = 1;
   */
  currentAvailableSlots = 0;

  /**
   * Number of slots used by the worker for specific tasks.
   *
   * @generated from field: int32 current_used_slots = 2;
   */
  currentUsedSlots = 0;

  /**
   * Kind of the slot supplier, which is used to determine how the slots are allocated.
   * Possible values: "Fixed | ResourceBased | Custom String"
   *
   * @generated from field: string slot_supplier_kind = 3;
   */
  slotSupplierKind = "";

  /**
   * Total number of tasks processed (completed both successfully and unsuccesfully, or any other way)
   * by the worker since the worker started. This is a cumulative counter.
   *
   * @generated from field: int32 total_processed_tasks = 4;
   */
  totalProcessedTasks = 0;

  /**
   * Total number of failed tasks processed by the worker so far.
   *
   * @generated from field: int32 total_failed_tasks = 5;
   */
  totalFailedTasks = 0;

  /**
   * Number of tasks processed in since the last heartbeat from the worker.
   * This is a cumulative counter, and it is reset to 0 each time the worker sends a heartbeat.
   * Contains both successful and failed tasks.
   *
   * @generated from field: int32 last_interval_processed_tasks = 6;
   */
  lastIntervalProcessedTasks = 0;

  /**
   * Number of failed tasks processed since the last heartbeat from the worker.
   *
   * @generated from field: int32 last_interval_failure_tasks = 7;
   */
  lastIntervalFailureTasks = 0;

  constructor(data?: PartialMessage<WorkerSlotsInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.WorkerSlotsInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_available_slots", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "current_used_slots", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "slot_supplier_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total_processed_tasks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "total_failed_tasks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "last_interval_processed_tasks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "last_interval_failure_tasks", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerSlotsInfo {
    return new WorkerSlotsInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerSlotsInfo {
    return new WorkerSlotsInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerSlotsInfo {
    return new WorkerSlotsInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerSlotsInfo | PlainMessage<WorkerSlotsInfo> | undefined, b: WorkerSlotsInfo | PlainMessage<WorkerSlotsInfo> | undefined): boolean {
    return proto3.util.equals(WorkerSlotsInfo, a, b);
  }
}

/**
 * Holds everything needed to identify the worker host/process context
 *
 * @generated from message temporal.api.worker.v1.WorkerHostInfo
 */
export class WorkerHostInfo extends Message<WorkerHostInfo> {
  /**
   * Worker host identifier.
   *
   * @generated from field: string host_name = 1;
   */
  hostName = "";

  /**
   * Worker grouping identifier. A key to group workers that share the same client+namespace+process.
   * This will be used to build the worker command nexus task queue name:
   * "temporal-sys/worker-commands/{worker_grouping_key}"
   *
   * @generated from field: string worker_grouping_key = 5;
   */
  workerGroupingKey = "";

  /**
   * Worker process identifier. This id only needs to be unique
   * within one host (so using e.g. a unix pid would be appropriate).
   *
   * @generated from field: string process_id = 2;
   */
  processId = "";

  /**
   * System used CPU as a float in the range [0.0, 1.0] where 1.0 is defined as all
   * cores on the host pegged.
   *
   * @generated from field: float current_host_cpu_usage = 3;
   */
  currentHostCpuUsage = 0;

  /**
   * System used memory as a float in the range [0.0, 1.0] where 1.0 is defined as
   * all available memory on the host is used.
   *
   * @generated from field: float current_host_mem_usage = 4;
   */
  currentHostMemUsage = 0;

  constructor(data?: PartialMessage<WorkerHostInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.WorkerHostInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "worker_grouping_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "process_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "current_host_cpu_usage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "current_host_mem_usage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerHostInfo {
    return new WorkerHostInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerHostInfo {
    return new WorkerHostInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerHostInfo {
    return new WorkerHostInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerHostInfo | PlainMessage<WorkerHostInfo> | undefined, b: WorkerHostInfo | PlainMessage<WorkerHostInfo> | undefined): boolean {
    return proto3.util.equals(WorkerHostInfo, a, b);
  }
}

/**
 * Worker info message, contains information about the worker and its current state.
 * All information is provided by the worker itself.
 * (-- api-linter: core::0140::prepositions=disabled
 *     aip.dev/not-precedent: Removing those words make names less clear. --)
 *
 * @generated from message temporal.api.worker.v1.WorkerHeartbeat
 */
export class WorkerHeartbeat extends Message<WorkerHeartbeat> {
  /**
   * Worker identifier, should be unique for the namespace.
   * It is distinct from worker identity, which is not necessarily namespace-unique.
   *
   * @generated from field: string worker_instance_key = 1;
   */
  workerInstanceKey = "";

  /**
   * Worker identity, set by the client, may not be unique.
   * Usually host_name+(user group name)+process_id, but can be overwritten by the user.
   *
   * @generated from field: string worker_identity = 2;
   */
  workerIdentity = "";

  /**
   * Worker host information.
   *
   * @generated from field: temporal.api.worker.v1.WorkerHostInfo host_info = 3;
   */
  hostInfo?: WorkerHostInfo;

  /**
   * Task queue this worker is polling for tasks.
   *
   * @generated from field: string task_queue = 4;
   */
  taskQueue = "";

  /**
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 5;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * @generated from field: string sdk_name = 6;
   */
  sdkName = "";

  /**
   * @generated from field: string sdk_version = 7;
   */
  sdkVersion = "";

  /**
   * Worker status. Defined by SDK.
   *
   * @generated from field: temporal.api.enums.v1.WorkerStatus status = 8;
   */
  status = WorkerStatus.UNSPECIFIED;

  /**
   * Worker start time.
   * It can be used to determine worker uptime. (current time - start time)
   *
   * @generated from field: google.protobuf.Timestamp start_time = 9;
   */
  startTime?: Timestamp;

  /**
   * Timestamp of this heartbeat, coming from the worker. Worker should set it to "now".
   * Note that this timestamp comes directly from the worker and is subject to workers' clock skew.
   *
   * @generated from field: google.protobuf.Timestamp heartbeat_time = 10;
   */
  heartbeatTime?: Timestamp;

  /**
   * Elapsed time since the last heartbeat from the worker.
   *
   * @generated from field: google.protobuf.Duration elapsed_since_last_heartbeat = 11;
   */
  elapsedSinceLastHeartbeat?: Duration;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerSlotsInfo workflow_task_slots_info = 12;
   */
  workflowTaskSlotsInfo?: WorkerSlotsInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerSlotsInfo activity_task_slots_info = 13;
   */
  activityTaskSlotsInfo?: WorkerSlotsInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerSlotsInfo nexus_task_slots_info = 14;
   */
  nexusTaskSlotsInfo?: WorkerSlotsInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerSlotsInfo local_activity_slots_info = 15;
   */
  localActivitySlotsInfo?: WorkerSlotsInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerPollerInfo workflow_poller_info = 16;
   */
  workflowPollerInfo?: WorkerPollerInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerPollerInfo workflow_sticky_poller_info = 17;
   */
  workflowStickyPollerInfo?: WorkerPollerInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerPollerInfo activity_poller_info = 18;
   */
  activityPollerInfo?: WorkerPollerInfo;

  /**
   * @generated from field: temporal.api.worker.v1.WorkerPollerInfo nexus_poller_info = 19;
   */
  nexusPollerInfo?: WorkerPollerInfo;

  /**
   * A Workflow Task found a cached Workflow Execution to run against.
   *
   * @generated from field: int32 total_sticky_cache_hit = 20;
   */
  totalStickyCacheHit = 0;

  /**
   * A Workflow Task did not find a cached Workflow execution to run against.
   *
   * @generated from field: int32 total_sticky_cache_miss = 21;
   */
  totalStickyCacheMiss = 0;

  /**
   * Current cache size, expressed in number of Workflow Executions.
   *
   * @generated from field: int32 current_sticky_cache_size = 22;
   */
  currentStickyCacheSize = 0;

  /**
   * Plugins currently in use by this SDK.
   *
   * @generated from field: repeated temporal.api.worker.v1.PluginInfo plugins = 23;
   */
  plugins: PluginInfo[] = [];

  constructor(data?: PartialMessage<WorkerHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.WorkerHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_instance_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "worker_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "host_info", kind: "message", T: WorkerHostInfo },
    { no: 4, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 6, name: "sdk_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "sdk_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(WorkerStatus) },
    { no: 9, name: "start_time", kind: "message", T: Timestamp },
    { no: 10, name: "heartbeat_time", kind: "message", T: Timestamp },
    { no: 11, name: "elapsed_since_last_heartbeat", kind: "message", T: Duration },
    { no: 12, name: "workflow_task_slots_info", kind: "message", T: WorkerSlotsInfo },
    { no: 13, name: "activity_task_slots_info", kind: "message", T: WorkerSlotsInfo },
    { no: 14, name: "nexus_task_slots_info", kind: "message", T: WorkerSlotsInfo },
    { no: 15, name: "local_activity_slots_info", kind: "message", T: WorkerSlotsInfo },
    { no: 16, name: "workflow_poller_info", kind: "message", T: WorkerPollerInfo },
    { no: 17, name: "workflow_sticky_poller_info", kind: "message", T: WorkerPollerInfo },
    { no: 18, name: "activity_poller_info", kind: "message", T: WorkerPollerInfo },
    { no: 19, name: "nexus_poller_info", kind: "message", T: WorkerPollerInfo },
    { no: 20, name: "total_sticky_cache_hit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 21, name: "total_sticky_cache_miss", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 22, name: "current_sticky_cache_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 23, name: "plugins", kind: "message", T: PluginInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerHeartbeat {
    return new WorkerHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerHeartbeat {
    return new WorkerHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerHeartbeat {
    return new WorkerHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerHeartbeat | PlainMessage<WorkerHeartbeat> | undefined, b: WorkerHeartbeat | PlainMessage<WorkerHeartbeat> | undefined): boolean {
    return proto3.util.equals(WorkerHeartbeat, a, b);
  }
}

/**
 * @generated from message temporal.api.worker.v1.WorkerInfo
 */
export class WorkerInfo extends Message<WorkerInfo> {
  /**
   * @generated from field: temporal.api.worker.v1.WorkerHeartbeat worker_heartbeat = 1;
   */
  workerHeartbeat?: WorkerHeartbeat;

  constructor(data?: PartialMessage<WorkerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.WorkerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "worker_heartbeat", kind: "message", T: WorkerHeartbeat },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkerInfo {
    return new WorkerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkerInfo {
    return new WorkerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkerInfo {
    return new WorkerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkerInfo | PlainMessage<WorkerInfo> | undefined, b: WorkerInfo | PlainMessage<WorkerInfo> | undefined): boolean {
    return proto3.util.equals(WorkerInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.worker.v1.PluginInfo
 */
export class PluginInfo extends Message<PluginInfo> {
  /**
   * The name of the plugin, required.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The version of the plugin, may be empty.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<PluginInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.worker.v1.PluginInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginInfo {
    return new PluginInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginInfo {
    return new PluginInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginInfo {
    return new PluginInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PluginInfo | PlainMessage<PluginInfo> | undefined, b: PluginInfo | PlainMessage<PluginInfo> | undefined): boolean {
    return proto3.util.equals(PluginInfo, a, b);
  }
}

