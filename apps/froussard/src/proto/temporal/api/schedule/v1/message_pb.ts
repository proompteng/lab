// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/schedule/v1/message.proto (package temporal.api.schedule.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ScheduleOverlapPolicy } from "../../enums/v1/schedule_pbts";
import { NewWorkflowExecutionInfo } from "../../workflow/v1/message_pbts";
import { Memo, SearchAttributes, WorkflowExecution, WorkflowType } from "../../common/v1/message_pbts";
import { WorkflowExecutionStatus } from "../../enums/v1/workflow_pbts";

/**
 * CalendarSpec describes an event specification relative to the calendar,
 * similar to a traditional cron specification, but with labeled fields. Each
 * field can be one of:
 *   *: matches always
 *   x: matches when the field equals x
 *   x/y : matches when the field equals x+n*y where n is an integer
 *   x-z: matches when the field is between x and z inclusive
 *   w,x,y,...: matches when the field is one of the listed values
 * Each x, y, z, ... is either a decimal integer, or a month or day of week name
 * or abbreviation (in the appropriate fields).
 * A timestamp matches if all fields match.
 * Note that fields have different default values, for convenience.
 * Note that the special case that some cron implementations have for treating
 * day_of_month and day_of_week as "or" instead of "and" when both are set is
 * not implemented.
 * day_of_week can accept 0 or 7 as Sunday
 * CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
 * returned if you describe the schedule.
 *
 * @generated from message temporal.api.schedule.v1.CalendarSpec
 */
export class CalendarSpec extends Message<CalendarSpec> {
  /**
   * Expression to match seconds. Default: 0
   *
   * @generated from field: string second = 1;
   */
  second = "";

  /**
   * Expression to match minutes. Default: 0
   *
   * @generated from field: string minute = 2;
   */
  minute = "";

  /**
   * Expression to match hours. Default: 0
   *
   * @generated from field: string hour = 3;
   */
  hour = "";

  /**
   * Expression to match days of the month. Default: *
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: standard name of field --)
   *
   * @generated from field: string day_of_month = 4;
   */
  dayOfMonth = "";

  /**
   * Expression to match months. Default: *
   *
   * @generated from field: string month = 5;
   */
  month = "";

  /**
   * Expression to match years. Default: *
   *
   * @generated from field: string year = 6;
   */
  year = "";

  /**
   * Expression to match days of the week. Default: *
   *
   * @generated from field: string day_of_week = 7;
   */
  dayOfWeek = "";

  /**
   * Free-form comment describing the intention of this spec.
   *
   * @generated from field: string comment = 8;
   */
  comment = "";

  constructor(data?: PartialMessage<CalendarSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.CalendarSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "second", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "minute", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hour", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "day_of_month", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "month", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "year", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "day_of_week", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CalendarSpec {
    return new CalendarSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CalendarSpec {
    return new CalendarSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CalendarSpec {
    return new CalendarSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CalendarSpec | PlainMessage<CalendarSpec> | undefined, b: CalendarSpec | PlainMessage<CalendarSpec> | undefined): boolean {
    return proto3.util.equals(CalendarSpec, a, b);
  }
}

/**
 * Range represents a set of integer values, used to match fields of a calendar
 * time in StructuredCalendarSpec. If end < start, then end is interpreted as
 * equal to start. This means you can use a Range with start set to a value, and
 * end and step unset (defaulting to 0) to represent a single value.
 *
 * @generated from message temporal.api.schedule.v1.Range
 */
export class Range extends Message<Range> {
  /**
   * Start of range (inclusive).
   *
   * @generated from field: int32 start = 1;
   */
  start = 0;

  /**
   * End of range (inclusive).
   *
   * @generated from field: int32 end = 2;
   */
  end = 0;

  /**
   * Step (optional, default 1).
   *
   * @generated from field: int32 step = 3;
   */
  step = 0;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "end", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "step", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * StructuredCalendarSpec describes an event specification relative to the
 * calendar, in a form that's easy to work with programmatically. Each field can
 * be one or more ranges.
 * A timestamp matches if at least one range of each field matches the
 * corresponding fields of the timestamp, except for year: if year is missing,
 * that means all years match. For all fields besides year, at least one Range
 * must be present to match anything.
 * TODO: add relative-to-end-of-month
 * TODO: add nth day-of-week in month
 *
 * @generated from message temporal.api.schedule.v1.StructuredCalendarSpec
 */
export class StructuredCalendarSpec extends Message<StructuredCalendarSpec> {
  /**
   * Match seconds (0-59)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range second = 1;
   */
  second: Range[] = [];

  /**
   * Match minutes (0-59)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range minute = 2;
   */
  minute: Range[] = [];

  /**
   * Match hours (0-23)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range hour = 3;
   */
  hour: Range[] = [];

  /**
   * Match days of the month (1-31)
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: standard name of field --)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range day_of_month = 4;
   */
  dayOfMonth: Range[] = [];

  /**
   * Match months (1-12)
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range month = 5;
   */
  month: Range[] = [];

  /**
   * Match years.
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range year = 6;
   */
  year: Range[] = [];

  /**
   * Match days of the week (0-6; 0 is Sunday).
   *
   * @generated from field: repeated temporal.api.schedule.v1.Range day_of_week = 7;
   */
  dayOfWeek: Range[] = [];

  /**
   * Free-form comment describing the intention of this spec.
   *
   * @generated from field: string comment = 8;
   */
  comment = "";

  constructor(data?: PartialMessage<StructuredCalendarSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.StructuredCalendarSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "second", kind: "message", T: Range, repeated: true },
    { no: 2, name: "minute", kind: "message", T: Range, repeated: true },
    { no: 3, name: "hour", kind: "message", T: Range, repeated: true },
    { no: 4, name: "day_of_month", kind: "message", T: Range, repeated: true },
    { no: 5, name: "month", kind: "message", T: Range, repeated: true },
    { no: 6, name: "year", kind: "message", T: Range, repeated: true },
    { no: 7, name: "day_of_week", kind: "message", T: Range, repeated: true },
    { no: 8, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StructuredCalendarSpec {
    return new StructuredCalendarSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StructuredCalendarSpec {
    return new StructuredCalendarSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StructuredCalendarSpec {
    return new StructuredCalendarSpec().fromJsonString(jsonString, options);
  }

  static equals(a: StructuredCalendarSpec | PlainMessage<StructuredCalendarSpec> | undefined, b: StructuredCalendarSpec | PlainMessage<StructuredCalendarSpec> | undefined): boolean {
    return proto3.util.equals(StructuredCalendarSpec, a, b);
  }
}

/**
 * IntervalSpec matches times that can be expressed as:
 * epoch + n * interval + phase
 * where n is an integer.
 * phase defaults to zero if missing. interval is required.
 * Both interval and phase must be non-negative and are truncated to the nearest
 * second before any calculations.
 * For example, an interval of 1 hour with phase of zero would match every hour,
 * on the hour. The same interval but a phase of 19 minutes would match every
 * xx:19:00. An interval of 28 days with phase zero would match
 * 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
 * days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
 *
 * @generated from message temporal.api.schedule.v1.IntervalSpec
 */
export class IntervalSpec extends Message<IntervalSpec> {
  /**
   * @generated from field: google.protobuf.Duration interval = 1;
   */
  interval?: Duration;

  /**
   * @generated from field: google.protobuf.Duration phase = 2;
   */
  phase?: Duration;

  constructor(data?: PartialMessage<IntervalSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.IntervalSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interval", kind: "message", T: Duration },
    { no: 2, name: "phase", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntervalSpec {
    return new IntervalSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntervalSpec {
    return new IntervalSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntervalSpec {
    return new IntervalSpec().fromJsonString(jsonString, options);
  }

  static equals(a: IntervalSpec | PlainMessage<IntervalSpec> | undefined, b: IntervalSpec | PlainMessage<IntervalSpec> | undefined): boolean {
    return proto3.util.equals(IntervalSpec, a, b);
  }
}

/**
 * ScheduleSpec is a complete description of a set of absolute timestamps
 * (possibly infinite) that an action should occur at. The meaning of a
 * ScheduleSpec depends only on its contents and never changes, except that the
 * definition of a time zone can change over time (most commonly, when daylight
 * saving time policy changes for an area). To create a totally self-contained
 * ScheduleSpec, use UTC or include timezone_data.
 *
 * For input, you can provide zero or more of: structured_calendar, calendar,
 * cron_string, interval, and exclude_structured_calendar, and all of them will
 * be used (the schedule will take action at the union of all of their times,
 * minus the ones that match exclude_structured_calendar).
 *
 * On input, calendar and cron_string fields will be compiled into
 * structured_calendar (and maybe interval and timezone_name), so if you
 * Describe a schedule, you'll see only structured_calendar, interval, etc.
 *
 * If a spec has no matching times after the current time, then the schedule
 * will be subject to automatic deletion (after several days).
 *
 * @generated from message temporal.api.schedule.v1.ScheduleSpec
 */
export class ScheduleSpec extends Message<ScheduleSpec> {
  /**
   * Calendar-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.StructuredCalendarSpec structured_calendar = 7;
   */
  structuredCalendar: StructuredCalendarSpec[] = [];

  /**
   * cron_string holds a traditional cron specification as a string. It
   * accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
   * same way as CalendarSpec.
   * 5 fields:         minute, hour, day_of_month, month, day_of_week
   * 6 fields:         minute, hour, day_of_month, month, day_of_week, year
   * 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
   * If year is not given, it defaults to *. If second is not given, it
   * defaults to 0.
   * Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
   * accepted instead of the 5-7 time fields.
   * Optionally, the string can be preceded by CRON_TZ=<timezone name> or
   * TZ=<timezone name>, which will get copied to timezone_name. (There must
   * not also be a timezone_name present.)
   * Optionally "#" followed by a comment can appear at the end of the string.
   * Note that the special case that some cron implementations have for
   * treating day_of_month and day_of_week as "or" instead of "and" when both
   * are set is not implemented.
   * @every <interval>[/<phase>] is accepted and gets compiled into an
   * IntervalSpec instead. <interval> and <phase> should be a decimal integer
   * with a unit suffix s, m, h, or d.
   *
   * @generated from field: repeated string cron_string = 8;
   */
  cronString: string[] = [];

  /**
   * Calendar-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.CalendarSpec calendar = 1;
   */
  calendar: CalendarSpec[] = [];

  /**
   * Interval-based specifications of times.
   *
   * @generated from field: repeated temporal.api.schedule.v1.IntervalSpec interval = 2;
   */
  interval: IntervalSpec[] = [];

  /**
   * Any timestamps matching any of exclude_* will be skipped.
   * Deprecated. Use exclude_structured_calendar.
   *
   * @generated from field: repeated temporal.api.schedule.v1.CalendarSpec exclude_calendar = 3 [deprecated = true];
   * @deprecated
   */
  excludeCalendar: CalendarSpec[] = [];

  /**
   * @generated from field: repeated temporal.api.schedule.v1.StructuredCalendarSpec exclude_structured_calendar = 9;
   */
  excludeStructuredCalendar: StructuredCalendarSpec[] = [];

  /**
   * If start_time is set, any timestamps before start_time will be skipped.
   * (Together, start_time and end_time make an inclusive interval.)
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * If end_time is set, any timestamps after end_time will be skipped.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 5;
   */
  endTime?: Timestamp;

  /**
   * All timestamps will be incremented by a random value from 0 to this
   * amount of jitter. Default: 0
   *
   * @generated from field: google.protobuf.Duration jitter = 6;
   */
  jitter?: Duration;

  /**
   * Time zone to interpret all calendar-based specs in.
   *
   * If unset, defaults to UTC. We recommend using UTC for your application if
   * at all possible, to avoid various surprising properties of time zones.
   *
   * Time zones may be provided by name, corresponding to names in the IANA
   * time zone database (see https://www.iana.org/time-zones). The definition
   * will be loaded by the Temporal server from the environment it runs in.
   *
   * If your application requires more control over the time zone definition
   * used, it may pass in a complete definition in the form of a TZif file
   * from the time zone database. If present, this will be used instead of
   * loading anything from the environment. You are then responsible for
   * updating timezone_data when the definition changes.
   *
   * Calendar spec matching is based on literal matching of the clock time
   * with no special handling of DST: if you write a calendar spec that fires
   * at 2:30am and specify a time zone that follows DST, that action will not
   * be triggered on the day that has no 2:30am. Similarly, an action that
   * fires at 1:30am will be triggered twice on the day that has two 1:30s.
   *
   * Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
   *
   * @generated from field: string timezone_name = 10;
   */
  timezoneName = "";

  /**
   * @generated from field: bytes timezone_data = 11;
   */
  timezoneData = new Uint8Array(0);

  constructor(data?: PartialMessage<ScheduleSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "structured_calendar", kind: "message", T: StructuredCalendarSpec, repeated: true },
    { no: 8, name: "cron_string", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 1, name: "calendar", kind: "message", T: CalendarSpec, repeated: true },
    { no: 2, name: "interval", kind: "message", T: IntervalSpec, repeated: true },
    { no: 3, name: "exclude_calendar", kind: "message", T: CalendarSpec, repeated: true },
    { no: 9, name: "exclude_structured_calendar", kind: "message", T: StructuredCalendarSpec, repeated: true },
    { no: 4, name: "start_time", kind: "message", T: Timestamp },
    { no: 5, name: "end_time", kind: "message", T: Timestamp },
    { no: 6, name: "jitter", kind: "message", T: Duration },
    { no: 10, name: "timezone_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "timezone_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleSpec {
    return new ScheduleSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleSpec {
    return new ScheduleSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleSpec {
    return new ScheduleSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleSpec | PlainMessage<ScheduleSpec> | undefined, b: ScheduleSpec | PlainMessage<ScheduleSpec> | undefined): boolean {
    return proto3.util.equals(ScheduleSpec, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.SchedulePolicies
 */
export class SchedulePolicies extends Message<SchedulePolicies> {
  /**
   * Policy for overlaps.
   * Note that this can be changed after a schedule has taken some actions,
   * and some changes might produce unintuitive results. In general, the later
   * policy overrides the earlier policy.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 1;
   */
  overlapPolicy = ScheduleOverlapPolicy.UNSPECIFIED;

  /**
   * Policy for catchups:
   * If the Temporal server misses an action due to one or more components
   * being down, and comes back up, the action will be run if the scheduled
   * time is within this window from the current time.
   * This value defaults to one year, and can't be less than 10 seconds.
   *
   * @generated from field: google.protobuf.Duration catchup_window = 2;
   */
  catchupWindow?: Duration;

  /**
   * If true, and a workflow run fails or times out, turn on "paused".
   * This applies after retry policies: the full chain of retries must fail to
   * trigger a pause here.
   *
   * @generated from field: bool pause_on_failure = 3;
   */
  pauseOnFailure = false;

  /**
   * If true, and the action would start a workflow, a timestamp will not be
   * appended to the scheduled workflow id.
   *
   * @generated from field: bool keep_original_workflow_id = 4;
   */
  keepOriginalWorkflowId = false;

  constructor(data?: PartialMessage<SchedulePolicies>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.SchedulePolicies";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overlap_policy", kind: "enum", T: proto3.getEnumType(ScheduleOverlapPolicy) },
    { no: 2, name: "catchup_window", kind: "message", T: Duration },
    { no: 3, name: "pause_on_failure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "keep_original_workflow_id", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchedulePolicies {
    return new SchedulePolicies().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchedulePolicies {
    return new SchedulePolicies().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchedulePolicies {
    return new SchedulePolicies().fromJsonString(jsonString, options);
  }

  static equals(a: SchedulePolicies | PlainMessage<SchedulePolicies> | undefined, b: SchedulePolicies | PlainMessage<SchedulePolicies> | undefined): boolean {
    return proto3.util.equals(SchedulePolicies, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.ScheduleAction
 */
export class ScheduleAction extends Message<ScheduleAction> {
  /**
   * @generated from oneof temporal.api.schedule.v1.ScheduleAction.action
   */
  action: {
    /**
     * All fields of NewWorkflowExecutionInfo are valid except for:
     * - workflow_id_reuse_policy
     * - cron_schedule
     * The workflow id of the started workflow may not match this exactly,
     * it may have a timestamp appended for uniqueness.
     *
     * @generated from field: temporal.api.workflow.v1.NewWorkflowExecutionInfo start_workflow = 1;
     */
    value: NewWorkflowExecutionInfo;
    case: "startWorkflow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ScheduleAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_workflow", kind: "message", T: NewWorkflowExecutionInfo, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleAction {
    return new ScheduleAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleAction {
    return new ScheduleAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleAction {
    return new ScheduleAction().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleAction | PlainMessage<ScheduleAction> | undefined, b: ScheduleAction | PlainMessage<ScheduleAction> | undefined): boolean {
    return proto3.util.equals(ScheduleAction, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.ScheduleActionResult
 */
export class ScheduleActionResult extends Message<ScheduleActionResult> {
  /**
   * Time that the action was taken (according to the schedule, including jitter).
   *
   * @generated from field: google.protobuf.Timestamp schedule_time = 1;
   */
  scheduleTime?: Timestamp;

  /**
   * Time that the action was taken (real time).
   *
   * @generated from field: google.protobuf.Timestamp actual_time = 2;
   */
  actualTime?: Timestamp;

  /**
   * If action was start_workflow:
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution start_workflow_result = 11;
   */
  startWorkflowResult?: WorkflowExecution;

  /**
   * If the action was start_workflow, this field will reflect an
   * eventually-consistent view of the started workflow's status.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus start_workflow_status = 12;
   */
  startWorkflowStatus = WorkflowExecutionStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<ScheduleActionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleActionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule_time", kind: "message", T: Timestamp },
    { no: 2, name: "actual_time", kind: "message", T: Timestamp },
    { no: 11, name: "start_workflow_result", kind: "message", T: WorkflowExecution },
    { no: 12, name: "start_workflow_status", kind: "enum", T: proto3.getEnumType(WorkflowExecutionStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleActionResult {
    return new ScheduleActionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleActionResult {
    return new ScheduleActionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleActionResult {
    return new ScheduleActionResult().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleActionResult | PlainMessage<ScheduleActionResult> | undefined, b: ScheduleActionResult | PlainMessage<ScheduleActionResult> | undefined): boolean {
    return proto3.util.equals(ScheduleActionResult, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.ScheduleState
 */
export class ScheduleState extends Message<ScheduleState> {
  /**
   * Informative human-readable message with contextual notes, e.g. the reason
   * a schedule is paused. The system may overwrite this message on certain
   * conditions, e.g. when pause-on-failure happens.
   *
   * @generated from field: string notes = 1;
   */
  notes = "";

  /**
   * If true, do not take any actions based on the schedule spec.
   *
   * @generated from field: bool paused = 2;
   */
  paused = false;

  /**
   * If limited_actions is true, decrement remaining_actions after each
   * action, and do not take any more scheduled actions if remaining_actions
   * is zero. Actions may still be taken by explicit request (i.e. trigger
   * immediately or backfill). Skipped actions (due to overlap policy) do not
   * count against remaining actions.
   * If a schedule has no more remaining actions, then the schedule will be
   * subject to automatic deletion (after several days).
   *
   * @generated from field: bool limited_actions = 3;
   */
  limitedActions = false;

  /**
   * @generated from field: int64 remaining_actions = 4;
   */
  remainingActions = protoInt64.zero;

  constructor(data?: PartialMessage<ScheduleState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "limited_actions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "remaining_actions", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleState {
    return new ScheduleState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleState {
    return new ScheduleState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleState {
    return new ScheduleState().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleState | PlainMessage<ScheduleState> | undefined, b: ScheduleState | PlainMessage<ScheduleState> | undefined): boolean {
    return proto3.util.equals(ScheduleState, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.TriggerImmediatelyRequest
 */
export class TriggerImmediatelyRequest extends Message<TriggerImmediatelyRequest> {
  /**
   * If set, override overlap policy for this one request.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 1;
   */
  overlapPolicy = ScheduleOverlapPolicy.UNSPECIFIED;

  /**
   * Timestamp used for the identity of the target workflow.
   * If not set the default value is the current time.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 2;
   */
  scheduledTime?: Timestamp;

  constructor(data?: PartialMessage<TriggerImmediatelyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.TriggerImmediatelyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overlap_policy", kind: "enum", T: proto3.getEnumType(ScheduleOverlapPolicy) },
    { no: 2, name: "scheduled_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerImmediatelyRequest {
    return new TriggerImmediatelyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerImmediatelyRequest {
    return new TriggerImmediatelyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerImmediatelyRequest {
    return new TriggerImmediatelyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerImmediatelyRequest | PlainMessage<TriggerImmediatelyRequest> | undefined, b: TriggerImmediatelyRequest | PlainMessage<TriggerImmediatelyRequest> | undefined): boolean {
    return proto3.util.equals(TriggerImmediatelyRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.BackfillRequest
 */
export class BackfillRequest extends Message<BackfillRequest> {
  /**
   * Time range to evaluate schedule in. Currently, this time range is
   * exclusive on start_time and inclusive on end_time. (This is admittedly
   * counterintuitive and it may change in the future, so to be safe, use a
   * start time strictly before a scheduled time.) Also note that an action
   * nominally scheduled in the interval but with jitter that pushes it after
   * end_time will not be included.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * If set, override overlap policy for this request.
   *
   * @generated from field: temporal.api.enums.v1.ScheduleOverlapPolicy overlap_policy = 3;
   */
  overlapPolicy = ScheduleOverlapPolicy.UNSPECIFIED;

  constructor(data?: PartialMessage<BackfillRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.BackfillRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
    { no: 3, name: "overlap_policy", kind: "enum", T: proto3.getEnumType(ScheduleOverlapPolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackfillRequest {
    return new BackfillRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackfillRequest {
    return new BackfillRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackfillRequest {
    return new BackfillRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BackfillRequest | PlainMessage<BackfillRequest> | undefined, b: BackfillRequest | PlainMessage<BackfillRequest> | undefined): boolean {
    return proto3.util.equals(BackfillRequest, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.SchedulePatch
 */
export class SchedulePatch extends Message<SchedulePatch> {
  /**
   * If set, trigger one action immediately.
   *
   * @generated from field: temporal.api.schedule.v1.TriggerImmediatelyRequest trigger_immediately = 1;
   */
  triggerImmediately?: TriggerImmediatelyRequest;

  /**
   * If set, runs though the specified time period(s) and takes actions as if that time
   * passed by right now, all at once. The overlap policy can be overridden for the
   * scope of the backfill.
   *
   * @generated from field: repeated temporal.api.schedule.v1.BackfillRequest backfill_request = 2;
   */
  backfillRequest: BackfillRequest[] = [];

  /**
   * If set, change the state to paused or unpaused (respectively) and set the
   * notes field to the value of the string.
   *
   * @generated from field: string pause = 3;
   */
  pause = "";

  /**
   * @generated from field: string unpause = 4;
   */
  unpause = "";

  constructor(data?: PartialMessage<SchedulePatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.SchedulePatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trigger_immediately", kind: "message", T: TriggerImmediatelyRequest },
    { no: 2, name: "backfill_request", kind: "message", T: BackfillRequest, repeated: true },
    { no: 3, name: "pause", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "unpause", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchedulePatch {
    return new SchedulePatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchedulePatch {
    return new SchedulePatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchedulePatch {
    return new SchedulePatch().fromJsonString(jsonString, options);
  }

  static equals(a: SchedulePatch | PlainMessage<SchedulePatch> | undefined, b: SchedulePatch | PlainMessage<SchedulePatch> | undefined): boolean {
    return proto3.util.equals(SchedulePatch, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.ScheduleInfo
 */
export class ScheduleInfo extends Message<ScheduleInfo> {
  /**
   * Number of actions taken so far.
   *
   * @generated from field: int64 action_count = 1;
   */
  actionCount = protoInt64.zero;

  /**
   * Number of times a scheduled action was skipped due to missing the catchup window.
   *
   * @generated from field: int64 missed_catchup_window = 2;
   */
  missedCatchupWindow = protoInt64.zero;

  /**
   * Number of skipped actions due to overlap.
   *
   * @generated from field: int64 overlap_skipped = 3;
   */
  overlapSkipped = protoInt64.zero;

  /**
   * Number of dropped actions due to buffer limit.
   *
   * @generated from field: int64 buffer_dropped = 10;
   */
  bufferDropped = protoInt64.zero;

  /**
   * Number of actions in the buffer. The buffer holds the actions that cannot
   * be immediately triggered (due to the overlap policy). These actions can be a result of
   * the normal schedule or a backfill.
   *
   * @generated from field: int64 buffer_size = 11;
   */
  bufferSize = protoInt64.zero;

  /**
   * Currently-running workflows started by this schedule. (There might be
   * more than one if the overlap policy allows overlaps.)
   * Note that the run_ids in here are the original execution run ids as
   * started by the schedule. If the workflows retried, did continue-as-new,
   * or were reset, they might still be running but with a different run_id.
   *
   * @generated from field: repeated temporal.api.common.v1.WorkflowExecution running_workflows = 9;
   */
  runningWorkflows: WorkflowExecution[] = [];

  /**
   * Most recent ten actual action times (including manual triggers).
   *
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleActionResult recent_actions = 4;
   */
  recentActions: ScheduleActionResult[] = [];

  /**
   * Next ten scheduled action times.
   *
   * @generated from field: repeated google.protobuf.Timestamp future_action_times = 5;
   */
  futureActionTimes: Timestamp[] = [];

  /**
   * Timestamps of schedule creation and last update.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 7;
   */
  updateTime?: Timestamp;

  /**
   * Deprecated.
   *
   * @generated from field: string invalid_schedule_error = 8 [deprecated = true];
   * @deprecated
   */
  invalidScheduleError = "";

  constructor(data?: PartialMessage<ScheduleInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "missed_catchup_window", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "overlap_skipped", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "buffer_dropped", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "buffer_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "running_workflows", kind: "message", T: WorkflowExecution, repeated: true },
    { no: 4, name: "recent_actions", kind: "message", T: ScheduleActionResult, repeated: true },
    { no: 5, name: "future_action_times", kind: "message", T: Timestamp, repeated: true },
    { no: 6, name: "create_time", kind: "message", T: Timestamp },
    { no: 7, name: "update_time", kind: "message", T: Timestamp },
    { no: 8, name: "invalid_schedule_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleInfo {
    return new ScheduleInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleInfo {
    return new ScheduleInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleInfo {
    return new ScheduleInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleInfo | PlainMessage<ScheduleInfo> | undefined, b: ScheduleInfo | PlainMessage<ScheduleInfo> | undefined): boolean {
    return proto3.util.equals(ScheduleInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.schedule.v1.Schedule
 */
export class Schedule extends Message<Schedule> {
  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleSpec spec = 1;
   */
  spec?: ScheduleSpec;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleAction action = 2;
   */
  action?: ScheduleAction;

  /**
   * @generated from field: temporal.api.schedule.v1.SchedulePolicies policies = 3;
   */
  policies?: SchedulePolicies;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleState state = 4;
   */
  state?: ScheduleState;

  constructor(data?: PartialMessage<Schedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.Schedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ScheduleSpec },
    { no: 2, name: "action", kind: "message", T: ScheduleAction },
    { no: 3, name: "policies", kind: "message", T: SchedulePolicies },
    { no: 4, name: "state", kind: "message", T: ScheduleState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Schedule {
    return new Schedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJsonString(jsonString, options);
  }

  static equals(a: Schedule | PlainMessage<Schedule> | undefined, b: Schedule | PlainMessage<Schedule> | undefined): boolean {
    return proto3.util.equals(Schedule, a, b);
  }
}

/**
 * ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
 * that's returned in ListSchedules.
 *
 * @generated from message temporal.api.schedule.v1.ScheduleListInfo
 */
export class ScheduleListInfo extends Message<ScheduleListInfo> {
  /**
   * From spec:
   * Some fields are dropped from this copy of spec: timezone_data
   *
   * @generated from field: temporal.api.schedule.v1.ScheduleSpec spec = 1;
   */
  spec?: ScheduleSpec;

  /**
   * From action:
   * Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
   * well with JSON. If action is start_workflow, this is set:
   *
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * From state:
   *
   * @generated from field: string notes = 3;
   */
  notes = "";

  /**
   * @generated from field: bool paused = 4;
   */
  paused = false;

  /**
   * From info (maybe fewer entries):
   *
   * @generated from field: repeated temporal.api.schedule.v1.ScheduleActionResult recent_actions = 5;
   */
  recentActions: ScheduleActionResult[] = [];

  /**
   * @generated from field: repeated google.protobuf.Timestamp future_action_times = 6;
   */
  futureActionTimes: Timestamp[] = [];

  constructor(data?: PartialMessage<ScheduleListInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleListInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ScheduleSpec },
    { no: 2, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 3, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "recent_actions", kind: "message", T: ScheduleActionResult, repeated: true },
    { no: 6, name: "future_action_times", kind: "message", T: Timestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleListInfo {
    return new ScheduleListInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleListInfo {
    return new ScheduleListInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleListInfo {
    return new ScheduleListInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleListInfo | PlainMessage<ScheduleListInfo> | undefined, b: ScheduleListInfo | PlainMessage<ScheduleListInfo> | undefined): boolean {
    return proto3.util.equals(ScheduleListInfo, a, b);
  }
}

/**
 * ScheduleListEntry is returned by ListSchedules.
 *
 * @generated from message temporal.api.schedule.v1.ScheduleListEntry
 */
export class ScheduleListEntry extends Message<ScheduleListEntry> {
  /**
   * @generated from field: string schedule_id = 1;
   */
  scheduleId = "";

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 2;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 3;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.schedule.v1.ScheduleListInfo info = 4;
   */
  info?: ScheduleListInfo;

  constructor(data?: PartialMessage<ScheduleListEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.schedule.v1.ScheduleListEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "memo", kind: "message", T: Memo },
    { no: 3, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 4, name: "info", kind: "message", T: ScheduleListInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduleListEntry {
    return new ScheduleListEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduleListEntry {
    return new ScheduleListEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduleListEntry {
    return new ScheduleListEntry().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduleListEntry | PlainMessage<ScheduleListEntry> | undefined, b: ScheduleListEntry | PlainMessage<ScheduleListEntry> | undefined): boolean {
    return proto3.util.equals(ScheduleListEntry, a, b);
  }
}

