// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=ts"
// @generated from file temporal/api/workflow/v1/message.proto (package temporal.api.workflow.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Empty, FieldMask, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ActivityType, Callback, Header, Link, Memo, Payloads, Priority, RetryPolicy, SearchAttributes, WorkerVersionStamp, WorkflowExecution, WorkflowType } from "../../common/v1/message_pbts";
import { ParentClosePolicy, PendingActivityState, PendingWorkflowTaskState, VersioningBehavior, WorkflowExecutionStatus, WorkflowIdReusePolicy } from "../../enums/v1/workflow_pbts";
import { Deployment, WorkerDeploymentVersion } from "../../deployment/v1/message_pbts";
import { TaskQueue } from "../../taskqueue/v1/message_pbts";
import { UserMetadata } from "../../sdk/v1/user_metadata_pbts";
import { Failure } from "../../failure/v1/message_pbts";
import { ActivityOptions } from "../../activity/v1/message_pbts";
import { CallbackState, NexusOperationCancellationState, PendingNexusOperationState } from "../../enums/v1/common_pbts";
import { EventType } from "../../enums/v1/event_type_pbts";

/**
 * Hold basic information about a workflow execution.
 * This structure is a part of visibility, and thus contain a limited subset of information.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionInfo
 */
export class WorkflowExecutionInfo extends Message<WorkflowExecutionInfo> {
  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution execution = 1;
   */
  execution?: WorkflowExecution;

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType type = 2;
   */
  type?: WorkflowType;

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
   */
  status = WorkflowExecutionStatus.UNSPECIFIED;

  /**
   * @generated from field: int64 history_length = 6;
   */
  historyLength = protoInt64.zero;

  /**
   * @generated from field: string parent_namespace_id = 7;
   */
  parentNamespaceId = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowExecution parent_execution = 8;
   */
  parentExecution?: WorkflowExecution;

  /**
   * @generated from field: google.protobuf.Timestamp execution_time = 9;
   */
  executionTime?: Timestamp;

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 10;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 11;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.workflow.v1.ResetPoints auto_reset_points = 12;
   */
  autoResetPoints?: ResetPoints;

  /**
   * @generated from field: string task_queue = 13;
   */
  taskQueue = "";

  /**
   * @generated from field: int64 state_transition_count = 14;
   */
  stateTransitionCount = protoInt64.zero;

  /**
   * @generated from field: int64 history_size_bytes = 15;
   */
  historySizeBytes = protoInt64.zero;

  /**
   * If set, the most recent worker version stamp that appeared in a workflow task completion
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp most_recent_worker_version_stamp = 16 [deprecated = true];
   * @deprecated
   */
  mostRecentWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * Workflow execution duration is defined as difference between close time and execution time.
   * This field is only populated if the workflow is closed.
   *
   * @generated from field: google.protobuf.Duration execution_duration = 17;
   */
  executionDuration?: Duration;

  /**
   * Contains information about the root workflow execution.
   * The root workflow execution is defined as follows:
   * 1. A workflow without parent workflow is its own root workflow.
   * 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
   * Note: workflows continued as new or reseted may or may not have parents, check examples below.
   *
   * Examples:
   *   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
   *     - The root workflow of all three workflows is W1.
   *   Scenario 3: Workflow W1 continued as new W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
   *     - The root workflow of all three workflows is W1.
   *   Scenario 5: Workflow W1 is reseted, creating W2.
   *     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
   *
   * @generated from field: temporal.api.common.v1.WorkflowExecution root_execution = 18;
   */
  rootExecution?: WorkflowExecution;

  /**
   * The currently assigned build ID for this execution. Presence of this value means worker versioning is used
   * for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
   * when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
   * again, the assigned build ID may change according to the latest versioning rules.
   * Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
   * this execution.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string assigned_build_id = 19 [deprecated = true];
   * @deprecated
   */
  assignedBuildId = "";

  /**
   * Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
   * of using the assignment rules.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: string inherited_build_id = 20 [deprecated = true];
   * @deprecated
   */
  inheritedBuildId = "";

  /**
   * The first run ID in the execution chain.
   * Executions created via the following operations are considered to be in the same chain
   * - ContinueAsNew
   * - Workflow Retry
   * - Workflow Reset
   * - Cron Schedule
   *
   * @generated from field: string first_run_id = 21;
   */
  firstRunId = "";

  /**
   * Absent value means the workflow execution is not versioned. When present, the execution might
   * be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
   * Experimental. Versioning info is experimental and might change in the future.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo versioning_info = 22;
   */
  versioningInfo?: WorkflowExecutionVersioningInfo;

  /**
   * The name of Worker Deployment that completed the most recent workflow task.
   * Experimental. Worker Deployments are experimental and might change in the future.
   *
   * @generated from field: string worker_deployment_name = 23;
   */
  workerDeploymentName = "";

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 24;
   */
  priority?: Priority;

  constructor(data?: PartialMessage<WorkflowExecutionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.WorkflowExecutionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execution", kind: "message", T: WorkflowExecution },
    { no: 2, name: "type", kind: "message", T: WorkflowType },
    { no: 3, name: "start_time", kind: "message", T: Timestamp },
    { no: 4, name: "close_time", kind: "message", T: Timestamp },
    { no: 5, name: "status", kind: "enum", T: proto3.getEnumType(WorkflowExecutionStatus) },
    { no: 6, name: "history_length", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "parent_namespace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "parent_execution", kind: "message", T: WorkflowExecution },
    { no: 9, name: "execution_time", kind: "message", T: Timestamp },
    { no: 10, name: "memo", kind: "message", T: Memo },
    { no: 11, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 12, name: "auto_reset_points", kind: "message", T: ResetPoints },
    { no: 13, name: "task_queue", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "state_transition_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "history_size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 16, name: "most_recent_worker_version_stamp", kind: "message", T: WorkerVersionStamp },
    { no: 17, name: "execution_duration", kind: "message", T: Duration },
    { no: 18, name: "root_execution", kind: "message", T: WorkflowExecution },
    { no: 19, name: "assigned_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "inherited_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "first_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "versioning_info", kind: "message", T: WorkflowExecutionVersioningInfo },
    { no: 23, name: "worker_deployment_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 24, name: "priority", kind: "message", T: Priority },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionInfo {
    return new WorkflowExecutionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionInfo {
    return new WorkflowExecutionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionInfo {
    return new WorkflowExecutionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecutionInfo | PlainMessage<WorkflowExecutionInfo> | undefined, b: WorkflowExecutionInfo | PlainMessage<WorkflowExecutionInfo> | undefined): boolean {
    return proto3.util.equals(WorkflowExecutionInfo, a, b);
  }
}

/**
 * Holds all the extra information about workflow execution that is not part of Visibility.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionExtendedInfo
 */
export class WorkflowExecutionExtendedInfo extends Message<WorkflowExecutionExtendedInfo> {
  /**
   * Workflow execution expiration time is defined as workflow start time plus expiration timeout.
   * Workflow start time may change after workflow reset.
   *
   * @generated from field: google.protobuf.Timestamp execution_expiration_time = 1;
   */
  executionExpirationTime?: Timestamp;

  /**
   * Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
   *
   * @generated from field: google.protobuf.Timestamp run_expiration_time = 2;
   */
  runExpirationTime?: Timestamp;

  /**
   * indicates if the workflow received a cancel request
   *
   * @generated from field: bool cancel_requested = 3;
   */
  cancelRequested = false;

  /**
   * Last workflow reset time. Nil if the workflow was never reset.
   *
   * @generated from field: google.protobuf.Timestamp last_reset_time = 4;
   */
  lastResetTime?: Timestamp;

  /**
   * Original workflow start time.
   *
   * @generated from field: google.protobuf.Timestamp original_start_time = 5;
   */
  originalStartTime?: Timestamp;

  /**
   * Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
   *
   * @generated from field: string reset_run_id = 6;
   */
  resetRunId = "";

  /**
   * Request ID information (eg: history event information associated with the request ID).
   * Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
   * calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
   * used in the StartWorkflowExecution request).
   *
   * @generated from field: map<string, temporal.api.workflow.v1.RequestIdInfo> request_id_infos = 7;
   */
  requestIdInfos: { [key: string]: RequestIdInfo } = {};

  constructor(data?: PartialMessage<WorkflowExecutionExtendedInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.WorkflowExecutionExtendedInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execution_expiration_time", kind: "message", T: Timestamp },
    { no: 2, name: "run_expiration_time", kind: "message", T: Timestamp },
    { no: 3, name: "cancel_requested", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "last_reset_time", kind: "message", T: Timestamp },
    { no: 5, name: "original_start_time", kind: "message", T: Timestamp },
    { no: 6, name: "reset_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "request_id_infos", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: RequestIdInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionExtendedInfo {
    return new WorkflowExecutionExtendedInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionExtendedInfo {
    return new WorkflowExecutionExtendedInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionExtendedInfo {
    return new WorkflowExecutionExtendedInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecutionExtendedInfo | PlainMessage<WorkflowExecutionExtendedInfo> | undefined, b: WorkflowExecutionExtendedInfo | PlainMessage<WorkflowExecutionExtendedInfo> | undefined): boolean {
    return proto3.util.equals(WorkflowExecutionExtendedInfo, a, b);
  }
}

/**
 * Holds all the information about worker versioning for a particular workflow execution.
 * Experimental. Versioning info is experimental and might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
 */
export class WorkflowExecutionVersioningInfo extends Message<WorkflowExecutionVersioningInfo> {
  /**
   * Versioning behavior determines how the server should treat this execution when workers are
   * upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
   * unversioned. See the comments in `VersioningBehavior` enum for more info about different
   * behaviors.
   * This field is first set after an execution completes its first workflow task on a versioned
   * worker, and set again on completion of every subsequent workflow task.
   * For child workflows of Pinned parents, this will be set to Pinned (along with `deployment_version`) when
   * the the child starts so that child's first workflow task goes to the same Version as the
   * parent. After the first workflow task, it depends on the child workflow itself if it wants
   * to stay pinned or become unpinned (according to Versioning Behavior set in the worker).
   * Note that `behavior` is overridden by `versioning_override` if the latter is present.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1;
   */
  behavior = VersioningBehavior.UNSPECIFIED;

  /**
   * The worker deployment that completed the last workflow task of this workflow execution. Must
   * be present if `behavior` is set. Absent value means no workflow task is completed, or the
   * last workflow task was completed by an unversioned worker. Unversioned workers may still send
   * a deployment value which will be stored here, so the right way to check if an execution is
   * versioned if an execution is versioned or not is via the `behavior` field.
   * Note that `deployment` is overridden by `versioning_override` if the latter is present.
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 5 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The Worker Deployment Version that completed the last workflow task of this workflow execution.
   * An absent value means no workflow task is completed, or the workflow is unversioned.
   * If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
   * by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
   *
   * For child workflows of Pinned parents, this will be set to the parent's Pinned Version when
   * the child starts, so that the child's first workflow task goes to the same Version as the parent.
   * Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
   * will override this value.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 7;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  /**
   * Present if user has set an execution-specific versioning override. This override takes
   * precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
   * override can be set when starting a new execution, as well as afterwards by calling the
   * `UpdateWorkflowExecutionOptions` API.
   * Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
   * workflow retries, and cron workflows.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 3;
   */
  versioningOverride?: VersioningOverride;

  /**
   * When present, indicates the workflow is transitioning to a different deployment. Can
   * indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current deployment if the task queue's current
   * deployment is different from the workflow's deployment.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current deployment. As soon as a poller from
   * that deployment is available to receive the task, the workflow will automatically start a
   * transition to that deployment and continue execution there.
   * A deployment transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target deployment, the
   * transition completes and the workflow's `deployment` and `behavior` fields are updated per
   * the worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new deployment.
   * Deprecated. Use version_transition.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentTransition deployment_transition = 4 [deprecated = true];
   * @deprecated
   */
  deploymentTransition?: DeploymentTransition;

  /**
   * When present, indicates the workflow is transitioning to a different deployment version
   * (which may belong to the same deployment name or another). Can indicate one of the following
   * transitions: unversioned -> versioned, versioned -> versioned
   * on a different deployment version, or versioned -> unversioned.
   * Not applicable to workflows with PINNED behavior.
   * When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
   * start a transition to the task queue's current version if the task queue's current version is
   * different from the workflow's current deployment version.
   * If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
   * tasks will be redirected to the task queue's current version. As soon as a poller from
   * that deployment version is available to receive the task, the workflow will automatically
   * start a transition to that version and continue execution there.
   * A version transition can only exist while there is a pending or started workflow task.
   * Once the pending workflow task completes on the transition's target version, the
   * transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
   * worker's task completion response.
   * Pending activities will not start new attempts during a transition. Once the transition is
   * completed, pending activities will start their next attempt on the new version.
   *
   * @generated from field: temporal.api.workflow.v1.DeploymentVersionTransition version_transition = 6;
   */
  versionTransition?: DeploymentVersionTransition;

  /**
   * Monotonic counter reflecting the latest routing decision for this workflow execution.
   * Used for staleness detection between history and matching when dispatching tasks to workers.
   * Incremented when a workflow execution routes to a new deployment version, which happens 
   * when a worker of the new deployment version completes a workflow task.
   * Note: Pinned tasks and sticky tasks send a value of 0 for this field since these tasks do not
   * face the problem of inconsistent dispatching that arises from eventual consistency between 
   * task queues and their partitions.
   *
   * @generated from field: int64 revision_number = 8;
   */
  revisionNumber = protoInt64.zero;

  constructor(data?: PartialMessage<WorkflowExecutionVersioningInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.WorkflowExecutionVersioningInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "behavior", kind: "enum", T: proto3.getEnumType(VersioningBehavior) },
    { no: 2, name: "deployment", kind: "message", T: Deployment },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 3, name: "versioning_override", kind: "message", T: VersioningOverride },
    { no: 4, name: "deployment_transition", kind: "message", T: DeploymentTransition },
    { no: 6, name: "version_transition", kind: "message", T: DeploymentVersionTransition },
    { no: 8, name: "revision_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionVersioningInfo {
    return new WorkflowExecutionVersioningInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionVersioningInfo {
    return new WorkflowExecutionVersioningInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionVersioningInfo {
    return new WorkflowExecutionVersioningInfo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecutionVersioningInfo | PlainMessage<WorkflowExecutionVersioningInfo> | undefined, b: WorkflowExecutionVersioningInfo | PlainMessage<WorkflowExecutionVersioningInfo> | undefined): boolean {
    return proto3.util.equals(WorkflowExecutionVersioningInfo, a, b);
  }
}

/**
 * Holds information about ongoing transition of a workflow execution from one deployment to another.
 * Deprecated. Use DeploymentVersionTransition.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentTransition
 */
export class DeploymentTransition extends Message<DeploymentTransition> {
  /**
   * The target deployment of the transition. Null means a so-far-versioned workflow is
   * transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 1;
   */
  deployment?: Deployment;

  constructor(data?: PartialMessage<DeploymentTransition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.DeploymentTransition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deployment", kind: "message", T: Deployment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeploymentTransition {
    return new DeploymentTransition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeploymentTransition {
    return new DeploymentTransition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeploymentTransition {
    return new DeploymentTransition().fromJsonString(jsonString, options);
  }

  static equals(a: DeploymentTransition | PlainMessage<DeploymentTransition> | undefined, b: DeploymentTransition | PlainMessage<DeploymentTransition> | undefined): boolean {
    return proto3.util.equals(DeploymentTransition, a, b);
  }
}

/**
 * Holds information about ongoing transition of a workflow execution from one worker
 * deployment version to another.
 * Experimental. Might change in the future.
 *
 * @generated from message temporal.api.workflow.v1.DeploymentVersionTransition
 */
export class DeploymentVersionTransition extends Message<DeploymentVersionTransition> {
  /**
   * Deprecated. Use `deployment_version`.
   *
   * @generated from field: string version = 1 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * The target Version of the transition.
   * If nil, a so-far-versioned workflow is transitioning to unversioned workers.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion deployment_version = 2;
   */
  deploymentVersion?: WorkerDeploymentVersion;

  constructor(data?: PartialMessage<DeploymentVersionTransition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.DeploymentVersionTransition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deployment_version", kind: "message", T: WorkerDeploymentVersion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeploymentVersionTransition {
    return new DeploymentVersionTransition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeploymentVersionTransition {
    return new DeploymentVersionTransition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeploymentVersionTransition {
    return new DeploymentVersionTransition().fromJsonString(jsonString, options);
  }

  static equals(a: DeploymentVersionTransition | PlainMessage<DeploymentVersionTransition> | undefined, b: DeploymentVersionTransition | PlainMessage<DeploymentVersionTransition> | undefined): boolean {
    return proto3.util.equals(DeploymentVersionTransition, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionConfig
 */
export class WorkflowExecutionConfig extends Message<WorkflowExecutionConfig> {
  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
   */
  taskQueue?: TaskQueue;

  /**
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 2;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 3;
   */
  workflowRunTimeout?: Duration;

  /**
   * @generated from field: google.protobuf.Duration default_workflow_task_timeout = 4;
   */
  defaultWorkflowTaskTimeout?: Duration;

  /**
   * User metadata provided on start workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 5;
   */
  userMetadata?: UserMetadata;

  constructor(data?: PartialMessage<WorkflowExecutionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.WorkflowExecutionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 2, name: "workflow_execution_timeout", kind: "message", T: Duration },
    { no: 3, name: "workflow_run_timeout", kind: "message", T: Duration },
    { no: 4, name: "default_workflow_task_timeout", kind: "message", T: Duration },
    { no: 5, name: "user_metadata", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionConfig {
    return new WorkflowExecutionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionConfig {
    return new WorkflowExecutionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionConfig {
    return new WorkflowExecutionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecutionConfig | PlainMessage<WorkflowExecutionConfig> | undefined, b: WorkflowExecutionConfig | PlainMessage<WorkflowExecutionConfig> | undefined): boolean {
    return proto3.util.equals(WorkflowExecutionConfig, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo
 */
export class PendingActivityInfo extends Message<PendingActivityInfo> {
  /**
   * @generated from field: string activity_id = 1;
   */
  activityId = "";

  /**
   * @generated from field: temporal.api.common.v1.ActivityType activity_type = 2;
   */
  activityType?: ActivityType;

  /**
   * @generated from field: temporal.api.enums.v1.PendingActivityState state = 3;
   */
  state = PendingActivityState.UNSPECIFIED;

  /**
   * @generated from field: temporal.api.common.v1.Payloads heartbeat_details = 4;
   */
  heartbeatDetails?: Payloads;

  /**
   * @generated from field: google.protobuf.Timestamp last_heartbeat_time = 5;
   */
  lastHeartbeatTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_started_time = 6;
   */
  lastStartedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 7;
   */
  attempt = 0;

  /**
   * @generated from field: int32 maximum_attempts = 8;
   */
  maximumAttempts = 0;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 9;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp expiration_time = 10;
   */
  expirationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.failure.v1.Failure last_failure = 11;
   */
  lastFailure?: Failure;

  /**
   * @generated from field: string last_worker_identity = 12;
   */
  lastWorkerIdentity = "";

  /**
   * Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
   * In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
   * independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
   * Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.assigned_build_id
   */
  assignedBuildId: {
    /**
     * Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
     *
     * @generated from field: google.protobuf.Empty use_workflow_build_id = 13 [deprecated = true];
     * @deprecated
     */
    value: Empty;
    case: "useWorkflowBuildId";
  } | {
    /**
     * Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
     * The activity will use the build id in this field instead.
     * If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
     * rules.
     *
     * @generated from field: string last_independently_assigned_build_id = 14 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "lastIndependentlyAssignedBuildId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
   * This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
   *
   * @generated from field: temporal.api.common.v1.WorkerVersionStamp last_worker_version_stamp = 15 [deprecated = true];
   * @deprecated
   */
  lastWorkerVersionStamp?: WorkerVersionStamp;

  /**
   * The time activity will wait until the next retry.
   * If activity is currently running it will be next retry interval if activity failed.
   * If activity is currently waiting it will be current retry interval.
   * If there will be no retry it will be null.
   *
   * @generated from field: google.protobuf.Duration current_retry_interval = 16;
   */
  currentRetryInterval?: Duration;

  /**
   * The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 17;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * Next time when activity will be scheduled.
   * If activity is currently scheduled or started it will be null.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 18;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * Indicates if activity is paused.
   *
   * @generated from field: bool paused = 19;
   */
  paused = false;

  /**
   * The deployment this activity was dispatched to most recently. Present only if the activity
   * was dispatched to a versioned worker.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment last_deployment = 20 [deprecated = true];
   * @deprecated
   */
  lastDeployment?: Deployment;

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * Deprecated. Use `last_deployment_version`.
   *
   * @generated from field: string last_worker_deployment_version = 21 [deprecated = true];
   * @deprecated
   */
  lastWorkerDeploymentVersion = "";

  /**
   * The Worker Deployment Version this activity was dispatched to most recently.
   * If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion last_deployment_version = 25;
   */
  lastDeploymentVersion?: WorkerDeploymentVersion;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 22;
   */
  priority?: Priority;

  /**
   * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo pause_info = 23;
   */
  pauseInfo?: PendingActivityInfo_PauseInfo;

  /**
   * Current activity options. May be different from the one used to start the activity.
   *
   * @generated from field: temporal.api.activity.v1.ActivityOptions activity_options = 24;
   */
  activityOptions?: ActivityOptions;

  constructor(data?: PartialMessage<PendingActivityInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingActivityInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "activity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "activity_type", kind: "message", T: ActivityType },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(PendingActivityState) },
    { no: 4, name: "heartbeat_details", kind: "message", T: Payloads },
    { no: 5, name: "last_heartbeat_time", kind: "message", T: Timestamp },
    { no: 6, name: "last_started_time", kind: "message", T: Timestamp },
    { no: 7, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "maximum_attempts", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 10, name: "expiration_time", kind: "message", T: Timestamp },
    { no: 11, name: "last_failure", kind: "message", T: Failure },
    { no: 12, name: "last_worker_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "use_workflow_build_id", kind: "message", T: Empty, oneof: "assigned_build_id" },
    { no: 14, name: "last_independently_assigned_build_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "assigned_build_id" },
    { no: 15, name: "last_worker_version_stamp", kind: "message", T: WorkerVersionStamp },
    { no: 16, name: "current_retry_interval", kind: "message", T: Duration },
    { no: 17, name: "last_attempt_complete_time", kind: "message", T: Timestamp },
    { no: 18, name: "next_attempt_schedule_time", kind: "message", T: Timestamp },
    { no: 19, name: "paused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "last_deployment", kind: "message", T: Deployment },
    { no: 21, name: "last_worker_deployment_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 25, name: "last_deployment_version", kind: "message", T: WorkerDeploymentVersion },
    { no: 22, name: "priority", kind: "message", T: Priority },
    { no: 23, name: "pause_info", kind: "message", T: PendingActivityInfo_PauseInfo },
    { no: 24, name: "activity_options", kind: "message", T: ActivityOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingActivityInfo {
    return new PendingActivityInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingActivityInfo {
    return new PendingActivityInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingActivityInfo {
    return new PendingActivityInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PendingActivityInfo | PlainMessage<PendingActivityInfo> | undefined, b: PendingActivityInfo | PlainMessage<PendingActivityInfo> | undefined): boolean {
    return proto3.util.equals(PendingActivityInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo
 */
export class PendingActivityInfo_PauseInfo extends Message<PendingActivityInfo_PauseInfo> {
  /**
   * The time when the activity was paused.
   *
   * @generated from field: google.protobuf.Timestamp pause_time = 1;
   */
  pauseTime?: Timestamp;

  /**
   * @generated from oneof temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.paused_by
   */
  pausedBy: {
    /**
     * activity was paused by the manual intervention
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual manual = 2;
     */
    value: PendingActivityInfo_PauseInfo_Manual;
    case: "manual";
  } | {
    /**
     * activity was paused by the rule
     *
     * @generated from field: temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule rule = 4;
     */
    value: PendingActivityInfo_PauseInfo_Rule;
    case: "rule";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PendingActivityInfo_PauseInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingActivityInfo.PauseInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pause_time", kind: "message", T: Timestamp },
    { no: 2, name: "manual", kind: "message", T: PendingActivityInfo_PauseInfo_Manual, oneof: "paused_by" },
    { no: 4, name: "rule", kind: "message", T: PendingActivityInfo_PauseInfo_Rule, oneof: "paused_by" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingActivityInfo_PauseInfo {
    return new PendingActivityInfo_PauseInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo {
    return new PendingActivityInfo_PauseInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo {
    return new PendingActivityInfo_PauseInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PendingActivityInfo_PauseInfo | PlainMessage<PendingActivityInfo_PauseInfo> | undefined, b: PendingActivityInfo_PauseInfo | PlainMessage<PendingActivityInfo_PauseInfo> | undefined): boolean {
    return proto3.util.equals(PendingActivityInfo_PauseInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual
 */
export class PendingActivityInfo_PauseInfo_Manual extends Message<PendingActivityInfo_PauseInfo_Manual> {
  /**
   * The identity of the actor that paused the activity.
   *
   * @generated from field: string identity = 1;
   */
  identity = "";

  /**
   * Reason for pausing the activity.
   *
   * @generated from field: string reason = 2;
   */
  reason = "";

  constructor(data?: PartialMessage<PendingActivityInfo_PauseInfo_Manual>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Manual";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingActivityInfo_PauseInfo_Manual {
    return new PendingActivityInfo_PauseInfo_Manual().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo_Manual {
    return new PendingActivityInfo_PauseInfo_Manual().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo_Manual {
    return new PendingActivityInfo_PauseInfo_Manual().fromJsonString(jsonString, options);
  }

  static equals(a: PendingActivityInfo_PauseInfo_Manual | PlainMessage<PendingActivityInfo_PauseInfo_Manual> | undefined, b: PendingActivityInfo_PauseInfo_Manual | PlainMessage<PendingActivityInfo_PauseInfo_Manual> | undefined): boolean {
    return proto3.util.equals(PendingActivityInfo_PauseInfo_Manual, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule
 */
export class PendingActivityInfo_PauseInfo_Rule extends Message<PendingActivityInfo_PauseInfo_Rule> {
  /**
   * The rule that paused the activity.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId = "";

  /**
   * The identity of the actor that created the rule.
   *
   * @generated from field: string identity = 2;
   */
  identity = "";

  /**
   * Reason why rule was created. Populated from rule description.
   *
   * @generated from field: string reason = 3;
   */
  reason = "";

  constructor(data?: PartialMessage<PendingActivityInfo_PauseInfo_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingActivityInfo.PauseInfo.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingActivityInfo_PauseInfo_Rule {
    return new PendingActivityInfo_PauseInfo_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo_Rule {
    return new PendingActivityInfo_PauseInfo_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingActivityInfo_PauseInfo_Rule {
    return new PendingActivityInfo_PauseInfo_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: PendingActivityInfo_PauseInfo_Rule | PlainMessage<PendingActivityInfo_PauseInfo_Rule> | undefined, b: PendingActivityInfo_PauseInfo_Rule | PlainMessage<PendingActivityInfo_PauseInfo_Rule> | undefined): boolean {
    return proto3.util.equals(PendingActivityInfo_PauseInfo_Rule, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingChildExecutionInfo
 */
export class PendingChildExecutionInfo extends Message<PendingChildExecutionInfo> {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId = "";

  /**
   * @generated from field: string run_id = 2;
   */
  runId = "";

  /**
   * @generated from field: string workflow_type_name = 3;
   */
  workflowTypeName = "";

  /**
   * @generated from field: int64 initiated_id = 4;
   */
  initiatedId = protoInt64.zero;

  /**
   * Default: PARENT_CLOSE_POLICY_TERMINATE.
   *
   * @generated from field: temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 5;
   */
  parentClosePolicy = ParentClosePolicy.UNSPECIFIED;

  constructor(data?: PartialMessage<PendingChildExecutionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingChildExecutionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workflow_type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "initiated_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "parent_close_policy", kind: "enum", T: proto3.getEnumType(ParentClosePolicy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingChildExecutionInfo {
    return new PendingChildExecutionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingChildExecutionInfo {
    return new PendingChildExecutionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingChildExecutionInfo {
    return new PendingChildExecutionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PendingChildExecutionInfo | PlainMessage<PendingChildExecutionInfo> | undefined, b: PendingChildExecutionInfo | PlainMessage<PendingChildExecutionInfo> | undefined): boolean {
    return proto3.util.equals(PendingChildExecutionInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.PendingWorkflowTaskInfo
 */
export class PendingWorkflowTaskInfo extends Message<PendingWorkflowTaskInfo> {
  /**
   * @generated from field: temporal.api.enums.v1.PendingWorkflowTaskState state = 1;
   */
  state = PendingWorkflowTaskState.UNSPECIFIED;

  /**
   * @generated from field: google.protobuf.Timestamp scheduled_time = 2;
   */
  scheduledTime?: Timestamp;

  /**
   * original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
   * Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
   * In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
   * some threshold, the workflow task will be forced timeout.
   *
   * @generated from field: google.protobuf.Timestamp original_scheduled_time = 3;
   */
  originalScheduledTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp started_time = 4;
   */
  startedTime?: Timestamp;

  /**
   * @generated from field: int32 attempt = 5;
   */
  attempt = 0;

  constructor(data?: PartialMessage<PendingWorkflowTaskInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingWorkflowTaskInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(PendingWorkflowTaskState) },
    { no: 2, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 3, name: "original_scheduled_time", kind: "message", T: Timestamp },
    { no: 4, name: "started_time", kind: "message", T: Timestamp },
    { no: 5, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingWorkflowTaskInfo {
    return new PendingWorkflowTaskInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingWorkflowTaskInfo {
    return new PendingWorkflowTaskInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingWorkflowTaskInfo {
    return new PendingWorkflowTaskInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PendingWorkflowTaskInfo | PlainMessage<PendingWorkflowTaskInfo> | undefined, b: PendingWorkflowTaskInfo | PlainMessage<PendingWorkflowTaskInfo> | undefined): boolean {
    return proto3.util.equals(PendingWorkflowTaskInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.ResetPoints
 */
export class ResetPoints extends Message<ResetPoints> {
  /**
   * @generated from field: repeated temporal.api.workflow.v1.ResetPointInfo points = 1;
   */
  points: ResetPointInfo[] = [];

  constructor(data?: PartialMessage<ResetPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.ResetPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: ResetPointInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetPoints {
    return new ResetPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetPoints {
    return new ResetPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetPoints {
    return new ResetPoints().fromJsonString(jsonString, options);
  }

  static equals(a: ResetPoints | PlainMessage<ResetPoints> | undefined, b: ResetPoints | PlainMessage<ResetPoints> | undefined): boolean {
    return proto3.util.equals(ResetPoints, a, b);
  }
}

/**
 * ResetPointInfo records the workflow event id that is the first one processed by a given
 * build id or binary checksum. A new reset point will be created if either build id or binary
 * checksum changes (although in general only one or the other will be used at a time).
 *
 * @generated from message temporal.api.workflow.v1.ResetPointInfo
 */
export class ResetPointInfo extends Message<ResetPointInfo> {
  /**
   * Worker build id.
   *
   * @generated from field: string build_id = 7;
   */
  buildId = "";

  /**
   * Deprecated. A worker binary version identifier.
   *
   * @generated from field: string binary_checksum = 1 [deprecated = true];
   * @deprecated
   */
  binaryChecksum = "";

  /**
   * The first run ID in the execution chain that was touched by this worker build.
   *
   * @generated from field: string run_id = 2;
   */
  runId = "";

  /**
   * Event ID of the first WorkflowTaskCompleted event processed by this worker build.
   *
   * @generated from field: int64 first_workflow_task_completed_id = 3;
   */
  firstWorkflowTaskCompletedId = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * (-- api-linter: core::0214::resource-expiry=disabled
   *     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
   * The time that the run is deleted due to retention.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 5;
   */
  expireTime?: Timestamp;

  /**
   * false if the reset point has pending childWFs/reqCancels/signalExternals.
   *
   * @generated from field: bool resettable = 6;
   */
  resettable = false;

  constructor(data?: PartialMessage<ResetPointInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.ResetPointInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 7, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "binary_checksum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "first_workflow_task_completed_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "create_time", kind: "message", T: Timestamp },
    { no: 5, name: "expire_time", kind: "message", T: Timestamp },
    { no: 6, name: "resettable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetPointInfo {
    return new ResetPointInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetPointInfo {
    return new ResetPointInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetPointInfo {
    return new ResetPointInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ResetPointInfo | PlainMessage<ResetPointInfo> | undefined, b: ResetPointInfo | PlainMessage<ResetPointInfo> | undefined): boolean {
    return proto3.util.equals(ResetPointInfo, a, b);
  }
}

/**
 * NewWorkflowExecutionInfo is a shared message that encapsulates all the
 * required arguments to starting a workflow in different contexts.
 *
 * @generated from message temporal.api.workflow.v1.NewWorkflowExecutionInfo
 */
export class NewWorkflowExecutionInfo extends Message<NewWorkflowExecutionInfo> {
  /**
   * @generated from field: string workflow_id = 1;
   */
  workflowId = "";

  /**
   * @generated from field: temporal.api.common.v1.WorkflowType workflow_type = 2;
   */
  workflowType?: WorkflowType;

  /**
   * @generated from field: temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
   */
  taskQueue?: TaskQueue;

  /**
   * Serialized arguments to the workflow.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 4;
   */
  input?: Payloads;

  /**
   * Total workflow execution timeout including retries and continue as new.
   *
   * @generated from field: google.protobuf.Duration workflow_execution_timeout = 5;
   */
  workflowExecutionTimeout?: Duration;

  /**
   * Timeout of a single workflow run.
   *
   * @generated from field: google.protobuf.Duration workflow_run_timeout = 6;
   */
  workflowRunTimeout?: Duration;

  /**
   * Timeout of a single workflow task.
   *
   * @generated from field: google.protobuf.Duration workflow_task_timeout = 7;
   */
  workflowTaskTimeout?: Duration;

  /**
   * Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
   *
   * @generated from field: temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 8;
   */
  workflowIdReusePolicy = WorkflowIdReusePolicy.UNSPECIFIED;

  /**
   * The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
   *
   * @generated from field: temporal.api.common.v1.RetryPolicy retry_policy = 9;
   */
  retryPolicy?: RetryPolicy;

  /**
   * See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
   *
   * @generated from field: string cron_schedule = 10;
   */
  cronSchedule = "";

  /**
   * @generated from field: temporal.api.common.v1.Memo memo = 11;
   */
  memo?: Memo;

  /**
   * @generated from field: temporal.api.common.v1.SearchAttributes search_attributes = 12;
   */
  searchAttributes?: SearchAttributes;

  /**
   * @generated from field: temporal.api.common.v1.Header header = 13;
   */
  header?: Header;

  /**
   * Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
   * for use by user interfaces to display the fixed as-of-start summary and details of the
   * workflow.
   *
   * @generated from field: temporal.api.sdk.v1.UserMetadata user_metadata = 14;
   */
  userMetadata?: UserMetadata;

  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   * To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 15;
   */
  versioningOverride?: VersioningOverride;

  /**
   * Priority metadata
   *
   * @generated from field: temporal.api.common.v1.Priority priority = 16;
   */
  priority?: Priority;

  constructor(data?: PartialMessage<NewWorkflowExecutionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.NewWorkflowExecutionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "workflow_type", kind: "message", T: WorkflowType },
    { no: 3, name: "task_queue", kind: "message", T: TaskQueue },
    { no: 4, name: "input", kind: "message", T: Payloads },
    { no: 5, name: "workflow_execution_timeout", kind: "message", T: Duration },
    { no: 6, name: "workflow_run_timeout", kind: "message", T: Duration },
    { no: 7, name: "workflow_task_timeout", kind: "message", T: Duration },
    { no: 8, name: "workflow_id_reuse_policy", kind: "enum", T: proto3.getEnumType(WorkflowIdReusePolicy) },
    { no: 9, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 10, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "memo", kind: "message", T: Memo },
    { no: 12, name: "search_attributes", kind: "message", T: SearchAttributes },
    { no: 13, name: "header", kind: "message", T: Header },
    { no: 14, name: "user_metadata", kind: "message", T: UserMetadata },
    { no: 15, name: "versioning_override", kind: "message", T: VersioningOverride },
    { no: 16, name: "priority", kind: "message", T: Priority },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewWorkflowExecutionInfo {
    return new NewWorkflowExecutionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewWorkflowExecutionInfo {
    return new NewWorkflowExecutionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewWorkflowExecutionInfo {
    return new NewWorkflowExecutionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: NewWorkflowExecutionInfo | PlainMessage<NewWorkflowExecutionInfo> | undefined, b: NewWorkflowExecutionInfo | PlainMessage<NewWorkflowExecutionInfo> | undefined): boolean {
    return proto3.util.equals(NewWorkflowExecutionInfo, a, b);
  }
}

/**
 * CallbackInfo contains the state of an attached workflow callback.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo
 */
export class CallbackInfo extends Message<CallbackInfo> {
  /**
   * Information on how this callback should be invoked (e.g. its URL and type).
   *
   * @generated from field: temporal.api.common.v1.Callback callback = 1;
   */
  callback?: Callback;

  /**
   * Trigger for this callback.
   *
   * @generated from field: temporal.api.workflow.v1.CallbackInfo.Trigger trigger = 2;
   */
  trigger?: CallbackInfo_Trigger;

  /**
   * The time when the callback was registered.
   *
   * @generated from field: google.protobuf.Timestamp registration_time = 3;
   */
  registrationTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.CallbackState state = 4;
   */
  state = CallbackState.UNSPECIFIED;

  /**
   * The number of attempts made to deliver the callback.
   * This number represents a minimum bound since the attempt is incremented after the callback request completes.
   *
   * @generated from field: int32 attempt = 5;
   */
  attempt = 0;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 6;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 7;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 8;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 9;
   */
  blockedReason = "";

  constructor(data?: PartialMessage<CallbackInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.CallbackInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "callback", kind: "message", T: Callback },
    { no: 2, name: "trigger", kind: "message", T: CallbackInfo_Trigger },
    { no: 3, name: "registration_time", kind: "message", T: Timestamp },
    { no: 4, name: "state", kind: "enum", T: proto3.getEnumType(CallbackState) },
    { no: 5, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "last_attempt_complete_time", kind: "message", T: Timestamp },
    { no: 7, name: "last_attempt_failure", kind: "message", T: Failure },
    { no: 8, name: "next_attempt_schedule_time", kind: "message", T: Timestamp },
    { no: 9, name: "blocked_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallbackInfo {
    return new CallbackInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallbackInfo {
    return new CallbackInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallbackInfo {
    return new CallbackInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CallbackInfo | PlainMessage<CallbackInfo> | undefined, b: CallbackInfo | PlainMessage<CallbackInfo> | undefined): boolean {
    return proto3.util.equals(CallbackInfo, a, b);
  }
}

/**
 * Trigger for when the workflow is closed.
 *
 * @generated from message temporal.api.workflow.v1.CallbackInfo.WorkflowClosed
 */
export class CallbackInfo_WorkflowClosed extends Message<CallbackInfo_WorkflowClosed> {
  constructor(data?: PartialMessage<CallbackInfo_WorkflowClosed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.CallbackInfo.WorkflowClosed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallbackInfo_WorkflowClosed {
    return new CallbackInfo_WorkflowClosed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallbackInfo_WorkflowClosed {
    return new CallbackInfo_WorkflowClosed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallbackInfo_WorkflowClosed {
    return new CallbackInfo_WorkflowClosed().fromJsonString(jsonString, options);
  }

  static equals(a: CallbackInfo_WorkflowClosed | PlainMessage<CallbackInfo_WorkflowClosed> | undefined, b: CallbackInfo_WorkflowClosed | PlainMessage<CallbackInfo_WorkflowClosed> | undefined): boolean {
    return proto3.util.equals(CallbackInfo_WorkflowClosed, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.CallbackInfo.Trigger
 */
export class CallbackInfo_Trigger extends Message<CallbackInfo_Trigger> {
  /**
   * @generated from oneof temporal.api.workflow.v1.CallbackInfo.Trigger.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.CallbackInfo.WorkflowClosed workflow_closed = 1;
     */
    value: CallbackInfo_WorkflowClosed;
    case: "workflowClosed";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CallbackInfo_Trigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.CallbackInfo.Trigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_closed", kind: "message", T: CallbackInfo_WorkflowClosed, oneof: "variant" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallbackInfo_Trigger {
    return new CallbackInfo_Trigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallbackInfo_Trigger {
    return new CallbackInfo_Trigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallbackInfo_Trigger {
    return new CallbackInfo_Trigger().fromJsonString(jsonString, options);
  }

  static equals(a: CallbackInfo_Trigger | PlainMessage<CallbackInfo_Trigger> | undefined, b: CallbackInfo_Trigger | PlainMessage<CallbackInfo_Trigger> | undefined): boolean {
    return proto3.util.equals(CallbackInfo_Trigger, a, b);
  }
}

/**
 * PendingNexusOperationInfo contains the state of a pending Nexus operation.
 *
 * @generated from message temporal.api.workflow.v1.PendingNexusOperationInfo
 */
export class PendingNexusOperationInfo extends Message<PendingNexusOperationInfo> {
  /**
   * Endpoint name.
   * Resolved to a URL via the cluster's endpoint registry.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint = "";

  /**
   * Service name.
   *
   * @generated from field: string service = 2;
   */
  service = "";

  /**
   * Operation name.
   *
   * @generated from field: string operation = 3;
   */
  operation = "";

  /**
   * Operation ID. Only set for asynchronous operations after a successful StartOperation call.
   *
   * Deprecated. Renamed to operation_token.
   *
   * @generated from field: string operation_id = 4 [deprecated = true];
   * @deprecated
   */
  operationId = "";

  /**
   * Schedule-to-close timeout for this operation.
   * This is the only timeout settable by a workflow.
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   *
   * @generated from field: google.protobuf.Duration schedule_to_close_timeout = 5;
   */
  scheduleToCloseTimeout?: Duration;

  /**
   * The time when the operation was scheduled.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 6;
   */
  scheduledTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.PendingNexusOperationState state = 7;
   */
  state = PendingNexusOperationState.UNSPECIFIED;

  /**
   * The number of attempts made to deliver the start operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 8;
   */
  attempt = 0;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 9;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 10;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 11;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * @generated from field: temporal.api.workflow.v1.NexusOperationCancellationInfo cancellation_info = 12;
   */
  cancellationInfo?: NexusOperationCancellationInfo;

  /**
   * The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
   * DescribeWorkflowExecution response with workflow history.
   *
   * @generated from field: int64 scheduled_event_id = 13;
   */
  scheduledEventId = protoInt64.zero;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 14;
   */
  blockedReason = "";

  /**
   * Operation token. Only set for asynchronous operations after a successful StartOperation call.
   *
   * @generated from field: string operation_token = 15;
   */
  operationToken = "";

  constructor(data?: PartialMessage<PendingNexusOperationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PendingNexusOperationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "schedule_to_close_timeout", kind: "message", T: Duration },
    { no: 6, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 7, name: "state", kind: "enum", T: proto3.getEnumType(PendingNexusOperationState) },
    { no: 8, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "last_attempt_complete_time", kind: "message", T: Timestamp },
    { no: 10, name: "last_attempt_failure", kind: "message", T: Failure },
    { no: 11, name: "next_attempt_schedule_time", kind: "message", T: Timestamp },
    { no: 12, name: "cancellation_info", kind: "message", T: NexusOperationCancellationInfo },
    { no: 13, name: "scheduled_event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 14, name: "blocked_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "operation_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingNexusOperationInfo {
    return new PendingNexusOperationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingNexusOperationInfo {
    return new PendingNexusOperationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingNexusOperationInfo {
    return new PendingNexusOperationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PendingNexusOperationInfo | PlainMessage<PendingNexusOperationInfo> | undefined, b: PendingNexusOperationInfo | PlainMessage<PendingNexusOperationInfo> | undefined): boolean {
    return proto3.util.equals(PendingNexusOperationInfo, a, b);
  }
}

/**
 * NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
 *
 * @generated from message temporal.api.workflow.v1.NexusOperationCancellationInfo
 */
export class NexusOperationCancellationInfo extends Message<NexusOperationCancellationInfo> {
  /**
   * The time when cancellation was requested.
   *
   * @generated from field: google.protobuf.Timestamp requested_time = 1;
   */
  requestedTime?: Timestamp;

  /**
   * @generated from field: temporal.api.enums.v1.NexusOperationCancellationState state = 2;
   */
  state = NexusOperationCancellationState.UNSPECIFIED;

  /**
   * The number of attempts made to deliver the cancel operation request.
   * This number represents a minimum bound since the attempt is incremented after the request completes.
   *
   * @generated from field: int32 attempt = 3;
   */
  attempt = 0;

  /**
   * The time when the last attempt completed.
   *
   * @generated from field: google.protobuf.Timestamp last_attempt_complete_time = 4;
   */
  lastAttemptCompleteTime?: Timestamp;

  /**
   * The last attempt's failure, if any.
   *
   * @generated from field: temporal.api.failure.v1.Failure last_attempt_failure = 5;
   */
  lastAttemptFailure?: Failure;

  /**
   * The time when the next attempt is scheduled.
   *
   * @generated from field: google.protobuf.Timestamp next_attempt_schedule_time = 6;
   */
  nextAttemptScheduleTime?: Timestamp;

  /**
   * If the state is BLOCKED, blocked reason provides additional information.
   *
   * @generated from field: string blocked_reason = 7;
   */
  blockedReason = "";

  constructor(data?: PartialMessage<NexusOperationCancellationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.NexusOperationCancellationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requested_time", kind: "message", T: Timestamp },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(NexusOperationCancellationState) },
    { no: 3, name: "attempt", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "last_attempt_complete_time", kind: "message", T: Timestamp },
    { no: 5, name: "last_attempt_failure", kind: "message", T: Failure },
    { no: 6, name: "next_attempt_schedule_time", kind: "message", T: Timestamp },
    { no: 7, name: "blocked_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NexusOperationCancellationInfo {
    return new NexusOperationCancellationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NexusOperationCancellationInfo {
    return new NexusOperationCancellationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NexusOperationCancellationInfo {
    return new NexusOperationCancellationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: NexusOperationCancellationInfo | PlainMessage<NexusOperationCancellationInfo> | undefined, b: NexusOperationCancellationInfo | PlainMessage<NexusOperationCancellationInfo> | undefined): boolean {
    return proto3.util.equals(NexusOperationCancellationInfo, a, b);
  }
}

/**
 * @generated from message temporal.api.workflow.v1.WorkflowExecutionOptions
 */
export class WorkflowExecutionOptions extends Message<WorkflowExecutionOptions> {
  /**
   * If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride versioning_override = 1;
   */
  versioningOverride?: VersioningOverride;

  constructor(data?: PartialMessage<WorkflowExecutionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.WorkflowExecutionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "versioning_override", kind: "message", T: VersioningOverride },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecutionOptions {
    return new WorkflowExecutionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecutionOptions {
    return new WorkflowExecutionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecutionOptions {
    return new WorkflowExecutionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecutionOptions | PlainMessage<WorkflowExecutionOptions> | undefined, b: WorkflowExecutionOptions | PlainMessage<WorkflowExecutionOptions> | undefined): boolean {
    return proto3.util.equals(WorkflowExecutionOptions, a, b);
  }
}

/**
 * Used to override the versioning behavior (and pinned deployment version, if applicable) of a
 * specific workflow execution. If set, takes precedence over the worker-sent values. See
 * `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call
 * `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`
 * to indicate that it should be mutated.
 * Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
 * workflow retries, and cron workflows.
 *
 * @generated from message temporal.api.workflow.v1.VersioningOverride
 */
export class VersioningOverride extends Message<VersioningOverride> {
  /**
   * Indicates whether to override the workflow to be AutoUpgrade or Pinned.
   *
   * @generated from oneof temporal.api.workflow.v1.VersioningOverride.override
   */
  override: {
    /**
     * Send the next workflow task to the Version specified in the override.
     *
     * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverride pinned = 3;
     */
    value: VersioningOverride_PinnedOverride;
    case: "pinned";
  } | {
    /**
     * Send the next workflow task to the Current Deployment Version
     * of its Task Queue when the next workflow task is dispatched.
     *
     * @generated from field: bool auto_upgrade = 4;
     */
    value: boolean;
    case: "autoUpgrade";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Required.
   * Deprecated. Use `override`.
   *
   * @generated from field: temporal.api.enums.v1.VersioningBehavior behavior = 1 [deprecated = true];
   * @deprecated
   */
  behavior = VersioningBehavior.UNSPECIFIED;

  /**
   * Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
   * Identifies the worker deployment to pin the workflow to.
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: temporal.api.deployment.v1.Deployment deployment = 2 [deprecated = true];
   * @deprecated
   */
  deployment?: Deployment;

  /**
   * Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
   * Identifies the worker deployment version to pin the workflow to, in the format
   * "<deployment_name>.<build_id>".
   * Deprecated. Use `override.pinned.version`.
   *
   * @generated from field: string pinned_version = 9 [deprecated = true];
   * @deprecated
   */
  pinnedVersion = "";

  constructor(data?: PartialMessage<VersioningOverride>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.VersioningOverride";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "pinned", kind: "message", T: VersioningOverride_PinnedOverride, oneof: "override" },
    { no: 4, name: "auto_upgrade", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "override" },
    { no: 1, name: "behavior", kind: "enum", T: proto3.getEnumType(VersioningBehavior) },
    { no: 2, name: "deployment", kind: "message", T: Deployment },
    { no: 9, name: "pinned_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersioningOverride {
    return new VersioningOverride().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersioningOverride {
    return new VersioningOverride().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersioningOverride {
    return new VersioningOverride().fromJsonString(jsonString, options);
  }

  static equals(a: VersioningOverride | PlainMessage<VersioningOverride> | undefined, b: VersioningOverride | PlainMessage<VersioningOverride> | undefined): boolean {
    return proto3.util.equals(VersioningOverride, a, b);
  }
}

/**
 * Used to specify different sub-types of Pinned override that we plan to add in the future.
 *
 * @generated from enum temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior
 */
export enum VersioningOverride_PinnedOverrideBehavior {
  /**
   * Unspecified.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Override workflow behavior to be Pinned.
   *
   * @generated from enum value: PINNED_OVERRIDE_BEHAVIOR_PINNED = 1;
   */
  PINNED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(VersioningOverride_PinnedOverrideBehavior)
proto3.util.setEnumType(VersioningOverride_PinnedOverrideBehavior, "temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior", [
  { no: 0, name: "PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED" },
  { no: 1, name: "PINNED_OVERRIDE_BEHAVIOR_PINNED" },
]);

/**
 * @generated from message temporal.api.workflow.v1.VersioningOverride.PinnedOverride
 */
export class VersioningOverride_PinnedOverride extends Message<VersioningOverride_PinnedOverride> {
  /**
   * Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
   * See `PinnedOverrideBehavior` for details.
   *
   * @generated from field: temporal.api.workflow.v1.VersioningOverride.PinnedOverrideBehavior behavior = 1;
   */
  behavior = VersioningOverride_PinnedOverrideBehavior.UNSPECIFIED;

  /**
   * Required.
   *
   * @generated from field: temporal.api.deployment.v1.WorkerDeploymentVersion version = 2;
   */
  version?: WorkerDeploymentVersion;

  constructor(data?: PartialMessage<VersioningOverride_PinnedOverride>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.VersioningOverride.PinnedOverride";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "behavior", kind: "enum", T: proto3.getEnumType(VersioningOverride_PinnedOverrideBehavior) },
    { no: 2, name: "version", kind: "message", T: WorkerDeploymentVersion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersioningOverride_PinnedOverride {
    return new VersioningOverride_PinnedOverride().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersioningOverride_PinnedOverride {
    return new VersioningOverride_PinnedOverride().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersioningOverride_PinnedOverride {
    return new VersioningOverride_PinnedOverride().fromJsonString(jsonString, options);
  }

  static equals(a: VersioningOverride_PinnedOverride | PlainMessage<VersioningOverride_PinnedOverride> | undefined, b: VersioningOverride_PinnedOverride | PlainMessage<VersioningOverride_PinnedOverride> | undefined): boolean {
    return proto3.util.equals(VersioningOverride_PinnedOverride, a, b);
  }
}

/**
 * When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
 * there is already an existing running workflow, OnConflictOptions defines actions to be taken on
 * the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
 * history event in the running workflow with the changes requested in this object.
 *
 * @generated from message temporal.api.workflow.v1.OnConflictOptions
 */
export class OnConflictOptions extends Message<OnConflictOptions> {
  /**
   * Attaches the request ID to the running workflow.
   *
   * @generated from field: bool attach_request_id = 1;
   */
  attachRequestId = false;

  /**
   * Attaches the completion callbacks to the running workflow.
   *
   * @generated from field: bool attach_completion_callbacks = 2;
   */
  attachCompletionCallbacks = false;

  /**
   * Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
   *
   * @generated from field: bool attach_links = 3;
   */
  attachLinks = false;

  constructor(data?: PartialMessage<OnConflictOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.OnConflictOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attach_request_id", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "attach_completion_callbacks", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "attach_links", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OnConflictOptions {
    return new OnConflictOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OnConflictOptions {
    return new OnConflictOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OnConflictOptions {
    return new OnConflictOptions().fromJsonString(jsonString, options);
  }

  static equals(a: OnConflictOptions | PlainMessage<OnConflictOptions> | undefined, b: OnConflictOptions | PlainMessage<OnConflictOptions> | undefined): boolean {
    return proto3.util.equals(OnConflictOptions, a, b);
  }
}

/**
 * RequestIdInfo contains details of a request ID.
 *
 * @generated from message temporal.api.workflow.v1.RequestIdInfo
 */
export class RequestIdInfo extends Message<RequestIdInfo> {
  /**
   * The event type of the history event generated by the request.
   *
   * @generated from field: temporal.api.enums.v1.EventType event_type = 1;
   */
  eventType = EventType.UNSPECIFIED;

  /**
   * The event id of the history event generated by the request. It's possible the event ID is not
   * known (unflushed buffered event). In this case, the value will be zero or a negative value,
   * representing an invalid ID.
   *
   * @generated from field: int64 event_id = 2;
   */
  eventId = protoInt64.zero;

  /**
   * Indicate if the request is still buffered. If so, the event ID is not known and its value
   * will be an invalid event ID.
   *
   * @generated from field: bool buffered = 3;
   */
  buffered = false;

  constructor(data?: PartialMessage<RequestIdInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.RequestIdInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "event_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "buffered", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestIdInfo {
    return new RequestIdInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestIdInfo {
    return new RequestIdInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestIdInfo {
    return new RequestIdInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RequestIdInfo | PlainMessage<RequestIdInfo> | undefined, b: RequestIdInfo | PlainMessage<RequestIdInfo> | undefined): boolean {
    return proto3.util.equals(RequestIdInfo, a, b);
  }
}

/**
 * PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation
 */
export class PostResetOperation extends Message<PostResetOperation> {
  /**
   * @generated from oneof temporal.api.workflow.v1.PostResetOperation.variant
   */
  variant: {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.SignalWorkflow signal_workflow = 1;
     */
    value: PostResetOperation_SignalWorkflow;
    case: "signalWorkflow";
  } | {
    /**
     * @generated from field: temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions update_workflow_options = 2;
     */
    value: PostResetOperation_UpdateWorkflowOptions;
    case: "updateWorkflowOptions";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PostResetOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PostResetOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signal_workflow", kind: "message", T: PostResetOperation_SignalWorkflow, oneof: "variant" },
    { no: 2, name: "update_workflow_options", kind: "message", T: PostResetOperation_UpdateWorkflowOptions, oneof: "variant" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostResetOperation {
    return new PostResetOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostResetOperation {
    return new PostResetOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostResetOperation {
    return new PostResetOperation().fromJsonString(jsonString, options);
  }

  static equals(a: PostResetOperation | PlainMessage<PostResetOperation> | undefined, b: PostResetOperation | PlainMessage<PostResetOperation> | undefined): boolean {
    return proto3.util.equals(PostResetOperation, a, b);
  }
}

/**
 * SignalWorkflow represents sending a signal after a workflow reset.
 * Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.SignalWorkflow
 */
export class PostResetOperation_SignalWorkflow extends Message<PostResetOperation_SignalWorkflow> {
  /**
   * The workflow author-defined name of the signal to send to the workflow.
   *
   * @generated from field: string signal_name = 1;
   */
  signalName = "";

  /**
   * Serialized value(s) to provide with the signal.
   *
   * @generated from field: temporal.api.common.v1.Payloads input = 2;
   */
  input?: Payloads;

  /**
   * Headers that are passed with the signal to the processing workflow.
   *
   * @generated from field: temporal.api.common.v1.Header header = 3;
   */
  header?: Header;

  /**
   * Links to be associated with the WorkflowExecutionSignaled event.
   *
   * @generated from field: repeated temporal.api.common.v1.Link links = 4;
   */
  links: Link[] = [];

  constructor(data?: PartialMessage<PostResetOperation_SignalWorkflow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PostResetOperation.SignalWorkflow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signal_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "input", kind: "message", T: Payloads },
    { no: 3, name: "header", kind: "message", T: Header },
    { no: 4, name: "links", kind: "message", T: Link, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostResetOperation_SignalWorkflow {
    return new PostResetOperation_SignalWorkflow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostResetOperation_SignalWorkflow {
    return new PostResetOperation_SignalWorkflow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostResetOperation_SignalWorkflow {
    return new PostResetOperation_SignalWorkflow().fromJsonString(jsonString, options);
  }

  static equals(a: PostResetOperation_SignalWorkflow | PlainMessage<PostResetOperation_SignalWorkflow> | undefined, b: PostResetOperation_SignalWorkflow | PlainMessage<PostResetOperation_SignalWorkflow> | undefined): boolean {
    return proto3.util.equals(PostResetOperation_SignalWorkflow, a, b);
  }
}

/**
 * UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
 * Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
 *
 * @generated from message temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions
 */
export class PostResetOperation_UpdateWorkflowOptions extends Message<PostResetOperation_UpdateWorkflowOptions> {
  /**
   * Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
   *
   * @generated from field: temporal.api.workflow.v1.WorkflowExecutionOptions workflow_execution_options = 1;
   */
  workflowExecutionOptions?: WorkflowExecutionOptions;

  /**
   * Controls which fields from `workflow_execution_options` will be applied.
   * To unset a field, set it to null and use the update mask to indicate that it should be mutated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<PostResetOperation_UpdateWorkflowOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "workflow_execution_options", kind: "message", T: WorkflowExecutionOptions },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostResetOperation_UpdateWorkflowOptions {
    return new PostResetOperation_UpdateWorkflowOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostResetOperation_UpdateWorkflowOptions {
    return new PostResetOperation_UpdateWorkflowOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostResetOperation_UpdateWorkflowOptions {
    return new PostResetOperation_UpdateWorkflowOptions().fromJsonString(jsonString, options);
  }

  static equals(a: PostResetOperation_UpdateWorkflowOptions | PlainMessage<PostResetOperation_UpdateWorkflowOptions> | undefined, b: PostResetOperation_UpdateWorkflowOptions | PlainMessage<PostResetOperation_UpdateWorkflowOptions> | undefined): boolean {
    return proto3.util.equals(PostResetOperation_UpdateWorkflowOptions, a, b);
  }
}

