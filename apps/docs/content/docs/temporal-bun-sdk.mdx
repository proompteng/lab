---
title: Temporal Bun SDK
description: Learn how to build and operate Temporal workers with the Bun runtime using the @proompteng Temporal Bun SDK.
---

`@proompteng/temporal-bun-sdk` is our Bun-first Temporal toolkit. It mirrors the
`prix` Go worker defaults (namespace `default`, task queue `prix`, gRPC port
`7233`) while layering on:

- Zod-backed environment parsing with TLS, API key, and insecure-mode support.
- Factories for Temporal clients, workflow handles, and worker registration.
- A `temporal-bun` CLI that scaffolds projects, checks connectivity, and builds
  Docker images.
- A `temporal-bun-worker` binary that boots a worker with sensible defaults.
- Optional Zig-native bridge binaries that ship alongside the TypeScript output
  for instant startup on macOS and Linux.

## Prerequisites

- Bun **1.1.20 or newer** (matches the package engine requirement).
- Access to a Temporal Cloud namespace or self-hosted cluster.
- (Optional) The [`temporal`](https://docs.temporal.io/cli) CLI for namespace
  administration.
- `docker` if you plan to build container images with the provided helpers.

## Install and scaffold

Add the SDK to an existing Bun workspace:

```bash
bun add @proompteng/temporal-bun-sdk
```

To generate a new worker project, run the bundled CLI:

```bash
bunx temporal-bun init my-worker
cd my-worker
bun install
bun run dev # runs the worker locally
```

The template includes example workflows, activities, and Docker packaging
scripts that map one-to-one with the library’s defaults.

## Configure your Temporal connection

Configuration flows through `loadTemporalConfig()`, which reads environment
variables, normalizes paths, and enforces required values. Drop a `.env` file in
your worker project and tailor the defaults as needed:

```bash
TEMPORAL_HOST=temporal.proompteng.local
TEMPORAL_GRPC_PORT=7233
TEMPORAL_NAMESPACE=default
TEMPORAL_TASK_QUEUE=prix
TEMPORAL_API_KEY=your-cloud-api-key
# Uncomment to enable mutual TLS
# TEMPORAL_TLS_CERT_PATH=./certs/client.crt
# TEMPORAL_TLS_KEY_PATH=./certs/client.key
# TEMPORAL_TLS_CA_PATH=./certs/ca.pem
```

Environment variables supported by the config loader:

| Variable | Default | Description |
| --- | --- | --- |
| `TEMPORAL_ADDRESS` | `${TEMPORAL_HOST}:${TEMPORAL_GRPC_PORT}` | Direct address override (e.g. `temporal.example.com:7233`). |
| `TEMPORAL_HOST` | `127.0.0.1` | Hostname used when `TEMPORAL_ADDRESS` is unset. |
| `TEMPORAL_GRPC_PORT` | `7233` | Temporal gRPC port. |
| `TEMPORAL_NAMESPACE` | `default` | Namespace passed to the worker and client. |
| `TEMPORAL_TASK_QUEUE` | `prix` | Worker task queue. |
| `TEMPORAL_API_KEY` | _unset_ | Injected into connection metadata for Cloud/API auth. |
| `TEMPORAL_TLS_CA_PATH` | _unset_ | Path to trusted CA bundle. |
| `TEMPORAL_TLS_CERT_PATH` / `TEMPORAL_TLS_KEY_PATH` | _unset_ | mTLS client certificate & key (require both). |
| `TEMPORAL_TLS_SERVER_NAME` | _unset_ | Overrides TLS server name verification. |
| `TEMPORAL_CLIENT_RETRY_MAX_ATTEMPTS` | `5` | Default WorkflowService RPC attempt budget. |
| `TEMPORAL_CLIENT_RETRY_INITIAL_MS` | `200` | Initial retry delay (milliseconds). |
| `TEMPORAL_CLIENT_RETRY_MAX_MS` | `5000` | Maximum retry delay (milliseconds). |
| `TEMPORAL_CLIENT_RETRY_BACKOFF` | `2` | Exponential backoff multiplier applied per attempt. |
| `TEMPORAL_CLIENT_RETRY_JITTER_FACTOR` | `0.2` | Decorrelated jitter factor between 0 and 1. |
| `TEMPORAL_CLIENT_RETRY_STATUS_CODES` | `UNAVAILABLE,DEADLINE_EXCEEDED` | Comma-separated Connect codes that should be retried. |
| `TEMPORAL_ALLOW_INSECURE` / `ALLOW_INSECURE_TLS` | `false` | Accepts `1/true/on` to skip certificate verification. |
| `TEMPORAL_WORKER_IDENTITY_PREFIX` | `temporal-bun-worker` | Worker identity prefix (host and PID are appended automatically). |
| `TEMPORAL_LOG_FORMAT` | `pretty` | Select `json` or `pretty` logging output for worker/client runs. |
| `TEMPORAL_LOG_LEVEL` | `info` | Minimum log severity (`debug`, `info`, `warn`, `error`). |
| `TEMPORAL_METRICS_EXPORTER` | `in-memory` | Choose metrics sink: `in-memory`, `file`, `prometheus`, or `otlp`. |
| `TEMPORAL_METRICS_ENDPOINT` | _unset_ | Path or URL consumed by file/Prometheus/OTLP exporters. |

`loadTemporalConfig()` returns typed values that the client and worker factories
consume directly, so you never have to stitch addresses or TLS buffers together
by hand.

## WorkflowService client resilience

`createTemporalClient()` automatically wraps WorkflowService RPCs with our retry helper and telemetry interceptors:

- **Configurable retries** – `config.rpcRetryPolicy` is populated from the `TEMPORAL_CLIENT_RETRY_*` env vars (or overrides passed to `loadTemporalConfig`). All client methods use the resulting jittered exponential backoff policy, and you can override per-call values via `TemporalClientCallOptions.retryPolicy`.
- **Optional call options** – `startWorkflow`, `signalWorkflow`, `queryWorkflow`, `signalWithStart`, `terminateWorkflow`, and `describeNamespace` accept an optional trailing `callOptions` argument (headers, timeout, abort signal, retry policy). Use `temporalCallOptions()` to brand the object so payloads aren’t mistaken for options:
  ```ts
  import { temporalCallOptions } from '@proompteng/temporal-bun-sdk'

  await client.signalWorkflow(handle, 'updateState', { payload: { signal: 'start' } }, temporalCallOptions({
    headers: { 'x-trace-id': traceId },
    timeoutMs: 5_000,
  }))
  ```
- **Default interceptors** – namespace/identity headers are added automatically, structured logs are emitted for every RPC, and latency/error metrics flow through the configured registry/exporter. Pass `interceptors` to `createTemporalClient` to append tracing or auth middleware.
- **Memo/search helpers** – `client.memo` and `client.searchAttributes` expose `encode`/`decode` helpers that reuse the client’s `DataConverter`, making it easy to prepare payloads for raw WorkflowService requests.
- **TLS validation** – TLS buffers are checked up front (missing files, invalid PEMs, and mismatched cert/key pairs throw `TemporalTlsConfigurationError`) and transport failures surface as `TemporalTlsHandshakeError` with remediation hints.

## Observability

The Temporal Bun SDK ships with structured logging and metrics layers so you can
treat Bun workers/clients like any other service in your stack. Configure the
behavior with the same environment variables listed above:

- `TEMPORAL_LOG_FORMAT` – controls the log formatter (`pretty` or `json`).
- `TEMPORAL_LOG_LEVEL` – sets the minimum log severity that makes it into the
  sink.
- `TEMPORAL_METRICS_EXPORTER` / `TEMPORAL_METRICS_ENDPOINT` – select a sink
  (`in-memory`, `file`, `prometheus`, or `otlp`) and its path/URL (e.g.
  `/tmp/metrics.json`).

Want to verify your configuration without running a worker? `temporal-bun`
includes a new `doctor` command that loads the shared config, spins up the
observability services, emits a log, increments a counter, and flushes the
selected exporter:

```bash
bunx temporal-bun doctor --log-format=json --metrics=file:/tmp/metrics.json
```

The command prints a success summary once the JSON log is emitted and the
metrics file is written, so you can script it into CI or pre-deployment checks.

## Author activities

Activities are plain Bun functions. Keep them deterministic from Temporal’s
perspective and delegate external side effects to this layer.

```ts title="workers/activities.ts"
export type Activities = {
  echo(input: { message: string }): Promise<string>
  sleep(milliseconds: number): Promise<void>
}

export const echo: Activities['echo'] = async ({ message }) => {
  return message
}

export const sleep: Activities['sleep'] = async (milliseconds) => {
  await Bun.sleep(milliseconds)
}
```

## Author workflows

Import workflow primitives from the SDK so Bun can bundle Temporal’s deterministic
runtime correctly.

```ts title="workers/workflows.ts"
import { proxyActivities } from '@proompteng/temporal-bun-sdk'
import type { Activities } from '../activities.ts'

const activities = proxyActivities<Activities>({
  startToCloseTimeout: '1 minute',
})

export async function helloWorkflow(name: string): Promise<string> {
  await activities.sleep(10)
  return await activities.echo({ message: `Hello, ${name}!` })
}
```

Export your workflows from an index file so the worker can register them all at
once:

```ts title="workers/workflows/index.ts"
export * from './workflows.ts'
```

## Run a worker

`createWorker()` wires up the Temporal connection, registers your workflows and
activities, and hands back both the worker instance and the resolved config.

```ts title="worker.ts"
import { fileURLToPath } from 'node:url'
import { createWorker } from '@proompteng/temporal-bun-sdk/worker'
import * as activities from './workers/activities.ts'

const { worker } = await createWorker({
  activities,
  workflowsPath: fileURLToPath(new URL('./workers/workflows/index.ts', import.meta.url)),
})

const shutdown = async (signal: string) => {
  console.log(`Received ${signal}. Shutting down worker…`)
  await worker.shutdown()
  process.exit(0)
}

process.on('SIGINT', () => void shutdown('SIGINT'))
process.on('SIGTERM', () => void shutdown('SIGTERM'))

await worker.run()
```

For quick tests, run the bundled binary instead of compiling your own entry
point:

```bash
bunx temporal-bun-worker
```

It uses the same configuration loader and ships with example workflows if you
need a smoke test.

## Start and manage workflows from Bun

`createTemporalClient()` produces a Bun-native Temporal client that already
understands the config loader, workflow handles, and retry policies.

```ts title="scripts/start-workflow.ts"
import { createTemporalClient } from '@proompteng/temporal-bun-sdk'

const { client } = await createTemporalClient()

const start = await client.startWorkflow({
  workflowId: `hello-${Date.now()}`,
  workflowType: 'helloWorkflow',
  taskQueue: 'prix',
  args: ['Proompteng'],
})

console.log('Workflow started:', start.runId)

await client.signalWorkflow(start.handle, 'complete', { ok: true })
await client.terminateWorkflow(start.handle, { reason: 'demo complete' })
await client.shutdown()
```

All workflow operations (`startWorkflow`, `signalWorkflow`, `queryWorkflow`,
`terminateWorkflow`, `cancelWorkflow`, and `signalWithStart`) share the same
handle structure, so you can persist it between processes without extra
serialization code.

## CLI quick reference

The `temporal-bun` CLI is available through `bunx temporal-bun <command>` once
the package is installed.

- `init [directory] [--force]` – scaffold a Bun worker project with example
  workflows, activities, Dockerfile, and scripts.
- `doctor` – validate the SDK config, emit a JSON log, and flush the selected
  metrics exporter.
- `docker-build [--tag <name>]` – package the current directory into a worker
  image using the provided Docker helper.
- `help` – print the command reference.

## Native bridge status

The pure TypeScript runtime is the default (and only) supported execution path.
Historical Zig bridge assets remain in `packages/temporal-bun-sdk/bruke/` for
reference, but environment flags such as `TEMPORAL_BUN_SDK_USE_ZIG` are no longer
wired into the worker or client. Future experiments should introduce new,
explicit configuration rather than relying on the retired flag.

## Local development and production tips

- Use Bun’s `--watch` flag (`bun run --watch worker.ts`) to restart the worker on
  changes.
- Keep activities free of Temporal SDK imports so they remain tree-shakeable and
  easy to unit-test.
- Expose Prometheus metrics via the worker runtime and forward them to your
  observability stack.
- Prefer Temporal schedules to cron jobs for recurring workloads.
- Store long-lived credentials in a secrets manager and inject them via the
  worker environment.

With `@proompteng/temporal-bun-sdk`, you can reuse existing Temporal workflows
while adopting Bun’s fast startup times and fully typed client/worker helpers.
